using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.IO;
using System.Net.Http;
using System.Net.Http.Json;
using System.Text.RegularExpressions;
using System.Threading.Tasks;
using static System.Console;

args = new string[] {@"D:\git\dependabot-dotnet-test-projects\"};

if (args is { Length: 0 } || args[0] is not string path)
{
    WriteLine("Must specify a repo root directory as input");
    return;
}

// yaml top-matter

string topMatter =
@"# generated by dependadotnet
# https://github.com/dotnet/core/tree/master/samples/dependadotnet
version: 2
updates:";

WriteLine(topMatter);

/* Generate the following pattern for each project file:

  Note: Wednesday was chosen for quick response to .NET patch Tuesday updates

- package-ecosystem: ""nuget""
  directory: ""/"" #projectfilename
  schedule:
      interval: ""weekly""
      day: ""wednesday""
  open-pull-requests-limit: 5
*/

string packagesJsonUrl = "https://gist.githubusercontent.com/richlander/b6e9d0a2550396813c8899dc8b20748d/raw/baaa3517d802b0f39333887bc0adde66ab110264/packages.json";
Dictionary<string, string[]> packageIgnore = await GetPackagesInfo(packagesJsonUrl);
string validPackageReference = @"PackageReference.*Version=""[0-9]";
string packageReference = @"PackageReference Include=""";
string targetFrameworkStart = "<TargetFramework>";
string targetFrameworkEnd = "</TargetFramework>";
string dotnetDir = $"{Path.AltDirectorySeparatorChar}.dotnet";

foreach (string directory in Directory.EnumerateDirectories(path,"*.*",SearchOption.AllDirectories))
{
    if (directory.EndsWith(dotnetDir))
    {
        continue;
    }

    foreach (string file in Directory.EnumerateFiles(directory))
    {
        if (!IsProject(file))
        {
            continue;
        }

        string filename = Path.GetFileName(file);
        string? parentDir = Path.GetDirectoryName(file);
        string? targetFramework = null;
        bool match = false;
        List<
        foreach (string content in File.ReadLines(file))
        {
            if (targetFramework is null && TryGetTargetFramework(content, out targetFramework))
            {
                Console.WriteLine(targetFramework);
            }

            if (Regex.IsMatch(content, validPackageReference))
            {
                match = true;

                if (TryGetPackageName(content, out string? packageName) &&
                    packageIgnore.TryGetValue($"{packageName}_{targetFramework}", out string[]? ignore))
                {
                    
                }

                break;
            }
        }

        if (!match)
        {
            continue;
        }

        WriteLine( 
    $@"  - package-ecosystem: ""nuget""
        directory: ""{relativeDir}"" #{filename}
        schedule:
        interval: ""weekly""
        day: ""wednesday""
        open-pull-requests-limit: 5");
    }
}

bool IsProject(string filename) => Path.GetExtension(filename) switch
{
    ".csproj" or ".fsproj" or ".vbproj" => true,
    _ => false
};

bool TryGetTargetFramework(string content, [NotNullWhen(true)] out string? targetFramework)
{
    targetFramework = null;
    int start = content.IndexOf(targetFrameworkStart);

    if (start == -1)
    {
        return false;
    }

    int end = content.IndexOf(targetFrameworkEnd);

    if (end == -1 ||
        end < start)
    {
        return false;
    }

    int startOfTFM = start + targetFrameworkStart.Length;
    targetFramework = content.Substring(startOfTFM, end - startOfTFM);

    return targetFramework.StartsWith("net");
}

bool TryGetPackageName(string content, [NotNullWhen(true)] out string? packageName)
{
    packageName = null;
    int start = content.IndexOf(packageReference);

    if (start < 0)
    {
        return false;
    }

    int startOfPackageName = start + packageReference.Length;
    int endOfPackageName = content.AsSpan(startOfPackageName).IndexOf('"');

    if (endOfPackageName == 0)
    {
        return false;
    }

    packageName = content.Substring(startOfPackageName, endOfPackageName);
    return true;
}

async Task<Dictionary<string, string[]>> GetPackagesInfo(string url)
{
    HttpClient client = new();
    PackageInfoSet? packages = await client.GetFromJsonAsync<PackageInfoSet>(packagesJsonUrl);

    if (packages is null)
    {
        throw new IOException("Could not download packages information");
    }
    
    Dictionary<string, string[]> packageIgnore = new();

    foreach (PackageInfo package in packages.Packages)
    {
        foreach(PackageMapping mapping in package.Mapping)
        {
            string key = $"{package.Name}_{mapping.TargetFramework}";
            packageIgnore.Add(key, mapping.Ignore);
        }
    }

    return packageIgnore;
}

record PackageInfoSet(PackageInfo[] Packages);
record PackageInfo(string Name, PackageMapping[] Mapping);
record PackageMapping(string TargetFramework, string[] Ignore);