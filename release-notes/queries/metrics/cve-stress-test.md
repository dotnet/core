# CVE Stress Tests (Q2-Hard)

Query cost comparison for Q2-Hard category tests from [release-graph-eval](https://github.com/dotnet/release-graph-eval).

See [overview.md](../overview.md) for design context, file characteristics, and link relation discovery.

## T4: .NET 6 EOL Details

**Query:** "When did .NET 6 go EOL, when was the last .NET 6 security patch and what CVEs did it fix?"

| Schema | Files Required | Total Transfer |
|--------|----------------|----------------|
| llms-index | `llms.json` → `index.json` → `6.0/index.json` → `6.0/6.0.35/index.json` | **45 KB** |
| hal-index | `index.json` → `6.0/index.json` → `6.0/6.0.35/index.json` | **40 KB** |
| releases-index | `releases-index.json` → `6.0/releases.json` | **1,612 KB** |

**llms-index:** EOL versions are not in `latest_patches[]`, so navigation through the release index is required:

```bash
LLMS="https://raw.githubusercontent.com/dotnet/core/release-index/release-notes/llms.json"

# Step 1: Get releases-index link (6.0 not in latest_patches since it's EOL)
ROOT=$(curl -s "$LLMS" | jq -r '._links["releases-index"].href')

# Step 2: Get 6.0 version href
VERSION_HREF=$(curl -s "$ROOT" | jq -r '._embedded.releases[] | select(.version == "6.0") | ._links.self.href')

# Step 3: Get EOL date and latest-security link
VERSION_DATA=$(curl -s "$VERSION_HREF")
echo "$VERSION_DATA" | jq -r '"EOL: \(.eol_date | split("T")[0])"'
# EOL: 2024-11-12

# Step 4: Get last security patch details
SECURITY_HREF=$(echo "$VERSION_DATA" | jq -r '._links["latest-security"].href')
curl -s "$SECURITY_HREF" | jq -r '"Last security: \(.version) (\(.date | split("T")[0])) | CVEs: \(.cve_records | join(", "))"'
# Last security: 6.0.35 (2024-10-08) | CVEs: CVE-2024-43483, CVE-2024-43484, CVE-2024-43485
```

**hal-index:**

```bash
ROOT="https://raw.githubusercontent.com/dotnet/core/release-index/release-notes/index.json"

# Step 1: Get 6.0 version href
VERSION_HREF=$(curl -s "$ROOT" | jq -r '._embedded.releases[] | select(.version == "6.0") | ._links.self.href')

# Step 2: Get EOL date and latest-security link
VERSION_DATA=$(curl -s "$VERSION_HREF")
echo "$VERSION_DATA" | jq -r '"EOL: \(.eol_date | split("T")[0])"'
# EOL: 2024-11-12

# Step 3: Get last security patch details
SECURITY_HREF=$(echo "$VERSION_DATA" | jq -r '._links["latest-security"].href')
curl -s "$SECURITY_HREF" | jq -r '"Last security: \(.version) (\(.date | split("T")[0])) | CVEs: \(.cve_records | join(", "))"'
# Last security: 6.0.35 (2024-10-08) | CVEs: CVE-2024-43483, CVE-2024-43484, CVE-2024-43485
```

**releases-index:**

```bash
ROOT="https://builds.dotnet.microsoft.com/dotnet/release-metadata/releases-index.json"

# Step 1: Get EOL date from root (available inline)
curl -s "$ROOT" | jq -r '.["releases-index"][] | select(.["channel-version"] == "6.0") | "EOL: \(.["eol-date"])"'
# EOL: 2024-11-12

# Step 2: Get 6.0 releases.json URL and find last security patch
RELEASES_URL=$(curl -s "$ROOT" | jq -r '.["releases-index"][] | select(.["channel-version"] == "6.0") | .["releases.json"]')
curl -s "$RELEASES_URL" | jq -r '
  [.releases[] | select(.security == true)][0] |
  "Last security: \(.["release-version"]) (\(.["release-date"])) | CVEs: \([.["cve-list"][]?["cve-id"]] | join(", "))"'
# Last security: 6.0.35 (2024-10-08) | CVEs: CVE-2024-43483, CVE-2024-43484, CVE-2024-43485
```

**Winner:** hal-index (**40x smaller** than releases-index)

- llms-index requires extra hop through `releases-index` link since EOL versions aren't embedded
- hal-index starts directly at the release index
- releases-index EOL date is in root, but CVE query requires 1.6 MB file

**Analysis:**

- **Completeness:** ✅ Equal—all three return the same EOL date, patch version, and CVE IDs.
- **EOL version handling:** The llms-index optimizes for supported versions (`latest_patches[]`), requiring navigation for EOL queries. This is a reasonable tradeoff since EOL queries are less frequent.
- **CVE details:** To get CVE severity/titles (not just IDs), hal-index and llms-index can navigate to `timeline/2024/10/cve.json`; releases-index cannot provide this data.

---

## T5: CVE Timeline with Code Fixes

**Query:** "What CVEs have affected .NET 8 in the last 3 months? For any CRITICAL severity ones, what was the code fix?"

| Schema | Files Required | Total Transfer |
|--------|----------------|----------------|
| llms-index | `llms.json` → `timeline/2025/10/index.json` (+ prev-security walk) | **~25 KB** |
| hal-index | `timeline/index.json` → `timeline/2025/index.json` → month indexes | **~30 KB** |
| releases-index | N/A | N/A (cannot answer) |

**llms-index:** Direct link to latest security month, then walk `prev-security`:

```bash
LLMS="https://raw.githubusercontent.com/dotnet/core/release-index/release-notes/llms.json"
VERSION="8.0"

# Step 1: Get latest security month
MONTH_HREF=$(curl -s "$LLMS" | jq -r '._links["latest-security-month"].href')

# Step 2: Walk back 3 security months, filter for .NET 8, show CRITICAL fixes inline
for i in {1..3}; do
  DATA=$(curl -s "$MONTH_HREF")
  YEAR=$(echo "$DATA" | jq -r '.year')
  MONTH=$(echo "$DATA" | jq -r '.month')
  echo "=== $YEAR-$MONTH ==="

  # List all CVEs affecting this version
  echo "$DATA" | jq -r --arg v "$VERSION" '._embedded.disclosures[] | select(.affected_releases | contains([$v])) | "\(.id) (\(.cvss_severity))"'

  # For CRITICAL ones, show fix details
  echo "$DATA" | jq -r --arg v "$VERSION" '._embedded.disclosures[] | select(.affected_releases | contains([$v])) | select(.cvss_severity == "CRITICAL") |
    "  → \(.title)\n  → Fix: \(.fixes[] | select(.release == $v) | "\(.repo) \(.href)")"'

  MONTH_HREF=$(echo "$DATA" | jq -r '._links["prev-security"].href // empty')
  [ -z "$MONTH_HREF" ] && break
done
# === 2025-10 ===
# CVE-2025-55248 (MEDIUM)
# CVE-2025-55315 (CRITICAL)
#   → .NET Security Feature Bypass Vulnerability
#   → Fix: dotnet/aspnetcore https://github.com/dotnet/aspnetcore/commit/61794b7f3aac0b6719f783db5b5c725fefc8b695.diff
# CVE-2025-55247 (HIGH)
# === 2025-06 ===
# CVE-2025-30399 (HIGH)
# === 2025-05 ===
# CVE-2025-26646 (HIGH)
```

**hal-index:**

```bash
TIMELINE="https://raw.githubusercontent.com/dotnet/core/release-index/release-notes/timeline/index.json"
VERSION="8.0"

# Step 1: Get latest year
YEAR_HREF=$(curl -s "$TIMELINE" | jq -r '._links["latest-year"].href')

# Step 2: Get latest security month
MONTH_HREF=$(curl -s "$YEAR_HREF" | jq -r '._links["latest-security-month"].href')

# Step 3: Walk back 3 security months, filter for version, show CRITICAL fixes inline
for i in {1..3}; do
  DATA=$(curl -s "$MONTH_HREF")
  YEAR=$(echo "$DATA" | jq -r '.year')
  MONTH=$(echo "$DATA" | jq -r '.month')
  echo "=== $YEAR-$MONTH ==="

  # List all CVEs affecting this version
  echo "$DATA" | jq -r --arg v "$VERSION" '._embedded.disclosures[] | select(.affected_releases | contains([$v])) | "\(.id) (\(.cvss_severity))"'

  # For CRITICAL ones, show fix details
  echo "$DATA" | jq -r --arg v "$VERSION" '._embedded.disclosures[] | select(.affected_releases | contains([$v])) | select(.cvss_severity == "CRITICAL") |
    "  → \(.title)\n  → Fix: \(.fixes[] | select(.release == $v) | "\(.repo) \(.href)")"'

  MONTH_HREF=$(echo "$DATA" | jq -r '._links["prev-security"].href // empty')
  [ -z "$MONTH_HREF" ] && break
done
# === 2025-10 ===
# CVE-2025-55248 (MEDIUM)
# CVE-2025-55315 (CRITICAL)
#   → .NET Security Feature Bypass Vulnerability
#   → Fix: dotnet/aspnetcore https://github.com/dotnet/aspnetcore/commit/61794b7f3aac0b6719f783db5b5c725fefc8b695.diff
# CVE-2025-55247 (HIGH)
# === 2025-06 ===
# CVE-2025-30399 (HIGH)
# === 2025-05 ===
# CVE-2025-26646 (HIGH)
```

**releases-index:** Cannot answer this query.

- No timeline navigation
- No CVE severity data
- No code fix references

**Winner:** llms-index (**~25 KB**, direct `latest-security-month` link)

- Skips 2 fetches compared to hal-index (timeline root → year index)
- `prev-security` links enable efficient month-to-month traversal
- Code fixes embedded with repo/branch/commit details

**Analysis:**

- **Completeness:** ❌ releases-index cannot answer—no severity data, no fix references.
- **Code fix access:** The `fixes[]` array in disclosure records provides direct `.diff` URLs, enabling code review without additional navigation.
- **Version filtering:** The `affected_releases` array enables filtering CVEs by .NET version (e.g., "8.0") within the timeline data.
- **Severity filtering:** CVSS severity is embedded, enabling CRITICAL/HIGH filtering without external lookups.

---

## T6: Security Process Analysis (Stress Test)

**Query:** "Please look at .NET Runtime and ASP.NET Core CVEs from December 2024 until November 2025 (12 months). I am concerned at the rate of these CVEs. Look at code diffs for the CVEs. Are the fixes sufficiently protecting my mission critical apps and could the .NET team have avoided these vulnerabilities with a stronger security process?"

| Schema | Files Required | Total Transfer |
|--------|----------------|----------------|
| llms-index | `llms.json` → timeline → years → months → diffs | **~450 KB** |
| hal-index | `timeline/index.json` → years → months → diffs | **~455 KB** |
| releases-index | N/A | N/A (cannot answer) |

**llms-index:** Batched approach matching optimal AI agent performance (~28 fetches, 8 turns).

*Note: This script gathers data for an LLM to analyze. An AI agent would fetch these URLs in parallel batches, then synthesize the security analysis from the CVE metadata and code diffs.*

```bash
LLMS="https://raw.githubusercontent.com/dotnet/core/release-index/release-notes/llms.json"
START_YEAR="2024"; START_MONTH="11"  # Nov 2024 (first security month in range)
END_YEAR="2025"; END_MONTH="11"      # Nov 2025

# Turn 1: Get entry point
LLMS_DATA=$(curl -s "$LLMS")
TIMELINE=$(echo "$LLMS_DATA" | jq -r '._links["timeline-index"].href')

# Turn 2: Get timeline index
TIMELINE_DATA=$(curl -s "$TIMELINE")
YEAR_2024=$(echo "$TIMELINE_DATA" | jq -r '._embedded.years[] | select(.year == "2024") | ._links.self.href')
YEAR_2025=$(echo "$TIMELINE_DATA" | jq -r '._embedded.years[] | select(.year == "2025") | ._links.self.href')

# Turn 3: Fetch both year indexes (parallel in AI agent)
YEAR_2024_DATA=$(curl -s "$YEAR_2024")
YEAR_2025_DATA=$(curl -s "$YEAR_2025")

# Turn 4: Identify security months in range from embedded data
MONTH_URLS=$(echo "$YEAR_2024_DATA" | jq -r --arg m "$START_MONTH" '._embedded.months[] | select(.month >= $m) | select(.security == true) | ._links.self.href')
MONTH_URLS+=$'\n'$(echo "$YEAR_2025_DATA" | jq -r --arg m "$END_MONTH" '._embedded.months[] | select(.month <= $m) | select(.security == true) | ._links.self.href')

# Turn 5: Fetch all security month indexes (parallel in AI agent)
for URL in $MONTH_URLS; do
  curl -s "$URL" | jq -r '._embedded.disclosures[] | select(.fixes[].repo | test("runtime|aspnetcore")) | "\(.id) (\(.cvss_severity)) - \(.title)"'
done

# Turn 6: Print diff URLs for runtime/aspnetcore fixes
for URL in $MONTH_URLS; do
  curl -s "$URL" | jq -r '._embedded.disclosures[] | select(.fixes[].repo | test("runtime|aspnetcore")) | .fixes[] | select(.repo | test("runtime|aspnetcore")) | .href'
done | sort -u

# Turn 7: Fetch diffs (parallel in AI agent) - URLs printed above
# Turn 8: Synthesize analysis from fetched data
```

**Output:**
```
# CVEs (Turn 5):
CVE-2024-43498 (CRITICAL) - .NET Remote Code Execution Vulnerability
CVE-2024-43499 (HIGH) - .NET Denial of Service Vulnerability
CVE-2025-21171 (HIGH) - .NET Remote Code Execution Vulnerability
CVE-2025-21172 (HIGH) - .NET and Visual Studio Remote Code Execution Vulnerability
CVE-2025-21176 (HIGH) - .NET and Visual Studio Remote Code Execution Vulnerability
CVE-2025-24070 (HIGH) - ASP.NET Core Elevation of Privilege Vulnerability
CVE-2025-26682 (HIGH) - ASP.NET Core and Visual Studio Denial of Service Vulnerability
CVE-2025-30399 (HIGH) - .NET Remote Code Execution Vulnerability
CVE-2025-55248 (MEDIUM) - .NET Information Disclosure Vulnerability
CVE-2025-55315 (CRITICAL) - .NET Security Feature Bypass Vulnerability

# Diff URLs (Turn 6):
https://github.com/dotnet/aspnetcore/commit/61794b7f3aac0b6719f783db5b5c725fefc8b695.diff
https://github.com/dotnet/aspnetcore/commit/67f3b04274d3acb607fe95796dcb35f4f11149bf.diff
https://github.com/dotnet/aspnetcore/commit/97a86434195a82fc7e302a4c57d5ec7f885c1ad5.diff
https://github.com/dotnet/aspnetcore/commit/d5933a9d685c3a09566ec7c9ca818bd7ac2f08ad.diff
https://github.com/dotnet/aspnetcore/commit/d6605eb150c993dd8943e2c1a6875a93927c301a.diff
https://github.com/dotnet/aspnetcore/commit/f71e283286d8470639486804053f28391f92fafc.diff
https://github.com/dotnet/runtime/commit/18e28d767acf44208afa6c4e2e67a10c65e9647e.diff
https://github.com/dotnet/runtime/commit/214743ee2a5a25b9a3a07e3f0451da73eb4e97e2.diff
https://github.com/dotnet/runtime/commit/32d8ea6eecf7f192a75162645390847b14b56dbb.diff
https://github.com/dotnet/runtime/commit/44527b9ed8427463578126a4494c3654dda11866.diff
https://github.com/dotnet/runtime/commit/89ef51c5d8f5239345127a1e282e11036e590c8b.diff
https://github.com/dotnet/runtime/commit/9da8c6a4a6ea03054e776275d3fd5c752897842e.diff
https://github.com/dotnet/runtime/commit/b33d4e34e1cbf993583d78fc1b64ea8400935978.diff
https://github.com/dotnet/runtime/commit/d16f41ad8fded18bf82bca88df27967cc3365eb0.diff
```

**hal-index:** Same pattern, starting from `timeline/index.json` instead of `llms.json`.

**releases-index:** Cannot answer this query.

- No timeline structure for date-range queries
- No CVE severity or title data
- No code fix references
- Would require fetching ALL version releases.json files (~8 MB) and still lack required data

**Winner:** llms-index / hal-index (releases-index **cannot answer**)

**Performance Comparison:**

| Metric | Optimal | Actual (Haiku) |
|--------|---------|----------------|
| Total fetches | ~28 | 28 |
| Turns | 8 | 8 |
| Bytes fetched | ~450 KB | 453 KB |
| Duration | - | 93.5s |

**Analysis:**

- **Completeness:** ❌ releases-index fundamentally cannot answer security analysis queries—it lacks severity, descriptions, and fix references.
- **Batching efficiency:** Year indexes embed month summaries with `.security` flag, enabling upfront identification of which months to fetch. This allows batching all month fetches in one turn.
- **Parallel fetching:** Independent fetches (year indexes, month indexes, diffs) can be parallelized within turns.
- **Code review:** Each CVE disclosure includes `fixes[]` with direct commit URLs, repo names, and affected version ranges—enabling comprehensive security analysis.
- **Query alignment:** The ~450 KB cost reflects a query that spans two calendar years ("Dec 2024 - Nov 2025"). Queries aligned with the graph structure would be significantly cheaper:
  - "CVEs in 2025" → single year index, ~40% fewer fetches
  - "CVEs affecting .NET 8" → version-based `prev-security` walk, no timeline navigation

**Fetch Strategy for AI Agents:**

For a 12-month analysis, an efficient agent should:
1. Fetch `llms.json` (5 KB) - get timeline link
2. Fetch `timeline/index.json` (4 KB) - get year links
3. Fetch both year indexes in parallel (12 KB total)
4. Identify security months in range from embedded `.security` flag
5. Fetch all relevant `cve.json` files in parallel (~12 files)
6. Filter for runtime/aspnetcore repos
7. Fetch code diffs in parallel for analysis

Total: ~450 KB (JSON navigation + code diffs)
