# System.Threading.AccessControl

```diff
+ namespace System.Security.AccessControl
+ {
+     public sealed class EventWaitHandleAccessRule
+     {
+         public EventWaitHandleAccessRule(System.Security.Principal.IdentityReference identity, System.Security.AccessControl.EventWaitHandleRights eventRights, System.Security.AccessControl.AccessControlType type);
+         public EventWaitHandleAccessRule(string identity, System.Security.AccessControl.EventWaitHandleRights eventRights, System.Security.AccessControl.AccessControlType type);
+         public System.Security.AccessControl.EventWaitHandleRights EventWaitHandleRights { get; }
+     }
+     public sealed class EventWaitHandleAuditRule
+     {
+         public EventWaitHandleAuditRule(System.Security.Principal.IdentityReference identity, System.Security.AccessControl.EventWaitHandleRights eventRights, System.Security.AccessControl.AuditFlags flags);
+         public System.Security.AccessControl.EventWaitHandleRights EventWaitHandleRights { get; }
+     }
+     public sealed class EventWaitHandleRights
+     {
+         public const System.Security.AccessControl.EventWaitHandleRights ChangePermissions = 262144;
+         public const System.Security.AccessControl.EventWaitHandleRights Delete = 65536;
+         public const System.Security.AccessControl.EventWaitHandleRights FullControl = 2031619;
+         public const System.Security.AccessControl.EventWaitHandleRights Modify = 2;
+         public const System.Security.AccessControl.EventWaitHandleRights ReadPermissions = 131072;
+         public const System.Security.AccessControl.EventWaitHandleRights Synchronize = 1048576;
+         public const System.Security.AccessControl.EventWaitHandleRights TakeOwnership = 524288;
+         public int value__;
+     }
+     public sealed class EventWaitHandleSecurity
+     {
+         public EventWaitHandleSecurity();
+         public override System.Security.AccessControl.AccessRule AccessRuleFactory(System.Security.Principal.IdentityReference identityReference, int accessMask, bool isInherited, System.Security.AccessControl.InheritanceFlags inheritanceFlags, System.Security.AccessControl.PropagationFlags propagationFlags, System.Security.AccessControl.AccessControlType type);
+         public void AddAccessRule(System.Security.AccessControl.EventWaitHandleAccessRule rule);
+         public void AddAuditRule(System.Security.AccessControl.EventWaitHandleAuditRule rule);
+         public override System.Security.AccessControl.AuditRule AuditRuleFactory(System.Security.Principal.IdentityReference identityReference, int accessMask, bool isInherited, System.Security.AccessControl.InheritanceFlags inheritanceFlags, System.Security.AccessControl.PropagationFlags propagationFlags, System.Security.AccessControl.AuditFlags flags);
+         public bool RemoveAccessRule(System.Security.AccessControl.EventWaitHandleAccessRule rule);
+         public void RemoveAccessRuleAll(System.Security.AccessControl.EventWaitHandleAccessRule rule);
+         public void RemoveAccessRuleSpecific(System.Security.AccessControl.EventWaitHandleAccessRule rule);
+         public bool RemoveAuditRule(System.Security.AccessControl.EventWaitHandleAuditRule rule);
+         public void RemoveAuditRuleAll(System.Security.AccessControl.EventWaitHandleAuditRule rule);
+         public void RemoveAuditRuleSpecific(System.Security.AccessControl.EventWaitHandleAuditRule rule);
+         public void ResetAccessRule(System.Security.AccessControl.EventWaitHandleAccessRule rule);
+         public void SetAccessRule(System.Security.AccessControl.EventWaitHandleAccessRule rule);
+         public void SetAuditRule(System.Security.AccessControl.EventWaitHandleAuditRule rule);
+         public override System.Type AccessRightType { get; }
+         public override System.Type AccessRuleType { get; }
+         public override System.Type AuditRuleType { get; }
+     }
+     public sealed class MutexAccessRule
+     {
+         public MutexAccessRule(System.Security.Principal.IdentityReference identity, System.Security.AccessControl.MutexRights eventRights, System.Security.AccessControl.AccessControlType type);
+         public MutexAccessRule(string identity, System.Security.AccessControl.MutexRights eventRights, System.Security.AccessControl.AccessControlType type);
+         public System.Security.AccessControl.MutexRights MutexRights { get; }
+     }
+     public sealed class MutexAuditRule
+     {
+         public MutexAuditRule(System.Security.Principal.IdentityReference identity, System.Security.AccessControl.MutexRights eventRights, System.Security.AccessControl.AuditFlags flags);
+         public System.Security.AccessControl.MutexRights MutexRights { get; }
+     }
+     public sealed class MutexRights
+     {
+         public const System.Security.AccessControl.MutexRights ChangePermissions = 262144;
+         public const System.Security.AccessControl.MutexRights Delete = 65536;
+         public const System.Security.AccessControl.MutexRights FullControl = 2031617;
+         public const System.Security.AccessControl.MutexRights Modify = 1;
+         public const System.Security.AccessControl.MutexRights ReadPermissions = 131072;
+         public const System.Security.AccessControl.MutexRights Synchronize = 1048576;
+         public const System.Security.AccessControl.MutexRights TakeOwnership = 524288;
+         public int value__;
+     }
+     public sealed class MutexSecurity
+     {
+         public MutexSecurity();
+         public MutexSecurity(string name, System.Security.AccessControl.AccessControlSections includeSections);
+         public override System.Security.AccessControl.AccessRule AccessRuleFactory(System.Security.Principal.IdentityReference identityReference, int accessMask, bool isInherited, System.Security.AccessControl.InheritanceFlags inheritanceFlags, System.Security.AccessControl.PropagationFlags propagationFlags, System.Security.AccessControl.AccessControlType type);
+         public void AddAccessRule(System.Security.AccessControl.MutexAccessRule rule);
+         public void AddAuditRule(System.Security.AccessControl.MutexAuditRule rule);
+         public override System.Security.AccessControl.AuditRule AuditRuleFactory(System.Security.Principal.IdentityReference identityReference, int accessMask, bool isInherited, System.Security.AccessControl.InheritanceFlags inheritanceFlags, System.Security.AccessControl.PropagationFlags propagationFlags, System.Security.AccessControl.AuditFlags flags);
+         public bool RemoveAccessRule(System.Security.AccessControl.MutexAccessRule rule);
+         public void RemoveAccessRuleAll(System.Security.AccessControl.MutexAccessRule rule);
+         public void RemoveAccessRuleSpecific(System.Security.AccessControl.MutexAccessRule rule);
+         public bool RemoveAuditRule(System.Security.AccessControl.MutexAuditRule rule);
+         public void RemoveAuditRuleAll(System.Security.AccessControl.MutexAuditRule rule);
+         public void RemoveAuditRuleSpecific(System.Security.AccessControl.MutexAuditRule rule);
+         public void ResetAccessRule(System.Security.AccessControl.MutexAccessRule rule);
+         public void SetAccessRule(System.Security.AccessControl.MutexAccessRule rule);
+         public void SetAuditRule(System.Security.AccessControl.MutexAuditRule rule);
+         public override System.Type AccessRightType { get; }
+         public override System.Type AccessRuleType { get; }
+         public override System.Type AuditRuleType { get; }
+     }
+     public sealed class SemaphoreAccessRule
+     {
+         public SemaphoreAccessRule(System.Security.Principal.IdentityReference identity, System.Security.AccessControl.SemaphoreRights eventRights, System.Security.AccessControl.AccessControlType type);
+         public SemaphoreAccessRule(string identity, System.Security.AccessControl.SemaphoreRights eventRights, System.Security.AccessControl.AccessControlType type);
+         public System.Security.AccessControl.SemaphoreRights SemaphoreRights { get; }
+     }
+     public sealed class SemaphoreAuditRule
+     {
+         public SemaphoreAuditRule(System.Security.Principal.IdentityReference identity, System.Security.AccessControl.SemaphoreRights eventRights, System.Security.AccessControl.AuditFlags flags);
+         public System.Security.AccessControl.SemaphoreRights SemaphoreRights { get; }
+     }
+     public sealed class SemaphoreRights
+     {
+ public const System.Security.AccessControl.SemaphoreRights ChangePermissions = 262144;
+         public const System.Security.AccessControl.SemaphoreRights Delete = 65536;
+         public const System.Security.AccessControl.SemaphoreRights FullControl = 2031619;
+         public const System.Security.AccessControl.SemaphoreRights Modify = 2;
+         public const System.Security.AccessControl.SemaphoreRights ReadPermissions = 131072;
+         public const System.Security.AccessControl.SemaphoreRights Synchronize = 1048576;
+         public const System.Security.AccessControl.SemaphoreRights TakeOwnership = 524288;
+         public int value__;
+     }
+     public sealed class SemaphoreSecurity
+     {
+         public SemaphoreSecurity();
+         public SemaphoreSecurity(string name, System.Security.AccessControl.AccessControlSections includeSections);
+         public override System.Security.AccessControl.AccessRule AccessRuleFactory(System.Security.Principal.IdentityReference identityReference, int accessMask, bool isInherited, System.Security.AccessControl.InheritanceFlags inheritanceFlags, System.Security.AccessControl.PropagationFlags propagationFlags, System.Security.AccessControl.AccessControlType type);
+         public void AddAccessRule(System.Security.AccessControl.SemaphoreAccessRule rule);
+         public void AddAuditRule(System.Security.AccessControl.SemaphoreAuditRule rule);
+         public override System.Security.AccessControl.AuditRule AuditRuleFactory(System.Security.Principal.IdentityReference identityReference, int accessMask, bool isInherited, System.Security.AccessControl.InheritanceFlags inheritanceFlags, System.Security.AccessControl.PropagationFlags propagationFlags, System.Security.AccessControl.AuditFlags flags);
+         public bool RemoveAccessRule(System.Security.AccessControl.SemaphoreAccessRule rule);
+         public void RemoveAccessRuleAll(System.Security.AccessControl.SemaphoreAccessRule rule);
+         public void RemoveAccessRuleSpecific(System.Security.AccessControl.SemaphoreAccessRule rule);
+         public bool RemoveAuditRule(System.Security.AccessControl.SemaphoreAuditRule rule);
+         public void RemoveAuditRuleAll(System.Security.AccessControl.SemaphoreAuditRule rule);
+         public void RemoveAuditRuleSpecific(System.Security.AccessControl.SemaphoreAuditRule rule);
+         public void ResetAccessRule(System.Security.AccessControl.SemaphoreAccessRule rule);
+         public void SetAccessRule(System.Security.AccessControl.SemaphoreAccessRule rule);
+         public void SetAuditRule(System.Security.AccessControl.SemaphoreAuditRule rule);
+         public override System.Type AccessRightType { get; }
+         public override System.Type AccessRuleType { get; }
+         public override System.Type AuditRuleType { get; }
+     }
+ }
+ namespace System.Threading
+ {
+     public static class EventWaitHandleAcl
+     {
+         public static System.Threading.EventWaitHandle Create(bool? initialState, System.Threading.EventResetMode? mode, string? name, out bool? createdNew, System.Security.AccessControl.EventWaitHandleSecurity? eventSecurity);
+         public static System.Threading.EventWaitHandle OpenExisting(string name, System.Security.AccessControl.EventWaitHandleRights rights);
+         public static bool TryOpenExisting(string name, System.Security.AccessControl.EventWaitHandleRights rights, out System.Threading.EventWaitHandle? result);
+     }
+     public static class MutexAcl
+     {
+         public static System.Threading.Mutex Create(bool? initiallyOwned, string? name, out bool? createdNew, System.Security.AccessControl.MutexSecurity? mutexSecurity);
+         public static System.Threading.Mutex OpenExisting(string name, System.Security.AccessControl.MutexRights rights);
+         public static bool TryOpenExisting(string name, System.Security.AccessControl.MutexRights rights, out System.Threading.Mutex? result);
+     }
+     public static class SemaphoreAcl
+     {
+         public static System.Threading.Semaphore Create(int? initialCount, int? maximumCount, string? name, out bool? createdNew, System.Security.AccessControl.SemaphoreSecurity? semaphoreSecurity);
+         public static System.Threading.Semaphore OpenExisting(string name, System.Security.AccessControl.SemaphoreRights rights);
+         public static bool TryOpenExisting(string name, System.Security.AccessControl.SemaphoreRights rights, out System.Threading.Semaphore? result);
+     }
+     public static class ThreadingAclExtensions
+     {
+         public static System.Security.AccessControl.EventWaitHandleSecurity GetAccessControl(this System.Threading.EventWaitHandle handle);
+         public static System.Security.AccessControl.MutexSecurity GetAccessControl(this System.Threading.Mutex mutex);
+         public static System.Security.AccessControl.SemaphoreSecurity GetAccessControl(this System.Threading.Semaphore semaphore);
+         public static void SetAccessControl(this System.Threading.EventWaitHandle handle, System.Security.AccessControl.EventWaitHandleSecurity eventSecurity);
+         public static void SetAccessControl(this System.Threading.Mutex mutex, System.Security.AccessControl.MutexSecurity mutexSecurity);
+         public static void SetAccessControl(this System.Threading.Semaphore semaphore, System.Security.AccessControl.SemaphoreSecurity semaphoreSecurity);
+     }
+ }
```
