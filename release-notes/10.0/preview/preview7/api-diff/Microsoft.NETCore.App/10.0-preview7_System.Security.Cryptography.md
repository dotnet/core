# System.Security.Cryptography

```diff
  namespace System.Security.Cryptography
  {
      public abstract class Aes : System.Security.Cryptography.SymmetricAlgorithm
      {
+         public byte[] DecryptKeyWrapPadded(byte[] ciphertext);
+         public int DecryptKeyWrapPadded(System.ReadOnlySpan<byte> ciphertext, System.Span<byte> destination);
+         public byte[] DecryptKeyWrapPadded(System.ReadOnlySpan<byte> ciphertext);
+         protected virtual int DecryptKeyWrapPaddedCore(System.ReadOnlySpan<byte> source, System.Span<byte> destination);
+         public byte[] EncryptKeyWrapPadded(byte[] plaintext);
+         public void EncryptKeyWrapPadded(System.ReadOnlySpan<byte> plaintext, System.Span<byte> destination);
+         public byte[] EncryptKeyWrapPadded(System.ReadOnlySpan<byte> plaintext);
+         protected virtual void EncryptKeyWrapPaddedCore(System.ReadOnlySpan<byte> source, System.Span<byte> destination);
+         public static int GetKeyWrapPaddedLength(int plaintextLengthInBytes);
+         public bool TryDecryptKeyWrapPadded(System.ReadOnlySpan<byte> ciphertext, System.Span<byte> destination, out int bytesWritten);
      }
      public sealed class AesCng : System.Security.Cryptography.Aes
      {
+         [System.Runtime.Versioning.SupportedOSPlatformAttribute("windows")]
+         public AesCng(System.Security.Cryptography.CngKey key);
      }
      public sealed class CngAlgorithm : System.IEquatable<System.Security.Cryptography.CngAlgorithm>
      {
+         [System.Diagnostics.CodeAnalysis.ExperimentalAttribute("SYSLIB5006", UrlFormat = "https://aka.ms/dotnet-warnings/{0}")]
+         public static System.Security.Cryptography.CngAlgorithm MLKem { get; }
      }
      public sealed class CngAlgorithmGroup : System.IEquatable<System.Security.Cryptography.CngAlgorithmGroup>
      {
+         [System.Diagnostics.CodeAnalysis.ExperimentalAttribute("SYSLIB5006", UrlFormat = "https://aka.ms/dotnet-warnings/{0}")]
+         public static System.Security.Cryptography.CngAlgorithmGroup MLKem { get; }
      }
      public sealed class CngKeyBlobFormat : System.IEquatable<System.Security.Cryptography.CngKeyBlobFormat>
      {
+         [System.Diagnostics.CodeAnalysis.ExperimentalAttribute("SYSLIB5006", UrlFormat = "https://aka.ms/dotnet-warnings/{0}")]
+         public static System.Security.Cryptography.CngKeyBlobFormat MLKemPrivateBlob { get; }
+         [System.Diagnostics.CodeAnalysis.ExperimentalAttribute("SYSLIB5006", UrlFormat = "https://aka.ms/dotnet-warnings/{0}")]
+         public static System.Security.Cryptography.CngKeyBlobFormat MLKemPrivateSeedBlob { get; }
+         [System.Diagnostics.CodeAnalysis.ExperimentalAttribute("SYSLIB5006", UrlFormat = "https://aka.ms/dotnet-warnings/{0}")]
+         public static System.Security.Cryptography.CngKeyBlobFormat MLKemPublicBlob { get; }
      }
      public abstract class MLDsa : System.IDisposable
      {
-         public int ExportMLDsaPrivateSeed(System.Span<byte> destination);
+         public void ExportMLDsaPrivateSeed(System.Span<byte> destination);
-         public int ExportMLDsaPublicKey(System.Span<byte> destination);
+         public void ExportMLDsaPublicKey(System.Span<byte> destination);
-         public int ExportMLDsaSecretKey(System.Span<byte> destination);
+         public void ExportMLDsaSecretKey(System.Span<byte> destination);
-         public int SignData(System.ReadOnlySpan<byte> data, System.Span<byte> destination, System.ReadOnlySpan<byte> context = default(System.ReadOnlySpan<byte>));
+         public void SignData(System.ReadOnlySpan<byte> data, System.Span<byte> destination, System.ReadOnlySpan<byte> context = default(System.ReadOnlySpan<byte>));
+         public byte[] ExportMLDsaPrivateSeed();
+         public byte[] ExportMLDsaPublicKey();
+         public byte[] ExportMLDsaSecretKey();
+         public static System.Security.Cryptography.MLDsa ImportMLDsaPrivateSeed(System.Security.Cryptography.MLDsaAlgorithm algorithm, byte[] source);
+         public static System.Security.Cryptography.MLDsa ImportMLDsaPublicKey(System.Security.Cryptography.MLDsaAlgorithm algorithm, byte[] source);
+         public static System.Security.Cryptography.MLDsa ImportMLDsaSecretKey(System.Security.Cryptography.MLDsaAlgorithm algorithm, byte[] source);
+         public byte[] SignData(byte[] data, byte[]? context = null);
+         public byte[] SignPreHash(byte[] hash, string hashAlgorithmOid, byte[]? context = null);
+         public void SignPreHash(System.ReadOnlySpan<byte> hash, System.Span<byte> destination, string hashAlgorithmOid, System.ReadOnlySpan<byte> context = default(System.ReadOnlySpan<byte>));
+         protected abstract void SignPreHashCore(System.ReadOnlySpan<byte> hash, System.ReadOnlySpan<byte> context, string hashAlgorithmOid, System.Span<byte> destination);
+         public bool VerifyData(byte[] data, byte[] signature, byte[]? context = null);
+         public bool VerifyPreHash(byte[] hash, byte[] signature, string hashAlgorithmOid, byte[]? context = null);
+         public bool VerifyPreHash(System.ReadOnlySpan<byte> hash, System.ReadOnlySpan<byte> signature, string hashAlgorithmOid, System.ReadOnlySpan<byte> context = default(System.ReadOnlySpan<byte>));
+         protected abstract bool VerifyPreHashCore(System.ReadOnlySpan<byte> hash, System.ReadOnlySpan<byte> context, string hashAlgorithmOid, System.ReadOnlySpan<byte> signature);
      }
      public sealed class MLDsaAlgorithm : System.IEquatable<System.Security.Cryptography.MLDsaAlgorithm>
      {
+         public override bool Equals(object? obj);
+         public bool Equals(System.Security.Cryptography.MLDsaAlgorithm? other);
+         public override int GetHashCode();
+         public static bool operator ==(System.Security.Cryptography.MLDsaAlgorithm? left, System.Security.Cryptography.MLDsaAlgorithm? right);
+         public static bool operator !=(System.Security.Cryptography.MLDsaAlgorithm? left, System.Security.Cryptography.MLDsaAlgorithm? right);
+         public override string ToString();
      }
      public sealed class MLDsaCng : System.Security.Cryptography.MLDsa
      {
-         public System.Security.Cryptography.CngKey Key { get; }
+         public System.Security.Cryptography.CngKey GetKey();
+         protected override void SignPreHashCore(System.ReadOnlySpan<byte> hash, System.ReadOnlySpan<byte> context, string hashAlgorithmOid, System.Span<byte> destination);
+         protected override bool VerifyPreHashCore(System.ReadOnlySpan<byte> hash, System.ReadOnlySpan<byte> context, string hashAlgorithmOid, System.ReadOnlySpan<byte> signature);
      }
      public sealed class MLDsaOpenSsl : System.Security.Cryptography.MLDsa
      {
+         protected override void SignPreHashCore(System.ReadOnlySpan<byte> hash, System.ReadOnlySpan<byte> context, string hashAlgorithmOid, System.Span<byte> destination);
+         protected override bool VerifyPreHashCore(System.ReadOnlySpan<byte> hash, System.ReadOnlySpan<byte> context, string hashAlgorithmOid, System.ReadOnlySpan<byte> signature);
      }
      public sealed class SlhDsaAlgorithm : System.IEquatable<System.Security.Cryptography.SlhDsaAlgorithm>
      {
+         public override bool Equals(object? obj);
+         public bool Equals(System.Security.Cryptography.SlhDsaAlgorithm? other);
+         public override int GetHashCode();
+         public static bool operator ==(System.Security.Cryptography.SlhDsaAlgorithm? left, System.Security.Cryptography.SlhDsaAlgorithm? right);
+         public static bool operator !=(System.Security.Cryptography.SlhDsaAlgorithm? left, System.Security.Cryptography.SlhDsaAlgorithm? right);
+         public override string ToString();
      }
+     [System.Diagnostics.CodeAnalysis.ExperimentalAttribute("SYSLIB5006", UrlFormat = "https://aka.ms/dotnet-warnings/{0}")]
+     public abstract class CompositeMLDsa : System.IDisposable
+     {
+         protected CompositeMLDsa(System.Security.Cryptography.CompositeMLDsaAlgorithm algorithm);
+         public void Dispose();
+         protected virtual void Dispose(bool disposing);
+         public byte[] ExportCompositeMLDsaPrivateKey();
+         public byte[] ExportCompositeMLDsaPublicKey();
+         public byte[] ExportEncryptedPkcs8PrivateKey(System.ReadOnlySpan<byte> passwordBytes, System.Security.Cryptography.PbeParameters pbeParameters);
+         public byte[] ExportEncryptedPkcs8PrivateKey(System.ReadOnlySpan<char> password, System.Security.Cryptography.PbeParameters pbeParameters);
+         public byte[] ExportEncryptedPkcs8PrivateKey(string password, System.Security.Cryptography.PbeParameters pbeParameters);
+         public string ExportEncryptedPkcs8PrivateKeyPem(System.ReadOnlySpan<byte> passwordBytes, System.Security.Cryptography.PbeParameters pbeParameters);
+         public string ExportEncryptedPkcs8PrivateKeyPem(System.ReadOnlySpan<char> password, System.Security.Cryptography.PbeParameters pbeParameters);
+         public string ExportEncryptedPkcs8PrivateKeyPem(string password, System.Security.Cryptography.PbeParameters pbeParameters);
+         public byte[] ExportPkcs8PrivateKey();
+         public string ExportPkcs8PrivateKeyPem();
+         public byte[] ExportSubjectPublicKeyInfo();
+         public string ExportSubjectPublicKeyInfoPem();
+         public static System.Security.Cryptography.CompositeMLDsa GenerateKey(System.Security.Cryptography.CompositeMLDsaAlgorithm algorithm);
+         public static System.Security.Cryptography.CompositeMLDsa ImportCompositeMLDsaPrivateKey(System.Security.Cryptography.CompositeMLDsaAlgorithm algorithm, byte[] source);
+         public static System.Security.Cryptography.CompositeMLDsa ImportCompositeMLDsaPrivateKey(System.Security.Cryptography.CompositeMLDsaAlgorithm algorithm, System.ReadOnlySpan<byte> source);
+         public static System.Security.Cryptography.CompositeMLDsa ImportCompositeMLDsaPublicKey(System.Security.Cryptography.CompositeMLDsaAlgorithm algorithm, byte[] source);
+         public static System.Security.Cryptography.CompositeMLDsa ImportCompositeMLDsaPublicKey(System.Security.Cryptography.CompositeMLDsaAlgorithm algorithm, System.ReadOnlySpan<byte> source);
+         public static System.Security.Cryptography.CompositeMLDsa ImportEncryptedPkcs8PrivateKey(System.ReadOnlySpan<byte> passwordBytes, System.ReadOnlySpan<byte> source);
+         public static System.Security.Cryptography.CompositeMLDsa ImportEncryptedPkcs8PrivateKey(System.ReadOnlySpan<char> password, System.ReadOnlySpan<byte> source);
+         public static System.Security.Cryptography.CompositeMLDsa ImportEncryptedPkcs8PrivateKey(string password, byte[] source);
+         public static System.Security.Cryptography.CompositeMLDsa ImportFromEncryptedPem(System.ReadOnlySpan<char> source, System.ReadOnlySpan<byte> passwordBytes);
+         public static System.Security.Cryptography.CompositeMLDsa ImportFromEncryptedPem(System.ReadOnlySpan<char> source, System.ReadOnlySpan<char> password);
+         public static System.Security.Cryptography.CompositeMLDsa ImportFromEncryptedPem(string source, byte[] passwordBytes);
+         public static System.Security.Cryptography.CompositeMLDsa ImportFromEncryptedPem(string source, string password);
+         public static System.Security.Cryptography.CompositeMLDsa ImportFromPem(System.ReadOnlySpan<char> source);
+         public static System.Security.Cryptography.CompositeMLDsa ImportFromPem(string source);
+         public static System.Security.Cryptography.CompositeMLDsa ImportPkcs8PrivateKey(byte[] source);
+         public static System.Security.Cryptography.CompositeMLDsa ImportPkcs8PrivateKey(System.ReadOnlySpan<byte> source);
+         public static System.Security.Cryptography.CompositeMLDsa ImportSubjectPublicKeyInfo(byte[] source);
+         public static System.Security.Cryptography.CompositeMLDsa ImportSubjectPublicKeyInfo(System.ReadOnlySpan<byte> source);
+         public static bool IsAlgorithmSupported(System.Security.Cryptography.CompositeMLDsaAlgorithm algorithm);
+         public byte[] SignData(byte[] data, byte[]? context = null);
+         public int SignData(System.ReadOnlySpan<byte> data, System.Span<byte> destination, System.ReadOnlySpan<byte> context = default(System.ReadOnlySpan<byte>));
+         protected abstract int SignDataCore(System.ReadOnlySpan<byte> data, System.ReadOnlySpan<byte> context, System.Span<byte> destination);
+         public bool TryExportCompositeMLDsaPrivateKey(System.Span<byte> destination, out int bytesWritten);
+         protected abstract bool TryExportCompositeMLDsaPrivateKeyCore(System.Span<byte> destination, out int bytesWritten);
+         public bool TryExportCompositeMLDsaPublicKey(System.Span<byte> destination, out int bytesWritten);
+         protected abstract bool TryExportCompositeMLDsaPublicKeyCore(System.Span<byte> destination, out int bytesWritten);
+         public bool TryExportEncryptedPkcs8PrivateKey(System.ReadOnlySpan<byte> passwordBytes, System.Security.Cryptography.PbeParameters pbeParameters, System.Span<byte> destination, out int bytesWritten);
+         public bool TryExportEncryptedPkcs8PrivateKey(System.ReadOnlySpan<char> password, System.Security.Cryptography.PbeParameters pbeParameters, System.Span<byte> destination, out int bytesWritten);
+         public bool TryExportEncryptedPkcs8PrivateKey(string password, System.Security.Cryptography.PbeParameters pbeParameters, System.Span<byte> destination, out int bytesWritten);
+         public bool TryExportPkcs8PrivateKey(System.Span<byte> destination, out int bytesWritten);
+         protected abstract bool TryExportPkcs8PrivateKeyCore(System.Span<byte> destination, out int bytesWritten);
+         public bool TryExportSubjectPublicKeyInfo(System.Span<byte> destination, out int bytesWritten);
+         public bool VerifyData(byte[] data, byte[] signature, byte[]? context = null);
+         public bool VerifyData(System.ReadOnlySpan<byte> data, System.ReadOnlySpan<byte> signature, System.ReadOnlySpan<byte> context = default(System.ReadOnlySpan<byte>));
+         protected abstract bool VerifyDataCore(System.ReadOnlySpan<byte> data, System.ReadOnlySpan<byte> context, System.ReadOnlySpan<byte> signature);
+         public System.Security.Cryptography.CompositeMLDsaAlgorithm Algorithm { get; }
+         public static bool IsSupported { get; }
+     }
+     [System.Diagnostics.CodeAnalysis.ExperimentalAttribute("SYSLIB5006", UrlFormat = "https://aka.ms/dotnet-warnings/{0}")]
+     public sealed class CompositeMLDsaAlgorithm : System.IEquatable<System.Security.Cryptography.CompositeMLDsaAlgorithm>
+     {
+         public override bool Equals(object? obj);
+         public bool Equals(System.Security.Cryptography.CompositeMLDsaAlgorithm? other);
+         public override int GetHashCode();
+         public static bool operator ==(System.Security.Cryptography.CompositeMLDsaAlgorithm? left, System.Security.Cryptography.CompositeMLDsaAlgorithm? right);
+         public static bool operator !=(System.Security.Cryptography.CompositeMLDsaAlgorithm? left, System.Security.Cryptography.CompositeMLDsaAlgorithm? right);
+         public override string ToString();
+         public int MaxSignatureSizeInBytes { get; }
+         public static System.Security.Cryptography.CompositeMLDsaAlgorithm MLDsa44WithECDsaP256 { get; }
+         public static System.Security.Cryptography.CompositeMLDsaAlgorithm MLDsa44WithEd25519 { get; }
+         public static System.Security.Cryptography.CompositeMLDsaAlgorithm MLDsa44WithRSA2048Pkcs15 { get; }
+         public static System.Security.Cryptography.CompositeMLDsaAlgorithm MLDsa44WithRSA2048Pss { get; }
+         public static System.Security.Cryptography.CompositeMLDsaAlgorithm MLDsa65WithECDsaBrainpoolP256r1 { get; }
+         public static System.Security.Cryptography.CompositeMLDsaAlgorithm MLDsa65WithECDsaP256 { get; }
+         public static System.Security.Cryptography.CompositeMLDsaAlgorithm MLDsa65WithECDsaP384 { get; }
+         public static System.Security.Cryptography.CompositeMLDsaAlgorithm MLDsa65WithEd25519 { get; }
+         public static System.Security.Cryptography.CompositeMLDsaAlgorithm MLDsa65WithRSA3072Pkcs15 { get; }
+         public static System.Security.Cryptography.CompositeMLDsaAlgorithm MLDsa65WithRSA3072Pss { get; }
+         public static System.Security.Cryptography.CompositeMLDsaAlgorithm MLDsa65WithRSA4096Pkcs15 { get; }
+         public static System.Security.Cryptography.CompositeMLDsaAlgorithm MLDsa65WithRSA4096Pss { get; }
+         public static System.Security.Cryptography.CompositeMLDsaAlgorithm MLDsa87WithECDsaBrainpoolP384r1 { get; }
+         public static System.Security.Cryptography.CompositeMLDsaAlgorithm MLDsa87WithECDsaP384 { get; }
+         public static System.Security.Cryptography.CompositeMLDsaAlgorithm MLDsa87WithECDsaP521 { get; }
+         public static System.Security.Cryptography.CompositeMLDsaAlgorithm MLDsa87WithEd448 { get; }
+         public static System.Security.Cryptography.CompositeMLDsaAlgorithm MLDsa87WithRSA3072Pss { get; }
+         public static System.Security.Cryptography.CompositeMLDsaAlgorithm MLDsa87WithRSA4096Pss { get; }
+         public string Name { get; }
+     }
+     [System.Diagnostics.CodeAnalysis.ExperimentalAttribute("SYSLIB5006", UrlFormat = "https://aka.ms/dotnet-warnings/{0}")]
+     public sealed class MLKemCng : System.Security.Cryptography.MLKem
+     {
+         [System.Runtime.Versioning.SupportedOSPlatformAttribute("windows")]
+         public MLKemCng(System.Security.Cryptography.CngKey key) : base(default(System.Security.Cryptography.MLKemAlgorithm)!);
+         protected override void DecapsulateCore(System.ReadOnlySpan<byte> ciphertext, System.Span<byte> sharedSecret);
+         protected override void Dispose(bool disposing);
+         protected override void EncapsulateCore(System.Span<byte> ciphertext, System.Span<byte> sharedSecret);
+         protected override void ExportDecapsulationKeyCore(System.Span<byte> destination);
+         protected override void ExportEncapsulationKeyCore(System.Span<byte> destination);
+         protected override void ExportPrivateSeedCore(System.Span<byte> destination);
+         public System.Security.Cryptography.CngKey GetKey();
+         protected override bool TryExportPkcs8PrivateKeyCore(System.Span<byte> destination, out int bytesWritten);
+     }
  }
  namespace System.Security.Cryptography.X509Certificates
  {
      public sealed class Pkcs12LoaderLimits
      {
+         public bool AllowDuplicateAttributes { get; set; }
      }
  }
```
