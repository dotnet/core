# System.Runtime

```diff
  namespace System.Runtime.CompilerServices
  {
      public sealed class ConditionalWeakTable<TKey, TValue> : Collections.Generic.IEnumerable<Collections.Generic.KeyValuePair<TKey, TValue>>, Collections.IEnumerable where TKey : class where TValue : class
      {
+         [ComponentModel.EditorBrowsable(ComponentModel.EditorBrowsableState.Never)]
          public TValue GetOrCreateValue(TKey key) { throw null; }

+         [ComponentModel.EditorBrowsable(ComponentModel.EditorBrowsableState.Never)]
          public TValue GetValue(TKey key, CreateValueCallback createValueCallback) { throw null; }

+         [ComponentModel.EditorBrowsable(ComponentModel.EditorBrowsableState.Never)]
          public delegate TValue CreateValueCallback(TKey key);
+         public TValue GetOrAdd(TKey key, TValue value) { throw null; }
+         public TValue GetOrAdd(TKey key, Func<TKey, TValue> valueFactory) { throw null; }
+         public TValue GetOrAdd<TArg>(TKey key, Func<TKey, TArg, TValue> valueFactory, TArg factoryArgument) { throw null; }
      }
  }
  namespace System.Runtime.InteropServices
  {
+     public static class GCHandleExtensions
+     {
+         [CLSCompliant(false)]
+         public static unsafe T* GetAddressOfArrayData<T>(this PinnedGCHandle<T[]> handle) { throw null; }
+         [CLSCompliant(false)]
+         public static unsafe Char* GetAddressOfStringData(this PinnedGCHandle<String> handle) { throw null; }
+     }
+     public struct GCHandle<T> : IDisposable, IEquatable<GCHandle<T>> where T : class
+     {
+         private int _dummyPrimitive;
+         public GCHandle(T target) { }
+         public Boolean IsAllocated { get { throw null; } }
+         public T Target { get { throw null; } set { } }
+         public void Dispose() { }
+         public override readonly Boolean Equals(Object? obj) { throw null; }
+         public readonly Boolean Equals(GCHandle<T> other) { throw null; }
+         public static GCHandle<T> FromIntPtr(nint value) { throw null; }
+         public override readonly Int32 GetHashCode() { throw null; }
+         public static nint ToIntPtr(GCHandle<T> value) { throw null; }
+     }
+     public struct PinnedGCHandle<T> : IDisposable, IEquatable<PinnedGCHandle<T>> where T : class
+     {
+         private int _dummyPrimitive;
+         public PinnedGCHandle(T target) { }
+         public Boolean IsAllocated { get { throw null; } }
+         public T Target { get { throw null; } set { } }
+         public void Dispose() { }
+         public override readonly Boolean Equals(Object? obj) { throw null; }
+         public readonly Boolean Equals(PinnedGCHandle<T> other) { throw null; }
+         public static PinnedGCHandle<T> FromIntPtr(nint value) { throw null; }
+         [CLSCompliant(false)]
+         public readonly unsafe void* GetAddressOfObjectData() { throw null; }
+         public override readonly Int32 GetHashCode() { throw null; }
+         public static nint ToIntPtr(PinnedGCHandle<T> value) { throw null; }
+     }
+     public struct WeakGCHandle<T> : IDisposable, IEquatable<WeakGCHandle<T>> where T : class
+     {
+         private int _dummyPrimitive;
+         public WeakGCHandle(T target, Boolean trackResurrection = false) { }
+         public Boolean IsAllocated { get { throw null; } }
+         public void Dispose() { }
+         public override readonly Boolean Equals(Object? obj) { throw null; }
+         public readonly Boolean Equals(WeakGCHandle<T> other) { throw null; }
+         public static WeakGCHandle<T> FromIntPtr(nint value) { throw null; }
+         public override readonly Int32 GetHashCode() { throw null; }
+         public readonly void SetTarget(T target) { }
+         public static nint ToIntPtr(WeakGCHandle<T> value) { throw null; }
+         public readonly Boolean TryGetTarget(out T? target) { throw null; }
+     }
  }
```
