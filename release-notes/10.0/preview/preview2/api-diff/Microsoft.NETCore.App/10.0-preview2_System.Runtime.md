# System.Runtime

```diff
  namespace System.Runtime.CompilerServices
  {
      public sealed class ConditionalWeakTable<TKey, TValue> : Collections.Generic.IEnumerable<Collections.Generic.KeyValuePair<TKey, TValue>>, Collections.IEnumerable where TKey : class where TValue : class
      {
+         [ComponentModel.EditorBrowsable(ComponentModel.EditorBrowsableState.Never)]
          public TValue GetOrCreateValue(TKey key);
+         [ComponentModel.EditorBrowsable(ComponentModel.EditorBrowsableState.Never)]
          public TValue GetValue(TKey key, CreateValueCallback createValueCallback);
+         [ComponentModel.EditorBrowsable(ComponentModel.EditorBrowsableState.Never)]
          public delegate TValue CreateValueCallback(TKey key);
+         public TValue GetOrAdd(TKey key, TValue value);
+         public TValue GetOrAdd(TKey key, Func<TKey, TValue> valueFactory);
+         public TValue GetOrAdd<TArg>(TKey key, Func<TKey, TArg, TValue> valueFactory, TArg factoryArgument);
      }
  }
  namespace System.Runtime.InteropServices
  {
+     public struct GCHandle<T> : IDisposable, IEquatable<GCHandle<T>> where T : class
+     {
+         public GCHandle(T target);
+         public void Dispose();
+         public override readonly Boolean Equals(Object? obj);
+         public readonly Boolean Equals(GCHandle<T> other);
+         public static GCHandle<T> FromIntPtr(nint value);
+         public override readonly Int32 GetHashCode();
+         public static nint ToIntPtr(GCHandle<T> value);
+         public Boolean IsAllocated { get; }
+         public T Target { get; set; }
+     }
+     public static class GCHandleExtensions
+     {
+         [CLSCompliant(false)]
+         public static unsafe T* GetAddressOfArrayData<T>(this PinnedGCHandle<T[]> handle);
+         [CLSCompliant(false)]
+         public static unsafe Char* GetAddressOfStringData(this PinnedGCHandle<String> handle);
+     }
+     public struct PinnedGCHandle<T> : IDisposable, IEquatable<PinnedGCHandle<T>> where T : class
+     {
+         public PinnedGCHandle(T target);
+         public void Dispose();
+         public override readonly Boolean Equals(Object? obj);
+         public readonly Boolean Equals(PinnedGCHandle<T> other);
+         public static PinnedGCHandle<T> FromIntPtr(nint value);
+         [CLSCompliant(false)]
+         public readonly unsafe void* GetAddressOfObjectData();
+         public override readonly Int32 GetHashCode();
+         public static nint ToIntPtr(PinnedGCHandle<T> value);
+         public Boolean IsAllocated { get; }
+         public T Target { get; set; }
+     }
+     public struct WeakGCHandle<T> : IDisposable, IEquatable<WeakGCHandle<T>> where T : class
+     {
+         public WeakGCHandle(T target, Boolean trackResurrection = false);
+         public void Dispose();
+         public override readonly Boolean Equals(Object? obj);
+         public readonly Boolean Equals(WeakGCHandle<T> other);
+         public static WeakGCHandle<T> FromIntPtr(nint value);
+         public override readonly Int32 GetHashCode();
+         public readonly void SetTarget(T target);
+         public static nint ToIntPtr(WeakGCHandle<T> value);
+         public readonly Boolean TryGetTarget(out T? target);
+         public Boolean IsAllocated { get; }
+     }
  }
```
