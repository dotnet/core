# System.Runtime

```diff
  namespace System
  {
      public static class StringNormalizationExtensions
      {
+         public static int GetNormalizedLength(this System.ReadOnlySpan<char> source, System.Text.NormalizationForm normalizationForm = System.Text.NormalizationForm.FormC);
+         public static bool IsNormalized(this System.ReadOnlySpan<char> source, System.Text.NormalizationForm normalizationForm = System.Text.NormalizationForm.FormC);
+         public static bool TryNormalize(this System.ReadOnlySpan<char> source, System.Span<char> destination, out int charsWritten, System.Text.NormalizationForm normalizationForm = System.Text.NormalizationForm.FormC);
      }
      public readonly struct TimeSpan : System.IComparable, System.IComparable<System.TimeSpan>, System.IEquatable<System.TimeSpan>, System.IFormattable, System.IParsable<System.TimeSpan>, System.ISpanFormattable, System.ISpanParsable<System.TimeSpan>, System.IUtf8SpanFormattable
      {
-         public static System.TimeSpan FromMilliseconds(long milliseconds, long microseconds = 0);
+         public static System.TimeSpan FromMilliseconds(long milliseconds, long microseconds);
+         public static System.TimeSpan FromMilliseconds(long milliseconds);
      }
      public abstract class Type : System.Reflection.MemberInfo, System.Reflection.IReflect
      {
-         [System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembersAttribute((System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes)(-1))]
+         [System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembersAttribute((((((((((((System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicConstructors) | (System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicConstructors)) | (System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicMethods)) | (System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicMethods)) | (System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicFields)) | (System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicFields)) | (System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicNestedTypes)) | (System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicNestedTypes)) | (System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicProperties)) | (System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicProperties)) | (System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicEvents)) | (System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicEvents))]
          public virtual System.Reflection.MemberInfo[] FindMembers(System.Reflection.MemberTypes memberType, System.Reflection.BindingFlags bindingAttr, System.Reflection.MemberFilter? filter, object? filterCriteria);
-         [System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembersAttribute((System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes)(-1))]
+         [System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembersAttribute((((((((System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicConstructors) | (System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicConstructors)) | (System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicMethods)) | (System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicMethods)) | (System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicFields)) | (System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicFields)) | (System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicProperties)) | (System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicProperties))]
          public object? InvokeMember(string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder? binder, object? target, object?[]? args, System.Globalization.CultureInfo? culture);
-         [System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembersAttribute((System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes)(-1))]
+         [System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembersAttribute((((((((System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicConstructors) | (System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicConstructors)) | (System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicMethods)) | (System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicMethods)) | (System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicFields)) | (System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicFields)) | (System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicProperties)) | (System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicProperties))]
          public abstract object? InvokeMember(string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder? binder, object? target, object?[]? args, System.Reflection.ParameterModifier[]? modifiers, System.Globalization.CultureInfo? culture, string[]? namedParameters);
-         [System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembersAttribute((System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes)(-1))]
+         [System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembersAttribute((((((((System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicConstructors) | (System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicConstructors)) | (System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicMethods)) | (System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicMethods)) | (System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicFields)) | (System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicFields)) | (System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicProperties)) | (System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicProperties))]
          public object? InvokeMember(string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder? binder, object? target, object?[]? args);
      }
      public sealed class Version : System.ICloneable, System.IComparable, System.IComparable<System.Version?>, System.IEquatable<System.Version?>, System.IFormattable, System.ISpanFormattable, System.IUtf8SpanFormattable, System.IUtf8SpanParsable<System.Version>
      {
+         public static System.Version Parse(System.ReadOnlySpan<byte> utf8Text);
+         public static bool TryParse(System.ReadOnlySpan<byte> utf8Text, out System.Version? result);
      }
  }
  namespace System.Collections.ObjectModel
  {
+     [System.Runtime.CompilerServices.CollectionBuilderAttribute(typeof(System.Collections.ObjectModel.ReadOnlyCollection), "CreateCollection")]
      public class ReadOnlyCollection<T> : System.Collections.Generic.ICollection<T>, System.Collections.Generic.IEnumerable<T>, System.Collections.IEnumerable, System.Collections.Generic.IList<T>, System.Collections.Generic.IReadOnlyCollection<T>, System.Collections.Generic.IReadOnlyList<T>, System.Collections.ICollection, System.Collections.IList
      {
      }
+     public static class ReadOnlyCollection
+     {
+         public static System.Collections.ObjectModel.ReadOnlyCollection<T> CreateCollection<T>(params scoped System.ReadOnlySpan<T> values);
+         public static System.Collections.ObjectModel.ReadOnlySet<T> CreateSet<T>(params scoped System.ReadOnlySpan<T> values);
+     }
+     [System.Runtime.CompilerServices.CollectionBuilderAttribute(typeof(System.Collections.ObjectModel.ReadOnlyCollection), "CreateSet")]
+     public class ReadOnlySet<T> : System.Collections.Generic.ICollection<T>, System.Collections.Generic.IEnumerable<T>, System.Collections.IEnumerable, System.Collections.Generic.IReadOnlyCollection<T>, System.Collections.Generic.IReadOnlySet<T>, System.Collections.Generic.ISet<T>, System.Collections.ICollection
+     {
+         public ReadOnlySet(System.Collections.Generic.ISet<T> set);
+         public bool Contains(T item);
+         public System.Collections.Generic.IEnumerator<T> GetEnumerator();
+         public bool IsProperSubsetOf(System.Collections.Generic.IEnumerable<T> other);
+         public bool IsProperSupersetOf(System.Collections.Generic.IEnumerable<T> other);
+         public bool IsSubsetOf(System.Collections.Generic.IEnumerable<T> other);
+         public bool IsSupersetOf(System.Collections.Generic.IEnumerable<T> other);
+         public bool Overlaps(System.Collections.Generic.IEnumerable<T> other);
+         public bool SetEquals(System.Collections.Generic.IEnumerable<T> other);
+         public int Count { get; }
+         public static System.Collections.ObjectModel.ReadOnlySet<T> Empty { get; }
+         protected System.Collections.Generic.ISet<T> Set { get; }
+     }
  }
  namespace System.Diagnostics.CodeAnalysis
  {
      public enum DynamicallyAccessedMemberTypes
      {
+         PublicConstructorsWithInherited = 1048579,
+         AllConstructors = 1064967,
+         NonPublicNestedTypesWithInherited = 131328,
+         NonPublicConstructorsWithInherited = 16388,
+         PublicNestedTypesWithInherited = 2097280,
+         AllNestedTypes = 2228608,
+         NonPublicPropertiesWithInherited = 263168,
+         AllProperties = 263680,
+         NonPublicMethodsWithInherited = 32784,
+         AllMethods = 32792,
+         NonPublicEventsWithInherited = 528384,
+         AllEvents = 530432,
+         NonPublicFieldsWithInherited = 65600,
+         AllFields = 65632,
      }
      public sealed class ExperimentalAttribute : System.Attribute
      {
+         public string? Message { get; set; }
      }
  }
  namespace System.Globalization
  {
      public enum CompareOptions
      {
+         NumericOrdering = 32,
      }
      public static class ISOWeek
      {
+         public static int GetWeekOfYear(System.DateOnly date);
+         public static int GetYear(System.DateOnly date);
+         public static System.DateOnly ToDateOnly(int year, int week, System.DayOfWeek dayOfWeek);
      }
  }
  namespace System.IO
  {
      public class BinaryReader : System.IDisposable
      {
+         public virtual void ReadExactly(System.Span<byte> buffer);
      }
      public class StreamReader : System.IO.TextReader
      {
-         public StreamReader(System.IO.Stream stream, System.Text.Encoding encoding, bool detectEncodingFromByteOrderMarks, int bufferSize);
+         public StreamReader(System.IO.Stream stream, System.Text.Encoding? encoding, bool detectEncodingFromByteOrderMarks, int bufferSize);
-         public StreamReader(System.IO.Stream stream, System.Text.Encoding encoding, bool detectEncodingFromByteOrderMarks);
+         public StreamReader(System.IO.Stream stream, System.Text.Encoding? encoding, bool detectEncodingFromByteOrderMarks);
-         public StreamReader(System.IO.Stream stream, System.Text.Encoding encoding);
+         public StreamReader(System.IO.Stream stream, System.Text.Encoding? encoding);
-         public StreamReader(string path, System.Text.Encoding encoding, bool detectEncodingFromByteOrderMarks, int bufferSize);
+         public StreamReader(string path, System.Text.Encoding? encoding, bool detectEncodingFromByteOrderMarks, int bufferSize);
-         public StreamReader(string path, System.Text.Encoding encoding, bool detectEncodingFromByteOrderMarks, System.IO.FileStreamOptions options);
+         public StreamReader(string path, System.Text.Encoding? encoding, bool detectEncodingFromByteOrderMarks, System.IO.FileStreamOptions options);
-         public StreamReader(string path, System.Text.Encoding encoding, bool detectEncodingFromByteOrderMarks);
+         public StreamReader(string path, System.Text.Encoding? encoding, bool detectEncodingFromByteOrderMarks);
-         public StreamReader(string path, System.Text.Encoding encoding);
+         public StreamReader(string path, System.Text.Encoding? encoding);
      }
      public class StreamWriter : System.IO.TextWriter
      {
-         public StreamWriter(System.IO.Stream stream, System.Text.Encoding encoding, int bufferSize);
+         public StreamWriter(System.IO.Stream stream, System.Text.Encoding? encoding, int bufferSize);
-         public StreamWriter(System.IO.Stream stream, System.Text.Encoding encoding);
+         public StreamWriter(System.IO.Stream stream, System.Text.Encoding? encoding);
-         public StreamWriter(string path, bool append, System.Text.Encoding encoding, int bufferSize);
+         public StreamWriter(string path, bool append, System.Text.Encoding? encoding, int bufferSize);
-         public StreamWriter(string path, bool append, System.Text.Encoding encoding);
+         public StreamWriter(string path, bool append, System.Text.Encoding? encoding);
-         public StreamWriter(string path, System.Text.Encoding encoding, System.IO.FileStreamOptions options);
+         public StreamWriter(string path, System.Text.Encoding? encoding, System.IO.FileStreamOptions options);
      }
  }
  namespace System.Numerics
  {
      public interface INumber<TSelf> : System.IComparable, System.IComparable<TSelf>, System.IEquatable<TSelf>, System.IFormattable, System.IParsable<TSelf>, System.ISpanFormattable, System.ISpanParsable<TSelf>, System.Numerics.IAdditionOperators<TSelf, TSelf, TSelf>, System.Numerics.IAdditiveIdentity<TSelf, TSelf>, System.Numerics.IComparisonOperators<TSelf, TSelf, bool>, System.Numerics.IEqualityOperators<TSelf, TSelf, bool>, System.Numerics.IDecrementOperators<TSelf>, System.Numerics.IDivisionOperators<TSelf, TSelf, TSelf>, System.Numerics.IIncrementOperators<TSelf>, System.Numerics.IModulusOperators<TSelf, TSelf, TSelf>, System.Numerics.IMultiplicativeIdentity<TSelf, TSelf>, System.Numerics.IMultiplyOperators<TSelf, TSelf, TSelf>, System.Numerics.INumberBase<TSelf>, System.IUtf8SpanFormattable, System.IUtf8SpanParsable<TSelf>, System.Numerics.ISubtractionOperators<TSelf, TSelf, TSelf>, System.Numerics.IUnaryNegationOperators<TSelf, TSelf>, System.Numerics.IUnaryPlusOperators<TSelf, TSelf> where TSelf : System.Numerics.INumber<TSelf>?
      {
+         TSelf ClampNative(TSelf value, TSelf min, TSelf max);
+         TSelf MaxNative(TSelf x, TSelf y);
+         TSelf MinNative(TSelf x, TSelf y);
      }
  }
  namespace System.Reflection
  {
      public interface IReflect
      {
-         [System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembersAttribute((System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes)(-1))]
+         [System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembersAttribute((((((((System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicConstructors) | (System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicConstructors)) | (System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicMethods)) | (System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicMethods)) | (System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicFields)) | (System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicFields)) | (System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicProperties)) | (System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicProperties))]
          object? InvokeMember(string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder? binder, object? target, object?[]? args, System.Reflection.ParameterModifier[]? modifiers, System.Globalization.CultureInfo? culture, string[]? namedParameters);
      }
      public class TypeDelegator : System.Reflection.TypeInfo
      {
-         [System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembersAttribute((System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes)(-1))]
+         [System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembersAttribute((((((((System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicConstructors) | (System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicConstructors)) | (System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicMethods)) | (System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicMethods)) | (System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicFields)) | (System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicFields)) | (System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicProperties)) | (System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicProperties))]
          public override object? InvokeMember(string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder? binder, object? target, object?[]? args, System.Reflection.ParameterModifier[]? modifiers, System.Globalization.CultureInfo? culture, string[]? namedParameters);
      }
  }
  namespace System.Runtime.ExceptionServices
  {
+     public static class ExceptionHandling
+     {
+         public static void SetUnhandledExceptionHandler(System.Func<System.Exception, bool> handler);
+     }
  }
  namespace System.Threading.Tasks
  {
      public class Task : System.IAsyncResult, System.IDisposable
      {
-         public static System.Collections.Generic.IAsyncEnumerable<System.Threading.Tasks.Task> WhenEach(System.ReadOnlySpan<System.Threading.Tasks.Task> tasks);
+         public static System.Collections.Generic.IAsyncEnumerable<System.Threading.Tasks.Task> WhenEach(params scoped System.ReadOnlySpan<System.Threading.Tasks.Task> tasks);
-         public static System.Collections.Generic.IAsyncEnumerable<System.Threading.Tasks.Task<TResult>> WhenEach<TResult>(System.ReadOnlySpan<System.Threading.Tasks.Task<TResult>> tasks);
+         public static System.Collections.Generic.IAsyncEnumerable<System.Threading.Tasks.Task<TResult>> WhenEach<TResult>(params scoped System.ReadOnlySpan<System.Threading.Tasks.Task<TResult>> tasks);
      }
  }
```
