# System.Runtime

```diff
  namespace System
  {
      public class ArgumentOutOfRangeException : System.ArgumentException
      {
-         public static void ThrowIfEqual<T>(T value, T other, string? paramName = null)
+         public static void ThrowIfEqual<T>(T value, T other, string? paramName = null);
-             where T : System.IEquatable<T>?;
-         public static void ThrowIfNotEqual<T>(T value, T other, string? paramName = null)
+         public static void ThrowIfNotEqual<T>(T value, T other, string? paramName = null);
-             where T : System.IEquatable<T>?;
      }
      public static class Convert
      {
+         public static System.Buffers.OperationStatus FromHexString(System.ReadOnlySpan<byte> utf8Source, System.Span<byte> destination, out int bytesConsumed, out int bytesWritten);
+         public static byte[] FromHexString(System.ReadOnlySpan<byte> utf8Source);
+         public static bool TryToHexString(System.ReadOnlySpan<byte> source, System.Span<byte> utf8Destination, out int bytesWritten);
+         public static bool TryToHexStringLower(System.ReadOnlySpan<byte> source, System.Span<byte> utf8Destination, out int bytesWritten);
      }
-     public delegate void EventHandler<TEventArgs>(object? sender, TEventArgs e);
+     public delegate void EventHandler<in TEventArgs>(object? sender, TEventArgs e);
      public readonly struct Guid : System.IComparable, System.IComparable<System.Guid>, System.IEquatable<System.Guid>, System.IFormattable, System.IParsable<System.Guid>, System.ISpanFormattable, System.ISpanParsable<System.Guid>, System.IUtf8SpanFormattable, System.IUtf8SpanParsable<System.Guid>
      {
+         public static System.Guid Parse(System.ReadOnlySpan<byte> utf8Text);
+         public static bool TryParse(System.ReadOnlySpan<byte> utf8Text, out System.Guid result);
      }
      public readonly struct Int128 : System.IComparable, System.IComparable<System.Int128>, System.IEquatable<System.Int128>, System.IFormattable, System.IParsable<System.Int128>, System.ISpanFormattable, System.ISpanParsable<System.Int128>, System.IUtf8SpanFormattable, System.IUtf8SpanParsable<System.Int128>, System.Numerics.IAdditionOperators<System.Int128, System.Int128, System.Int128>, System.Numerics.IAdditiveIdentity<System.Int128, System.Int128>, System.Numerics.IBinaryInteger<System.Int128>, System.Numerics.IBinaryNumber<System.Int128>, System.Numerics.IBitwiseOperators<System.Int128, System.Int128, System.Int128>, System.Numerics.IComparisonOperators<System.Int128, System.Int128, bool>, System.Numerics.IEqualityOperators<System.Int128, System.Int128, bool>, System.Numerics.IDecrementOperators<System.Int128>, System.Numerics.IDivisionOperators<System.Int128, System.Int128, System.Int128>, System.Numerics.IIncrementOperators<System.Int128>, System.Numerics.IModulusOperators<System.Int128, System.Int128, System.Int128>, System.Numerics.IMultiplicativeIdentity<System.Int128, System.Int128>, System.Numerics.IMultiplyOperators<System.Int128, System.Int128, System.Int128>, System.Numerics.INumber<System.Int128>, System.Numerics.INumberBase<System.Int128>, System.Numerics.ISubtractionOperators<System.Int128, System.Int128, System.Int128>, System.Numerics.IUnaryNegationOperators<System.Int128, System.Int128>, System.Numerics.IUnaryPlusOperators<System.Int128, System.Int128>, System.Numerics.IShiftOperators<System.Int128, int, System.Int128>, System.Numerics.IMinMaxValue<System.Int128>, System.Numerics.ISignedNumber<System.Int128>
      {
+         public static System.Int128 BigMul(System.Int128 left, System.Int128 right, out System.Int128 lower);
      }
      public readonly struct IntPtr : System.IComparable, System.IComparable<nint>, System.IEquatable<nint>, System.IFormattable, System.IParsable<nint>, System.ISpanFormattable, System.ISpanParsable<nint>, System.IUtf8SpanFormattable, System.IUtf8SpanParsable<nint>, System.Numerics.IAdditionOperators<nint, nint, nint>, System.Numerics.IAdditiveIdentity<nint, nint>, System.Numerics.IBinaryInteger<nint>, System.Numerics.IBinaryNumber<nint>, System.Numerics.IBitwiseOperators<nint, nint, nint>, System.Numerics.IComparisonOperators<nint, nint, bool>, System.Numerics.IEqualityOperators<nint, nint, bool>, System.Numerics.IDecrementOperators<nint>, System.Numerics.IDivisionOperators<nint, nint, nint>, System.Numerics.IIncrementOperators<nint>, System.Numerics.IModulusOperators<nint, nint, nint>, System.Numerics.IMultiplicativeIdentity<nint, nint>, System.Numerics.IMultiplyOperators<nint, nint, nint>, System.Numerics.INumber<nint>, System.Numerics.INumberBase<nint>, System.Numerics.ISubtractionOperators<nint, nint, nint>, System.Numerics.IUnaryNegationOperators<nint, nint>, System.Numerics.IUnaryPlusOperators<nint, nint>, System.Numerics.IShiftOperators<nint, int, nint>, System.Numerics.IMinMaxValue<nint>, System.Numerics.ISignedNumber<nint>, System.Runtime.Serialization.ISerializable
      {
+         public static nint BigMul(nint left, nint right, out nint lower);
      }
      public class Random
      {
+         public string GetHexString(int stringLength, bool lowercase = false);
+         public void GetHexString(System.Span<char> destination, bool lowercase = false);
+         public string GetString(System.ReadOnlySpan<char> choices, int length);
      }
      public static class StringNormalizationExtensions
      {
+         public static int GetNormalizedLength(this System.ReadOnlySpan<char> source, System.Text.NormalizationForm normalizationForm = System.Text.NormalizationForm.FormC);
+         public static bool IsNormalized(this System.ReadOnlySpan<char> source, System.Text.NormalizationForm normalizationForm = System.Text.NormalizationForm.FormC);
+         public static bool TryNormalize(this System.ReadOnlySpan<char> source, System.Span<char> destination, out int charsWritten, System.Text.NormalizationForm normalizationForm = System.Text.NormalizationForm.FormC);
      }
      public readonly struct TimeSpan : System.IComparable, System.IComparable<System.TimeSpan>, System.IEquatable<System.TimeSpan>, System.IFormattable, System.IParsable<System.TimeSpan>, System.ISpanFormattable, System.ISpanParsable<System.TimeSpan>, System.IUtf8SpanFormattable
      {
-         public static System.TimeSpan FromMilliseconds(long milliseconds, long microseconds = 0);
+         public static System.TimeSpan FromMilliseconds(long milliseconds, long microseconds);
+         public static System.TimeSpan FromMilliseconds(long milliseconds);
      }
      public abstract class Type : System.Reflection.MemberInfo, System.Reflection.IReflect
      {
-         [System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembersAttribute((System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes)(-1))]
+         [System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembersAttribute((((((((((((System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicConstructors) | (System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicConstructors)) | (System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicMethods)) | (System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicMethods)) | (System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicFields)) | (System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicFields)) | (System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicNestedTypes)) | (System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicNestedTypes)) | (System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicProperties)) | (System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicProperties)) | (System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicEvents)) | (System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicEvents))]
          public virtual System.Reflection.MemberInfo[] FindMembers(System.Reflection.MemberTypes memberType, System.Reflection.BindingFlags bindingAttr, System.Reflection.MemberFilter? filter, object? filterCriteria);
-         [System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembersAttribute((System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes)(-1))]
+         [System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembersAttribute((((((((System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicConstructors) | (System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicConstructors)) | (System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicMethods)) | (System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicMethods)) | (System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicFields)) | (System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicFields)) | (System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicProperties)) | (System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicProperties))]
          public object? InvokeMember(string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder? binder, object? target, object?[]? args, System.Globalization.CultureInfo? culture);
-         [System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembersAttribute((System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes)(-1))]
+         [System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembersAttribute((((((((System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicConstructors) | (System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicConstructors)) | (System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicMethods)) | (System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicMethods)) | (System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicFields)) | (System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicFields)) | (System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicProperties)) | (System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicProperties))]
          public abstract object? InvokeMember(string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder? binder, object? target, object?[]? args, System.Reflection.ParameterModifier[]? modifiers, System.Globalization.CultureInfo? culture, string[]? namedParameters);
-         [System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembersAttribute((System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes)(-1))]
+         [System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembersAttribute((((((((System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicConstructors) | (System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicConstructors)) | (System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicMethods)) | (System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicMethods)) | (System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicFields)) | (System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicFields)) | (System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicProperties)) | (System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicProperties))]
          public object? InvokeMember(string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder? binder, object? target, object?[]? args);
      }
      public readonly struct UInt128 : System.IComparable, System.IComparable<System.UInt128>, System.IEquatable<System.UInt128>, System.IFormattable, System.IParsable<System.UInt128>, System.ISpanFormattable, System.ISpanParsable<System.UInt128>, System.IUtf8SpanFormattable, System.IUtf8SpanParsable<System.UInt128>, System.Numerics.IAdditionOperators<System.UInt128, System.UInt128, System.UInt128>, System.Numerics.IAdditiveIdentity<System.UInt128, System.UInt128>, System.Numerics.IBinaryInteger<System.UInt128>, System.Numerics.IBinaryNumber<System.UInt128>, System.Numerics.IBitwiseOperators<System.UInt128, System.UInt128, System.UInt128>, System.Numerics.IComparisonOperators<System.UInt128, System.UInt128, bool>, System.Numerics.IEqualityOperators<System.UInt128, System.UInt128, bool>, System.Numerics.IDecrementOperators<System.UInt128>, System.Numerics.IDivisionOperators<System.UInt128, System.UInt128, System.UInt128>, System.Numerics.IIncrementOperators<System.UInt128>, System.Numerics.IModulusOperators<System.UInt128, System.UInt128, System.UInt128>, System.Numerics.IMultiplicativeIdentity<System.UInt128, System.UInt128>, System.Numerics.IMultiplyOperators<System.UInt128, System.UInt128, System.UInt128>, System.Numerics.INumber<System.UInt128>, System.Numerics.INumberBase<System.UInt128>, System.Numerics.ISubtractionOperators<System.UInt128, System.UInt128, System.UInt128>, System.Numerics.IUnaryNegationOperators<System.UInt128, System.UInt128>, System.Numerics.IUnaryPlusOperators<System.UInt128, System.UInt128>, System.Numerics.IShiftOperators<System.UInt128, int, System.UInt128>, System.Numerics.IMinMaxValue<System.UInt128>, System.Numerics.IUnsignedNumber<System.UInt128>
      {
+         public static System.UInt128 BigMul(System.UInt128 left, System.UInt128 right, out System.UInt128 lower);
      }
      public readonly struct UIntPtr : System.IComparable, System.IComparable<nuint>, System.IEquatable<nuint>, System.IFormattable, System.IParsable<nuint>, System.ISpanFormattable, System.ISpanParsable<nuint>, System.IUtf8SpanFormattable, System.IUtf8SpanParsable<nuint>, System.Numerics.IAdditionOperators<nuint, nuint, nuint>, System.Numerics.IAdditiveIdentity<nuint, nuint>, System.Numerics.IBinaryInteger<nuint>, System.Numerics.IBinaryNumber<nuint>, System.Numerics.IBitwiseOperators<nuint, nuint, nuint>, System.Numerics.IComparisonOperators<nuint, nuint, bool>, System.Numerics.IEqualityOperators<nuint, nuint, bool>, System.Numerics.IDecrementOperators<nuint>, System.Numerics.IDivisionOperators<nuint, nuint, nuint>, System.Numerics.IIncrementOperators<nuint>, System.Numerics.IModulusOperators<nuint, nuint, nuint>, System.Numerics.IMultiplicativeIdentity<nuint, nuint>, System.Numerics.IMultiplyOperators<nuint, nuint, nuint>, System.Numerics.INumber<nuint>, System.Numerics.INumberBase<nuint>, System.Numerics.ISubtractionOperators<nuint, nuint, nuint>, System.Numerics.IUnaryNegationOperators<nuint, nuint>, System.Numerics.IUnaryPlusOperators<nuint, nuint>, System.Numerics.IShiftOperators<nuint, int, nuint>, System.Numerics.IMinMaxValue<nuint>, System.Numerics.IUnsignedNumber<nuint>, System.Runtime.Serialization.ISerializable
      {
+         public static nuint BigMul(nuint left, nuint right, out nuint lower);
      }
      public sealed class Version : System.ICloneable, System.IComparable, System.IComparable<System.Version?>, System.IEquatable<System.Version?>, System.IFormattable, System.ISpanFormattable, System.IUtf8SpanFormattable, System.IUtf8SpanParsable<System.Version>
      {
+         public static System.Version Parse(System.ReadOnlySpan<byte> utf8Text);
+         public static bool TryParse(System.ReadOnlySpan<byte> utf8Text, out System.Version? result);
      }
+     public delegate void EventHandler<in TSender, in TEventArgs>(TSender sender, TEventArgs e);
  }
  namespace System.Collections.ObjectModel
  {
+     [System.Runtime.CompilerServices.CollectionBuilderAttribute(typeof(System.Collections.ObjectModel.ReadOnlyCollection), "CreateCollection")]
      public class ReadOnlyCollection<T> : System.Collections.Generic.ICollection<T>, System.Collections.Generic.IEnumerable<T>, System.Collections.IEnumerable, System.Collections.Generic.IList<T>, System.Collections.Generic.IReadOnlyCollection<T>, System.Collections.Generic.IReadOnlyList<T>, System.Collections.ICollection, System.Collections.IList
      {
      }
+     public static class ReadOnlyCollection
+     {
+         public static System.Collections.ObjectModel.ReadOnlyCollection<T> CreateCollection<T>(params scoped System.ReadOnlySpan<T> values);
+         public static System.Collections.ObjectModel.ReadOnlySet<T> CreateSet<T>(params scoped System.ReadOnlySpan<T> values);
+     }
+     [System.Runtime.CompilerServices.CollectionBuilderAttribute(typeof(System.Collections.ObjectModel.ReadOnlyCollection), "CreateSet")]
+     public class ReadOnlySet<T> : System.Collections.Generic.ICollection<T>, System.Collections.Generic.IEnumerable<T>, System.Collections.IEnumerable, System.Collections.Generic.IReadOnlyCollection<T>, System.Collections.Generic.IReadOnlySet<T>, System.Collections.Generic.ISet<T>, System.Collections.ICollection
+     {
+         public ReadOnlySet(System.Collections.Generic.ISet<T> set);
+         public bool Contains(T item);
+         public System.Collections.Generic.IEnumerator<T> GetEnumerator();
+         public bool IsProperSubsetOf(System.Collections.Generic.IEnumerable<T> other);
+         public bool IsProperSupersetOf(System.Collections.Generic.IEnumerable<T> other);
+         public bool IsSubsetOf(System.Collections.Generic.IEnumerable<T> other);
+         public bool IsSupersetOf(System.Collections.Generic.IEnumerable<T> other);
+         public bool Overlaps(System.Collections.Generic.IEnumerable<T> other);
+         public bool SetEquals(System.Collections.Generic.IEnumerable<T> other);
+         public int Count { get; }
+         public static System.Collections.ObjectModel.ReadOnlySet<T> Empty { get; }
+         protected System.Collections.Generic.ISet<T> Set { get; }
+     }
  }
  namespace System.Diagnostics.CodeAnalysis
  {
+     [System.Runtime.CompilerServices.CompilerLoweringPreserveAttribute]
      public sealed class DynamicallyAccessedMembersAttribute : System.Attribute
      {
      }
      public enum DynamicallyAccessedMemberTypes
      {
+         PublicConstructorsWithInherited = 1048579,
+         AllConstructors = 1064967,
+         NonPublicNestedTypesWithInherited = 131328,
+         NonPublicConstructorsWithInherited = 16388,
+         PublicNestedTypesWithInherited = 2097280,
+         AllNestedTypes = 2228608,
+         NonPublicPropertiesWithInherited = 263168,
+         AllProperties = 263680,
+         NonPublicMethodsWithInherited = 32784,
+         AllMethods = 32792,
+         NonPublicEventsWithInherited = 528384,
+         AllEvents = 530432,
+         NonPublicFieldsWithInherited = 65600,
+         AllFields = 65632,
      }
      public sealed class DynamicDependencyAttribute : System.Attribute
      {
+         [System.ObsoleteAttribute("This property is no longer supported.")]
          public string? Condition { get; set; }
      }
      public sealed class ExperimentalAttribute : System.Attribute
      {
+         public string? Message { get; set; }
      }
      public sealed class RequiresDynamicCodeAttribute : System.Attribute
      {
+         public bool ExcludeStatics { get; set; }
      }
      public sealed class RequiresUnreferencedCodeAttribute : System.Attribute
      {
+         public bool ExcludeStatics { get; set; }
      }
  }
  namespace System.Globalization
  {
      public enum CompareOptions
      {
+         NumericOrdering = 32,
      }
      public static class ISOWeek
      {
+         public static int GetWeekOfYear(System.DateOnly date);
+         public static int GetYear(System.DateOnly date);
+         public static System.DateOnly ToDateOnly(int year, int week, System.DayOfWeek dayOfWeek);
      }
  }
  namespace System.IO
  {
      public class BinaryReader : System.IDisposable
      {
+         public virtual void ReadExactly(System.Span<byte> buffer);
      }
      public class StreamReader : System.IO.TextReader
      {
-         public StreamReader(System.IO.Stream stream, System.Text.Encoding encoding, bool detectEncodingFromByteOrderMarks, int bufferSize);
+         public StreamReader(System.IO.Stream stream, System.Text.Encoding? encoding, bool detectEncodingFromByteOrderMarks, int bufferSize);
-         public StreamReader(System.IO.Stream stream, System.Text.Encoding encoding, bool detectEncodingFromByteOrderMarks);
+         public StreamReader(System.IO.Stream stream, System.Text.Encoding? encoding, bool detectEncodingFromByteOrderMarks);
-         public StreamReader(System.IO.Stream stream, System.Text.Encoding encoding);
+         public StreamReader(System.IO.Stream stream, System.Text.Encoding? encoding);
-         public StreamReader(string path, System.Text.Encoding encoding, bool detectEncodingFromByteOrderMarks, int bufferSize);
+         public StreamReader(string path, System.Text.Encoding? encoding, bool detectEncodingFromByteOrderMarks, int bufferSize);
-         public StreamReader(string path, System.Text.Encoding encoding, bool detectEncodingFromByteOrderMarks, System.IO.FileStreamOptions options);
+         public StreamReader(string path, System.Text.Encoding? encoding, bool detectEncodingFromByteOrderMarks, System.IO.FileStreamOptions options);
-         public StreamReader(string path, System.Text.Encoding encoding, bool detectEncodingFromByteOrderMarks);
+         public StreamReader(string path, System.Text.Encoding? encoding, bool detectEncodingFromByteOrderMarks);
-         public StreamReader(string path, System.Text.Encoding encoding);
+         public StreamReader(string path, System.Text.Encoding? encoding);
      }
      public class StreamWriter : System.IO.TextWriter
      {
-         public StreamWriter(System.IO.Stream stream, System.Text.Encoding encoding, int bufferSize);
+         public StreamWriter(System.IO.Stream stream, System.Text.Encoding? encoding, int bufferSize);
-         public StreamWriter(System.IO.Stream stream, System.Text.Encoding encoding);
+         public StreamWriter(System.IO.Stream stream, System.Text.Encoding? encoding);
-         public StreamWriter(string path, bool append, System.Text.Encoding encoding, int bufferSize);
+         public StreamWriter(string path, bool append, System.Text.Encoding? encoding, int bufferSize);
-         public StreamWriter(string path, bool append, System.Text.Encoding encoding);
+         public StreamWriter(string path, bool append, System.Text.Encoding? encoding);
-         public StreamWriter(string path, System.Text.Encoding encoding, System.IO.FileStreamOptions options);
+         public StreamWriter(string path, System.Text.Encoding? encoding, System.IO.FileStreamOptions options);
      }
  }
  namespace System.Numerics
  {
      public interface INumber<TSelf> : System.IComparable, System.IComparable<TSelf>, System.IEquatable<TSelf>, System.IFormattable, System.IParsable<TSelf>, System.ISpanFormattable, System.ISpanParsable<TSelf>, System.Numerics.IAdditionOperators<TSelf, TSelf, TSelf>, System.Numerics.IAdditiveIdentity<TSelf, TSelf>, System.Numerics.IComparisonOperators<TSelf, TSelf, bool>, System.Numerics.IEqualityOperators<TSelf, TSelf, bool>, System.Numerics.IDecrementOperators<TSelf>, System.Numerics.IDivisionOperators<TSelf, TSelf, TSelf>, System.Numerics.IIncrementOperators<TSelf>, System.Numerics.IModulusOperators<TSelf, TSelf, TSelf>, System.Numerics.IMultiplicativeIdentity<TSelf, TSelf>, System.Numerics.IMultiplyOperators<TSelf, TSelf, TSelf>, System.Numerics.INumberBase<TSelf>, System.IUtf8SpanFormattable, System.IUtf8SpanParsable<TSelf>, System.Numerics.ISubtractionOperators<TSelf, TSelf, TSelf>, System.Numerics.IUnaryNegationOperators<TSelf, TSelf>, System.Numerics.IUnaryPlusOperators<TSelf, TSelf> where TSelf : System.Numerics.INumber<TSelf>?
      {
+         TSelf ClampNative(TSelf value, TSelf min, TSelf max);
+         TSelf MaxNative(TSelf x, TSelf y);
+         TSelf MinNative(TSelf x, TSelf y);
      }
  }
  namespace System.Reflection
  {
      public interface IReflect
      {
-         [System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembersAttribute((System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes)(-1))]
+         [System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembersAttribute((((((((System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicConstructors) | (System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicConstructors)) | (System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicMethods)) | (System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicMethods)) | (System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicFields)) | (System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicFields)) | (System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicProperties)) | (System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicProperties))]
          object? InvokeMember(string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder? binder, object? target, object?[]? args, System.Reflection.ParameterModifier[]? modifiers, System.Globalization.CultureInfo? culture, string[]? namedParameters);
      }
      public enum MethodImplAttributes
      {
+         Async = 8192,
      }
      public class TypeDelegator : System.Reflection.TypeInfo
      {
-         [System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembersAttribute((System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes)(-1))]
+         [System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembersAttribute((((((((System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicConstructors) | (System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicConstructors)) | (System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicMethods)) | (System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicMethods)) | (System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicFields)) | (System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicFields)) | (System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicProperties)) | (System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.NonPublicProperties))]
          public override object? InvokeMember(string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder? binder, object? target, object?[]? args, System.Reflection.ParameterModifier[]? modifiers, System.Globalization.CultureInfo? culture, string[]? namedParameters);
      }
  }
  namespace System.Runtime.CompilerServices
  {
      public sealed class ConditionalWeakTable<TKey, TValue> : System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey, TValue>>, System.Collections.IEnumerable where TKey : class where TValue : class
      {
+         public TValue GetOrAdd(TKey key, TValue value);
+         public TValue GetOrAdd(TKey key, System.Func<TKey, TValue> valueFactory);
+         public TValue GetOrAdd<TArg>(TKey key, System.Func<TKey, TArg, TValue> valueFactory, TArg factoryArgument);
+         public bool Remove(TKey key, out TValue value);
      }
      public ref struct DefaultInterpolatedStringHandler
      {
+         public void Clear();
+         public System.ReadOnlySpan<char> Text { get; }
      }
      public enum MethodImplOptions
      {
+         Async = 8192,
      }
      public static class Unsafe
      {
-         public static unsafe void* AsPointer<T>(ref T value);
+         public static unsafe void* AsPointer<T>(ref readonly T value);
+         public static bool IsAddressGreaterThanOrEqualTo<T>(ref readonly T left, ref readonly T right);
+         public static bool IsAddressLessThanOrEqualTo<T>(ref readonly T left, ref readonly T right);
      }
+     [System.Diagnostics.CodeAnalysis.ExperimentalAttribute("SYSLIB5007", UrlFormat = "https://aka.ms/dotnet-warnings/{0}")]
+     public static class AsyncHelpers
+     {
+         [System.Runtime.Versioning.RequiresPreviewFeaturesAttribute]
+         public static void Await(System.Runtime.CompilerServices.ConfiguredTaskAwaitable configuredAwaitable);
+         [System.Runtime.Versioning.RequiresPreviewFeaturesAttribute]
+         public static void Await(System.Runtime.CompilerServices.ConfiguredValueTaskAwaitable configuredAwaitable);
+         [System.Runtime.Versioning.RequiresPreviewFeaturesAttribute]
+         public static void Await(System.Threading.Tasks.Task task);
+         [System.Runtime.Versioning.RequiresPreviewFeaturesAttribute]
+         public static void Await(System.Threading.Tasks.ValueTask task);
+         [System.Runtime.Versioning.RequiresPreviewFeaturesAttribute]
+         public static T Await<T>(System.Runtime.CompilerServices.ConfiguredTaskAwaitable<T> configuredAwaitable);
+         [System.Runtime.Versioning.RequiresPreviewFeaturesAttribute]
+         public static T Await<T>(System.Runtime.CompilerServices.ConfiguredValueTaskAwaitable<T> configuredAwaitable);
+         [System.Runtime.Versioning.RequiresPreviewFeaturesAttribute]
+         public static T Await<T>(System.Threading.Tasks.Task<T> task);
+         [System.Runtime.Versioning.RequiresPreviewFeaturesAttribute]
+         public static T Await<T>(System.Threading.Tasks.ValueTask<T> task);
+         [System.Runtime.Versioning.RequiresPreviewFeaturesAttribute]
+         public static void AwaitAwaiter<TAwaiter>(TAwaiter awaiter)
+             where TAwaiter : System.Runtime.CompilerServices.INotifyCompletion;
+         [System.Runtime.Versioning.RequiresPreviewFeaturesAttribute]
+         public static void UnsafeAwaitAwaiter<TAwaiter>(TAwaiter awaiter)
+             where TAwaiter : System.Runtime.CompilerServices.ICriticalNotifyCompletion;
+     }
+     public sealed class CompilerLoweringPreserveAttribute : System.Attribute
+     {
+         public CompilerLoweringPreserveAttribute();
+     }
+     public sealed class ExtensionMarkerAttribute : System.Attribute
+     {
+         public ExtensionMarkerAttribute(string name);
+         public string Name { get; }
+     }
+     [System.Runtime.CompilerServices.InlineArrayAttribute(10)]
+     public struct InlineArray10<T>
+     {
+     }
+     [System.Runtime.CompilerServices.InlineArrayAttribute(11)]
+     public struct InlineArray11<T>
+     {
+     }
+     [System.Runtime.CompilerServices.InlineArrayAttribute(12)]
+     public struct InlineArray12<T>
+     {
+     }
+     [System.Runtime.CompilerServices.InlineArrayAttribute(13)]
+     public struct InlineArray13<T>
+     {
+     }
+     [System.Runtime.CompilerServices.InlineArrayAttribute(14)]
+     public struct InlineArray14<T>
+     {
+     }
+     [System.Runtime.CompilerServices.InlineArrayAttribute(15)]
+     public struct InlineArray15<T>
+     {
+     }
+     [System.Runtime.CompilerServices.InlineArrayAttribute(16)]
+     public struct InlineArray16<T>
+     {
+     }
+     [System.Runtime.CompilerServices.InlineArrayAttribute(2)]
+     public struct InlineArray2<T>
+     {
+     }
+     [System.Runtime.CompilerServices.InlineArrayAttribute(3)]
+     public struct InlineArray3<T>
+     {
+     }
+     [System.Runtime.CompilerServices.InlineArrayAttribute(4)]
+     public struct InlineArray4<T>
+     {
+     }
+     [System.Runtime.CompilerServices.InlineArrayAttribute(5)]
+     public struct InlineArray5<T>
+     {
+     }
+     [System.Runtime.CompilerServices.InlineArrayAttribute(6)]
+     public struct InlineArray6<T>
+     {
+     }
+     [System.Runtime.CompilerServices.InlineArrayAttribute(7)]
+     public struct InlineArray7<T>
+     {
+     }
+     [System.Runtime.CompilerServices.InlineArrayAttribute(8)]
+     public struct InlineArray8<T>
+     {
+     }
+     [System.Runtime.CompilerServices.InlineArrayAttribute(9)]
+     public struct InlineArray9<T>
+     {
+     }
+     public sealed class UnsafeAccessorTypeAttribute : System.Attribute
+     {
+         public UnsafeAccessorTypeAttribute(string typeName);
+         public string TypeName { get; }
+     }
  }
  namespace System.Runtime.ExceptionServices
  {
+     public static class ExceptionHandling
+     {
+         public static void RaiseAppDomainUnhandledExceptionEvent(object exception);
+         public static void SetUnhandledExceptionHandler(System.Func<System.Exception, bool> handler);
+     }
  }
  namespace System.Runtime.InteropServices
  {
+     public struct GCHandle<T> : System.IDisposable, System.IEquatable<System.Runtime.InteropServices.GCHandle<T>> where T : class
+     {
+         public GCHandle(T target);
+         public void Dispose();
+         public override readonly bool Equals(object? obj);
+         public readonly bool Equals(System.Runtime.InteropServices.GCHandle<T> other);
+         public static System.Runtime.InteropServices.GCHandle<T> FromIntPtr(nint value);
+         public override readonly int GetHashCode();
+         public static nint ToIntPtr(System.Runtime.InteropServices.GCHandle<T> value);
+         public bool IsAllocated { get; }
+         public T Target { get; set; }
+     }
+     public static class GCHandleExtensions
+     {
+         [System.CLSCompliantAttribute(false)]
+         public static unsafe T* GetAddressOfArrayData<T>(this System.Runtime.InteropServices.PinnedGCHandle<T[]> handle);
+         [System.CLSCompliantAttribute(false)]
+         public static unsafe char* GetAddressOfStringData(this System.Runtime.InteropServices.PinnedGCHandle<string> handle);
+     }
+     public struct PinnedGCHandle<T> : System.IDisposable, System.IEquatable<System.Runtime.InteropServices.PinnedGCHandle<T>> where T : class
+     {
+         public PinnedGCHandle(T target);
+         public void Dispose();
+         public override readonly bool Equals(object? obj);
+         public readonly bool Equals(System.Runtime.InteropServices.PinnedGCHandle<T> other);
+         public static System.Runtime.InteropServices.PinnedGCHandle<T> FromIntPtr(nint value);
+         [System.CLSCompliantAttribute(false)]
+         public readonly unsafe void* GetAddressOfObjectData();
+         public override readonly int GetHashCode();
+         public static nint ToIntPtr(System.Runtime.InteropServices.PinnedGCHandle<T> value);
+         public bool IsAllocated { get; }
+         public T Target { get; set; }
+     }
+     public struct WeakGCHandle<T> : System.IDisposable, System.IEquatable<System.Runtime.InteropServices.WeakGCHandle<T>> where T : class
+     {
+         public WeakGCHandle(T target, bool trackResurrection = false);
+         public void Dispose();
+         public override readonly bool Equals(object? obj);
+         public readonly bool Equals(System.Runtime.InteropServices.WeakGCHandle<T> other);
+         public static System.Runtime.InteropServices.WeakGCHandle<T> FromIntPtr(nint value);
+         public override readonly int GetHashCode();
+         public readonly void SetTarget(T target);
+         public static nint ToIntPtr(System.Runtime.InteropServices.WeakGCHandle<T> value);
+         public readonly bool TryGetTarget(out T? target);
+         public bool IsAllocated { get; }
+     }
  }
  namespace System.Threading.Tasks
  {
      public class Task : System.IAsyncResult, System.IDisposable
      {
-         public static System.Collections.Generic.IAsyncEnumerable<System.Threading.Tasks.Task> WhenEach(System.ReadOnlySpan<System.Threading.Tasks.Task> tasks);
+         public static System.Collections.Generic.IAsyncEnumerable<System.Threading.Tasks.Task> WhenEach(params scoped System.ReadOnlySpan<System.Threading.Tasks.Task> tasks);
-         public static System.Collections.Generic.IAsyncEnumerable<System.Threading.Tasks.Task<TResult>> WhenEach<TResult>(System.ReadOnlySpan<System.Threading.Tasks.Task<TResult>> tasks);
+         public static System.Collections.Generic.IAsyncEnumerable<System.Threading.Tasks.Task<TResult>> WhenEach<TResult>(params scoped System.ReadOnlySpan<System.Threading.Tasks.Task<TResult>> tasks);
      }
  }
```
