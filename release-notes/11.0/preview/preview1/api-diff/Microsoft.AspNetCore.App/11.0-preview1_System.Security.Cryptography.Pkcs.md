# System.Security.Cryptography.Pkcs

```diff
+ namespace System.Security.Cryptography
+ {
+     public sealed class CryptographicAttributeObject
+     {
+         public CryptographicAttributeObject(System.Security.Cryptography.Oid oid, System.Security.Cryptography.AsnEncodedDataCollection? values);
+         public CryptographicAttributeObject(System.Security.Cryptography.Oid oid);
+         public System.Security.Cryptography.Oid Oid { get; }
+         public System.Security.Cryptography.AsnEncodedDataCollection Values { get; }
+     }
+     public sealed class CryptographicAttributeObjectCollection : System.Collections.ICollection, System.Collections.IEnumerable
+     {
+         public CryptographicAttributeObjectCollection();
+         public CryptographicAttributeObjectCollection(System.Security.Cryptography.CryptographicAttributeObject attribute);
+         public int Add(System.Security.Cryptography.AsnEncodedData asnEncodedData);
+         public int Add(System.Security.Cryptography.CryptographicAttributeObject attribute);
+         public void CopyTo(System.Security.Cryptography.CryptographicAttributeObject[] array, int index);
+         public System.Security.Cryptography.CryptographicAttributeObjectEnumerator GetEnumerator();
+         public void Remove(System.Security.Cryptography.CryptographicAttributeObject attribute);
+         public int Count { get; }
+         public bool IsSynchronized { get; }
+         public System.Security.Cryptography.CryptographicAttributeObject this[int index] {
+             get { }
+         }
+         public object SyncRoot { get; }
+     }
+     public sealed class CryptographicAttributeObjectEnumerator : System.Collections.IEnumerator
+     {
+         public bool MoveNext();
+         public void Reset();
+ public System.Security.Cryptography.CryptographicAttributeObject Current { get; }
+     }
+ }
+ namespace System.Security.Cryptography.Pkcs
+ {
+     public sealed class AlgorithmIdentifier
+     {
+         public AlgorithmIdentifier();
+         public AlgorithmIdentifier(System.Security.Cryptography.Oid oid, int keyLength);
+         public AlgorithmIdentifier(System.Security.Cryptography.Oid oid);
+         public int KeyLength { get; set; }
+         public System.Security.Cryptography.Oid Oid { get; set; }
+         public byte[] Parameters { get; set; }
+     }
+     public sealed class CmsRecipient
+     {
+         public CmsRecipient(System.Security.Cryptography.Pkcs.SubjectIdentifierType recipientIdentifierType, System.Security.Cryptography.X509Certificates.X509Certificate2 certificate, System.Security.Cryptography.RSAEncryptionPadding rsaEncryptionPadding);
+         public CmsRecipient(System.Security.Cryptography.Pkcs.SubjectIdentifierType recipientIdentifierType, System.Security.Cryptography.X509Certificates.X509Certificate2 certificate);
+         public CmsRecipient(System.Security.Cryptography.X509Certificates.X509Certificate2 certificate, System.Security.Cryptography.RSAEncryptionPadding rsaEncryptionPadding);
+         public CmsRecipient(System.Security.Cryptography.X509Certificates.X509Certificate2 certificate);
+         public System.Security.Cryptography.X509Certificates.X509Certificate2 Certificate { get; }
+         public System.Security.Cryptography.Pkcs.SubjectIdentifierType RecipientIdentifierType { get; }
+         public System.Security.Cryptography.RSAEncryptionPadding? RSAEncryptionPadding { get; }
+     }
+     public sealed class CmsRecipientCollection : System.Collections.ICollection, System.Collections.IEnumerable
+     {
+         public CmsRecipientCollection();
+         public CmsRecipientCollection(System.Security.Cryptography.Pkcs.CmsRecipient recipient);
+         public CmsRecipientCollection(System.Security.Cryptography.Pkcs.SubjectIdentifierType recipientIdentifierType, System.Security.Cryptography.X509Certificates.X509Certificate2Collection certificates);
+         public int Add(System.Security.Cryptography.Pkcs.CmsRecipient recipient);
+         public void CopyTo(System.Array array, int index);
+         public void CopyTo(System.Security.Cryptography.Pkcs.CmsRecipient[] array, int index);
+         public System.Security.Cryptography.Pkcs.CmsRecipientEnumerator GetEnumerator();
+         public void Remove(System.Security.Cryptography.Pkcs.CmsRecipient recipient);
+         public int Count { get; }
+         public bool IsSynchronized { get; }
+         public System.Security.Cryptography.Pkcs.CmsRecipient this[int index] {
+             get { }
+         }
+         public object SyncRoot { get; }
+     }
+     public sealed class CmsRecipientEnumerator : System.Collections.IEnumerator
+     {
+         public bool MoveNext();
+         public void Reset();
+ public System.Security.Cryptography.Pkcs.CmsRecipient Current { get; }
+     }
+     public sealed class CmsSigner
+     {
+         public CmsSigner();
+         [System.ObsoleteAttribute("CmsSigner(CspParameters) is obsolete and is not supported. Use an alternative constructor instead.", DiagnosticId = "SYSLIB0034", UrlFormat = "https://aka.ms/dotnet-warnings/{0}")]
+         public CmsSigner(System.Security.Cryptography.CspParameters parameters);
+         public CmsSigner(System.Security.Cryptography.Pkcs.SubjectIdentifierType signerIdentifierType, System.Security.Cryptography.X509Certificates.X509Certificate2? certificate, System.Security.Cryptography.AsymmetricAlgorithm? privateKey);
+         [System.Diagnostics.CodeAnalysis.ExperimentalAttribute("SYSLIB5006", UrlFormat = "https://aka.ms/dotnet-warnings/{0}")]
+         public CmsSigner(System.Security.Cryptography.Pkcs.SubjectIdentifierType signerIdentifierType, System.Security.Cryptography.X509Certificates.X509Certificate2? certificate, System.Security.Cryptography.CompositeMLDsa? privateKey);
+         [System.Diagnostics.CodeAnalysis.ExperimentalAttribute("SYSLIB5006", UrlFormat = "https://aka.ms/dotnet-warnings/{0}")]
+         public CmsSigner(System.Security.Cryptography.Pkcs.SubjectIdentifierType signerIdentifierType, System.Security.Cryptography.X509Certificates.X509Certificate2? certificate, System.Security.Cryptography.MLDsa? privateKey);
+         public CmsSigner(System.Security.Cryptography.Pkcs.SubjectIdentifierType signerIdentifierType, System.Security.Cryptography.X509Certificates.X509Certificate2? certificate, System.Security.Cryptography.RSA? privateKey, System.Security.Cryptography.RSASignaturePadding? signaturePadding);
+         [System.Diagnostics.CodeAnalysis.ExperimentalAttribute("SYSLIB5006", UrlFormat = "https://aka.ms/dotnet-warnings/{0}")]
+         public CmsSigner(System.Security.Cryptography.Pkcs.SubjectIdentifierType signerIdentifierType, System.Security.Cryptography.X509Certificates.X509Certificate2? certificate, System.Security.Cryptography.SlhDsa? privateKey);
+         public CmsSigner(System.Security.Cryptography.Pkcs.SubjectIdentifierType signerIdentifierType, System.Security.Cryptography.X509Certificates.X509Certificate2? certificate);
+         public CmsSigner(System.Security.Cryptography.Pkcs.SubjectIdentifierType signerIdentifierType);
+         public CmsSigner(System.Security.Cryptography.X509Certificates.X509Certificate2? certificate);
+         public System.Security.Cryptography.X509Certificates.X509Certificate2? Certificate { get; set; }
+         public System.Security.Cryptography.X509Certificates.X509Certificate2Collection Certificates { get; }
+         public System.Security.Cryptography.Oid DigestAlgorithm { get; set; }
+         public System.Security.Cryptography.X509Certificates.X509IncludeOption IncludeOption { get; set; }
+         public System.Security.Cryptography.AsymmetricAlgorithm? PrivateKey { get; set; }
+         public System.Security.Cryptography.RSASignaturePadding? SignaturePadding { get; set; }
+         public System.Security.Cryptography.CryptographicAttributeObjectCollection SignedAttributes { get; }
+         public System.Security.Cryptography.Pkcs.SubjectIdentifierType SignerIdentifierType { get; set; }
+         public System.Security.Cryptography.CryptographicAttributeObjectCollection UnsignedAttributes { get; }
+     }
+     public sealed class ContentInfo
+     {
+         public ContentInfo(byte[] content);
+         public ContentInfo(System.Security.Cryptography.Oid contentType, byte[] content);
+         public static System.Security.Cryptography.Oid GetContentType(byte[] encodedMessage);
+         public static System.Security.Cryptography.Oid GetContentType(System.ReadOnlySpan<byte> encodedMessage);
+         public byte[] Content { get; }
+         public System.Security.Cryptography.Oid ContentType { get; }
+     }
+     public sealed class EnvelopedCms
+     {
+         public EnvelopedCms();
+         public EnvelopedCms(System.Security.Cryptography.Pkcs.ContentInfo contentInfo, System.Security.Cryptography.Pkcs.AlgorithmIdentifier encryptionAlgorithm);
+         public EnvelopedCms(System.Security.Cryptography.Pkcs.ContentInfo contentInfo);
+         public void Decode(byte[] encodedMessage);
+         public void Decode(System.ReadOnlySpan<byte> encodedMessage);
+         public void Decrypt();
+         public void Decrypt(System.Security.Cryptography.Pkcs.RecipientInfo recipientInfo, System.Security.Cryptography.AsymmetricAlgorithm? privateKey);
+         public void Decrypt(System.Security.Cryptography.Pkcs.RecipientInfo recipientInfo, System.Security.Cryptography.X509Certificates.X509Certificate2Collection extraStore);
+         public void Decrypt(System.Security.Cryptography.Pkcs.RecipientInfo recipientInfo);
+         public void Decrypt(System.Security.Cryptography.X509Certificates.X509Certificate2Collection extraStore);
+         public byte[] Encode();
+         public void Encrypt(System.Security.Cryptography.Pkcs.CmsRecipient recipient);
+         public void Encrypt(System.Security.Cryptography.Pkcs.CmsRecipientCollection recipients);
+         public System.Security.Cryptography.X509Certificates.X509Certificate2Collection Certificates { get; }
+         public System.Security.Cryptography.Pkcs.AlgorithmIdentifier ContentEncryptionAlgorithm { get; }
+         public System.Security.Cryptography.Pkcs.ContentInfo ContentInfo { get; }
+         public System.Security.Cryptography.Pkcs.RecipientInfoCollection RecipientInfos { get; }
+         public System.Security.Cryptography.CryptographicAttributeObjectCollection UnprotectedAttributes { get; }
+         public int Version { get; }
+     }
+     public sealed class KeyAgreeRecipientInfo : System.Security.Cryptography.Pkcs.RecipientInfo
+     {
+ public System.DateTime Date { get; }
+         public override byte[] EncryptedKey { get; }
+         public override System.Security.Cryptography.Pkcs.AlgorithmIdentifier KeyEncryptionAlgorithm { get; }
+         public System.Security.Cryptography.Pkcs.SubjectIdentifierOrKey OriginatorIdentifierOrKey { get; }
+         public System.Security.Cryptography.CryptographicAttributeObject? OtherKeyAttribute { get; }
+         public override System.Security.Cryptography.Pkcs.SubjectIdentifier RecipientIdentifier { get; }
+         public override int Version { get; }
+     }
+     public sealed class KeyTransRecipientInfo : System.Security.Cryptography.Pkcs.RecipientInfo
+     {
+ public override byte[] EncryptedKey { get; }
+         public override System.Security.Cryptography.Pkcs.AlgorithmIdentifier KeyEncryptionAlgorithm { get; }
+         public override System.Security.Cryptography.Pkcs.SubjectIdentifier RecipientIdentifier { get; }
+         public override int Version { get; }
+     }
+     public sealed class Pkcs12Builder
+     {
+         public Pkcs12Builder();
+         public void AddSafeContentsEncrypted(System.Security.Cryptography.Pkcs.Pkcs12SafeContents safeContents, byte[]? passwordBytes, System.Security.Cryptography.PbeParameters pbeParameters);
+         public void AddSafeContentsEncrypted(System.Security.Cryptography.Pkcs.Pkcs12SafeContents safeContents, System.ReadOnlySpan<byte> passwordBytes, System.Security.Cryptography.PbeParameters pbeParameters);
+         public void AddSafeContentsEncrypted(System.Security.Cryptography.Pkcs.Pkcs12SafeContents safeContents, System.ReadOnlySpan<char> password, System.Security.Cryptography.PbeParameters pbeParameters);
+         public void AddSafeContentsEncrypted(System.Security.Cryptography.Pkcs.Pkcs12SafeContents safeContents, string? password, System.Security.Cryptography.PbeParameters pbeParameters);
+         public void AddSafeContentsUnencrypted(System.Security.Cryptography.Pkcs.Pkcs12SafeContents safeContents);
+         public byte[] Encode();
+         public void SealWithMac(System.ReadOnlySpan<char> password, System.Security.Cryptography.HashAlgorithmName hashAlgorithm, int iterationCount);
+         public void SealWithMac(string? password, System.Security.Cryptography.HashAlgorithmName hashAlgorithm, int iterationCount);
+         public void SealWithoutIntegrity();
+         public bool TryEncode(System.Span<byte> destination, out int bytesWritten);
+         public bool IsSealed { get; }
+     }
+     public sealed class Pkcs12CertBag : System.Security.Cryptography.Pkcs.Pkcs12SafeBag
+     {
+         public Pkcs12CertBag(System.Security.Cryptography.Oid certificateType, System.ReadOnlyMemory<byte> encodedCertificate) : base(default(string)!, default(System.ReadOnlyMemory<byte>), default(bool));
+         public System.Security.Cryptography.X509Certificates.X509Certificate2 GetCertificate();
+         public System.Security.Cryptography.Oid GetCertificateType();
+         public System.ReadOnlyMemory<byte> EncodedCertificate { get; }
+         public bool IsX509Certificate { get; }
+     }
+     public enum Pkcs12ConfidentialityMode
+     {
+         Unknown = 0,
+         None = 1,
+         Password = 2,
+         PublicKey = 3,
+     }
+     public sealed class Pkcs12Info
+     {
+         public static System.Security.Cryptography.Pkcs.Pkcs12Info Decode(System.ReadOnlyMemory<byte> encodedBytes, out int bytesConsumed, bool skipCopy = false);
+         public bool VerifyMac(System.ReadOnlySpan<char> password);
+         public bool VerifyMac(string? password);
+ public System.Collections.ObjectModel.ReadOnlyCollection<System.Security.Cryptography.Pkcs.Pkcs12SafeContents> AuthenticatedSafe { get; }
+         public System.Security.Cryptography.Pkcs.Pkcs12IntegrityMode IntegrityMode { get; }
+     }
+     public enum Pkcs12IntegrityMode
+     {
+         Unknown = 0,
+         None = 1,
+         Password = 2,
+         PublicKey = 3,
+     }
+     public sealed class Pkcs12KeyBag : System.Security.Cryptography.Pkcs.Pkcs12SafeBag
+     {
+         public Pkcs12KeyBag(System.ReadOnlyMemory<byte> pkcs8PrivateKey, bool skipCopy = false) : base(default(string)!, default(System.ReadOnlyMemory<byte>), default(bool));
+         public System.ReadOnlyMemory<byte> Pkcs8PrivateKey { get; }
+     }
+     public abstract class Pkcs12SafeBag
+     {
+         protected Pkcs12SafeBag(string bagIdValue, System.ReadOnlyMemory<byte> encodedBagValue, bool skipCopy = false);
+         public byte[] Encode();
+         public System.Security.Cryptography.Oid GetBagId();
+         public bool TryEncode(System.Span<byte> destination, out int bytesWritten);
+         public System.Security.Cryptography.CryptographicAttributeObjectCollection Attributes { get; }
+         public System.ReadOnlyMemory<byte> EncodedBagValue { get; }
+     }
+     public sealed class Pkcs12SafeContents
+     {
+         public Pkcs12SafeContents();
+         public System.Security.Cryptography.Pkcs.Pkcs12CertBag AddCertificate(System.Security.Cryptography.X509Certificates.X509Certificate2 certificate);
+         public System.Security.Cryptography.Pkcs.Pkcs12KeyBag AddKeyUnencrypted(System.Security.Cryptography.AsymmetricAlgorithm key);
+         public System.Security.Cryptography.Pkcs.Pkcs12SafeContentsBag AddNestedContents(System.Security.Cryptography.Pkcs.Pkcs12SafeContents safeContents);
+         public void AddSafeBag(System.Security.Cryptography.Pkcs.Pkcs12SafeBag safeBag);
+         public System.Security.Cryptography.Pkcs.Pkcs12SecretBag AddSecret(System.Security.Cryptography.Oid secretType, System.ReadOnlyMemory<byte> secretValue);
+         public System.Security.Cryptography.Pkcs.Pkcs12ShroudedKeyBag AddShroudedKey(System.Security.Cryptography.AsymmetricAlgorithm key, byte[]? passwordBytes, System.Security.Cryptography.PbeParameters pbeParameters);
+         public System.Security.Cryptography.Pkcs.Pkcs12ShroudedKeyBag AddShroudedKey(System.Security.Cryptography.AsymmetricAlgorithm key, System.ReadOnlySpan<byte> passwordBytes, System.Security.Cryptography.PbeParameters pbeParameters);
+         public System.Security.Cryptography.Pkcs.Pkcs12ShroudedKeyBag AddShroudedKey(System.Security.Cryptography.AsymmetricAlgorithm key, System.ReadOnlySpan<char> password, System.Security.Cryptography.PbeParameters pbeParameters);
+         public System.Security.Cryptography.Pkcs.Pkcs12ShroudedKeyBag AddShroudedKey(System.Security.Cryptography.AsymmetricAlgorithm key, string? password, System.Security.Cryptography.PbeParameters pbeParameters);
+         public void Decrypt(byte[]? passwordBytes);
+         public void Decrypt(System.ReadOnlySpan<byte> passwordBytes);
+         public void Decrypt(System.ReadOnlySpan<char> password);
+         public void Decrypt(string? password);
+         public System.Collections.Generic.IEnumerable<System.Security.Cryptography.Pkcs.Pkcs12SafeBag> GetBags();
+         public System.Security.Cryptography.Pkcs.Pkcs12ConfidentialityMode ConfidentialityMode { get; }
+         public bool IsReadOnly { get; }
+     }
+     public sealed class Pkcs12SafeContentsBag : System.Security.Cryptography.Pkcs.Pkcs12SafeBag
+     {
+ public System.Security.Cryptography.Pkcs.Pkcs12SafeContents? SafeContents { get; }
+     }
+     public sealed class Pkcs12SecretBag : System.Security.Cryptography.Pkcs.Pkcs12SafeBag
+     {
+         public System.Security.Cryptography.Oid GetSecretType();
+ public System.ReadOnlyMemory<byte> SecretValue { get; }
+     }
+     public sealed class Pkcs12ShroudedKeyBag : System.Security.Cryptography.Pkcs.Pkcs12SafeBag
+     {
+         public Pkcs12ShroudedKeyBag(System.ReadOnlyMemory<byte> encryptedPkcs8PrivateKey, bool skipCopy = false) : base(default(string)!, default(System.ReadOnlyMemory<byte>), default(bool));
+         public System.ReadOnlyMemory<byte> EncryptedPkcs8PrivateKey { get; }
+     }
+     public sealed class Pkcs8PrivateKeyInfo
+     {
+         public Pkcs8PrivateKeyInfo(System.Security.Cryptography.Oid algorithmId, System.ReadOnlyMemory<byte>? algorithmParameters, System.ReadOnlyMemory<byte> privateKey, bool skipCopies = false);
+         public static System.Security.Cryptography.Pkcs.Pkcs8PrivateKeyInfo Create(System.Security.Cryptography.AsymmetricAlgorithm privateKey);
+         public static System.Security.Cryptography.Pkcs.Pkcs8PrivateKeyInfo Decode(System.ReadOnlyMemory<byte> source, out int bytesRead, bool skipCopy = false);
+         public static System.Security.Cryptography.Pkcs.Pkcs8PrivateKeyInfo DecryptAndDecode(System.ReadOnlySpan<byte> passwordBytes, System.ReadOnlyMemory<byte> source, out int bytesRead);
+         public static System.Security.Cryptography.Pkcs.Pkcs8PrivateKeyInfo DecryptAndDecode(System.ReadOnlySpan<char> password, System.ReadOnlyMemory<byte> source, out int bytesRead);
+         public byte[] Encode();
+         public byte[] Encrypt(System.ReadOnlySpan<byte> passwordBytes, System.Security.Cryptography.PbeParameters pbeParameters);
+         public byte[] Encrypt(System.ReadOnlySpan<char> password, System.Security.Cryptography.PbeParameters pbeParameters);
+         public bool TryEncode(System.Span<byte> destination, out int bytesWritten);
+         public bool TryEncrypt(System.ReadOnlySpan<byte> passwordBytes, System.Security.Cryptography.PbeParameters pbeParameters, System.Span<byte> destination, out int bytesWritten);
+         public bool TryEncrypt(System.ReadOnlySpan<char> password, System.Security.Cryptography.PbeParameters pbeParameters, System.Span<byte> destination, out int bytesWritten);
+         public System.Security.Cryptography.Oid AlgorithmId { get; }
+         public System.ReadOnlyMemory<byte>? AlgorithmParameters { get; }
+         public System.Security.Cryptography.CryptographicAttributeObjectCollection Attributes { get; }
+         public System.ReadOnlyMemory<byte> PrivateKeyBytes { get; }
+     }
+     public class Pkcs9AttributeObject : System.Security.Cryptography.AsnEncodedData
+     {
+         public Pkcs9AttributeObject();
+         public Pkcs9AttributeObject(System.Security.Cryptography.AsnEncodedData asnEncodedData);
+         public Pkcs9AttributeObject(System.Security.Cryptography.Oid oid, byte[] encodedData);
+         public Pkcs9AttributeObject(string oid, byte[] encodedData);
+         public override void CopyFrom(System.Security.Cryptography.AsnEncodedData asnEncodedData);
+         public new System.Security.Cryptography.Oid? Oid { get; }
+     }
+     public sealed class Pkcs9ContentType : System.Security.Cryptography.Pkcs.Pkcs9AttributeObject
+     {
+         public Pkcs9ContentType();
+         public override void CopyFrom(System.Security.Cryptography.AsnEncodedData asnEncodedData);
+         public System.Security.Cryptography.Oid ContentType { get; }
+     }
+     public sealed class Pkcs9DocumentDescription : System.Security.Cryptography.Pkcs.Pkcs9AttributeObject
+     {
+         public Pkcs9DocumentDescription();
+         public Pkcs9DocumentDescription(byte[] encodedDocumentDescription);
+         public Pkcs9DocumentDescription(string documentDescription);
+         public override void CopyFrom(System.Security.Cryptography.AsnEncodedData asnEncodedData);
+         public string DocumentDescription { get; }
+     }
+     public sealed class Pkcs9DocumentName : System.Security.Cryptography.Pkcs.Pkcs9AttributeObject
+     {
+         public Pkcs9DocumentName();
+         public Pkcs9DocumentName(byte[] encodedDocumentName);
+         public Pkcs9DocumentName(string documentName);
+         public override void CopyFrom(System.Security.Cryptography.AsnEncodedData asnEncodedData);
+         public string DocumentName { get; }
+     }
+     public sealed class Pkcs9LocalKeyId : System.Security.Cryptography.Pkcs.Pkcs9AttributeObject
+     {
+         public Pkcs9LocalKeyId();
+         public Pkcs9LocalKeyId(byte[] keyId);
+         public Pkcs9LocalKeyId(System.ReadOnlySpan<byte> keyId);
+         public System.ReadOnlyMemory<byte> KeyId { get; }
+     }
+     public sealed class Pkcs9MessageDigest : System.Security.Cryptography.Pkcs.Pkcs9AttributeObject
+     {
+         public Pkcs9MessageDigest();
+         public override void CopyFrom(System.Security.Cryptography.AsnEncodedData asnEncodedData);
+         public byte[] MessageDigest { get; }
+     }
+     public sealed class Pkcs9SigningTime : System.Security.Cryptography.Pkcs.Pkcs9AttributeObject
+     {
+         public Pkcs9SigningTime();
+         public Pkcs9SigningTime(byte[] encodedSigningTime);
+         public Pkcs9SigningTime(System.DateTime signingTime);
+         public override void CopyFrom(System.Security.Cryptography.AsnEncodedData asnEncodedData);
+         public System.DateTime SigningTime { get; }
+     }
+     public sealed class PublicKeyInfo
+     {
+ public System.Security.Cryptography.Pkcs.AlgorithmIdentifier Algorithm { get; }
+         public byte[] KeyValue { get; }
+     }
+     public abstract class RecipientInfo
+     {
+ public abstract byte[] EncryptedKey { get; }
+         public abstract System.Security.Cryptography.Pkcs.AlgorithmIdentifier KeyEncryptionAlgorithm { get; }
+         public abstract System.Security.Cryptography.Pkcs.SubjectIdentifier RecipientIdentifier { get; }
+         public System.Security.Cryptography.Pkcs.RecipientInfoType Type { get; }
+         public abstract int Version { get; }
+     }
+     public sealed class RecipientInfoCollection : System.Collections.ICollection, System.Collections.IEnumerable
+     {
+         public void CopyTo(System.Array array, int index);
+         public void CopyTo(System.Security.Cryptography.Pkcs.RecipientInfo[] array, int index);
+         public System.Security.Cryptography.Pkcs.RecipientInfoEnumerator GetEnumerator();
+ public int Count { get; }
+         public bool IsSynchronized { get; }
+         public System.Security.Cryptography.Pkcs.RecipientInfo this[int index] {
+             get { }
+         }
+         public object SyncRoot { get; }
+     }
+     public sealed class RecipientInfoEnumerator : System.Collections.IEnumerator
+     {
+         public bool MoveNext();
+         public void Reset();
+ public System.Security.Cryptography.Pkcs.RecipientInfo Current { get; }
+     }
+     public enum RecipientInfoType
+     {
+         Unknown = 0,
+         KeyTransport = 1,
+         KeyAgreement = 2,
+     }
+     public sealed class Rfc3161TimestampRequest
+     {
+         public static System.Security.Cryptography.Pkcs.Rfc3161TimestampRequest CreateFromData(System.ReadOnlySpan<byte> data, System.Security.Cryptography.HashAlgorithmName hashAlgorithm, System.Security.Cryptography.Oid? requestedPolicyId = null, System.ReadOnlyMemory<byte>? nonce = null, bool requestSignerCertificates = false, System.Security.Cryptography.X509Certificates.X509ExtensionCollection? extensions = null);
+         public static System.Security.Cryptography.Pkcs.Rfc3161TimestampRequest CreateFromHash(System.ReadOnlyMemory<byte> hash, System.Security.Cryptography.HashAlgorithmName hashAlgorithm, System.Security.Cryptography.Oid? requestedPolicyId = null, System.ReadOnlyMemory<byte>? nonce = null, bool requestSignerCertificates = false, System.Security.Cryptography.X509Certificates.X509ExtensionCollection? extensions = null);
+         public static System.Security.Cryptography.Pkcs.Rfc3161TimestampRequest CreateFromHash(System.ReadOnlyMemory<byte> hash, System.Security.Cryptography.Oid hashAlgorithmId, System.Security.Cryptography.Oid? requestedPolicyId = null, System.ReadOnlyMemory<byte>? nonce = null, bool requestSignerCertificates = false, System.Security.Cryptography.X509Certificates.X509ExtensionCollection? extensions = null);
+         public static System.Security.Cryptography.Pkcs.Rfc3161TimestampRequest CreateFromSignerInfo(System.Security.Cryptography.Pkcs.SignerInfo signerInfo, System.Security.Cryptography.HashAlgorithmName hashAlgorithm, System.Security.Cryptography.Oid? requestedPolicyId = null, System.ReadOnlyMemory<byte>? nonce = null, bool requestSignerCertificates = false, System.Security.Cryptography.X509Certificates.X509ExtensionCollection? extensions = null);
+         public byte[] Encode();
+         public System.Security.Cryptography.X509Certificates.X509ExtensionCollection GetExtensions();
+         public System.ReadOnlyMemory<byte> GetMessageHash();
+         public System.ReadOnlyMemory<byte>? GetNonce();
+         public System.Security.Cryptography.Pkcs.Rfc3161TimestampToken ProcessResponse(System.ReadOnlyMemory<byte> responseBytes, out int bytesConsumed);
+         public static bool TryDecode(System.ReadOnlyMemory<byte> encodedBytes, out System.Security.Cryptography.Pkcs.Rfc3161TimestampRequest? request, out int bytesConsumed);
+         public bool TryEncode(System.Span<byte> destination, out int bytesWritten);
+ public bool HasExtensions { get; }
+         public System.Security.Cryptography.Oid HashAlgorithmId { get; }
+         public System.Security.Cryptography.Oid? RequestedPolicyId { get; }
+         public bool RequestSignerCertificate { get; }
+         public int Version { get; }
+     }
+     public sealed class Rfc3161TimestampToken
+     {
+         public System.Security.Cryptography.Pkcs.SignedCms AsSignedCms();
+         public static bool TryDecode(System.ReadOnlyMemory<byte> encodedBytes, out System.Security.Cryptography.Pkcs.Rfc3161TimestampToken? token, out int bytesConsumed);
+         public bool VerifySignatureForData(System.ReadOnlySpan<byte> data, out System.Security.Cryptography.X509Certificates.X509Certificate2? signerCertificate, System.Security.Cryptography.X509Certificates.X509Certificate2Collection? extraCandidates = null);
+         public bool VerifySignatureForHash(System.ReadOnlySpan<byte> hash, System.Security.Cryptography.HashAlgorithmName hashAlgorithm, out System.Security.Cryptography.X509Certificates.X509Certificate2? signerCertificate, System.Security.Cryptography.X509Certificates.X509Certificate2Collection? extraCandidates = null);
+         public bool VerifySignatureForHash(System.ReadOnlySpan<byte> hash, System.Security.Cryptography.Oid hashAlgorithmId, out System.Security.Cryptography.X509Certificates.X509Certificate2? signerCertificate, System.Security.Cryptography.X509Certificates.X509Certificate2Collection? extraCandidates = null);
+         public bool VerifySignatureForSignerInfo(System.Security.Cryptography.Pkcs.SignerInfo signerInfo, out System.Security.Cryptography.X509Certificates.X509Certificate2? signerCertificate, System.Security.Cryptography.X509Certificates.X509Certificate2Collection? extraCandidates = null);
+ public System.Security.Cryptography.Pkcs.Rfc3161TimestampTokenInfo TokenInfo { get; }
+     }
+     public sealed class Rfc3161TimestampTokenInfo
+     {
+         public Rfc3161TimestampTokenInfo(System.Security.Cryptography.Oid policyId, System.Security.Cryptography.Oid hashAlgorithmId, System.ReadOnlyMemory<byte> messageHash, System.ReadOnlyMemory<byte> serialNumber, System.DateTimeOffset timestamp, long? accuracyInMicroseconds = null, bool isOrdering = false, System.ReadOnlyMemory<byte>? nonce = null, System.ReadOnlyMemory<byte>? timestampAuthorityName = null, System.Security.Cryptography.X509Certificates.X509ExtensionCollection? extensions = null);
+         public byte[] Encode();
+         public System.Security.Cryptography.X509Certificates.X509ExtensionCollection GetExtensions();
+         public System.ReadOnlyMemory<byte> GetMessageHash();
+         public System.ReadOnlyMemory<byte>? GetNonce();
+         public System.ReadOnlyMemory<byte> GetSerialNumber();
+         public System.ReadOnlyMemory<byte>? GetTimestampAuthorityName();
+         public static bool TryDecode(System.ReadOnlyMemory<byte> encodedBytes, out System.Security.Cryptography.Pkcs.Rfc3161TimestampTokenInfo? timestampTokenInfo, out int bytesConsumed);
+         public bool TryEncode(System.Span<byte> destination, out int bytesWritten);
+         public long? AccuracyInMicroseconds { get; }
+         public bool HasExtensions { get; }
+         public System.Security.Cryptography.Oid HashAlgorithmId { get; }
+         public bool IsOrdering { get; }
+         public System.Security.Cryptography.Oid PolicyId { get; }
+         public System.DateTimeOffset Timestamp { get; }
+         public int Version { get; }
+     }
+     public sealed class SignedCms
+     {
+         public SignedCms();
+         public SignedCms(System.Security.Cryptography.Pkcs.ContentInfo contentInfo, bool detached);
+         public SignedCms(System.Security.Cryptography.Pkcs.ContentInfo contentInfo);
+         public SignedCms(System.Security.Cryptography.Pkcs.SubjectIdentifierType signerIdentifierType, System.Security.Cryptography.Pkcs.ContentInfo contentInfo, bool detached);
+         public SignedCms(System.Security.Cryptography.Pkcs.SubjectIdentifierType signerIdentifierType, System.Security.Cryptography.Pkcs.ContentInfo contentInfo);
+         public SignedCms(System.Security.Cryptography.Pkcs.SubjectIdentifierType signerIdentifierType);
+         public void AddCertificate(System.Security.Cryptography.X509Certificates.X509Certificate2 certificate);
+         public void CheckHash();
+         public void CheckSignature(bool verifySignatureOnly);
+         public void CheckSignature(System.Security.Cryptography.X509Certificates.X509Certificate2Collection extraStore, bool verifySignatureOnly);
+         public void ComputeSignature();
+         public void ComputeSignature(System.Security.Cryptography.Pkcs.CmsSigner signer, bool silent);
+         public void ComputeSignature(System.Security.Cryptography.Pkcs.CmsSigner signer);
+         public void Decode(byte[] encodedMessage);
+         public void Decode(System.ReadOnlySpan<byte> encodedMessage);
+         public byte[] Encode();
+         public void RemoveCertificate(System.Security.Cryptography.X509Certificates.X509Certificate2 certificate);
+         public void RemoveSignature(int index);
+         public void RemoveSignature(System.Security.Cryptography.Pkcs.SignerInfo signerInfo);
+         public System.Security.Cryptography.X509Certificates.X509Certificate2Collection Certificates { get; }
+         public System.Security.Cryptography.Pkcs.ContentInfo ContentInfo { get; }
+         public bool Detached { get; }
+         public System.Security.Cryptography.Pkcs.SignerInfoCollection SignerInfos { get; }
+         public int Version { get; }
+     }
+     public sealed class SignerInfo
+     {
+         public void AddUnsignedAttribute(System.Security.Cryptography.AsnEncodedData unsignedAttribute);
+         public void CheckHash();
+         public void CheckSignature(bool verifySignatureOnly);
+         public void CheckSignature(System.Security.Cryptography.X509Certificates.X509Certificate2Collection extraStore, bool verifySignatureOnly);
+         [System.ObsoleteAttribute("ComputeCounterSignature without specifying a CmsSigner is obsolete and is not supported. Use the overload that accepts a CmsSigner.", DiagnosticId = "SYSLIB0035", UrlFormat = "https://aka.ms/dotnet-warnings/{0}")]
+         public void ComputeCounterSignature();
+         public void ComputeCounterSignature(System.Security.Cryptography.Pkcs.CmsSigner signer);
+         public byte[] GetSignature();
+         public void RemoveCounterSignature(int index);
+         public void RemoveCounterSignature(System.Security.Cryptography.Pkcs.SignerInfo counterSignerInfo);
+         public void RemoveUnsignedAttribute(System.Security.Cryptography.AsnEncodedData unsignedAttribute);
+ public System.Security.Cryptography.X509Certificates.X509Certificate2? Certificate { get; }
+         public System.Security.Cryptography.Pkcs.SignerInfoCollection CounterSignerInfos { get; }
+         public System.Security.Cryptography.Oid DigestAlgorithm { get; }
+         public System.Security.Cryptography.Oid SignatureAlgorithm { get; }
+         public System.Security.Cryptography.CryptographicAttributeObjectCollection SignedAttributes { get; }
+         public System.Security.Cryptography.Pkcs.SubjectIdentifier SignerIdentifier { get; }
+         public System.Security.Cryptography.CryptographicAttributeObjectCollection UnsignedAttributes { get; }
+         public int Version { get; }
+     }
+     public sealed class SignerInfoCollection : System.Collections.ICollection, System.Collections.IEnumerable
+     {
+         public void CopyTo(System.Array array, int index);
+         public void CopyTo(System.Security.Cryptography.Pkcs.SignerInfo[] array, int index);
+         public System.Security.Cryptography.Pkcs.SignerInfoEnumerator GetEnumerator();
+ public int Count { get; }
+         public bool IsSynchronized { get; }
+         public System.Security.Cryptography.Pkcs.SignerInfo this[int index] {
+             get { }
+         }
+         public object SyncRoot { get; }
+     }
+     public sealed class SignerInfoEnumerator : System.Collections.IEnumerator
+     {
+         public bool MoveNext();
+         public void Reset();
+ public System.Security.Cryptography.Pkcs.SignerInfo Current { get; }
+     }
+     public sealed class SubjectIdentifier
+     {
+         public bool MatchesCertificate(System.Security.Cryptography.X509Certificates.X509Certificate2 certificate);
+ public System.Security.Cryptography.Pkcs.SubjectIdentifierType Type { get; }
+         public object? Value { get; }
+     }
+     public sealed class SubjectIdentifierOrKey
+     {
+ public System.Security.Cryptography.Pkcs.SubjectIdentifierOrKeyType Type { get; }
+         public object Value { get; }
+     }
+     public enum SubjectIdentifierOrKeyType
+     {
+         Unknown = 0,
+         IssuerAndSerialNumber = 1,
+         SubjectKeyIdentifier = 2,
+         PublicKeyInfo = 3,
+     }
+     public enum SubjectIdentifierType
+     {
+         Unknown = 0,
+         IssuerAndSerialNumber = 1,
+         SubjectKeyIdentifier = 2,
+         NoSignature = 3,
+     }
+ }
+ namespace System.Security.Cryptography.Xml
+ {
+     public struct X509IssuerSerial
+     {
+         public string IssuerName { get; set; }
+         public string SerialNumber { get; set; }
+     }
+ }
```
