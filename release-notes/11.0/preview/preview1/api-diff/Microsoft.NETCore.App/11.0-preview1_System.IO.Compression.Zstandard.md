# System.IO.Compression.Zstandard

```diff
+ namespace System.IO.Compression
+ {
+     public sealed class ZstandardCompressionOptions
+     {
+         public ZstandardCompressionOptions();
+         public bool AppendChecksum { get; set; }
+         public static int DefaultQuality { get; }
+         public static int DefaultWindowLog { get; }
+         public System.IO.Compression.ZstandardDictionary? Dictionary { get; set; }
+         public bool EnableLongDistanceMatching { get; set; }
+         public static int MaxQuality { get; }
+         public static int MaxWindowLog { get; }
+         public static int MinQuality { get; }
+         public static int MinWindowLog { get; }
+         public int Quality { get; set; }
+         public int TargetBlockSize { get; set; }
+         public int WindowLog { get; set; }
+     }
+     public sealed class ZstandardDecoder : System.IDisposable
+     {
+         public ZstandardDecoder();
+         public ZstandardDecoder(int maxWindowLog);
+         public ZstandardDecoder(System.IO.Compression.ZstandardDictionary dictionary, int maxWindowLog);
+         public ZstandardDecoder(System.IO.Compression.ZstandardDictionary dictionary);
+         public System.Buffers.OperationStatus Decompress(System.ReadOnlySpan<byte> source, System.Span<byte> destination, out int bytesConsumed, out int bytesWritten);
+         public void Dispose();
+         public void Reset();
+         public void SetPrefix(System.ReadOnlyMemory<byte> prefix);
+         public static bool TryDecompress(System.ReadOnlySpan<byte> source, System.Span<byte> destination, out int bytesWritten, System.IO.Compression.ZstandardDictionary dictionary);
+         public static bool TryDecompress(System.ReadOnlySpan<byte> source, System.Span<byte> destination, out int bytesWritten);
+         public static bool TryGetMaxDecompressedLength(System.ReadOnlySpan<byte> data, out long length);
+     }
+     public sealed class ZstandardDictionary : System.IDisposable
+     {
+         public static System.IO.Compression.ZstandardDictionary Create(System.ReadOnlySpan<byte> buffer, int quality);
+         public static System.IO.Compression.ZstandardDictionary Create(System.ReadOnlySpan<byte> buffer);
+         public void Dispose();
+         public static System.IO.Compression.ZstandardDictionary Train(System.ReadOnlySpan<byte> samples, System.ReadOnlySpan<int> sampleLengths, int maxDictionarySize);
+ public System.ReadOnlyMemory<byte> Data { get; }
+     }
+     public sealed class ZstandardEncoder : System.IDisposable
+     {
+         public ZstandardEncoder();
+         public ZstandardEncoder(int quality, int windowLog);
+         public ZstandardEncoder(int quality);
+         public ZstandardEncoder(System.IO.Compression.ZstandardCompressionOptions compressionOptions);
+         public ZstandardEncoder(System.IO.Compression.ZstandardDictionary dictionary, int windowLog);
+         public ZstandardEncoder(System.IO.Compression.ZstandardDictionary dictionary);
+         public System.Buffers.OperationStatus Compress(System.ReadOnlySpan<byte> source, System.Span<byte> destination, out int bytesConsumed, out int bytesWritten, bool isFinalBlock);
+         public void Dispose();
+         public System.Buffers.OperationStatus Flush(System.Span<byte> destination, out int bytesWritten);
+         public static long GetMaxCompressedLength(long inputLength);
+         public void Reset();
+         public void SetPrefix(System.ReadOnlyMemory<byte> prefix);
+         public void SetSourceLength(long length);
+         public static bool TryCompress(System.ReadOnlySpan<byte> source, System.Span<byte> destination, out int bytesWritten, int quality, int windowLog);
+         public static bool TryCompress(System.ReadOnlySpan<byte> source, System.Span<byte> destination, out int bytesWritten, System.IO.Compression.ZstandardDictionary dictionary, int windowLog);
+         public static bool TryCompress(System.ReadOnlySpan<byte> source, System.Span<byte> destination, out int bytesWritten);
+     }
+     public sealed class ZstandardStream : System.IO.Stream
+     {
+         public ZstandardStream(System.IO.Stream stream, System.IO.Compression.CompressionLevel compressionLevel, bool leaveOpen);
+         public ZstandardStream(System.IO.Stream stream, System.IO.Compression.CompressionLevel compressionLevel);
+         public ZstandardStream(System.IO.Stream stream, System.IO.Compression.CompressionMode mode, bool leaveOpen);
+         public ZstandardStream(System.IO.Stream stream, System.IO.Compression.CompressionMode mode, System.IO.Compression.ZstandardDictionary dictionary, bool leaveOpen = false);
+         public ZstandardStream(System.IO.Stream stream, System.IO.Compression.CompressionMode mode);
+         public ZstandardStream(System.IO.Stream stream, System.IO.Compression.ZstandardCompressionOptions compressionOptions, bool leaveOpen = false);
+         public ZstandardStream(System.IO.Stream stream, System.IO.Compression.ZstandardDecoder decoder, bool leaveOpen = false);
+         public ZstandardStream(System.IO.Stream stream, System.IO.Compression.ZstandardEncoder encoder, bool leaveOpen = false);
+         public override System.IAsyncResult BeginRead(byte[] buffer, int offset, int count, System.AsyncCallback? callback, object? state);
+         public override System.IAsyncResult BeginWrite(byte[] buffer, int offset, int count, System.AsyncCallback? callback, object? state);
+         protected override void Dispose(bool disposing);
+         public override System.Threading.Tasks.ValueTask DisposeAsync();
+         public override int EndRead(System.IAsyncResult asyncResult);
+         public override void EndWrite(System.IAsyncResult asyncResult);
+         public override void Flush();
+         public override System.Threading.Tasks.Task FlushAsync(System.Threading.CancellationToken cancellationToken);
+         public override int Read(byte[] buffer, int offset, int count);
+         public override int Read(System.Span<byte> buffer);
+         public override System.Threading.Tasks.Task<int> ReadAsync(byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);
+         public override System.Threading.Tasks.ValueTask<int> ReadAsync(System.Memory<byte> buffer, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
+         public override int ReadByte();
+         public override long Seek(long offset, System.IO.SeekOrigin origin);
+         public override void SetLength(long value);
+         public void SetSourceLength(long length);
+         public override void Write(byte[] buffer, int offset, int count);
+         public override void Write(System.ReadOnlySpan<byte> buffer);
+         public override System.Threading.Tasks.Task WriteAsync(byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);
+         public override System.Threading.Tasks.ValueTask WriteAsync(System.ReadOnlyMemory<byte> buffer, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
+         public override void WriteByte(byte value);
+         public System.IO.Stream BaseStream { get; }
+         public override bool CanRead { get; }
+         public override bool CanSeek { get; }
+         public override bool CanWrite { get; }
+         public override long Length { get; }
+         public override long Position { get; set; }
+     }
+ }
```
