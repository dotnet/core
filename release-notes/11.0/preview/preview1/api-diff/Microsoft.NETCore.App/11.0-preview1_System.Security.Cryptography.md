# System.Security.Cryptography

```diff
  namespace System.Security.Cryptography
  {
      public static class CryptographicOperations
      {
+         public static bool VerifyHmac(System.Security.Cryptography.HashAlgorithmName hashAlgorithm, byte[] key, byte[] source, byte[] hash);
+         public static bool VerifyHmac(System.Security.Cryptography.HashAlgorithmName hashAlgorithm, byte[] key, System.IO.Stream source, byte[] hash);
+         public static bool VerifyHmac(System.Security.Cryptography.HashAlgorithmName hashAlgorithm, System.ReadOnlySpan<byte> key, System.IO.Stream source, System.ReadOnlySpan<byte> hash);
+         public static bool VerifyHmac(System.Security.Cryptography.HashAlgorithmName hashAlgorithm, System.ReadOnlySpan<byte> key, System.ReadOnlySpan<byte> source, System.ReadOnlySpan<byte> hash);
+         public static System.Threading.Tasks.ValueTask<bool> VerifyHmacAsync(System.Security.Cryptography.HashAlgorithmName hashAlgorithm, byte[] key, System.IO.Stream source, byte[] hash, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
+         public static System.Threading.Tasks.ValueTask<bool> VerifyHmacAsync(System.Security.Cryptography.HashAlgorithmName hashAlgorithm, System.ReadOnlyMemory<byte> key, System.IO.Stream source, System.ReadOnlyMemory<byte> hash, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
      }
      public class HMACMD5 : System.Security.Cryptography.HMAC
      {
+         public static bool Verify(byte[] key, byte[] source, byte[] hash);
+         public static bool Verify(byte[] key, System.IO.Stream source, byte[] hash);
+         public static bool Verify(System.ReadOnlySpan<byte> key, System.IO.Stream source, System.ReadOnlySpan<byte> hash);
+         public static bool Verify(System.ReadOnlySpan<byte> key, System.ReadOnlySpan<byte> source, System.ReadOnlySpan<byte> hash);
+         public static System.Threading.Tasks.ValueTask<bool> VerifyAsync(byte[] key, System.IO.Stream source, byte[] hash, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
+         public static System.Threading.Tasks.ValueTask<bool> VerifyAsync(System.ReadOnlyMemory<byte> key, System.IO.Stream source, System.ReadOnlyMemory<byte> hash, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
      }
      public class HMACSHA1 : System.Security.Cryptography.HMAC
      {
+         public static bool Verify(byte[] key, byte[] source, byte[] hash);
+         public static bool Verify(byte[] key, System.IO.Stream source, byte[] hash);
+         public static bool Verify(System.ReadOnlySpan<byte> key, System.IO.Stream source, System.ReadOnlySpan<byte> hash);
+         public static bool Verify(System.ReadOnlySpan<byte> key, System.ReadOnlySpan<byte> source, System.ReadOnlySpan<byte> hash);
+         public static System.Threading.Tasks.ValueTask<bool> VerifyAsync(byte[] key, System.IO.Stream source, byte[] hash, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
+         public static System.Threading.Tasks.ValueTask<bool> VerifyAsync(System.ReadOnlyMemory<byte> key, System.IO.Stream source, System.ReadOnlyMemory<byte> hash, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
      }
      public class HMACSHA256 : System.Security.Cryptography.HMAC
      {
+         public static bool Verify(byte[] key, byte[] source, byte[] hash);
+         public static bool Verify(byte[] key, System.IO.Stream source, byte[] hash);
+         public static bool Verify(System.ReadOnlySpan<byte> key, System.IO.Stream source, System.ReadOnlySpan<byte> hash);
+         public static bool Verify(System.ReadOnlySpan<byte> key, System.ReadOnlySpan<byte> source, System.ReadOnlySpan<byte> hash);
+         public static System.Threading.Tasks.ValueTask<bool> VerifyAsync(byte[] key, System.IO.Stream source, byte[] hash, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
+         public static System.Threading.Tasks.ValueTask<bool> VerifyAsync(System.ReadOnlyMemory<byte> key, System.IO.Stream source, System.ReadOnlyMemory<byte> hash, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
      }
      public class HMACSHA3_256 : System.Security.Cryptography.HMAC
      {
+         public static bool Verify(byte[] key, byte[] source, byte[] hash);
+         public static bool Verify(byte[] key, System.IO.Stream source, byte[] hash);
+         public static bool Verify(System.ReadOnlySpan<byte> key, System.IO.Stream source, System.ReadOnlySpan<byte> hash);
+         public static bool Verify(System.ReadOnlySpan<byte> key, System.ReadOnlySpan<byte> source, System.ReadOnlySpan<byte> hash);
+         public static System.Threading.Tasks.ValueTask<bool> VerifyAsync(byte[] key, System.IO.Stream source, byte[] hash, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
+         public static System.Threading.Tasks.ValueTask<bool> VerifyAsync(System.ReadOnlyMemory<byte> key, System.IO.Stream source, System.ReadOnlyMemory<byte> hash, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
      }
      public class HMACSHA3_384 : System.Security.Cryptography.HMAC
      {
+         public static bool Verify(byte[] key, byte[] source, byte[] hash);
+         public static bool Verify(byte[] key, System.IO.Stream source, byte[] hash);
+         public static bool Verify(System.ReadOnlySpan<byte> key, System.IO.Stream source, System.ReadOnlySpan<byte> hash);
+         public static bool Verify(System.ReadOnlySpan<byte> key, System.ReadOnlySpan<byte> source, System.ReadOnlySpan<byte> hash);
+         public static System.Threading.Tasks.ValueTask<bool> VerifyAsync(byte[] key, System.IO.Stream source, byte[] hash, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
+         public static System.Threading.Tasks.ValueTask<bool> VerifyAsync(System.ReadOnlyMemory<byte> key, System.IO.Stream source, System.ReadOnlyMemory<byte> hash, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
      }
      public class HMACSHA3_512 : System.Security.Cryptography.HMAC
      {
+         public static bool Verify(byte[] key, byte[] source, byte[] hash);
+         public static bool Verify(byte[] key, System.IO.Stream source, byte[] hash);
+         public static bool Verify(System.ReadOnlySpan<byte> key, System.IO.Stream source, System.ReadOnlySpan<byte> hash);
+         public static bool Verify(System.ReadOnlySpan<byte> key, System.ReadOnlySpan<byte> source, System.ReadOnlySpan<byte> hash);
+         public static System.Threading.Tasks.ValueTask<bool> VerifyAsync(byte[] key, System.IO.Stream source, byte[] hash, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
+         public static System.Threading.Tasks.ValueTask<bool> VerifyAsync(System.ReadOnlyMemory<byte> key, System.IO.Stream source, System.ReadOnlyMemory<byte> hash, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
      }
      public class HMACSHA384 : System.Security.Cryptography.HMAC
      {
+         public static bool Verify(byte[] key, byte[] source, byte[] hash);
+         public static bool Verify(byte[] key, System.IO.Stream source, byte[] hash);
+         public static bool Verify(System.ReadOnlySpan<byte> key, System.IO.Stream source, System.ReadOnlySpan<byte> hash);
+         public static bool Verify(System.ReadOnlySpan<byte> key, System.ReadOnlySpan<byte> source, System.ReadOnlySpan<byte> hash);
+         public static System.Threading.Tasks.ValueTask<bool> VerifyAsync(byte[] key, System.IO.Stream source, byte[] hash, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
+         public static System.Threading.Tasks.ValueTask<bool> VerifyAsync(System.ReadOnlyMemory<byte> key, System.IO.Stream source, System.ReadOnlyMemory<byte> hash, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
      }
      public class HMACSHA512 : System.Security.Cryptography.HMAC
      {
+         public static bool Verify(byte[] key, byte[] source, byte[] hash);
+         public static bool Verify(byte[] key, System.IO.Stream source, byte[] hash);
+         public static bool Verify(System.ReadOnlySpan<byte> key, System.IO.Stream source, System.ReadOnlySpan<byte> hash);
+         public static bool Verify(System.ReadOnlySpan<byte> key, System.ReadOnlySpan<byte> source, System.ReadOnlySpan<byte> hash);
+         public static System.Threading.Tasks.ValueTask<bool> VerifyAsync(byte[] key, System.IO.Stream source, byte[] hash, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
+         public static System.Threading.Tasks.ValueTask<bool> VerifyAsync(System.ReadOnlyMemory<byte> key, System.IO.Stream source, System.ReadOnlyMemory<byte> hash, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
      }
      public sealed class IncrementalHash : System.IDisposable
      {
+         public bool VerifyCurrentHash(byte[] hash);
+         public bool VerifyCurrentHash(System.ReadOnlySpan<byte> hash);
+         public bool VerifyHashAndReset(byte[] hash);
+         public bool VerifyHashAndReset(System.ReadOnlySpan<byte> hash);
      }
      public sealed class Kmac128 : System.IDisposable
      {
+         public static bool Verify(byte[] key, byte[] source, byte[] hash, byte[]? customizationString = null);
+         public static bool Verify(byte[] key, System.IO.Stream source, byte[] hash, byte[]? customizationString = null);
+         public static bool Verify(System.ReadOnlySpan<byte> key, System.IO.Stream source, System.ReadOnlySpan<byte> hash, System.ReadOnlySpan<byte> customizationString = default(System.ReadOnlySpan<byte>));
+         public static bool Verify(System.ReadOnlySpan<byte> key, System.ReadOnlySpan<byte> source, System.ReadOnlySpan<byte> hash, System.ReadOnlySpan<byte> customizationString = default(System.ReadOnlySpan<byte>));
+         public static System.Threading.Tasks.ValueTask<bool> VerifyAsync(byte[] key, System.IO.Stream source, byte[] hash, byte[]? customizationString = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
+         public static System.Threading.Tasks.ValueTask<bool> VerifyAsync(System.ReadOnlyMemory<byte> key, System.IO.Stream source, System.ReadOnlyMemory<byte> hash, System.ReadOnlyMemory<byte> customizationString = default(System.ReadOnlyMemory<byte>), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
+         public bool VerifyCurrentHash(byte[] hash);
+         public bool VerifyCurrentHash(System.ReadOnlySpan<byte> hash);
+         public bool VerifyHashAndReset(byte[] hash);
+         public bool VerifyHashAndReset(System.ReadOnlySpan<byte> hash);
      }
      public sealed class Kmac256 : System.IDisposable
      {
+         public static bool Verify(byte[] key, byte[] source, byte[] hash, byte[]? customizationString = null);
+         public static bool Verify(byte[] key, System.IO.Stream source, byte[] hash, byte[]? customizationString = null);
+         public static bool Verify(System.ReadOnlySpan<byte> key, System.IO.Stream source, System.ReadOnlySpan<byte> hash, System.ReadOnlySpan<byte> customizationString = default(System.ReadOnlySpan<byte>));
+         public static bool Verify(System.ReadOnlySpan<byte> key, System.ReadOnlySpan<byte> source, System.ReadOnlySpan<byte> hash, System.ReadOnlySpan<byte> customizationString = default(System.ReadOnlySpan<byte>));
+         public static System.Threading.Tasks.ValueTask<bool> VerifyAsync(byte[] key, System.IO.Stream source, byte[] hash, byte[]? customizationString = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
+         public static System.Threading.Tasks.ValueTask<bool> VerifyAsync(System.ReadOnlyMemory<byte> key, System.IO.Stream source, System.ReadOnlyMemory<byte> hash, System.ReadOnlyMemory<byte> customizationString = default(System.ReadOnlyMemory<byte>), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
+         public bool VerifyCurrentHash(byte[] hash);
+         public bool VerifyCurrentHash(System.ReadOnlySpan<byte> hash);
+         public bool VerifyHashAndReset(byte[] hash);
+         public bool VerifyHashAndReset(System.ReadOnlySpan<byte> hash);
      }
      public sealed class KmacXof128 : System.IDisposable
      {
+         public static bool Verify(byte[] key, byte[] source, byte[] hash, byte[]? customizationString = null);
+         public static bool Verify(byte[] key, System.IO.Stream source, byte[] hash, byte[]? customizationString = null);
+         public static bool Verify(System.ReadOnlySpan<byte> key, System.IO.Stream source, System.ReadOnlySpan<byte> hash, System.ReadOnlySpan<byte> customizationString = default(System.ReadOnlySpan<byte>));
+         public static bool Verify(System.ReadOnlySpan<byte> key, System.ReadOnlySpan<byte> source, System.ReadOnlySpan<byte> hash, System.ReadOnlySpan<byte> customizationString = default(System.ReadOnlySpan<byte>));
+         public static System.Threading.Tasks.ValueTask<bool> VerifyAsync(byte[] key, System.IO.Stream source, byte[] hash, byte[]? customizationString = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
+         public static System.Threading.Tasks.ValueTask<bool> VerifyAsync(System.ReadOnlyMemory<byte> key, System.IO.Stream source, System.ReadOnlyMemory<byte> hash, System.ReadOnlyMemory<byte> customizationString = default(System.ReadOnlyMemory<byte>), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
+         public bool VerifyCurrentHash(byte[] hash);
+         public bool VerifyCurrentHash(System.ReadOnlySpan<byte> hash);
+         public bool VerifyHashAndReset(byte[] hash);
+         public bool VerifyHashAndReset(System.ReadOnlySpan<byte> hash);
      }
      public sealed class KmacXof256 : System.IDisposable
      {
+         public static bool Verify(byte[] key, byte[] source, byte[] hash, byte[]? customizationString = null);
+         public static bool Verify(byte[] key, System.IO.Stream source, byte[] hash, byte[]? customizationString = null);
+         public static bool Verify(System.ReadOnlySpan<byte> key, System.IO.Stream source, System.ReadOnlySpan<byte> hash, System.ReadOnlySpan<byte> customizationString = default(System.ReadOnlySpan<byte>));
+         public static bool Verify(System.ReadOnlySpan<byte> key, System.ReadOnlySpan<byte> source, System.ReadOnlySpan<byte> hash, System.ReadOnlySpan<byte> customizationString = default(System.ReadOnlySpan<byte>));
+         public static System.Threading.Tasks.ValueTask<bool> VerifyAsync(byte[] key, System.IO.Stream source, byte[] hash, byte[]? customizationString = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
+         public static System.Threading.Tasks.ValueTask<bool> VerifyAsync(System.ReadOnlyMemory<byte> key, System.IO.Stream source, System.ReadOnlyMemory<byte> hash, System.ReadOnlyMemory<byte> customizationString = default(System.ReadOnlyMemory<byte>), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
+         public bool VerifyCurrentHash(byte[] hash);
+         public bool VerifyCurrentHash(System.ReadOnlySpan<byte> hash);
+         public bool VerifyHashAndReset(byte[] hash);
+         public bool VerifyHashAndReset(System.ReadOnlySpan<byte> hash);
      }
  }
```
