# System.Runtime

```diff
  namespace System
  {
      public static class BitConverter
      {
+         public static short BFloat16ToInt16Bits(System.Numerics.BFloat16 value);
+         [System.CLSCompliantAttribute(false)]
+         public static ushort BFloat16ToUInt16Bits(System.Numerics.BFloat16 value);
+         public static byte[] GetBytes(System.Numerics.BFloat16 value);
+         public static System.Numerics.BFloat16 Int16BitsToBFloat16(short value);
+         public static System.Numerics.BFloat16 ToBFloat16(byte[] value, int startIndex);
+         public static System.Numerics.BFloat16 ToBFloat16(System.ReadOnlySpan<byte> value);
+         public static bool TryWriteBytes(System.Span<byte> destination, System.Numerics.BFloat16 value);
+         [System.CLSCompliantAttribute(false)]
+         public static System.Numerics.BFloat16 UInt16BitsToBFloat16(ushort value);
      }
      public readonly struct Char : System.IComparable, System.IComparable<char>, System.IConvertible, System.IEquatable<char>, System.IFormattable, System.IParsable<char>, System.ISpanFormattable, System.ISpanParsable<char>, System.IUtf8SpanFormattable, System.IUtf8SpanParsable<char>, System.Numerics.IAdditionOperators<char, char, char>, System.Numerics.IAdditiveIdentity<char, char>, System.Numerics.IBinaryInteger<char>, System.Numerics.IBinaryNumber<char>, System.Numerics.IBitwiseOperators<char, char, char>, System.Numerics.IComparisonOperators<char, char, bool>, System.Numerics.IEqualityOperators<char, char, bool>, System.Numerics.IDecrementOperators<char>, System.Numerics.IDivisionOperators<char, char, char>, System.Numerics.IIncrementOperators<char>, System.Numerics.IModulusOperators<char, char, char>, System.Numerics.IMultiplicativeIdentity<char, char>, System.Numerics.IMultiplyOperators<char, char, char>, System.Numerics.INumber<char>, System.Numerics.INumberBase<char>, System.Numerics.ISubtractionOperators<char, char, char>, System.Numerics.IUnaryNegationOperators<char, char>, System.Numerics.IUnaryPlusOperators<char, char>, System.Numerics.IShiftOperators<char, int, char>, System.Numerics.IMinMaxValue<char>, System.Numerics.IUnsignedNumber<char>
      {
+         public readonly bool Equals(char other, System.StringComparison comparisonType);
      }
      public sealed class String : System.Collections.Generic.IEnumerable<char>, System.Collections.IEnumerable, System.ICloneable, System.IComparable, System.IComparable<string?>, System.IConvertible, System.IEquatable<string?>, System.IParsable<string>, System.ISpanParsable<string>
      {
+         public bool Contains(System.Text.Rune value, System.StringComparison comparisonType);
+         public bool Contains(System.Text.Rune value);
+         public bool EndsWith(char value, System.StringComparison comparisonType);
+         public bool EndsWith(System.Text.Rune value, System.StringComparison comparisonType);
+         public bool EndsWith(System.Text.Rune value);
+         public int IndexOf(char value, int startIndex, int count, System.StringComparison comparisonType);
+         public int IndexOf(char value, int startIndex, System.StringComparison comparisonType);
+         public int IndexOf(System.Text.Rune value, int startIndex, int count, System.StringComparison comparisonType);
+         public int IndexOf(System.Text.Rune value, int startIndex, int count);
+         public int IndexOf(System.Text.Rune value, int startIndex, System.StringComparison comparisonType);
+         public int IndexOf(System.Text.Rune value, int startIndex);
+         public int IndexOf(System.Text.Rune value, System.StringComparison comparisonType);
+         public int IndexOf(System.Text.Rune value);
+         public int LastIndexOf(char value, int startIndex, int count, System.StringComparison comparisonType);
+         public int LastIndexOf(char value, int startIndex, System.StringComparison comparisonType);
+         public int LastIndexOf(char value, System.StringComparison comparisonType);
+         public int LastIndexOf(System.Text.Rune value, int startIndex, int count, System.StringComparison comparisonType);
+         public int LastIndexOf(System.Text.Rune value, int startIndex, int count);
+         public int LastIndexOf(System.Text.Rune value, int startIndex, System.StringComparison comparisonType);
+         public int LastIndexOf(System.Text.Rune value, int startIndex);
+         public int LastIndexOf(System.Text.Rune value, System.StringComparison comparisonType);
+         public int LastIndexOf(System.Text.Rune value);
+         public string Replace(System.Text.Rune oldRune, System.Text.Rune newRune);
+         public string[] Split(System.Text.Rune separator, int count, System.StringSplitOptions options = System.StringSplitOptions.None);
+         public string[] Split(System.Text.Rune separator, System.StringSplitOptions options = System.StringSplitOptions.None);
+         public bool StartsWith(char value, System.StringComparison comparisonType);
+         public bool StartsWith(System.Text.Rune value, System.StringComparison comparisonType);
+         public bool StartsWith(System.Text.Rune value);
+         public string Trim(System.Text.Rune trimRune);
+         public string TrimEnd(System.Text.Rune trimRune);
+         public string TrimStart(System.Text.Rune trimRune);
      }
      public class Uri : System.IEquatable<System.Uri>, System.IFormattable, System.ISpanFormattable, System.Runtime.Serialization.ISerializable
      {
+         public static readonly string UriSchemeData;
      }
  }
  namespace System.Buffers.Text
  {
      public static class Base64
      {
+         public static System.Buffers.OperationStatus DecodeFromChars(System.ReadOnlySpan<char> source, System.Span<byte> destination, out int charsConsumed, out int bytesWritten, bool isFinalBlock = true);
+         public static int DecodeFromChars(System.ReadOnlySpan<char> source, System.Span<byte> destination);
+         public static byte[] DecodeFromChars(System.ReadOnlySpan<char> source);
+         public static int DecodeFromUtf8(System.ReadOnlySpan<byte> source, System.Span<byte> destination);
+         public static byte[] DecodeFromUtf8(System.ReadOnlySpan<byte> source);
+         public static System.Buffers.OperationStatus EncodeToChars(System.ReadOnlySpan<byte> source, System.Span<char> destination, out int bytesConsumed, out int charsWritten, bool isFinalBlock = true);
+         public static int EncodeToChars(System.ReadOnlySpan<byte> source, System.Span<char> destination);
+         public static char[] EncodeToChars(System.ReadOnlySpan<byte> source);
+         public static string EncodeToString(System.ReadOnlySpan<byte> source);
+         public static int EncodeToUtf8(System.ReadOnlySpan<byte> source, System.Span<byte> destination);
+         public static byte[] EncodeToUtf8(System.ReadOnlySpan<byte> source);
+         public static int GetEncodedLength(int bytesLength);
+         public static int GetMaxDecodedLength(int base64Length);
+         public static bool TryDecodeFromChars(System.ReadOnlySpan<char> source, System.Span<byte> destination, out int bytesWritten);
+         public static bool TryDecodeFromUtf8(System.ReadOnlySpan<byte> source, System.Span<byte> destination, out int bytesWritten);
+         public static bool TryEncodeToChars(System.ReadOnlySpan<byte> source, System.Span<char> destination, out int charsWritten);
+         public static bool TryEncodeToUtf8(System.ReadOnlySpan<byte> source, System.Span<byte> destination, out int bytesWritten);
+         public static bool TryEncodeToUtf8InPlace(System.Span<byte> buffer, int dataLength, out int bytesWritten);
      }
  }
  namespace System.Diagnostics.CodeAnalysis
  {
      public sealed class StringSyntaxAttribute : System.Attribute
      {
+         public const string CSharp = "C#";
+         public const string FSharp = "F#";
+         public const string VisualBasic = "Visual Basic";
      }
  }
  namespace System.Globalization
  {
      public sealed class TextInfo : System.ICloneable, System.Runtime.Serialization.IDeserializationCallback
      {
+         public System.Text.Rune ToLower(System.Text.Rune value);
+         public System.Text.Rune ToUpper(System.Text.Rune value);
      }
  }
  namespace System.IO
  {
      public static class File
      {
+         public static System.IO.FileSystemInfo CreateHardLink(string path, string pathToTarget);
      }
      public sealed class FileInfo : System.IO.FileSystemInfo
      {
+         public void CreateAsHardLink(string pathToTarget);
      }
      public abstract class TextWriter : System.MarshalByRefObject, System.IAsyncDisposable, System.IDisposable
      {
+         public virtual void Write(System.Text.Rune value);
+         public System.Threading.Tasks.Task WriteAsync(string? value, System.Threading.CancellationToken cancellationToken);
+         public virtual System.Threading.Tasks.Task WriteAsync(System.Text.Rune value);
+         public virtual void WriteLine(System.Text.Rune value);
+         public System.Threading.Tasks.Task WriteLineAsync(string? value, System.Threading.CancellationToken cancellationToken);
+         public virtual System.Threading.Tasks.Task WriteLineAsync(System.Text.Rune value);
+         public System.Threading.Tasks.Task WriteLineAsync(System.Threading.CancellationToken cancellationToken);
      }
  }
  namespace System.Numerics
  {
      public interface IBinaryInteger<TSelf> : System.IComparable, System.IComparable<TSelf>, System.IEquatable<TSelf>, System.IFormattable, System.IParsable<TSelf>, System.ISpanFormattable, System.ISpanParsable<TSelf>, System.Numerics.IAdditionOperators<TSelf, TSelf, TSelf>, System.Numerics.IAdditiveIdentity<TSelf, TSelf>, System.Numerics.IBinaryNumber<TSelf>, System.Numerics.IBitwiseOperators<TSelf, TSelf, TSelf>, System.Numerics.IComparisonOperators<TSelf, TSelf, bool>, System.Numerics.IEqualityOperators<TSelf, TSelf, bool>, System.Numerics.IDecrementOperators<TSelf>, System.Numerics.IDivisionOperators<TSelf, TSelf, TSelf>, System.Numerics.IIncrementOperators<TSelf>, System.Numerics.IModulusOperators<TSelf, TSelf, TSelf>, System.Numerics.IMultiplicativeIdentity<TSelf, TSelf>, System.Numerics.IMultiplyOperators<TSelf, TSelf, TSelf>, System.Numerics.INumber<TSelf>, System.Numerics.INumberBase<TSelf>, System.IUtf8SpanFormattable, System.IUtf8SpanParsable<TSelf>, System.Numerics.ISubtractionOperators<TSelf, TSelf, TSelf>, System.Numerics.IUnaryNegationOperators<TSelf, TSelf>, System.Numerics.IUnaryPlusOperators<TSelf, TSelf>, System.Numerics.IShiftOperators<TSelf, int, TSelf> where TSelf : System.Numerics.IBinaryInteger<TSelf>?
      {
+         TSelf Divide(TSelf left, TSelf right, System.Numerics.DivisionRounding mode);
+         (TSelf Quotient, TSelf Remainder) DivRem(TSelf left, TSelf right, System.Numerics.DivisionRounding mode);
+         TSelf Remainder(TSelf left, TSelf right, System.Numerics.DivisionRounding mode);
      }
+     public readonly struct BFloat16 : System.IComparable, System.IComparable<System.Numerics.BFloat16>, System.IEquatable<System.Numerics.BFloat16>, System.IFormattable, System.IParsable<System.Numerics.BFloat16>, System.ISpanFormattable, System.ISpanParsable<System.Numerics.BFloat16>, System.IUtf8SpanFormattable, System.IUtf8SpanParsable<System.Numerics.BFloat16>, System.Numerics.IAdditionOperators<System.Numerics.BFloat16, System.Numerics.BFloat16, System.Numerics.BFloat16>, System.Numerics.IAdditiveIdentity<System.Numerics.BFloat16, System.Numerics.BFloat16>, System.Numerics.IBinaryFloatingPointIeee754<System.Numerics.BFloat16>, System.Numerics.IBinaryNumber<System.Numerics.BFloat16>, System.Numerics.IBitwiseOperators<System.Numerics.BFloat16, System.Numerics.BFloat16, System.Numerics.BFloat16>, System.Numerics.IComparisonOperators<System.Numerics.BFloat16, System.Numerics.BFloat16, bool>, System.Numerics.IEqualityOperators<System.Numerics.BFloat16, System.Numerics.BFloat16, bool>, System.Numerics.IDecrementOperators<System.Numerics.BFloat16>, System.Numerics.IDivisionOperators<System.Numerics.BFloat16, System.Numerics.BFloat16, System.Numerics.BFloat16>, System.Numerics.IIncrementOperators<System.Numerics.BFloat16>, System.Numerics.IModulusOperators<System.Numerics.BFloat16, System.Numerics.BFloat16, System.Numerics.BFloat16>, System.Numerics.IMultiplicativeIdentity<System.Numerics.BFloat16, System.Numerics.BFloat16>, System.Numerics.IMultiplyOperators<System.Numerics.BFloat16, System.Numerics.BFloat16, System.Numerics.BFloat16>, System.Numerics.INumber<System.Numerics.BFloat16>, System.Numerics.INumberBase<System.Numerics.BFloat16>, System.Numerics.ISubtractionOperators<System.Numerics.BFloat16, System.Numerics.BFloat16, System.Numerics.BFloat16>, System.Numerics.IUnaryNegationOperators<System.Numerics.BFloat16, System.Numerics.BFloat16>, System.Numerics.IUnaryPlusOperators<System.Numerics.BFloat16, System.Numerics.BFloat16>, System.Numerics.IExponentialFunctions<System.Numerics.BFloat16>, System.Numerics.IFloatingPointConstants<System.Numerics.BFloat16>, System.Numerics.IFloatingPoint<System.Numerics.BFloat16>, System.Numerics.ISignedNumber<System.Numerics.BFloat16>, System.Numerics.IFloatingPointIeee754<System.Numerics.BFloat16>, System.Numerics.IHyperbolicFunctions<System.Numerics.BFloat16>, System.Numerics.ILogarithmicFunctions<System.Numerics.BFloat16>, System.Numerics.IPowerFunctions<System.Numerics.BFloat16>, System.Numerics.IRootFunctions<System.Numerics.BFloat16>, System.Numerics.ITrigonometricFunctions<System.Numerics.BFloat16>, System.Numerics.IMinMaxValue<System.Numerics.BFloat16>
+     {
+         public readonly int CompareTo(System.Numerics.BFloat16 other);
+         public readonly int CompareTo(object? obj);
+         public readonly bool Equals(System.Numerics.BFloat16 other);
+         public override readonly bool Equals(object? obj);
+         public override readonly int GetHashCode();
+         public static bool IsZero(System.Numerics.BFloat16 value);
+         public static System.Numerics.BFloat16 operator +(System.Numerics.BFloat16 left, System.Numerics.BFloat16 right);
+         public static explicit operator checked byte(System.Numerics.BFloat16 value);
+         public static explicit operator checked char(System.Numerics.BFloat16 value);
+         public static explicit operator checked System.Int128(System.Numerics.BFloat16 value);
+         public static explicit operator checked short(System.Numerics.BFloat16 value);
+         public static explicit operator checked int(System.Numerics.BFloat16 value);
+         public static explicit operator checked long(System.Numerics.BFloat16 value);
+         public static explicit operator checked nint(System.Numerics.BFloat16 value);
+         [System.CLSCompliantAttribute(false)]
+         public static explicit operator checked sbyte(System.Numerics.BFloat16 value);
+         [System.CLSCompliantAttribute(false)]
+         public static explicit operator checked System.UInt128(System.Numerics.BFloat16 value);
+         [System.CLSCompliantAttribute(false)]
+         public static explicit operator checked ushort(System.Numerics.BFloat16 value);
+         [System.CLSCompliantAttribute(false)]
+         public static explicit operator checked uint(System.Numerics.BFloat16 value);
+         [System.CLSCompliantAttribute(false)]
+         public static explicit operator checked ulong(System.Numerics.BFloat16 value);
+         [System.CLSCompliantAttribute(false)]
+         public static explicit operator checked nuint(System.Numerics.BFloat16 value);
+         public static System.Numerics.BFloat16 operator --(System.Numerics.BFloat16 value);
+         public static System.Numerics.BFloat16 operator /(System.Numerics.BFloat16 left, System.Numerics.BFloat16 right);
+         public static bool operator ==(System.Numerics.BFloat16 left, System.Numerics.BFloat16 right);
+         public static explicit operator System.Numerics.BFloat16(char value);
+         public static explicit operator System.Numerics.BFloat16(decimal value);
+         public static explicit operator System.Numerics.BFloat16(double value);
+         public static explicit operator System.Numerics.BFloat16(System.Half value);
+         public static explicit operator System.Numerics.BFloat16(System.Int128 value);
+         public static explicit operator System.Numerics.BFloat16(short value);
+         public static explicit operator System.Numerics.BFloat16(int value);
+         public static explicit operator System.Numerics.BFloat16(long value);
+         public static explicit operator System.Numerics.BFloat16(nint value);
+         public static explicit operator byte(System.Numerics.BFloat16 value);
+         public static explicit operator char(System.Numerics.BFloat16 value);
+         public static explicit operator decimal(System.Numerics.BFloat16 value);
+         public static explicit operator double(System.Numerics.BFloat16 value);
+         public static explicit operator System.Half(System.Numerics.BFloat16 value);
+         public static explicit operator System.Int128(System.Numerics.BFloat16 value);
+         public static explicit operator short(System.Numerics.BFloat16 value);
+         public static explicit operator int(System.Numerics.BFloat16 value);
+         public static explicit operator long(System.Numerics.BFloat16 value);
+         public static explicit operator nint(System.Numerics.BFloat16 value);
+         [System.CLSCompliantAttribute(false)]
+         public static explicit operator sbyte(System.Numerics.BFloat16 value);
+         public static explicit operator float(System.Numerics.BFloat16 value);
+         [System.CLSCompliantAttribute(false)]
+         public static explicit operator System.UInt128(System.Numerics.BFloat16 value);
+         [System.CLSCompliantAttribute(false)]
+         public static explicit operator ushort(System.Numerics.BFloat16 value);
+         [System.CLSCompliantAttribute(false)]
+         public static explicit operator uint(System.Numerics.BFloat16 value);
+         [System.CLSCompliantAttribute(false)]
+         public static explicit operator ulong(System.Numerics.BFloat16 value);
+         [System.CLSCompliantAttribute(false)]
+         public static explicit operator nuint(System.Numerics.BFloat16 value);
+         public static explicit operator System.Numerics.BFloat16(float value);
+         [System.CLSCompliantAttribute(false)]
+         public static explicit operator System.Numerics.BFloat16(System.UInt128 value);
+         [System.CLSCompliantAttribute(false)]
+         public static explicit operator System.Numerics.BFloat16(ushort value);
+         [System.CLSCompliantAttribute(false)]
+         public static explicit operator System.Numerics.BFloat16(uint value);
+         [System.CLSCompliantAttribute(false)]
+         public static explicit operator System.Numerics.BFloat16(ulong value);
+         [System.CLSCompliantAttribute(false)]
+         public static explicit operator System.Numerics.BFloat16(nuint value);
+         public static bool operator >(System.Numerics.BFloat16 left, System.Numerics.BFloat16 right);
+         public static bool operator >=(System.Numerics.BFloat16 left, System.Numerics.BFloat16 right);
+         public static implicit operator System.Numerics.BFloat16(byte value);
+         [System.CLSCompliantAttribute(false)]
+         public static implicit operator System.Numerics.BFloat16(sbyte value);
+         public static System.Numerics.BFloat16 operator ++(System.Numerics.BFloat16 value);
+         public static bool operator !=(System.Numerics.BFloat16 left, System.Numerics.BFloat16 right);
+         public static bool operator <(System.Numerics.BFloat16 left, System.Numerics.BFloat16 right);
+         public static bool operator <=(System.Numerics.BFloat16 left, System.Numerics.BFloat16 right);
+         public static System.Numerics.BFloat16 operator %(System.Numerics.BFloat16 left, System.Numerics.BFloat16 right);
+         public static System.Numerics.BFloat16 operator *(System.Numerics.BFloat16 left, System.Numerics.BFloat16 right);
+         public static System.Numerics.BFloat16 operator -(System.Numerics.BFloat16 left, System.Numerics.BFloat16 right);
+         public static System.Numerics.BFloat16 operator -(System.Numerics.BFloat16 value);
+         public static System.Numerics.BFloat16 operator +(System.Numerics.BFloat16 value);
+         public static System.Numerics.BFloat16 Parse(string s, System.Globalization.NumberStyles style);
+         public static System.Numerics.BFloat16 Parse(string s);
+         public override readonly string ToString();
+         public readonly string ToString(System.IFormatProvider? provider);
+         public readonly string ToString(string? format, System.IFormatProvider? provider);
+         public readonly string ToString(string? format);
+         public readonly bool TryFormat(System.Span<byte> utf8Destination, out int bytesWritten, System.ReadOnlySpan<char> format = default(System.ReadOnlySpan<char>), System.IFormatProvider? provider = null);
+         public readonly bool TryFormat(System.Span<char> destination, out int charsWritten, System.ReadOnlySpan<char> format = default(System.ReadOnlySpan<char>), System.IFormatProvider? provider = null);
+         public static bool TryParse(System.ReadOnlySpan<byte> utf8Text, out System.Numerics.BFloat16 result);
+         public static bool TryParse(System.ReadOnlySpan<char> s, out System.Numerics.BFloat16 result);
+         public static bool TryParse(string? s, out System.Numerics.BFloat16 result);
+     }
+     public enum DivisionRounding
+     {
+         Truncate = 0,
+         Floor = 1,
+         Ceiling = 2,
+         AwayFromZero = 3,
+         Euclidean = 4,
+     }
  }
  namespace System.Reflection
  {
      public enum TypeAttributes
      {
+         ExtendedLayout = 24,
      }
  }
  namespace System.Runtime.CompilerServices
  {
-     [System.Diagnostics.CodeAnalysis.ExperimentalAttribute("SYSLIB5007", UrlFormat = "https://aka.ms/dotnet-warnings/{0}")]
      public static class AsyncHelpers
      {
+         public static void HandleAsyncEntryPoint(System.Threading.Tasks.Task task);
+         public static int HandleAsyncEntryPoint(System.Threading.Tasks.Task<int> task);
      }
      public static class RuntimeHelpers
      {
+         public static nint AllocateTypeAssociatedMemory(System.Type type, int size, int alignment);
      }
  }
  namespace System.Runtime.InteropServices
  {
      public enum LayoutKind
      {
+         Extended = 1,
      }
      public static class MemoryMarshal
      {
+         [System.Runtime.CompilerServices.OverloadResolutionPriorityAttribute(1)]
          public static ref T AsRef<T>(System.Span<byte> span)
              where T : struct;
      }
+     public sealed class ExtendedLayoutAttribute : System.Attribute
+     {
+         public ExtendedLayoutAttribute(System.Runtime.InteropServices.ExtendedLayoutKind layoutKind);
+     }
+     public enum ExtendedLayoutKind
+     {
+         CStruct = 0,
+         CUnion = 1,
+     }
  }
  namespace System.Text
  {
      public readonly struct Rune : System.IComparable, System.IComparable<System.Text.Rune>, System.IEquatable<System.Text.Rune>, System.IFormattable, System.ISpanFormattable, System.IUtf8SpanFormattable, System.IUtf8SpanParsable<System.Text.Rune>
      {
+         public readonly bool Equals(System.Text.Rune other, System.StringComparison comparisonType);
      }
      public sealed class StringBuilder : System.Runtime.Serialization.ISerializable
      {
+         public System.Text.StringBuilder Append(System.Text.Rune value);
+         public System.Text.StringBuilderRuneEnumerator EnumerateRunes();
+         public System.Text.Rune GetRuneAt(int index);
+         public System.Text.StringBuilder Insert(int index, System.Text.Rune value);
+         public System.Text.StringBuilder Replace(System.Text.Rune oldRune, System.Text.Rune newRune, int startIndex, int count);
+         public System.Text.StringBuilder Replace(System.Text.Rune oldRune, System.Text.Rune newRune);
+         public bool TryGetRuneAt(int index, out System.Text.Rune value);
      }
+     public readonly struct RunePosition : System.IEquatable<System.Text.RunePosition>
+     {
+         public RunePosition(System.Text.Rune rune, int startIndex, int length, bool wasReplaced);
+         public readonly void Deconstruct(out System.Text.Rune rune, out int startIndex, out int length);
+         public readonly void Deconstruct(out System.Text.Rune rune, out int startIndex);
+         public static System.Text.RunePosition.Utf16Enumerator EnumerateUtf16(System.ReadOnlySpan<char> span);
+         public static System.Text.RunePosition.Utf8Enumerator EnumerateUtf8(System.ReadOnlySpan<byte> span);
+         public override readonly bool Equals(object? obj);
+         public readonly bool Equals(System.Text.RunePosition other);
+         public override readonly int GetHashCode();
+         public static bool operator ==(System.Text.RunePosition left, System.Text.RunePosition right);
+         public static bool operator !=(System.Text.RunePosition left, System.Text.RunePosition right);
+         public int Length { get; }
+         public System.Text.Rune Rune { get; }
+         public int StartIndex { get; }
+         public bool WasReplaced { get; }
+         public ref struct Utf16Enumerator : System.Collections.Generic.IEnumerator<System.Text.RunePosition>, System.Collections.IEnumerator, System.IDisposable
+         {
+             public System.Text.RunePosition.Utf16Enumerator GetEnumerator();
+             public bool MoveNext();
+             public void Reset();
+             public System.Text.RunePosition Current { get; }
+         }
+         public ref struct Utf8Enumerator : System.Collections.Generic.IEnumerator<System.Text.RunePosition>, System.Collections.IEnumerator, System.IDisposable
+         {
+             public System.Text.RunePosition.Utf8Enumerator GetEnumerator();
+             public bool MoveNext();
+             public void Reset();
+             public System.Text.RunePosition Current { get; }
+         }
+     }
+     public struct StringBuilderRuneEnumerator : System.Collections.Generic.IEnumerable<System.Text.Rune>, System.Collections.IEnumerable, System.Collections.Generic.IEnumerator<System.Text.Rune>, System.Collections.IEnumerator, System.IDisposable
+     {
+         public System.Text.StringBuilderRuneEnumerator GetEnumerator();
+         public bool MoveNext();
+         public System.Text.Rune Current { get; }
+     }
  }
```
