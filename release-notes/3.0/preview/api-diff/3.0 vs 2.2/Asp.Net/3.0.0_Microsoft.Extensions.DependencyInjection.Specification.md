# Microsoft.Extensions.DependencyInjection.Specification

``` diff
+namespace Microsoft.Extensions.DependencyInjection.Specification {
+    public class ClassWithOptionalArgsCtor {
+        public ClassWithOptionalArgsCtor(string whatever = "BLARGH");
+        public string Whatever { get; set; }
+    }
+    public class ClassWithOptionalArgsCtorWithStructs {
+        public ClassWithOptionalArgsCtorWithStructs(DateTime dateTime = default(DateTime), DateTime dateTimeDefault = default(DateTime), TimeSpan timeSpan = default(TimeSpan), TimeSpan timeSpanDefault = default(TimeSpan), DateTimeOffset dateTimeOffset = default(DateTimeOffset), DateTimeOffset dateTimeOffsetDefault = default(DateTimeOffset), Guid guid = default(Guid), Guid guidDefault = default(Guid), ClassWithOptionalArgsCtorWithStructs.CustomStruct customStruct = default(ClassWithOptionalArgsCtorWithStructs.CustomStruct), ClassWithOptionalArgsCtorWithStructs.CustomStruct customStructDefault = default(ClassWithOptionalArgsCtorWithStructs.CustomStruct), Nullable<ConsoleColor> color = 2, Nullable<ConsoleColor> colorNull = default(Nullable<ConsoleColor>), Nullable<int> integer = 12, Nullable<int> integerNull = default(Nullable<int>));
+        public Nullable<ConsoleColor> Color { get; }
+        public Nullable<ConsoleColor> ColorNull { get; }
+        public Nullable<int> Integer { get; }
+        public Nullable<int> IntegerNull { get; }
+        public struct CustomStruct
+    }
+    public abstract class DependencyInjectionSpecificationTests {
+        protected DependencyInjectionSpecificationTests();
+        public static IEnumerable<object[]> CreateInstanceFuncs { get; }
+        public static TheoryData ServiceContainerPicksConstructorWithLongestMatchesData { get; }
+        public static IEnumerable<object[]> TypesWithNonPublicConstructorData { get; }
+        public void AttemptingToResolveNonexistentServiceReturnsNull();
+        public void ClosedServicesPreferredOverOpenGenericServices();
+        public void CreateInstance_CapturesInnerException_OfTargetInvocationException();
+        public void CreateInstance_WithAbstractTypeAndPublicConstructor_ThrowsCorrectException();
+        protected abstract IServiceProvider CreateServiceProvider(IServiceCollection serviceCollection);
+        public void DisposesInReverseOrderOfCreation();
+        public void DisposingScopeDisposesService();
+        public void FactoryServicesAreCreatedAsPartOfCreatingObjectGraph();
+        public void FactoryServicesCanBeCreatedByGetService();
+        public void GetServiceOrCreateInstanceRegisteredServiceSingleton();
+        public void GetServiceOrCreateInstanceRegisteredServiceTransient();
+        public void GetServiceOrCreateInstanceUnregisteredService();
+        public void LastServiceReplacesPreviousServices();
+        public void MultipleServiceCanBeIEnumerableResolved();
+        public void NestedScopedServiceCanBeResolved();
+        public void NestedScopedServiceCanBeResolvedWithNoFallbackProvider();
+        public void NonexistentServiceCanBeIEnumerableResolved();
+        public void OpenGenericServicesCanBeResolved();
+        public void OuterServiceCanHaveOtherServicesInjected();
+        public void RegistrationOrderIsPreservedWhenServicesAreIEnumerableResolved();
+        public void ResolvesDifferentInstancesForServiceWhenResolvingEnumerable(Type serviceType, Type implementation, Type resolve, ServiceLifetime lifetime);
+        public void ResolvesMixedOpenClosedGenericsAsEnumerable();
+        public void SafelyDisposeNestedProviderReferences();
+        public void ScopedServiceCanBeResolved();
+        public void ScopedServices_FromCachedScopeFactory_CanBeResolvedAndDisposed();
+        public void SelfResolveThenDispose();
+        public void ServiceContainerPicksConstructorWithLongestMatches(IServiceCollection serviceCollection, TypeWithSupersetConstructors expected);
+        public void ServiceInstanceCanBeResolved();
+        public void ServiceProviderRegistersServiceScopeFactory();
+        public void ServicesRegisteredWithImplementationTypeCanBeResolved();
+        public void ServicesRegisteredWithImplementationType_ReturnDifferentInstancesPerResolution_ForTransientServices();
+        public void ServicesRegisteredWithImplementationType_ReturnSameInstancesPerResolution_ForSingletons();
+        public void SingleServiceCanBeIEnumerableResolved();
+        public void SingletonServiceCanBeResolved();
+        public void SingletonServicesComeFromRootProvider();
+        public void TransientServiceCanBeResolvedFromProvider();
+        public void TransientServiceCanBeResolvedFromScope();
+        public void TypeActivatorAcceptsAnyNumberOfAdditionalConstructorParametersToProvide(DependencyInjectionSpecificationTests.CreateInstanceFunc createFunc);
+        public void TypeActivatorCanDisambiguateConstructorsWithUniqueArguments(DependencyInjectionSpecificationTests.CreateInstanceFunc createFunc);
+        public void TypeActivatorCreateFactoryDoesNotAllowForAmbiguousConstructorMatches(Type paramType);
+        public void TypeActivatorCreateInstanceUsesFirstMathchedConstructor(object value, string ctor);
+        public void TypeActivatorEnablesYouToCreateAnyTypeWithServicesEvenWhenNotInIocContainer(DependencyInjectionSpecificationTests.CreateInstanceFunc createFunc);
+        public void TypeActivatorRequiresAllArgumentsCanBeAccepted(DependencyInjectionSpecificationTests.CreateInstanceFunc createFunc);
+        public void TypeActivatorRequiresPublicConstructor(DependencyInjectionSpecificationTests.CreateInstanceFunc createFunc, Type type);
+        public void TypeActivatorRethrowsOriginalExceptionFromConstructor(DependencyInjectionSpecificationTests.CreateInstanceFunc createFunc);
+        public void TypeActivatorThrowsOnMultipleMarkedCtors(DependencyInjectionSpecificationTests.CreateInstanceFunc createFunc);
+        public void TypeActivatorThrowsWhenMarkedCtorDoesntAcceptArguments(DependencyInjectionSpecificationTests.CreateInstanceFunc createFunc);
+        public void TypeActivatorUsesMarkedConstructor(DependencyInjectionSpecificationTests.CreateInstanceFunc createFunc);
+        public void TypeActivatorWorksWithCtorWithOptionalArgs(DependencyInjectionSpecificationTests.CreateInstanceFunc createFunc);
+        public void TypeActivatorWorksWithCtorWithOptionalArgs_WithStructDefaults(DependencyInjectionSpecificationTests.CreateInstanceFunc createFunc);
+        public void TypeActivatorWorksWithStaticCtor(DependencyInjectionSpecificationTests.CreateInstanceFunc createFunc);
+        public void UnRegisteredServiceAsConstructorParameterThrowsException(DependencyInjectionSpecificationTests.CreateInstanceFunc createFunc);
+        public delegate object CreateInstanceFunc(IServiceProvider provider, Type type, object[] args);
+    }
+}
```

