# .NET Core 1.0.0 API List

API listing follows standard diff formatting. Lines preceded by a '+' are additions and a '-' indicates removal.

* [Microsoft.CSharp.RuntimeBinder](#microsoftcsharpruntimebinder)
* [Microsoft.SqlServer.Server](#microsoftsqlserverserver)
* [Microsoft.VisualBasic](#microsoftvisualbasic)
* [Microsoft.VisualBasic.CompilerServices](#microsoftvisualbasiccompilerservices)
* [Microsoft.Win32](#microsoftwin32)
* [Microsoft.Win32.SafeHandles](#microsoftwin32safehandles)
* [System](#system)
* [System.Buffers](#systembuffers)
* [System.CodeDom.Compiler](#systemcodedomcompiler)
* [System.Collections](#systemcollections)
* [System.Collections.Concurrent](#systemcollectionsconcurrent)
* [System.Collections.Generic](#systemcollectionsgeneric)
* [System.Collections.Immutable](#systemcollectionsimmutable)
* [System.Collections.ObjectModel](#systemcollectionsobjectmodel)
* [System.Collections.Specialized](#systemcollectionsspecialized)
* [System.ComponentModel](#systemcomponentmodel)
* [System.ComponentModel.DataAnnotations](#systemcomponentmodeldataannotations)
* [System.ComponentModel.DataAnnotations.Schema](#systemcomponentmodeldataannotationsschema)
* [System.Configuration.Assemblies](#systemconfigurationassemblies)
* [System.Data](#systemdata)
* [System.Data.Common](#systemdatacommon)
* [System.Data.SqlClient](#systemdatasqlclient)
* [System.Data.SqlTypes](#systemdatasqltypes)
* [System.Diagnostics](#systemdiagnostics)
* [System.Diagnostics.CodeAnalysis](#systemdiagnosticscodeanalysis)
* [System.Diagnostics.Contracts](#systemdiagnosticscontracts)
* [System.Diagnostics.Contracts.Internal](#systemdiagnosticscontractsinternal)
* [System.Diagnostics.SymbolStore](#systemdiagnosticssymbolstore)
* [System.Diagnostics.Tracing](#systemdiagnosticstracing)
* [System.Drawing](#systemdrawing)
* [System.Dynamic](#systemdynamic)
* [System.Globalization](#systemglobalization)
* [System.IdentityModel](#systemidentitymodel)
* [System.IdentityModel.Claims](#systemidentitymodelclaims)
* [System.IdentityModel.Policy](#systemidentitymodelpolicy)
* [System.IdentityModel.Selectors](#systemidentitymodelselectors)
* [System.IdentityModel.Tokens](#systemidentitymodeltokens)
* [System.IO](#systemio)
* [System.IO.Compression](#systemiocompression)
* [System.IO.MemoryMappedFiles](#systemiomemorymappedfiles)
* [System.IO.Packaging](#systemiopackaging)
* [System.IO.Pipes](#systemiopipes)
* [System.Linq](#systemlinq)
* [System.Linq.Expressions](#systemlinqexpressions)
* [System.Net](#systemnet)
* [System.Net.Http](#systemnethttp)
* [System.Net.Http.Headers](#systemnethttpheaders)
* [System.Net.NetworkInformation](#systemnetnetworkinformation)
* [System.Net.Security](#systemnetsecurity)
* [System.Net.Sockets](#systemnetsockets)
* [System.Net.WebSockets](#systemnetwebsockets)
* [System.Numerics](#systemnumerics)
* [System.Reflection](#systemreflection)
* [System.Reflection.Context](#systemreflectioncontext)
* [System.Reflection.Emit](#systemreflectionemit)
* [System.Reflection.Metadata](#systemreflectionmetadata)
* [System.Reflection.Metadata.Ecma335](#systemreflectionmetadataecma335)
* [System.Reflection.PortableExecutable](#systemreflectionportableexecutable)
* [System.Resources](#systemresources)
* [System.Runtime](#systemruntime)
* [System.Runtime.CompilerServices](#systemruntimecompilerservices)
* [System.Runtime.ConstrainedExecution](#systemruntimeconstrainedexecution)
* [System.Runtime.Diagnostics](#systemruntimediagnostics)
* [System.Runtime.ExceptionServices](#systemruntimeexceptionservices)
* [System.Runtime.InteropServices](#systemruntimeinteropservices)
* [System.Runtime.InteropServices.ComTypes](#systemruntimeinteropservicescomtypes)
* [System.Runtime.InteropServices.WindowsRuntime](#systemruntimeinteropserviceswindowsruntime)
* [System.Runtime.Loader](#systemruntimeloader)
* [System.Runtime.Serialization](#systemruntimeserialization)
* [System.Runtime.Serialization.Json](#systemruntimeserializationjson)
* [System.Runtime.Versioning](#systemruntimeversioning)
* [System.Security](#systemsecurity)
* [System.Security.AccessControl](#systemsecurityaccesscontrol)
* [System.Security.Authentication](#systemsecurityauthentication)
* [System.Security.Authentication.ExtendedProtection](#systemsecurityauthenticationextendedprotection)
* [System.Security.Claims](#systemsecurityclaims)
* [System.Security.Cryptography](#systemsecuritycryptography)
* [System.Security.Cryptography.Pkcs](#systemsecuritycryptographypkcs)
* [System.Security.Cryptography.X509Certificates](#systemsecuritycryptographyx509certificates)
* [System.Security.Cryptography.Xml](#systemsecuritycryptographyxml)
* [System.Security.Permissions](#systemsecuritypermissions)
* [System.Security.Principal](#systemsecurityprincipal)
* [System.ServiceModel](#systemservicemodel)
* [System.ServiceModel.Channels](#systemservicemodelchannels)
* [System.ServiceModel.Description](#systemservicemodeldescription)
* [System.ServiceModel.Diagnostics](#systemservicemodeldiagnostics)
* [System.ServiceModel.Dispatcher](#systemservicemodeldispatcher)
* [System.ServiceModel.Security](#systemservicemodelsecurity)
* [System.ServiceModel.Security.Tokens](#systemservicemodelsecuritytokens)
* [System.ServiceProcess](#systemserviceprocess)
* [System.Text](#systemtext)
* [System.Text.Encodings.Web](#systemtextencodingsweb)
* [System.Text.RegularExpressions](#systemtextregularexpressions)
* [System.Text.Unicode](#systemtextunicode)
* [System.Threading](#systemthreading)
* [System.Threading.Tasks](#systemthreadingtasks)
* [System.Threading.Tasks.Dataflow](#systemthreadingtasksdataflow)
* [System.Windows.Input](#systemwindowsinput)
* [System.Xml](#systemxml)
* [System.Xml.Linq](#systemxmllinq)
* [System.Xml.Schema](#systemxmlschema)
* [System.Xml.Serialization](#systemxmlserialization)
* [System.Xml.XPath](#systemxmlxpath)

## Microsoft.CSharp.RuntimeBinder

```csharp
+namespace Microsoft.CSharp.RuntimeBinder {
+    public static class Binder {
+        public static CallSiteBinder BinaryOperation(CSharpBinderFlags flags, ExpressionType operation, Type context, IEnumerable<CSharpArgumentInfo> argumentInfo);
+        public static CallSiteBinder Convert(CSharpBinderFlags flags, Type type, Type context);
+        public static CallSiteBinder GetIndex(CSharpBinderFlags flags, Type context, IEnumerable<CSharpArgumentInfo> argumentInfo);
+        public static CallSiteBinder GetMember(CSharpBinderFlags flags, string name, Type context, IEnumerable<CSharpArgumentInfo> argumentInfo);
+        public static CallSiteBinder Invoke(CSharpBinderFlags flags, Type context, IEnumerable<CSharpArgumentInfo> argumentInfo);
+        public static CallSiteBinder InvokeConstructor(CSharpBinderFlags flags, Type context, IEnumerable<CSharpArgumentInfo> argumentInfo);
+        public static CallSiteBinder InvokeMember(CSharpBinderFlags flags, string name, IEnumerable<Type> typeArguments, Type context, IEnumerable<CSharpArgumentInfo> argumentInfo);
+        public static CallSiteBinder IsEvent(CSharpBinderFlags flags, string name, Type context);
+        public static CallSiteBinder SetIndex(CSharpBinderFlags flags, Type context, IEnumerable<CSharpArgumentInfo> argumentInfo);
+        public static CallSiteBinder SetMember(CSharpBinderFlags flags, string name, Type context, IEnumerable<CSharpArgumentInfo> argumentInfo);
+        public static CallSiteBinder UnaryOperation(CSharpBinderFlags flags, ExpressionType operation, Type context, IEnumerable<CSharpArgumentInfo> argumentInfo);
+    }
+    public sealed class CSharpArgumentInfo {
+        public static CSharpArgumentInfo Create(CSharpArgumentInfoFlags flags, string name);
+    }
+    public enum CSharpArgumentInfoFlags {
+        Constant = 2,
+        IsOut = 16,
+        IsRef = 8,
+        IsStaticType = 32,
+        NamedArgument = 4,
+        None = 0,
+        UseCompileTimeType = 1,
+    }
+    public enum CSharpBinderFlags {
+        BinaryOperationLogical = 8,
+        CheckedContext = 1,
+        ConvertArrayIndex = 32,
+        ConvertExplicit = 16,
+        InvokeSimpleName = 2,
+        InvokeSpecialName = 4,
+        None = 0,
+        ResultDiscarded = 256,
+        ResultIndexed = 64,
+        ValueFromCompoundAssignment = 128,
+    }
+    public class RuntimeBinderException : Exception {
+        public RuntimeBinderException();
+        public RuntimeBinderException(string message);
+        public RuntimeBinderException(string message, Exception innerException);
+    }
+    public class RuntimeBinderInternalCompilerException : Exception {
+        public RuntimeBinderInternalCompilerException();
+        public RuntimeBinderInternalCompilerException(string message);
+        public RuntimeBinderInternalCompilerException(string message, Exception innerException);
+    }
+}
```

## Microsoft.SqlServer.Server

```c#
+namespace Microsoft.SqlServer.Server {
+    public class SqlDataRecord {
+        public SqlDataRecord(params SqlMetaData[] metaData);
+        public virtual int FieldCount { get; }
+        public virtual object this[int ordinal] { get; }
+        public virtual object this[string name] { get; }
+        public virtual bool GetBoolean(int ordinal);
+        public virtual byte GetByte(int ordinal);
+        public virtual long GetBytes(int ordinal, long fieldOffset, byte[] buffer, int bufferOffset, int length);
+        public virtual char GetChar(int ordinal);
+        public virtual long GetChars(int ordinal, long fieldOffset, char[] buffer, int bufferOffset, int length);
+        public virtual string GetDataTypeName(int ordinal);
+        public virtual DateTime GetDateTime(int ordinal);
+        public virtual DateTimeOffset GetDateTimeOffset(int ordinal);
+        public virtual Decimal GetDecimal(int ordinal);
+        public virtual double GetDouble(int ordinal);
+        public virtual Type GetFieldType(int ordinal);
+        public virtual float GetFloat(int ordinal);
+        public virtual Guid GetGuid(int ordinal);
+        public virtual short GetInt16(int ordinal);
+        public virtual int GetInt32(int ordinal);
+        public virtual long GetInt64(int ordinal);
+        public virtual string GetName(int ordinal);
+        public virtual int GetOrdinal(string name);
+        public virtual SqlBinary GetSqlBinary(int ordinal);
+        public virtual SqlBoolean GetSqlBoolean(int ordinal);
+        public virtual SqlByte GetSqlByte(int ordinal);
+        public virtual SqlBytes GetSqlBytes(int ordinal);
+        public virtual SqlChars GetSqlChars(int ordinal);
+        public virtual SqlDateTime GetSqlDateTime(int ordinal);
+        public virtual SqlDecimal GetSqlDecimal(int ordinal);
+        public virtual SqlDouble GetSqlDouble(int ordinal);
+        public virtual Type GetSqlFieldType(int ordinal);
+        public virtual SqlGuid GetSqlGuid(int ordinal);
+        public virtual SqlInt16 GetSqlInt16(int ordinal);
+        public virtual SqlInt32 GetSqlInt32(int ordinal);
+        public virtual SqlInt64 GetSqlInt64(int ordinal);
+        public virtual SqlMetaData GetSqlMetaData(int ordinal);
+        public virtual SqlMoney GetSqlMoney(int ordinal);
+        public virtual SqlSingle GetSqlSingle(int ordinal);
+        public virtual SqlString GetSqlString(int ordinal);
+        public virtual object GetSqlValue(int ordinal);
+        public virtual int GetSqlValues(object[] values);
+        public virtual SqlXml GetSqlXml(int ordinal);
+        public virtual string GetString(int ordinal);
+        public virtual TimeSpan GetTimeSpan(int ordinal);
+        public virtual object GetValue(int ordinal);
+        public virtual int GetValues(object[] values);
+        public virtual bool IsDBNull(int ordinal);
+        public virtual void SetBoolean(int ordinal, bool value);
+        public virtual void SetByte(int ordinal, byte value);
+        public virtual void SetBytes(int ordinal, long fieldOffset, byte[] buffer, int bufferOffset, int length);
+        public virtual void SetChar(int ordinal, char value);
+        public virtual void SetChars(int ordinal, long fieldOffset, char[] buffer, int bufferOffset, int length);
+        public virtual void SetDateTime(int ordinal, DateTime value);
+        public virtual void SetDateTimeOffset(int ordinal, DateTimeOffset value);
+        public virtual void SetDBNull(int ordinal);
+        public virtual void SetDecimal(int ordinal, Decimal value);
+        public virtual void SetDouble(int ordinal, double value);
+        public virtual void SetFloat(int ordinal, float value);
+        public virtual void SetGuid(int ordinal, Guid value);
+        public virtual void SetInt16(int ordinal, short value);
+        public virtual void SetInt32(int ordinal, int value);
+        public virtual void SetInt64(int ordinal, long value);
+        public virtual void SetSqlBinary(int ordinal, SqlBinary value);
+        public virtual void SetSqlBoolean(int ordinal, SqlBoolean value);
+        public virtual void SetSqlByte(int ordinal, SqlByte value);
+        public virtual void SetSqlBytes(int ordinal, SqlBytes value);
+        public virtual void SetSqlChars(int ordinal, SqlChars value);
+        public virtual void SetSqlDateTime(int ordinal, SqlDateTime value);
+        public virtual void SetSqlDecimal(int ordinal, SqlDecimal value);
+        public virtual void SetSqlDouble(int ordinal, SqlDouble value);
+        public virtual void SetSqlGuid(int ordinal, SqlGuid value);
+        public virtual void SetSqlInt16(int ordinal, SqlInt16 value);
+        public virtual void SetSqlInt32(int ordinal, SqlInt32 value);
+        public virtual void SetSqlInt64(int ordinal, SqlInt64 value);
+        public virtual void SetSqlMoney(int ordinal, SqlMoney value);
+        public virtual void SetSqlSingle(int ordinal, SqlSingle value);
+        public virtual void SetSqlString(int ordinal, SqlString value);
+        public virtual void SetSqlXml(int ordinal, SqlXml value);
+        public virtual void SetString(int ordinal, string value);
+        public virtual void SetTimeSpan(int ordinal, TimeSpan value);
+        public virtual void SetValue(int ordinal, object value);
+        public virtual int SetValues(params object[] values);
+    }
+    public sealed class SqlMetaData {
+        public SqlMetaData(string name, SqlDbType dbType);
+        public SqlMetaData(string name, SqlDbType dbType, bool useServerDefault, bool isUniqueKey, SortOrder columnSortOrder, int sortOrdinal);
+        public SqlMetaData(string name, SqlDbType dbType, byte precision, byte scale);
+        public SqlMetaData(string name, SqlDbType dbType, byte precision, byte scale, bool useServerDefault, bool isUniqueKey, SortOrder columnSortOrder, int sortOrdinal);
+        public SqlMetaData(string name, SqlDbType dbType, long maxLength);
+        public SqlMetaData(string name, SqlDbType dbType, long maxLength, bool useServerDefault, bool isUniqueKey, SortOrder columnSortOrder, int sortOrdinal);
+        public SqlMetaData(string name, SqlDbType dbType, long maxLength, byte precision, byte scale, long locale, SqlCompareOptions compareOptions, Type userDefinedType);
+        public SqlMetaData(string name, SqlDbType dbType, long maxLength, byte precision, byte scale, long localeId, SqlCompareOptions compareOptions, Type userDefinedType, bool useServerDefault, bool isUniqueKey, SortOrder columnSortOrder, int sortOrdinal);
+        public SqlMetaData(string name, SqlDbType dbType, long maxLength, long locale, SqlCompareOptions compareOptions);
+        public SqlMetaData(string name, SqlDbType dbType, long maxLength, long locale, SqlCompareOptions compareOptions, bool useServerDefault, bool isUniqueKey, SortOrder columnSortOrder, int sortOrdinal);
+        public SqlMetaData(string name, SqlDbType dbType, string database, string owningSchema, string objectName);
+        public SqlMetaData(string name, SqlDbType dbType, string database, string owningSchema, string objectName, bool useServerDefault, bool isUniqueKey, SortOrder columnSortOrder, int sortOrdinal);
+        public SqlCompareOptions CompareOptions { get; }
+        public bool IsUniqueKey { get; }
+        public long LocaleId { get; }
+        public static long Max { get; }
+        public long MaxLength { get; }
+        public string Name { get; }
+        public byte Precision { get; }
+        public byte Scale { get; }
+        public SortOrder SortOrder { get; }
+        public int SortOrdinal { get; }
+        public SqlDbType SqlDbType { get; }
+        public string TypeName { get; }
+        public bool UseServerDefault { get; }
+        public string XmlSchemaCollectionDatabase { get; }
+        public string XmlSchemaCollectionName { get; }
+        public string XmlSchemaCollectionOwningSchema { get; }
+        public bool Adjust(bool value);
+        public byte Adjust(byte value);
+        public byte[] Adjust(byte[] value);
+        public char Adjust(char value);
+        public char[] Adjust(char[] value);
+        public SqlBinary Adjust(SqlBinary value);
+        public SqlBoolean Adjust(SqlBoolean value);
+        public SqlByte Adjust(SqlByte value);
+        public SqlBytes Adjust(SqlBytes value);
+        public SqlChars Adjust(SqlChars value);
+        public SqlDateTime Adjust(SqlDateTime value);
+        public SqlDecimal Adjust(SqlDecimal value);
+        public SqlDouble Adjust(SqlDouble value);
+        public SqlGuid Adjust(SqlGuid value);
+        public SqlInt16 Adjust(SqlInt16 value);
+        public SqlInt32 Adjust(SqlInt32 value);
+        public SqlInt64 Adjust(SqlInt64 value);
+        public SqlMoney Adjust(SqlMoney value);
+        public SqlSingle Adjust(SqlSingle value);
+        public SqlString Adjust(SqlString value);
+        public SqlXml Adjust(SqlXml value);
+        public DateTime Adjust(DateTime value);
+        public DateTimeOffset Adjust(DateTimeOffset value);
+        public Decimal Adjust(Decimal value);
+        public double Adjust(double value);
+        public Guid Adjust(Guid value);
+        public short Adjust(short value);
+        public int Adjust(int value);
+        public long Adjust(long value);
+        public object Adjust(object value);
+        public float Adjust(float value);
+        public string Adjust(string value);
+        public TimeSpan Adjust(TimeSpan value);
+        public static SqlMetaData InferFromValue(object value, string name);
+    }
+}
```

## Microsoft.VisualBasic

```c#
+namespace Microsoft.VisualBasic {
+    public enum CallType {
+        Get = 2,
+        Let = 4,
+        Method = 1,
+        Set = 8,
+    }
+    public sealed class Constants {
+        public const string vbBack = "\b";
+        public const string vbCr = "\r";
+        public const string vbCrLf = "\r\n";
+        public const string vbFormFeed = "\f";
+        public const string vbLf = "\n";
+        public const string vbNewLine = "\r\n";
+        public const string vbNullChar = "\0";
+        public const string vbNullString = null;
+        public const string vbTab = "\t";
+        public const string vbVerticalTab = "\v";
+    }
+    public sealed class HideModuleNameAttribute : Attribute {
+        public HideModuleNameAttribute();
+    }
+    public sealed class Strings {
+        public static int AscW(char String);
+        public static int AscW(string String);
+        public static char ChrW(int CharCode);
+    }
+}
```

## Microsoft.VisualBasic.CompilerServices

```c#
+namespace Microsoft.VisualBasic.CompilerServices {
+    public sealed class Conversions {
+        public static object ChangeType(object Expression, Type TargetType);
+        public static bool ToBoolean(object Value);
+        public static bool ToBoolean(string Value);
+        public static byte ToByte(object Value);
+        public static byte ToByte(string Value);
+        public static char ToChar(object Value);
+        public static char ToChar(string Value);
+        public static char[] ToCharArrayRankOne(object Value);
+        public static char[] ToCharArrayRankOne(string Value);
+        public static DateTime ToDate(object Value);
+        public static DateTime ToDate(string Value);
+        public static Decimal ToDecimal(bool Value);
+        public static Decimal ToDecimal(object Value);
+        public static Decimal ToDecimal(string Value);
+        public static double ToDouble(object Value);
+        public static double ToDouble(string Value);
+        public static T ToGenericParameter<T>(object Value);
+        public static int ToInteger(object Value);
+        public static int ToInteger(string Value);
+        public static long ToLong(object Value);
+        public static long ToLong(string Value);
+        public static sbyte ToSByte(object Value);
+        public static sbyte ToSByte(string Value);
+        public static short ToShort(object Value);
+        public static short ToShort(string Value);
+        public static float ToSingle(object Value);
+        public static float ToSingle(string Value);
+        public static string ToString(bool Value);
+        public static string ToString(byte Value);
+        public static string ToString(char Value);
+        public static string ToString(DateTime Value);
+        public static string ToString(Decimal Value);
+        public static string ToString(double Value);
+        public static string ToString(short Value);
+        public static string ToString(int Value);
+        public static string ToString(long Value);
+        public static string ToString(object Value);
+        public static string ToString(float Value);
+        public static string ToString(uint Value);
+        public static string ToString(ulong Value);
+        public static uint ToUInteger(object Value);
+        public static uint ToUInteger(string Value);
+        public static ulong ToULong(object Value);
+        public static ulong ToULong(string Value);
+        public static ushort ToUShort(object Value);
+        public static ushort ToUShort(string Value);
+    }
+    public sealed class DesignerGeneratedAttribute : Attribute {
+        public DesignerGeneratedAttribute();
+    }
+    public sealed class IncompleteInitialization : Exception {
+        public IncompleteInitialization();
+    }
+    public sealed class NewLateBinding {
+        public static object LateCall(object Instance, Type Type, string MemberName, object[] Arguments, string[] ArgumentNames, Type[] TypeArguments, bool[] CopyBack, bool IgnoreReturn);
+        public static object LateGet(object Instance, Type Type, string MemberName, object[] Arguments, string[] ArgumentNames, Type[] TypeArguments, bool[] CopyBack);
+        public static object LateIndexGet(object Instance, object[] Arguments, string[] ArgumentNames);
+        public static void LateIndexSet(object Instance, object[] Arguments, string[] ArgumentNames);
+        public static void LateIndexSetComplex(object Instance, object[] Arguments, string[] ArgumentNames, bool OptimisticSet, bool RValueBase);
+        public static void LateSet(object Instance, Type Type, string MemberName, object[] Arguments, string[] ArgumentNames, Type[] TypeArguments);
+        public static void LateSet(object Instance, Type Type, string MemberName, object[] Arguments, string[] ArgumentNames, Type[] TypeArguments, bool OptimisticSet, bool RValueBase, CallType CallType);
+        public static void LateSetComplex(object Instance, Type Type, string MemberName, object[] Arguments, string[] ArgumentNames, Type[] TypeArguments, bool OptimisticSet, bool RValueBase);
+    }
+    public sealed class ObjectFlowControl {
+        public static void CheckForSyncLockOnValueType(object Expression);
+        public sealed class ForLoopControl {
+            public static bool ForLoopInitObj(object Counter, object Start, object Limit, object StepValue, ref object LoopForResult, ref object CounterResult);
+            public static bool ForNextCheckDec(Decimal count, Decimal limit, Decimal StepValue);
+            public static bool ForNextCheckObj(object Counter, object LoopObj, ref object CounterResult);
+            public static bool ForNextCheckR4(float count, float limit, float StepValue);
+            public static bool ForNextCheckR8(double count, double limit, double StepValue);
+        }
+    }
+    public sealed class Operators {
+        public static object AddObject(object Left, object Right);
+        public static object AndObject(object Left, object Right);
+        public static object CompareObjectEqual(object Left, object Right, bool TextCompare);
+        public static object CompareObjectGreater(object Left, object Right, bool TextCompare);
+        public static object CompareObjectGreaterEqual(object Left, object Right, bool TextCompare);
+        public static object CompareObjectLess(object Left, object Right, bool TextCompare);
+        public static object CompareObjectLessEqual(object Left, object Right, bool TextCompare);
+        public static object CompareObjectNotEqual(object Left, object Right, bool TextCompare);
+        public static int CompareString(string Left, string Right, bool TextCompare);
+        public static object ConcatenateObject(object Left, object Right);
+        public static bool ConditionalCompareObjectEqual(object Left, object Right, bool TextCompare);
+        public static bool ConditionalCompareObjectGreater(object Left, object Right, bool TextCompare);
+        public static bool ConditionalCompareObjectGreaterEqual(object Left, object Right, bool TextCompare);
+        public static bool ConditionalCompareObjectLess(object Left, object Right, bool TextCompare);
+        public static bool ConditionalCompareObjectLessEqual(object Left, object Right, bool TextCompare);
+        public static bool ConditionalCompareObjectNotEqual(object Left, object Right, bool TextCompare);
+        public static object DivideObject(object Left, object Right);
+        public static object ExponentObject(object Left, object Right);
+        public static object IntDivideObject(object Left, object Right);
+        public static object LeftShiftObject(object Operand, object Amount);
+        public static object ModObject(object Left, object Right);
+        public static object MultiplyObject(object Left, object Right);
+        public static object NegateObject(object Operand);
+        public static object NotObject(object Operand);
+        public static object OrObject(object Left, object Right);
+        public static object PlusObject(object Operand);
+        public static object RightShiftObject(object Operand, object Amount);
+        public static object SubtractObject(object Left, object Right);
+        public static object XorObject(object Left, object Right);
+    }
+    public sealed class OptionCompareAttribute : Attribute {
+        public OptionCompareAttribute();
+    }
+    public sealed class OptionTextAttribute : Attribute {
+        public OptionTextAttribute();
+    }
+    public sealed class ProjectData {
+        public static void ClearProjectError();
+        public static void SetProjectError(Exception ex);
+        public static void SetProjectError(Exception ex, int lErl);
+    }
+    public sealed class StandardModuleAttribute : Attribute {
+        public StandardModuleAttribute();
+    }
+    public sealed class StaticLocalInitFlag {
+        public short State;
+        public StaticLocalInitFlag();
+    }
+    public sealed class Utils {
+        public static Array CopyArray(Array arySrc, Array aryDest);
+    }
+}
```

## Microsoft.Win32

```c#
+namespace Microsoft.Win32 {
+    public static class Registry {
+        public static readonly RegistryKey ClassesRoot;
+        public static readonly RegistryKey CurrentConfig;
+        public static readonly RegistryKey CurrentUser;
+        public static readonly RegistryKey LocalMachine;
+        public static readonly RegistryKey PerformanceData;
+        public static readonly RegistryKey Users;
+        public static object GetValue(string keyName, string valueName, object defaultValue);
+        public static void SetValue(string keyName, string valueName, object value);
+        public static void SetValue(string keyName, string valueName, object value, RegistryValueKind valueKind);
+    }
+    public static class RegistryAclExtensions {
+        public static RegistrySecurity GetAccessControl(this RegistryKey key);
+        public static RegistrySecurity GetAccessControl(this RegistryKey key, AccessControlSections includeSections);
+        public static void SetAccessControl(this RegistryKey key, RegistrySecurity registrySecurity);
+    }
+    public enum RegistryHive {
+        ClassesRoot = -2147483648,
+        CurrentConfig = -2147483643,
+        CurrentUser = -2147483647,
+        LocalMachine = -2147483646,
+        PerformanceData = -2147483644,
+        Users = -2147483645,
+    }
+    public sealed class RegistryKey : IDisposable {
+        public SafeRegistryHandle Handle { get; }
+        public string Name { get; }
+        public int SubKeyCount { get; }
+        public int ValueCount { get; }
+        public RegistryView View { get; }
+        public RegistryKey CreateSubKey(string subkey);
+        public RegistryKey CreateSubKey(string subkey, bool writable);
+        public RegistryKey CreateSubKey(string subkey, bool writable, RegistryOptions options);
+        public void DeleteSubKey(string subkey);
+        public void DeleteSubKey(string subkey, bool throwOnMissingSubKey);
+        public void DeleteSubKeyTree(string subkey);
+        public void DeleteSubKeyTree(string subkey, bool throwOnMissingSubKey);
+        public void DeleteValue(string name);
+        public void DeleteValue(string name, bool throwOnMissingValue);
+        public void Dispose();
+        public void Flush();
+        public static RegistryKey FromHandle(SafeRegistryHandle handle);
+        public static RegistryKey FromHandle(SafeRegistryHandle handle, RegistryView view);
+        public string[] GetSubKeyNames();
+        public object GetValue(string name);
+        public object GetValue(string name, object defaultValue);
+        public object GetValue(string name, object defaultValue, RegistryValueOptions options);
+        public RegistryValueKind GetValueKind(string name);
+        public string[] GetValueNames();
+        public static RegistryKey OpenBaseKey(RegistryHive hKey, RegistryView view);
+        public RegistryKey OpenSubKey(string name);
+        public RegistryKey OpenSubKey(string name, bool writable);
+        public RegistryKey OpenSubKey(string name, RegistryRights rights);
+        public void SetValue(string name, object value);
+        public void SetValue(string name, object value, RegistryValueKind valueKind);
+        public override string ToString();
+    }
+    public enum RegistryOptions {
+        None = 0,
+        Volatile = 1,
+    }
+    public enum RegistryValueKind {
+        Binary = 3,
+        DWord = 4,
+        ExpandString = 2,
+        MultiString = 7,
+        None = -1,
+        QWord = 11,
+        String = 1,
+        Unknown = 0,
+    }
+    public enum RegistryValueOptions {
+        DoNotExpandEnvironmentNames = 1,
+        None = 0,
+    }
+    public enum RegistryView {
+        Default = 0,
+        Registry32 = 512,
+        Registry64 = 256,
+    }
+}
```

## Microsoft.Win32.SafeHandles

```c#
+namespace Microsoft.Win32.SafeHandles {
+    public sealed class SafeAccessTokenHandle : SafeHandle {
+        public SafeAccessTokenHandle(IntPtr handle);
+        public static SafeAccessTokenHandle InvalidHandle { get; }
+        public override bool IsInvalid { get; }
+        protected override bool ReleaseHandle();
+    }
+    public sealed class SafeFileHandle : SafeHandle {
+        public SafeFileHandle(IntPtr preexistingHandle, bool ownsHandle);
+        public override bool IsInvalid { get; }
+        protected override bool ReleaseHandle();
+    }
+    public abstract class SafeHandleZeroOrMinusOneIsInvalid : SafeHandle {
+        public override bool IsInvalid { get; }
+    }
+    public sealed class SafeMemoryMappedFileHandle : SafeHandle {
+        public override bool IsInvalid { get; }
+        protected override bool ReleaseHandle();
+    }
+    public sealed class SafeMemoryMappedViewHandle : SafeBuffer {
+        protected override bool ReleaseHandle();
+    }
+    public abstract class SafeNCryptHandle : SafeHandle {
+        protected SafeNCryptHandle();
+        public override bool IsInvalid { get; }
+        protected override bool ReleaseHandle();
+        protected abstract bool ReleaseNativeHandle();
+    }
+    public sealed class SafeNCryptKeyHandle : SafeNCryptHandle {
+        public SafeNCryptKeyHandle();
+        protected override bool ReleaseNativeHandle();
+    }
+    public sealed class SafeNCryptProviderHandle : SafeNCryptHandle {
+        public SafeNCryptProviderHandle();
+        protected override bool ReleaseNativeHandle();
+    }
+    public sealed class SafeNCryptSecretHandle : SafeNCryptHandle {
+        public SafeNCryptSecretHandle();
+        protected override bool ReleaseNativeHandle();
+    }
+    public sealed class SafePipeHandle : SafeHandle {
+        public SafePipeHandle(IntPtr preexistingHandle, bool ownsHandle);
+        public override bool IsInvalid { get; }
+        protected override bool ReleaseHandle();
+    }
+    public sealed class SafeProcessHandle : SafeHandle {
+        public SafeProcessHandle(IntPtr existingHandle, bool ownsHandle);
+        public override bool IsInvalid { get; }
+        protected override bool ReleaseHandle();
+    }
+    public sealed class SafeRegistryHandle : SafeHandle {
+        public SafeRegistryHandle(IntPtr preexistingHandle, bool ownsHandle);
+        public override bool IsInvalid { get; }
+        protected override bool ReleaseHandle();
+    }
+    public sealed class SafeWaitHandle : SafeHandle {
+        public SafeWaitHandle(IntPtr existingHandle, bool ownsHandle);
+        public override bool IsInvalid { get; }
+        protected override bool ReleaseHandle();
+    }
+    public sealed class SafeX509ChainHandle : SafeHandle {
+        public override bool IsInvalid { get; }
+        protected override bool ReleaseHandle();
+    }
+}
```

## System

```c#
+namespace System {
+    public class AccessViolationException : SystemException {
+        public AccessViolationException();
+        public AccessViolationException(string message);
+        public AccessViolationException(string message, Exception innerException);
+    }
+    public delegate void Action();
+    public delegate void Action<in T>(T obj);
+    public delegate void Action<in T1, in T2>(T1 arg1, T2 arg2);
+    public delegate void Action<in T1, in T2, in T3>(T1 arg1, T2 arg2, T3 arg3);
+    public delegate void Action<in T1, in T2, in T3, in T4>(T1 arg1, T2 arg2, T3 arg3, T4 arg4);
+    public delegate void Action<in T1, in T2, in T3, in T4, in T5>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5);
+    public delegate void Action<in T1, in T2, in T3, in T4, in T5, in T6>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6);
+    public delegate void Action<in T1, in T2, in T3, in T4, in T5, in T6, in T7>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7);
+    public delegate void Action<in T1, in T2, in T3, in T4, in T5, in T6, in T7, in T8>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8);
+    public delegate void Action<in T1, in T2, in T3, in T4, in T5, in T6, in T7, in T8, in T9>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9);
+    public delegate void Action<in T1, in T2, in T3, in T4, in T5, in T6, in T7, in T8, in T9, in T10>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10);
+    public delegate void Action<in T1, in T2, in T3, in T4, in T5, in T6, in T7, in T8, in T9, in T10, in T11>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11);
+    public delegate void Action<in T1, in T2, in T3, in T4, in T5, in T6, in T7, in T8, in T9, in T10, in T11, in T12>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12);
+    public delegate void Action<in T1, in T2, in T3, in T4, in T5, in T6, in T7, in T8, in T9, in T10, in T11, in T12, in T13>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13);
+    public delegate void Action<in T1, in T2, in T3, in T4, in T5, in T6, in T7, in T8, in T9, in T10, in T11, in T12, in T13, in T14>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14);
+    public delegate void Action<in T1, in T2, in T3, in T4, in T5, in T6, in T7, in T8, in T9, in T10, in T11, in T12, in T13, in T14, in T15>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14, T15 arg15);
+    public delegate void Action<in T1, in T2, in T3, in T4, in T5, in T6, in T7, in T8, in T9, in T10, in T11, in T12, in T13, in T14, in T15, in T16>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14, T15 arg15, T16 arg16);
+    public static class Activator {
+        public static object CreateInstance(Type type);
+        public static object CreateInstance(Type type, bool nonPublic);
+        public static object CreateInstance(Type type, params object[] args);
+        public static T CreateInstance<T>();
+    }
+    public class AggregateException : Exception {
+        public AggregateException();
+        public AggregateException(IEnumerable<Exception> innerExceptions);
+        public AggregateException(params Exception[] innerExceptions);
+        public AggregateException(string message);
+        public AggregateException(string message, IEnumerable<Exception> innerExceptions);
+        public AggregateException(string message, Exception innerException);
+        public AggregateException(string message, params Exception[] innerExceptions);
+        public ReadOnlyCollection<Exception> InnerExceptions { get; }
+        public override string Message { get; }
+        public AggregateException Flatten();
+        public override Exception GetBaseException();
+        public void Handle(Func<Exception, bool> predicate);
+        public override string ToString();
+    }
+    public static class AppContext {
+        public static string BaseDirectory { get; }
+        public static string TargetFrameworkName { get; }
+        public static object GetData(string name);
+        public static void SetSwitch(string switchName, bool isEnabled);
+        public static bool TryGetSwitch(string switchName, out bool isEnabled);
+    }
+    public sealed class AppDomain : _AppDomain {
+        public string BaseDirectory { get; }
+        public static AppDomain CurrentDomain { get; }
+        public bool IsFullyTrusted { get; }
+        public object GetData(string name);
+        public override string ToString();
+    }
+    public class AppDomainManager {
+        public AppDomainManager();
+        public virtual bool CheckSecuritySettings(SecurityState state);
+        public virtual void InitializeNewDomain(AppDomainSetup appDomainInfo);
+    }
+    public sealed class AppDomainSetup
+    public class AppDomainUnloadedException : SystemException {
+        public AppDomainUnloadedException();
+        public AppDomainUnloadedException(string message);
+        public AppDomainUnloadedException(string message, Exception innerException);
+    }
+    public class ApplicationException : Exception {
+        public ApplicationException();
+        public ApplicationException(string message);
+        public ApplicationException(string message, Exception innerException);
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct ArgIterator {
+        public override bool Equals(object o);
+        public override int GetHashCode();
+    }
+    public class ArgumentException : Exception {
+        public ArgumentException();
+        public ArgumentException(string message);
+        public ArgumentException(string message, Exception innerException);
+        public ArgumentException(string message, string paramName);
+        public ArgumentException(string message, string paramName, Exception innerException);
+        public override string Message { get; }
+        public virtual string ParamName { get; }
+    }
+    public class ArgumentNullException : ArgumentException {
+        public ArgumentNullException();
+        public ArgumentNullException(string paramName);
+        public ArgumentNullException(string message, Exception innerException);
+        public ArgumentNullException(string paramName, string message);
+    }
+    public class ArgumentOutOfRangeException : ArgumentException {
+        public ArgumentOutOfRangeException();
+        public ArgumentOutOfRangeException(string paramName);
+        public ArgumentOutOfRangeException(string message, Exception innerException);
+        public ArgumentOutOfRangeException(string paramName, object actualValue, string message);
+        public ArgumentOutOfRangeException(string paramName, string message);
+        public virtual object ActualValue { get; }
+        public override string Message { get; }
+    }
+    public class ArithmeticException : Exception {
+        public ArithmeticException();
+        public ArithmeticException(string message);
+        public ArithmeticException(string message, Exception innerException);
+    }
+    public abstract class Array : ICollection, IEnumerable, IList, IStructuralComparable, IStructuralEquatable {
+        public bool IsFixedSize { get; }
+        public bool IsReadOnly { get; }
+        public bool IsSynchronized { get; }
+        public int Length { get; }
+        public int Rank { get; }
+        public object SyncRoot { get; }
+        int System.Collections.ICollection.Count { get; }
+        bool System.Collections.ICollection.IsSynchronized { get; }
+        object System.Collections.ICollection.SyncRoot { get; }
+        bool System.Collections.IList.IsFixedSize { get; }
+        bool System.Collections.IList.IsReadOnly { get; }
+        object System.Collections.IList.this[int index] { get; set; }
+        public static ReadOnlyCollection<T> AsReadOnly<T>(T[] array);
+        public static int BinarySearch(Array array, int index, int length, object value);
+        public static int BinarySearch(Array array, int index, int length, object value, IComparer comparer);
+        public static int BinarySearch(Array array, object value);
+        public static int BinarySearch(Array array, object value, IComparer comparer);
+        public static int BinarySearch<T>(T[] array, int index, int length, T value);
+        public static int BinarySearch<T>(T[] array, int index, int length, T value, IComparer<T> comparer);
+        public static int BinarySearch<T>(T[] array, T value);
+        public static int BinarySearch<T>(T[] array, T value, IComparer<T> comparer);
+        public static void Clear(Array array, int index, int length);
+        public object Clone();
+        public static void ConstrainedCopy(Array sourceArray, int sourceIndex, Array destinationArray, int destinationIndex, int length);
+        public static void Copy(Array sourceArray, Array destinationArray, int length);
+        public static void Copy(Array sourceArray, int sourceIndex, Array destinationArray, int destinationIndex, int length);
+        public void CopyTo(Array array, int index);
+        public static Array CreateInstance(Type elementType, int length);
+        public static Array CreateInstance(Type elementType, params int[] lengths);
+        public static Array CreateInstance(Type elementType, int[] lengths, int[] lowerBounds);
+        public static T[] Empty<T>();
+        public static bool Exists<T>(T[] array, Predicate<T> match);
+        public static T Find<T>(T[] array, Predicate<T> match);
+        public static T[] FindAll<T>(T[] array, Predicate<T> match);
+        public static int FindIndex<T>(T[] array, int startIndex, int count, Predicate<T> match);
+        public static int FindIndex<T>(T[] array, int startIndex, Predicate<T> match);
+        public static int FindIndex<T>(T[] array, Predicate<T> match);
+        public static T FindLast<T>(T[] array, Predicate<T> match);
+        public static int FindLastIndex<T>(T[] array, int startIndex, int count, Predicate<T> match);
+        public static int FindLastIndex<T>(T[] array, int startIndex, Predicate<T> match);
+        public static int FindLastIndex<T>(T[] array, Predicate<T> match);
+        public static void ForEach<T>(T[] array, Action<T> action);
+        public IEnumerator GetEnumerator();
+        public int GetLength(int dimension);
+        public int GetLowerBound(int dimension);
+        public int GetUpperBound(int dimension);
+        public object GetValue(int index);
+        public object GetValue(params int[] indices);
+        public static int IndexOf(Array array, object value);
+        public static int IndexOf(Array array, object value, int startIndex);
+        public static int IndexOf(Array array, object value, int startIndex, int count);
+        public static int IndexOf<T>(T[] array, T value);
+        public static int IndexOf<T>(T[] array, T value, int startIndex);
+        public static int IndexOf<T>(T[] array, T value, int startIndex, int count);
+        public void Initialize();
+        public static int LastIndexOf(Array array, object value);
+        public static int LastIndexOf(Array array, object value, int startIndex);
+        public static int LastIndexOf(Array array, object value, int startIndex, int count);
+        public static int LastIndexOf<T>(T[] array, T value);
+        public static int LastIndexOf<T>(T[] array, T value, int startIndex);
+        public static int LastIndexOf<T>(T[] array, T value, int startIndex, int count);
+        public static void Resize<T>(ref T[] array, int newSize);
+        public static void Reverse(Array array);
+        public static void Reverse(Array array, int index, int length);
+        public void SetValue(object value, int index);
+        public void SetValue(object value, params int[] indices);
+        public static void Sort(Array array);
+        public static void Sort(Array keys, Array items);
+        public static void Sort(Array keys, Array items, IComparer comparer);
+        public static void Sort(Array keys, Array items, int index, int length);
+        public static void Sort(Array keys, Array items, int index, int length, IComparer comparer);
+        public static void Sort(Array array, IComparer comparer);
+        public static void Sort(Array array, int index, int length);
+        public static void Sort(Array array, int index, int length, IComparer comparer);
+        public static void Sort<T>(T[] array);
+        public static void Sort<T>(T[] array, IComparer<T> comparer);
+        public static void Sort<T>(T[] array, Comparison<T> comparison);
+        public static void Sort<T>(T[] array, int index, int length);
+        public static void Sort<T>(T[] array, int index, int length, IComparer<T> comparer);
+        public static void Sort<TKey, TValue>(TKey[] keys, TValue[] items);
+        public static void Sort<TKey, TValue>(TKey[] keys, TValue[] items, IComparer<TKey> comparer);
+        public static void Sort<TKey, TValue>(TKey[] keys, TValue[] items, int index, int length);
+        public static void Sort<TKey, TValue>(TKey[] keys, TValue[] items, int index, int length, IComparer<TKey> comparer);
+        int System.Collections.IList.Add(object value);
+        void System.Collections.IList.Clear();
+        bool System.Collections.IList.Contains(object value);
+        int System.Collections.IList.IndexOf(object value);
+        void System.Collections.IList.Insert(int index, object value);
+        void System.Collections.IList.Remove(object value);
+        void System.Collections.IList.RemoveAt(int index);
+        int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
+        bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
+        int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
+        public static bool TrueForAll<T>(T[] array, Predicate<T> match);
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct ArraySegment<T> : ICollection<T>, IEnumerable, IEnumerable<T>, IList<T>, IReadOnlyCollection<T>, IReadOnlyList<T> {
+        public ArraySegment(T[] array);
+        public ArraySegment(T[] array, int offset, int count);
+        public T[] Array { get; }
+        public int Count { get; }
+        public int Offset { get; }
+        bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
+        T System.Collections.Generic.IList<T>.this[int index] { get; set; }
+        T System.Collections.Generic.IReadOnlyList<T>.this[int index] { get; }
+        public bool Equals(ArraySegment<T> obj);
+        public override bool Equals(object obj);
+        public override int GetHashCode();
+        public static bool operator ==(ArraySegment<T> a, ArraySegment<T> b);
+        public static bool operator !=(ArraySegment<T> a, ArraySegment<T> b);
+        void System.Collections.Generic.ICollection<T>.Add(T item);
+        void System.Collections.Generic.ICollection<T>.Clear();
+        bool System.Collections.Generic.ICollection<T>.Contains(T item);
+        void System.Collections.Generic.ICollection<T>.CopyTo(T[] array, int arrayIndex);
+        bool System.Collections.Generic.ICollection<T>.Remove(T item);
+        IEnumerator<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
+        int System.Collections.Generic.IList<T>.IndexOf(T item);
+        void System.Collections.Generic.IList<T>.Insert(int index, T item);
+        void System.Collections.Generic.IList<T>.RemoveAt(int index);
+        IEnumerator System.Collections.IEnumerable.GetEnumerator();
+    }
+    public class ArrayTypeMismatchException : Exception {
+        public ArrayTypeMismatchException();
+        public ArrayTypeMismatchException(string message);
+        public ArrayTypeMismatchException(string message, Exception innerException);
+    }
+    public delegate void AsyncCallback(IAsyncResult ar);
+    public abstract class Attribute {
+        protected Attribute();
+        public override bool Equals(object obj);
+        public static Attribute GetCustomAttribute(Assembly element, Type attributeType);
+        public static Attribute GetCustomAttribute(Assembly element, Type attributeType, bool inherit);
+        public static Attribute GetCustomAttribute(MemberInfo element, Type attributeType);
+        public static Attribute GetCustomAttribute(MemberInfo element, Type attributeType, bool inherit);
+        public static Attribute GetCustomAttribute(Module element, Type attributeType);
+        public static Attribute GetCustomAttribute(Module element, Type attributeType, bool inherit);
+        public static Attribute GetCustomAttribute(ParameterInfo element, Type attributeType);
+        public static Attribute GetCustomAttribute(ParameterInfo element, Type attributeType, bool inherit);
+        public static Attribute[] GetCustomAttributes(Assembly element);
+        public static Attribute[] GetCustomAttributes(Assembly element, bool inherit);
+        public static Attribute[] GetCustomAttributes(Assembly element, Type attributeType);
+        public static Attribute[] GetCustomAttributes(Assembly element, Type attributeType, bool inherit);
+        public static Attribute[] GetCustomAttributes(MemberInfo element);
+        public static Attribute[] GetCustomAttributes(MemberInfo element, bool inherit);
+        public static Attribute[] GetCustomAttributes(MemberInfo element, Type type);
+        public static Attribute[] GetCustomAttributes(MemberInfo element, Type type, bool inherit);
+        public static Attribute[] GetCustomAttributes(Module element);
+        public static Attribute[] GetCustomAttributes(Module element, bool inherit);
+        public static Attribute[] GetCustomAttributes(Module element, Type attributeType);
+        public static Attribute[] GetCustomAttributes(Module element, Type attributeType, bool inherit);
+        public static Attribute[] GetCustomAttributes(ParameterInfo element);
+        public static Attribute[] GetCustomAttributes(ParameterInfo element, bool inherit);
+        public static Attribute[] GetCustomAttributes(ParameterInfo element, Type attributeType);
+        public static Attribute[] GetCustomAttributes(ParameterInfo element, Type attributeType, bool inherit);
+        public override int GetHashCode();
+        public static bool IsDefined(Assembly element, Type attributeType);
+        public static bool IsDefined(Assembly element, Type attributeType, bool inherit);
+        public static bool IsDefined(MemberInfo element, Type attributeType);
+        public static bool IsDefined(MemberInfo element, Type attributeType, bool inherit);
+        public static bool IsDefined(Module element, Type attributeType);
+        public static bool IsDefined(Module element, Type attributeType, bool inherit);
+        public static bool IsDefined(ParameterInfo element, Type attributeType);
+        public static bool IsDefined(ParameterInfo element, Type attributeType, bool inherit);
+        public virtual bool Match(object obj);
+    }
+    public enum AttributeTargets {
+        All = 32767,
+        Assembly = 1,
+        Class = 4,
+        Constructor = 32,
+        Delegate = 4096,
+        Enum = 16,
+        Event = 512,
+        Field = 256,
+        GenericParameter = 16384,
+        Interface = 1024,
+        Method = 64,
+        Module = 2,
+        Parameter = 2048,
+        Property = 128,
+        ReturnValue = 8192,
+        Struct = 8,
+    }
+    public sealed class AttributeUsageAttribute : Attribute {
+        public AttributeUsageAttribute(AttributeTargets validOn);
+        public bool AllowMultiple { get; set; }
+        public bool Inherited { get; set; }
+        public AttributeTargets ValidOn { get; }
+    }
+    public class BadImageFormatException : Exception {
+        public BadImageFormatException();
+        public BadImageFormatException(string message);
+        public BadImageFormatException(string message, Exception inner);
+        public BadImageFormatException(string message, string fileName);
+        public BadImageFormatException(string message, string fileName, Exception inner);
+        public string FileName { get; }
+        public override string Message { get; }
+        public override string ToString();
+    }
+    public static class BitConverter {
+        public static readonly bool IsLittleEndian;
+        public static long DoubleToInt64Bits(double value);
+        public static byte[] GetBytes(bool value);
+        public static byte[] GetBytes(char value);
+        public static byte[] GetBytes(double value);
+        public static byte[] GetBytes(short value);
+        public static byte[] GetBytes(int value);
+        public static byte[] GetBytes(long value);
+        public static byte[] GetBytes(float value);
+        public static byte[] GetBytes(ushort value);
+        public static byte[] GetBytes(uint value);
+        public static byte[] GetBytes(ulong value);
+        public static double Int64BitsToDouble(long value);
+        public static bool ToBoolean(byte[] value, int startIndex);
+        public static char ToChar(byte[] value, int startIndex);
+        public static double ToDouble(byte[] value, int startIndex);
+        public static short ToInt16(byte[] value, int startIndex);
+        public static int ToInt32(byte[] value, int startIndex);
+        public static long ToInt64(byte[] value, int startIndex);
+        public static float ToSingle(byte[] value, int startIndex);
+        public static string ToString(byte[] value);
+        public static string ToString(byte[] value, int startIndex);
+        public static string ToString(byte[] value, int startIndex, int length);
+        public static ushort ToUInt16(byte[] value, int startIndex);
+        public static uint ToUInt32(byte[] value, int startIndex);
+        public static ulong ToUInt64(byte[] value, int startIndex);
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct Boolean : IComparable, IComparable<bool>, IConvertible, IEquatable<bool> {
+        public static readonly string FalseString;
+        public static readonly string TrueString;
+        public int CompareTo(bool value);
+        public int CompareTo(object obj);
+        public bool Equals(bool obj);
+        public override bool Equals(object obj);
+        public override int GetHashCode();
+        public TypeCode GetTypeCode();
+        public static bool Parse(string value);
+        int System.IComparable.CompareTo(object obj);
+        TypeCode System.IConvertible.GetTypeCode();
+        bool System.IConvertible.ToBoolean(IFormatProvider provider);
+        byte System.IConvertible.ToByte(IFormatProvider provider);
+        char System.IConvertible.ToChar(IFormatProvider provider);
+        DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
+        Decimal System.IConvertible.ToDecimal(IFormatProvider provider);
+        double System.IConvertible.ToDouble(IFormatProvider provider);
+        short System.IConvertible.ToInt16(IFormatProvider provider);
+        int System.IConvertible.ToInt32(IFormatProvider provider);
+        long System.IConvertible.ToInt64(IFormatProvider provider);
+        sbyte System.IConvertible.ToSByte(IFormatProvider provider);
+        float System.IConvertible.ToSingle(IFormatProvider provider);
+        string System.IConvertible.ToString(IFormatProvider provider);
+        object System.IConvertible.ToType(Type type, IFormatProvider provider);
+        ushort System.IConvertible.ToUInt16(IFormatProvider provider);
+        uint System.IConvertible.ToUInt32(IFormatProvider provider);
+        ulong System.IConvertible.ToUInt64(IFormatProvider provider);
+        public override string ToString();
+        public string ToString(IFormatProvider provider);
+        public static bool TryParse(string value, out bool result);
+    }
+    public static class Buffer {
+        public static void BlockCopy(Array src, int srcOffset, Array dst, int dstOffset, int count);
+        public static int ByteLength(Array array);
+        public static byte GetByte(Array array, int index);
+        public unsafe static void MemoryCopy(void* source, void* destination, long destinationSizeInBytes, long sourceBytesToCopy);
+        public unsafe static void MemoryCopy(void* source, void* destination, ulong destinationSizeInBytes, ulong sourceBytesToCopy);
+        public static void SetByte(Array array, int index, byte value);
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct Byte : IComparable, IComparable<byte>, IConvertible, IEquatable<byte>, IFormattable {
+        public const byte MaxValue = (byte)255;
+        public const byte MinValue = (byte)0;
+        public int CompareTo(byte value);
+        public int CompareTo(object value);
+        public bool Equals(byte obj);
+        public override bool Equals(object obj);
+        public override int GetHashCode();
+        public TypeCode GetTypeCode();
+        public static byte Parse(string s);
+        public static byte Parse(string s, NumberStyles style);
+        public static byte Parse(string s, NumberStyles style, IFormatProvider provider);
+        public static byte Parse(string s, IFormatProvider provider);
+        int System.IComparable.CompareTo(object value);
+        TypeCode System.IConvertible.GetTypeCode();
+        bool System.IConvertible.ToBoolean(IFormatProvider provider);
+        byte System.IConvertible.ToByte(IFormatProvider provider);
+        char System.IConvertible.ToChar(IFormatProvider provider);
+        DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
+        Decimal System.IConvertible.ToDecimal(IFormatProvider provider);
+        double System.IConvertible.ToDouble(IFormatProvider provider);
+        short System.IConvertible.ToInt16(IFormatProvider provider);
+        int System.IConvertible.ToInt32(IFormatProvider provider);
+        long System.IConvertible.ToInt64(IFormatProvider provider);
+        sbyte System.IConvertible.ToSByte(IFormatProvider provider);
+        float System.IConvertible.ToSingle(IFormatProvider provider);
+        object System.IConvertible.ToType(Type type, IFormatProvider provider);
+        ushort System.IConvertible.ToUInt16(IFormatProvider provider);
+        uint System.IConvertible.ToUInt32(IFormatProvider provider);
+        ulong System.IConvertible.ToUInt64(IFormatProvider provider);
+        public override string ToString();
+        public string ToString(IFormatProvider provider);
+        public string ToString(string format);
+        public string ToString(string format, IFormatProvider provider);
+        public static bool TryParse(string s, out byte result);
+        public static bool TryParse(string s, NumberStyles style, IFormatProvider provider, out byte result);
+    }
+    public class CannotUnloadAppDomainException : SystemException {
+        public CannotUnloadAppDomainException();
+        public CannotUnloadAppDomainException(string message);
+        public CannotUnloadAppDomainException(string message, Exception innerException);
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct Char : IComparable, IComparable<char>, IConvertible, IEquatable<char> {
+        public const char MaxValue = '\uFFFF';
+        public const char MinValue = '\0';
+        public int CompareTo(char value);
+        public int CompareTo(object value);
+        public static string ConvertFromUtf32(int utf32);
+        public static int ConvertToUtf32(char highSurrogate, char lowSurrogate);
+        public static int ConvertToUtf32(string s, int index);
+        public bool Equals(char obj);
+        public override bool Equals(object obj);
+        public override int GetHashCode();
+        public static double GetNumericValue(char c);
+        public static double GetNumericValue(string s, int index);
+        public TypeCode GetTypeCode();
+        public static UnicodeCategory GetUnicodeCategory(char c);
+        public static UnicodeCategory GetUnicodeCategory(string s, int index);
+        public static bool IsControl(char c);
+        public static bool IsControl(string s, int index);
+        public static bool IsDigit(char c);
+        public static bool IsDigit(string s, int index);
+        public static bool IsHighSurrogate(char c);
+        public static bool IsHighSurrogate(string s, int index);
+        public static bool IsLetter(char c);
+        public static bool IsLetter(string s, int index);
+        public static bool IsLetterOrDigit(char c);
+        public static bool IsLetterOrDigit(string s, int index);
+        public static bool IsLower(char c);
+        public static bool IsLower(string s, int index);
+        public static bool IsLowSurrogate(char c);
+        public static bool IsLowSurrogate(string s, int index);
+        public static bool IsNumber(char c);
+        public static bool IsNumber(string s, int index);
+        public static bool IsPunctuation(char c);
+        public static bool IsPunctuation(string s, int index);
+        public static bool IsSeparator(char c);
+        public static bool IsSeparator(string s, int index);
+        public static bool IsSurrogate(char c);
+        public static bool IsSurrogate(string s, int index);
+        public static bool IsSurrogatePair(char highSurrogate, char lowSurrogate);
+        public static bool IsSurrogatePair(string s, int index);
+        public static bool IsSymbol(char c);
+        public static bool IsSymbol(string s, int index);
+        public static bool IsUpper(char c);
+        public static bool IsUpper(string s, int index);
+        public static bool IsWhiteSpace(char c);
+        public static bool IsWhiteSpace(string s, int index);
+        public static char Parse(string s);
+        int System.IComparable.CompareTo(object value);
+        TypeCode System.IConvertible.GetTypeCode();
+        bool System.IConvertible.ToBoolean(IFormatProvider provider);
+        byte System.IConvertible.ToByte(IFormatProvider provider);
+        char System.IConvertible.ToChar(IFormatProvider provider);
+        DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
+        Decimal System.IConvertible.ToDecimal(IFormatProvider provider);
+        double System.IConvertible.ToDouble(IFormatProvider provider);
+        short System.IConvertible.ToInt16(IFormatProvider provider);
+        int System.IConvertible.ToInt32(IFormatProvider provider);
+        long System.IConvertible.ToInt64(IFormatProvider provider);
+        sbyte System.IConvertible.ToSByte(IFormatProvider provider);
+        float System.IConvertible.ToSingle(IFormatProvider provider);
+        string System.IConvertible.ToString(IFormatProvider provider);
+        object System.IConvertible.ToType(Type type, IFormatProvider provider);
+        ushort System.IConvertible.ToUInt16(IFormatProvider provider);
+        uint System.IConvertible.ToUInt32(IFormatProvider provider);
+        ulong System.IConvertible.ToUInt64(IFormatProvider provider);
+        public static char ToLower(char c);
+        public static char ToLower(char c, CultureInfo culture);
+        public static char ToLowerInvariant(char c);
+        public override string ToString();
+        public static string ToString(char c);
+        public string ToString(IFormatProvider provider);
+        public static char ToUpper(char c);
+        public static char ToUpper(char c, CultureInfo culture);
+        public static char ToUpperInvariant(char c);
+        public static bool TryParse(string s, out char result);
+    }
+    public sealed class CLSCompliantAttribute : Attribute {
+        public CLSCompliantAttribute(bool isCompliant);
+        public bool IsCompliant { get; }
+    }
+    public delegate int Comparison<in T>(T x, T y);
+    public static class Console {
+        public static ConsoleColor BackgroundColor { get; set; }
+        public static int BufferHeight { get; set; }
+        public static int BufferWidth { get; set; }
+        public static bool CapsLock { get; }
+        public static int CursorLeft { get; set; }
+        public static int CursorSize { get; set; }
+        public static int CursorTop { get; set; }
+        public static bool CursorVisible { get; set; }
+        public static TextWriter Error { get; }
+        public static ConsoleColor ForegroundColor { get; set; }
+        public static TextReader In { get; }
+        public static Encoding InputEncoding { get; set; }
+        public static bool IsErrorRedirected { get; }
+        public static bool IsInputRedirected { get; }
+        public static bool IsOutputRedirected { get; }
+        public static bool KeyAvailable { get; }
+        public static int LargestWindowHeight { get; }
+        public static int LargestWindowWidth { get; }
+        public static bool NumberLock { get; }
+        public static TextWriter Out { get; }
+        public static Encoding OutputEncoding { get; set; }
+        public static string Title { get; set; }
+        public static bool TreatControlCAsInput { get; set; }
+        public static int WindowHeight { get; set; }
+        public static int WindowLeft { get; set; }
+        public static int WindowTop { get; set; }
+        public static int WindowWidth { get; set; }
+        public static event ConsoleCancelEventHandler CancelKeyPress;
+        public static void Beep();
+        public static void Beep(int frequency, int duration);
+        public static void Clear();
+        public static void MoveBufferArea(int sourceLeft, int sourceTop, int sourceWidth, int sourceHeight, int targetLeft, int targetTop);
+        public static void MoveBufferArea(int sourceLeft, int sourceTop, int sourceWidth, int sourceHeight, int targetLeft, int targetTop, char sourceChar, ConsoleColor sourceForeColor, ConsoleColor sourceBackColor);
+        public static Stream OpenStandardError();
+        public static Stream OpenStandardInput();
+        public static Stream OpenStandardOutput();
+        public static int Read();
+        public static ConsoleKeyInfo ReadKey();
+        public static ConsoleKeyInfo ReadKey(bool intercept);
+        public static string ReadLine();
+        public static void ResetColor();
+        public static void SetBufferSize(int width, int height);
+        public static void SetCursorPosition(int left, int top);
+        public static void SetError(TextWriter newError);
+        public static void SetIn(TextReader newIn);
+        public static void SetOut(TextWriter newOut);
+        public static void SetWindowPosition(int left, int top);
+        public static void SetWindowSize(int width, int height);
+        public static void Write(bool value);
+        public static void Write(char value);
+        public static void Write(char[] buffer);
+        public static void Write(char[] buffer, int index, int count);
+        public static void Write(Decimal value);
+        public static void Write(double value);
+        public static void Write(int value);
+        public static void Write(long value);
+        public static void Write(object value);
+        public static void Write(float value);
+        public static void Write(string s);
+        public static void Write(string format, object arg0);
+        public static void Write(string format, object arg0, object arg1);
+        public static void Write(string format, object arg0, object arg1, object arg2);
+        public static void Write(string format, params object[] arg);
+        public static void Write(uint value);
+        public static void Write(ulong value);
+        public static void WriteLine();
+        public static void WriteLine(bool value);
+        public static void WriteLine(char value);
+        public static void WriteLine(char[] buffer);
+        public static void WriteLine(char[] buffer, int index, int count);
+        public static void WriteLine(Decimal value);
+        public static void WriteLine(double value);
+        public static void WriteLine(int value);
+        public static void WriteLine(long value);
+        public static void WriteLine(object value);
+        public static void WriteLine(float value);
+        public static void WriteLine(string s);
+        public static void WriteLine(string format, object arg0);
+        public static void WriteLine(string format, object arg0, object arg1);
+        public static void WriteLine(string format, object arg0, object arg1, object arg2);
+        public static void WriteLine(string format, params object[] arg);
+        public static void WriteLine(uint value);
+        public static void WriteLine(ulong value);
+    }
+    public sealed class ConsoleCancelEventArgs : EventArgs {
+        public bool Cancel { get; set; }
+        public ConsoleSpecialKey SpecialKey { get; }
+    }
+    public delegate void ConsoleCancelEventHandler(object sender, ConsoleCancelEventArgs e);
+    public enum ConsoleColor {
+        Black = 0,
+        Blue = 9,
+        Cyan = 11,
+        DarkBlue = 1,
+        DarkCyan = 3,
+        DarkGray = 8,
+        DarkGreen = 2,
+        DarkMagenta = 5,
+        DarkRed = 4,
+        DarkYellow = 6,
+        Gray = 7,
+        Green = 10,
+        Magenta = 13,
+        Red = 12,
+        White = 15,
+        Yellow = 14,
+    }
+    public enum ConsoleKey {
+        A = 65,
+        Add = 107,
+        B = 66,
+        Backspace = 8,
+        C = 67,
+        Clear = 12,
+        D = 68,
+        D0 = 48,
+        D1 = 49,
+        D2 = 50,
+        D3 = 51,
+        D4 = 52,
+        D5 = 53,
+        D6 = 54,
+        D7 = 55,
+        D8 = 56,
+        D9 = 57,
+        Decimal = 110,
+        Delete = 46,
+        Divide = 111,
+        DownArrow = 40,
+        E = 69,
+        End = 35,
+        Enter = 13,
+        Escape = 27,
+        Execute = 43,
+        F = 70,
+        F1 = 112,
+        F10 = 121,
+        F11 = 122,
+        F12 = 123,
+        F13 = 124,
+        F14 = 125,
+        F15 = 126,
+        F16 = 127,
+        F17 = 128,
+        F18 = 129,
+        F19 = 130,
+        F2 = 113,
+        F20 = 131,
+        F21 = 132,
+        F22 = 133,
+        F23 = 134,
+        F24 = 135,
+        F3 = 114,
+        F4 = 115,
+        F5 = 116,
+        F6 = 117,
+        F7 = 118,
+        F8 = 119,
+        F9 = 120,
+        G = 71,
+        H = 72,
+        Help = 47,
+        Home = 36,
+        I = 73,
+        Insert = 45,
+        J = 74,
+        K = 75,
+        L = 76,
+        LeftArrow = 37,
+        M = 77,
+        Multiply = 106,
+        N = 78,
+        NumPad0 = 96,
+        NumPad1 = 97,
+        NumPad2 = 98,
+        NumPad3 = 99,
+        NumPad4 = 100,
+        NumPad5 = 101,
+        NumPad6 = 102,
+        NumPad7 = 103,
+        NumPad8 = 104,
+        NumPad9 = 105,
+        O = 79,
+        Oem1 = 186,
+        Oem2 = 191,
+        Oem3 = 192,
+        Oem4 = 219,
+        Oem5 = 220,
+        Oem6 = 221,
+        Oem7 = 222,
+        Oem8 = 223,
+        OemClear = 254,
+        OemComma = 188,
+        OemMinus = 189,
+        OemPeriod = 190,
+        OemPlus = 187,
+        P = 80,
+        PageDown = 34,
+        PageUp = 33,
+        Pause = 19,
+        Print = 42,
+        PrintScreen = 44,
+        Q = 81,
+        R = 82,
+        RightArrow = 39,
+        S = 83,
+        Select = 41,
+        Separator = 108,
+        Sleep = 95,
+        Spacebar = 32,
+        Subtract = 109,
+        T = 84,
+        Tab = 9,
+        U = 85,
+        UpArrow = 38,
+        V = 86,
+        W = 87,
+        X = 88,
+        Y = 89,
+        Z = 90,
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Size=1)]
+    public struct ConsoleKeyInfo {
+        public ConsoleKeyInfo(char keyChar, ConsoleKey key, bool shift, bool alt, bool control);
+        public ConsoleKey Key { get; }
+        public char KeyChar { get; }
+        public ConsoleModifiers Modifiers { get; }
+        public bool Equals(ConsoleKeyInfo obj);
+        public override bool Equals(object value);
+        public override int GetHashCode();
+        public static bool operator ==(ConsoleKeyInfo a, ConsoleKeyInfo b);
+        public static bool operator !=(ConsoleKeyInfo a, ConsoleKeyInfo b);
+    }
+    public enum ConsoleModifiers {
+        Alt = 1,
+        Control = 4,
+        Shift = 2,
+    }
+    public enum ConsoleSpecialKey {
+        ControlBreak = 1,
+        ControlC = 0,
+    }
+    public class ContextMarshalException : SystemException {
+        public ContextMarshalException();
+        public ContextMarshalException(string message);
+        public ContextMarshalException(string message, Exception inner);
+    }
+    public class ContextStaticAttribute : Attribute {
+        public ContextStaticAttribute();
+    }
+    public static class Convert {
+        public static readonly object DBNull;
+        public static object ChangeType(object value, Type conversionType);
+        public static object ChangeType(object value, Type conversionType, IFormatProvider provider);
+        public static object ChangeType(object value, TypeCode typeCode, IFormatProvider provider);
+        public static byte[] FromBase64CharArray(char[] inArray, int offset, int length);
+        public static byte[] FromBase64String(string s);
+        public static TypeCode GetTypeCode(object value);
+        public static bool IsDBNull(object value);
+        public static int ToBase64CharArray(byte[] inArray, int offsetIn, int length, char[] outArray, int offsetOut);
+        public static string ToBase64String(byte[] inArray);
+        public static string ToBase64String(byte[] inArray, int offset, int length);
+        public static bool ToBoolean(bool value);
+        public static bool ToBoolean(byte value);
+        public static bool ToBoolean(char value);
+        public static bool ToBoolean(Decimal value);
+        public static bool ToBoolean(double value);
+        public static bool ToBoolean(short value);
+        public static bool ToBoolean(int value);
+        public static bool ToBoolean(long value);
+        public static bool ToBoolean(object value);
+        public static bool ToBoolean(object value, IFormatProvider provider);
+        public static bool ToBoolean(sbyte value);
+        public static bool ToBoolean(float value);
+        public static bool ToBoolean(string value);
+        public static bool ToBoolean(string value, IFormatProvider provider);
+        public static bool ToBoolean(ushort value);
+        public static bool ToBoolean(uint value);
+        public static bool ToBoolean(ulong value);
+        public static byte ToByte(bool value);
+        public static byte ToByte(byte value);
+        public static byte ToByte(char value);
+        public static byte ToByte(Decimal value);
+        public static byte ToByte(double value);
+        public static byte ToByte(short value);
+        public static byte ToByte(int value);
+        public static byte ToByte(long value);
+        public static byte ToByte(object value);
+        public static byte ToByte(object value, IFormatProvider provider);
+        public static byte ToByte(sbyte value);
+        public static byte ToByte(float value);
+        public static byte ToByte(string value);
+        public static byte ToByte(string value, IFormatProvider provider);
+        public static byte ToByte(string value, int fromBase);
+        public static byte ToByte(ushort value);
+        public static byte ToByte(uint value);
+        public static byte ToByte(ulong value);
+        public static char ToChar(byte value);
+        public static char ToChar(char value);
+        public static char ToChar(decimal value);
+        public static char ToChar(double value);
+        public static char ToChar(short value);
+        public static char ToChar(int value);
+        public static char ToChar(long value);
+        public static char ToChar(object value);
+        public static char ToChar(object value, IFormatProvider provider);
+        public static char ToChar(sbyte value);
+        public static char ToChar(float value);
+        public static char ToChar(string value);
+        public static char ToChar(string value, IFormatProvider provider);
+        public static char ToChar(ushort value);
+        public static char ToChar(uint value);
+        public static char ToChar(ulong value);
+        public static DateTime ToDateTime(object value);
+        public static DateTime ToDateTime(object value, IFormatProvider provider);
+        public static DateTime ToDateTime(string value);
+        public static DateTime ToDateTime(string value, IFormatProvider provider);
+        public static Decimal ToDecimal(bool value);
+        public static Decimal ToDecimal(byte value);
+        public static decimal ToDecimal(char value);
+        public static decimal ToDecimal(DateTime value);
+        public static Decimal ToDecimal(Decimal value);
+        public static Decimal ToDecimal(double value);
+        public static Decimal ToDecimal(short value);
+        public static Decimal ToDecimal(int value);
+        public static Decimal ToDecimal(long value);
+        public static Decimal ToDecimal(object value);
+        public static Decimal ToDecimal(object value, IFormatProvider provider);
+        public static Decimal ToDecimal(sbyte value);
+        public static Decimal ToDecimal(float value);
+        public static Decimal ToDecimal(string value);
+        public static Decimal ToDecimal(string value, IFormatProvider provider);
+        public static Decimal ToDecimal(ushort value);
+        public static Decimal ToDecimal(uint value);
+        public static Decimal ToDecimal(ulong value);
+        public static double ToDouble(bool value);
+        public static double ToDouble(byte value);
+        public static double ToDouble(char value);
+        public static double ToDouble(Decimal value);
+        public static double ToDouble(double value);
+        public static double ToDouble(short value);
+        public static double ToDouble(int value);
+        public static double ToDouble(long value);
+        public static double ToDouble(object value);
+        public static double ToDouble(object value, IFormatProvider provider);
+        public static double ToDouble(sbyte value);
+        public static double ToDouble(float value);
+        public static double ToDouble(string value);
+        public static double ToDouble(string value, IFormatProvider provider);
+        public static double ToDouble(ushort value);
+        public static double ToDouble(uint value);
+        public static double ToDouble(ulong value);
+        public static short ToInt16(bool value);
+        public static short ToInt16(byte value);
+        public static short ToInt16(char value);
+        public static short ToInt16(Decimal value);
+        public static short ToInt16(double value);
+        public static short ToInt16(short value);
+        public static short ToInt16(int value);
+        public static short ToInt16(long value);
+        public static short ToInt16(object value);
+        public static short ToInt16(object value, IFormatProvider provider);
+        public static short ToInt16(sbyte value);
+        public static short ToInt16(float value);
+        public static short ToInt16(string value);
+        public static short ToInt16(string value, IFormatProvider provider);
+        public static short ToInt16(string value, int fromBase);
+        public static short ToInt16(ushort value);
+        public static short ToInt16(uint value);
+        public static short ToInt16(ulong value);
+        public static int ToInt32(bool value);
+        public static int ToInt32(byte value);
+        public static int ToInt32(char value);
+        public static int ToInt32(Decimal value);
+        public static int ToInt32(double value);
+        public static int ToInt32(short value);
+        public static int ToInt32(int value);
+        public static int ToInt32(long value);
+        public static int ToInt32(object value);
+        public static int ToInt32(object value, IFormatProvider provider);
+        public static int ToInt32(sbyte value);
+        public static int ToInt32(float value);
+        public static int ToInt32(string value);
+        public static int ToInt32(string value, IFormatProvider provider);
+        public static int ToInt32(string value, int fromBase);
+        public static int ToInt32(ushort value);
+        public static int ToInt32(uint value);
+        public static int ToInt32(ulong value);
+        public static long ToInt64(bool value);
+        public static long ToInt64(byte value);
+        public static long ToInt64(char value);
+        public static long ToInt64(Decimal value);
+        public static long ToInt64(double value);
+        public static long ToInt64(short value);
+        public static long ToInt64(int value);
+        public static long ToInt64(long value);
+        public static long ToInt64(object value);
+        public static long ToInt64(object value, IFormatProvider provider);
+        public static long ToInt64(sbyte value);
+        public static long ToInt64(float value);
+        public static long ToInt64(string value);
+        public static long ToInt64(string value, IFormatProvider provider);
+        public static long ToInt64(string value, int fromBase);
+        public static long ToInt64(ushort value);
+        public static long ToInt64(uint value);
+        public static long ToInt64(ulong value);
+        public static sbyte ToSByte(bool value);
+        public static sbyte ToSByte(byte value);
+        public static sbyte ToSByte(char value);
+        public static sbyte ToSByte(Decimal value);
+        public static sbyte ToSByte(double value);
+        public static sbyte ToSByte(short value);
+        public static sbyte ToSByte(int value);
+        public static sbyte ToSByte(long value);
+        public static sbyte ToSByte(object value);
+        public static sbyte ToSByte(object value, IFormatProvider provider);
+        public static sbyte ToSByte(sbyte value);
+        public static sbyte ToSByte(float value);
+        public static sbyte ToSByte(string value);
+        public static sbyte ToSByte(string value, IFormatProvider provider);
+        public static sbyte ToSByte(string value, int fromBase);
+        public static sbyte ToSByte(ushort value);
+        public static sbyte ToSByte(uint value);
+        public static sbyte ToSByte(ulong value);
+        public static float ToSingle(bool value);
+        public static float ToSingle(byte value);
+        public static float ToSingle(char value);
+        public static float ToSingle(Decimal value);
+        public static float ToSingle(double value);
+        public static float ToSingle(short value);
+        public static float ToSingle(int value);
+        public static float ToSingle(long value);
+        public static float ToSingle(object value);
+        public static float ToSingle(object value, IFormatProvider provider);
+        public static float ToSingle(sbyte value);
+        public static float ToSingle(float value);
+        public static float ToSingle(string value);
+        public static float ToSingle(string value, IFormatProvider provider);
+        public static float ToSingle(ushort value);
+        public static float ToSingle(uint value);
+        public static float ToSingle(ulong value);
+        public static string ToString(bool value);
+        public static string ToString(bool value, IFormatProvider provider);
+        public static string ToString(byte value);
+        public static string ToString(byte value, IFormatProvider provider);
+        public static string ToString(byte value, int toBase);
+        public static string ToString(char value);
+        public static string ToString(char value, IFormatProvider provider);
+        public static string ToString(DateTime value);
+        public static string ToString(DateTime value, IFormatProvider provider);
+        public static string ToString(Decimal value);
+        public static string ToString(Decimal value, IFormatProvider provider);
+        public static string ToString(double value);
+        public static string ToString(double value, IFormatProvider provider);
+        public static string ToString(short value);
+        public static string ToString(short value, IFormatProvider provider);
+        public static string ToString(short value, int toBase);
+        public static string ToString(int value);
+        public static string ToString(int value, IFormatProvider provider);
+        public static string ToString(int value, int toBase);
+        public static string ToString(long value);
+        public static string ToString(long value, IFormatProvider provider);
+        public static string ToString(long value, int toBase);
+        public static string ToString(object value);
+        public static string ToString(object value, IFormatProvider provider);
+        public static string ToString(sbyte value);
+        public static string ToString(sbyte value, IFormatProvider provider);
+        public static string ToString(float value);
+        public static string ToString(float value, IFormatProvider provider);
+        public static string ToString(ushort value);
+        public static string ToString(ushort value, IFormatProvider provider);
+        public static string ToString(uint value);
+        public static string ToString(uint value, IFormatProvider provider);
+        public static string ToString(ulong value);
+        public static string ToString(ulong value, IFormatProvider provider);
+        public static ushort ToUInt16(bool value);
+        public static ushort ToUInt16(byte value);
+        public static ushort ToUInt16(char value);
+        public static ushort ToUInt16(Decimal value);
+        public static ushort ToUInt16(double value);
+        public static ushort ToUInt16(short value);
+        public static ushort ToUInt16(int value);
+        public static ushort ToUInt16(long value);
+        public static ushort ToUInt16(object value);
+        public static ushort ToUInt16(object value, IFormatProvider provider);
+        public static ushort ToUInt16(sbyte value);
+        public static ushort ToUInt16(float value);
+        public static ushort ToUInt16(string value);
+        public static ushort ToUInt16(string value, IFormatProvider provider);
+        public static ushort ToUInt16(string value, int fromBase);
+        public static ushort ToUInt16(ushort value);
+        public static ushort ToUInt16(uint value);
+        public static ushort ToUInt16(ulong value);
+        public static uint ToUInt32(bool value);
+        public static uint ToUInt32(byte value);
+        public static uint ToUInt32(char value);
+        public static uint ToUInt32(Decimal value);
+        public static uint ToUInt32(double value);
+        public static uint ToUInt32(short value);
+        public static uint ToUInt32(int value);
+        public static uint ToUInt32(long value);
+        public static uint ToUInt32(object value);
+        public static uint ToUInt32(object value, IFormatProvider provider);
+        public static uint ToUInt32(sbyte value);
+        public static uint ToUInt32(float value);
+        public static uint ToUInt32(string value);
+        public static uint ToUInt32(string value, IFormatProvider provider);
+        public static uint ToUInt32(string value, int fromBase);
+        public static uint ToUInt32(ushort value);
+        public static uint ToUInt32(uint value);
+        public static uint ToUInt32(ulong value);
+        public static ulong ToUInt64(bool value);
+        public static ulong ToUInt64(byte value);
+        public static ulong ToUInt64(char value);
+        public static ulong ToUInt64(Decimal value);
+        public static ulong ToUInt64(double value);
+        public static ulong ToUInt64(short value);
+        public static ulong ToUInt64(int value);
+        public static ulong ToUInt64(long value);
+        public static ulong ToUInt64(object value);
+        public static ulong ToUInt64(object value, IFormatProvider provider);
+        public static ulong ToUInt64(sbyte value);
+        public static ulong ToUInt64(float value);
+        public static ulong ToUInt64(string value);
+        public static ulong ToUInt64(string value, IFormatProvider provider);
+        public static ulong ToUInt64(string value, int fromBase);
+        public static ulong ToUInt64(ushort value);
+        public static ulong ToUInt64(uint value);
+        public static ulong ToUInt64(ulong value);
+    }
+    public delegate TOutput Converter<in TInput, out TOutput>(TInput input);
+    public sealed class DataMisalignedException : Exception {
+        public DataMisalignedException();
+        public DataMisalignedException(string message);
+        public DataMisalignedException(string message, Exception innerException);
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Size=1)]
+    public struct DateTime : IComparable, IComparable<DateTime>, IConvertible, IEquatable<DateTime>, IFormattable {
+        public static readonly DateTime MaxValue;
+        public static readonly DateTime MinValue;
+        public DateTime(int year, int month, int day);
+        public DateTime(int year, int month, int day, Calendar calendar);
+        public DateTime(int year, int month, int day, int hour, int minute, int second);
+        public DateTime(int year, int month, int day, int hour, int minute, int second, DateTimeKind kind);
+        public DateTime(int year, int month, int day, int hour, int minute, int second, Calendar calendar);
+        public DateTime(int year, int month, int day, int hour, int minute, int second, int millisecond);
+        public DateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, DateTimeKind kind);
+        public DateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, Calendar calendar);
+        public DateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, Calendar calendar, DateTimeKind kind);
+        public DateTime(long ticks);
+        public DateTime(long ticks, DateTimeKind kind);
+        public DateTime Date { get; }
+        public int Day { get; }
+        public DayOfWeek DayOfWeek { get; }
+        public int DayOfYear { get; }
+        public int Hour { get; }
+        public DateTimeKind Kind { get; }
+        public int Millisecond { get; }
+        public int Minute { get; }
+        public int Month { get; }
+        public static DateTime Now { get; }
+        public int Second { get; }
+        public long Ticks { get; }
+        public TimeSpan TimeOfDay { get; }
+        public static DateTime Today { get; }
+        public static DateTime UtcNow { get; }
+        public int Year { get; }
+        public DateTime Add(TimeSpan value);
+        public DateTime AddDays(double value);
+        public DateTime AddHours(double value);
+        public DateTime AddMilliseconds(double value);
+        public DateTime AddMinutes(double value);
+        public DateTime AddMonths(int months);
+        public DateTime AddSeconds(double value);
+        public DateTime AddTicks(long value);
+        public DateTime AddYears(int value);
+        public static int Compare(DateTime t1, DateTime t2);
+        public int CompareTo(DateTime value);
+        public int CompareTo(object value);
+        public static int DaysInMonth(int year, int month);
+        public bool Equals(DateTime value);
+        public static bool Equals(DateTime t1, DateTime t2);
+        public override bool Equals(object value);
+        public static DateTime FromBinary(long dateData);
+        public static DateTime FromFileTime(long fileTime);
+        public static DateTime FromFileTimeUtc(long fileTime);
+        public static DateTime FromOADate(double d);
+        public string[] GetDateTimeFormats();
+        public string[] GetDateTimeFormats(char format);
+        public string[] GetDateTimeFormats(char format, IFormatProvider provider);
+        public string[] GetDateTimeFormats(IFormatProvider provider);
+        public override int GetHashCode();
+        public TypeCode GetTypeCode();
+        public bool IsDaylightSavingTime();
+        public static bool IsLeapYear(int year);
+        public static DateTime operator +(DateTime d, TimeSpan t);
+        public static bool operator ==(DateTime d1, DateTime d2);
+        public static bool operator >(DateTime t1, DateTime t2);
+        public static bool operator >=(DateTime t1, DateTime t2);
+        public static bool operator !=(DateTime d1, DateTime d2);
+        public static bool operator <(DateTime t1, DateTime t2);
+        public static bool operator <=(DateTime t1, DateTime t2);
+        public static TimeSpan operator -(DateTime d1, DateTime d2);
+        public static DateTime operator -(DateTime d, TimeSpan t);
+        public static DateTime Parse(string s);
+        public static DateTime Parse(string s, IFormatProvider provider);
+        public static DateTime Parse(string s, IFormatProvider provider, DateTimeStyles styles);
+        public static DateTime ParseExact(string s, string format, IFormatProvider provider);
+        public static DateTime ParseExact(string s, string format, IFormatProvider provider, DateTimeStyles style);
+        public static DateTime ParseExact(string s, string[] formats, IFormatProvider provider, DateTimeStyles style);
+        public static DateTime SpecifyKind(DateTime value, DateTimeKind kind);
+        public TimeSpan Subtract(DateTime value);
+        public DateTime Subtract(TimeSpan value);
+        int System.IComparable.CompareTo(object value);
+        TypeCode System.IConvertible.GetTypeCode();
+        bool System.IConvertible.ToBoolean(IFormatProvider provider);
+        byte System.IConvertible.ToByte(IFormatProvider provider);
+        char System.IConvertible.ToChar(IFormatProvider provider);
+        DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
+        Decimal System.IConvertible.ToDecimal(IFormatProvider provider);
+        double System.IConvertible.ToDouble(IFormatProvider provider);
+        short System.IConvertible.ToInt16(IFormatProvider provider);
+        int System.IConvertible.ToInt32(IFormatProvider provider);
+        long System.IConvertible.ToInt64(IFormatProvider provider);
+        sbyte System.IConvertible.ToSByte(IFormatProvider provider);
+        float System.IConvertible.ToSingle(IFormatProvider provider);
+        object System.IConvertible.ToType(Type type, IFormatProvider provider);
+        ushort System.IConvertible.ToUInt16(IFormatProvider provider);
+        uint System.IConvertible.ToUInt32(IFormatProvider provider);
+        ulong System.IConvertible.ToUInt64(IFormatProvider provider);
+        public long ToBinary();
+        public long ToFileTime();
+        public long ToFileTimeUtc();
+        public DateTime ToLocalTime();
+        public string ToLongDateString();
+        public string ToLongTimeString();
+        public double ToOADate();
+        public string ToShortDateString();
+        public string ToShortTimeString();
+        public override string ToString();
+        public string ToString(IFormatProvider provider);
+        public string ToString(string format);
+        public string ToString(string format, IFormatProvider provider);
+        public DateTime ToUniversalTime();
+        public static bool TryParse(string s, out DateTime result);
+        public static bool TryParse(string s, IFormatProvider provider, DateTimeStyles styles, out DateTime result);
+        public static bool TryParseExact(string s, string format, IFormatProvider provider, DateTimeStyles style, out DateTime result);
+        public static bool TryParseExact(string s, string[] formats, IFormatProvider provider, DateTimeStyles style, out DateTime result);
+    }
+    public enum DateTimeKind {
+        Local = 2,
+        Unspecified = 0,
+        Utc = 1,
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Size=1)]
+    public struct DateTimeOffset : IComparable, IComparable<DateTimeOffset>, IEquatable<DateTimeOffset>, IFormattable {
+        public static readonly DateTimeOffset MaxValue;
+        public static readonly DateTimeOffset MinValue;
+        public DateTimeOffset(DateTime dateTime);
+        public DateTimeOffset(DateTime dateTime, TimeSpan offset);
+        public DateTimeOffset(int year, int month, int day, int hour, int minute, int second, int millisecond, Calendar calendar, TimeSpan offset);
+        public DateTimeOffset(int year, int month, int day, int hour, int minute, int second, int millisecond, TimeSpan offset);
+        public DateTimeOffset(int year, int month, int day, int hour, int minute, int second, TimeSpan offset);
+        public DateTimeOffset(long ticks, TimeSpan offset);
+        public DateTime Date { get; }
+        public DateTime DateTime { get; }
+        public int Day { get; }
+        public DayOfWeek DayOfWeek { get; }
+        public int DayOfYear { get; }
+        public int Hour { get; }
+        public DateTime LocalDateTime { get; }
+        public int Millisecond { get; }
+        public int Minute { get; }
+        public int Month { get; }
+        public static DateTimeOffset Now { get; }
+        public TimeSpan Offset { get; }
+        public int Second { get; }
+        public long Ticks { get; }
+        public TimeSpan TimeOfDay { get; }
+        public DateTime UtcDateTime { get; }
+        public static DateTimeOffset UtcNow { get; }
+        public long UtcTicks { get; }
+        public int Year { get; }
+        public DateTimeOffset Add(TimeSpan timeSpan);
+        public DateTimeOffset AddDays(double days);
+        public DateTimeOffset AddHours(double hours);
+        public DateTimeOffset AddMilliseconds(double milliseconds);
+        public DateTimeOffset AddMinutes(double minutes);
+        public DateTimeOffset AddMonths(int months);
+        public DateTimeOffset AddSeconds(double seconds);
+        public DateTimeOffset AddTicks(long ticks);
+        public DateTimeOffset AddYears(int years);
+        public static int Compare(DateTimeOffset first, DateTimeOffset second);
+        public int CompareTo(DateTimeOffset other);
+        public bool Equals(DateTimeOffset other);
+        public static bool Equals(DateTimeOffset first, DateTimeOffset second);
+        public override bool Equals(object obj);
+        public bool EqualsExact(DateTimeOffset other);
+        public static DateTimeOffset FromFileTime(long fileTime);
+        public static DateTimeOffset FromUnixTimeMilliseconds(long milliseconds);
+        public static DateTimeOffset FromUnixTimeSeconds(long seconds);
+        public override int GetHashCode();
+        public static DateTimeOffset operator +(DateTimeOffset dateTimeOffset, TimeSpan timeSpan);
+        public static bool operator ==(DateTimeOffset left, DateTimeOffset right);
+        public static bool operator >(DateTimeOffset left, DateTimeOffset right);
+        public static bool operator >=(DateTimeOffset left, DateTimeOffset right);
+        public static implicit operator DateTimeOffset (DateTime dateTime);
+        public static bool operator !=(DateTimeOffset left, DateTimeOffset right);
+        public static bool operator <(DateTimeOffset left, DateTimeOffset right);
+        public static bool operator <=(DateTimeOffset left, DateTimeOffset right);
+        public static TimeSpan operator -(DateTimeOffset left, DateTimeOffset right);
+        public static DateTimeOffset operator -(DateTimeOffset dateTimeOffset, TimeSpan timeSpan);
+        public static DateTimeOffset Parse(string input);
+        public static DateTimeOffset Parse(string input, IFormatProvider formatProvider);
+        public static DateTimeOffset Parse(string input, IFormatProvider formatProvider, DateTimeStyles styles);
+        public static DateTimeOffset ParseExact(string input, string format, IFormatProvider formatProvider);
+        public static DateTimeOffset ParseExact(string input, string format, IFormatProvider formatProvider, DateTimeStyles styles);
+        public static DateTimeOffset ParseExact(string input, string[] formats, IFormatProvider formatProvider, DateTimeStyles styles);
+        public TimeSpan Subtract(DateTimeOffset value);
+        public DateTimeOffset Subtract(TimeSpan value);
+        int System.IComparable.CompareTo(object obj);
+        public long ToFileTime();
+        public DateTimeOffset ToLocalTime();
+        public DateTimeOffset ToOffset(TimeSpan offset);
+        public override string ToString();
+        public string ToString(IFormatProvider formatProvider);
+        public string ToString(string format);
+        public string ToString(string format, IFormatProvider formatProvider);
+        public DateTimeOffset ToUniversalTime();
+        public long ToUnixTimeMilliseconds();
+        public long ToUnixTimeSeconds();
+        public static bool TryParse(string input, out DateTimeOffset result);
+        public static bool TryParse(string input, IFormatProvider formatProvider, DateTimeStyles styles, out DateTimeOffset result);
+        public static bool TryParseExact(string input, string format, IFormatProvider formatProvider, DateTimeStyles styles, out DateTimeOffset result);
+        public static bool TryParseExact(string input, string[] formats, IFormatProvider formatProvider, DateTimeStyles styles, out DateTimeOffset result);
+    }
+    public enum DayOfWeek {
+        Friday = 5,
+        Monday = 1,
+        Saturday = 6,
+        Sunday = 0,
+        Thursday = 4,
+        Tuesday = 2,
+        Wednesday = 3,
+    }
+    public sealed class DBNull : IConvertible {
+        public static readonly DBNull Value;
+        public TypeCode GetTypeCode();
+        bool System.IConvertible.ToBoolean(IFormatProvider provider);
+        byte System.IConvertible.ToByte(IFormatProvider provider);
+        char System.IConvertible.ToChar(IFormatProvider provider);
+        DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
+        decimal System.IConvertible.ToDecimal(IFormatProvider provider);
+        double System.IConvertible.ToDouble(IFormatProvider provider);
+        short System.IConvertible.ToInt16(IFormatProvider provider);
+        int System.IConvertible.ToInt32(IFormatProvider provider);
+        long System.IConvertible.ToInt64(IFormatProvider provider);
+        sbyte System.IConvertible.ToSByte(IFormatProvider provider);
+        float System.IConvertible.ToSingle(IFormatProvider provider);
+        object System.IConvertible.ToType(Type type, IFormatProvider provider);
+        ushort System.IConvertible.ToUInt16(IFormatProvider provider);
+        uint System.IConvertible.ToUInt32(IFormatProvider provider);
+        ulong System.IConvertible.ToUInt64(IFormatProvider provider);
+        public override string ToString();
+        public string ToString(IFormatProvider provider);
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct Decimal : IComparable, IComparable<Decimal>, IConvertible, IEquatable<Decimal>, IFormattable {
+        public static readonly Decimal MaxValue;
+        public static readonly Decimal MinusOne;
+        public static readonly Decimal MinValue;
+        public static readonly Decimal One;
+        public static readonly Decimal Zero;
+        public Decimal(double value);
+        public Decimal(int value);
+        public Decimal(int lo, int mid, int hi, bool isNegative, byte scale);
+        public Decimal(int[] bits);
+        public Decimal(long value);
+        public Decimal(float value);
+        public Decimal(uint value);
+        public Decimal(ulong value);
+        public static Decimal Add(Decimal d1, Decimal d2);
+        public static Decimal Ceiling(Decimal d);
+        public static int Compare(Decimal d1, Decimal d2);
+        public int CompareTo(Decimal value);
+        public int CompareTo(object value);
+        public static Decimal Divide(Decimal d1, Decimal d2);
+        public bool Equals(Decimal value);
+        public static bool Equals(Decimal d1, Decimal d2);
+        public override bool Equals(object value);
+        public static Decimal Floor(Decimal d);
+        public static int[] GetBits(Decimal d);
+        public override int GetHashCode();
+        public TypeCode GetTypeCode();
+        public static Decimal Multiply(Decimal d1, Decimal d2);
+        public static Decimal Negate(Decimal d);
+        public static Decimal operator +(Decimal d1, Decimal d2);
+        public static Decimal operator --(Decimal d);
+        public static Decimal operator /(Decimal d1, Decimal d2);
+        public static bool operator ==(Decimal d1, Decimal d2);
+        public static explicit operator byte (Decimal value);
+        public static explicit operator sbyte (Decimal value);
+        public static explicit operator char (Decimal value);
+        public static explicit operator short (Decimal value);
+        public static explicit operator ushort (Decimal value);
+        public static explicit operator int (Decimal value);
+        public static explicit operator uint (Decimal value);
+        public static explicit operator long (Decimal value);
+        public static explicit operator ulong (Decimal value);
+        public static explicit operator float (Decimal value);
+        public static explicit operator double (Decimal value);
+        public static explicit operator Decimal (double value);
+        public static explicit operator Decimal (float value);
+        public static bool operator >(Decimal d1, Decimal d2);
+        public static bool operator >=(Decimal d1, Decimal d2);
+        public static implicit operator Decimal (byte value);
+        public static implicit operator Decimal (char value);
+        public static implicit operator Decimal (short value);
+        public static implicit operator Decimal (int value);
+        public static implicit operator Decimal (long value);
+        public static implicit operator Decimal (sbyte value);
+        public static implicit operator Decimal (ushort value);
+        public static implicit operator Decimal (uint value);
+        public static implicit operator Decimal (ulong value);
+        public static Decimal operator ++(Decimal d);
+        public static bool operator !=(Decimal d1, Decimal d2);
+        public static bool operator <(Decimal d1, Decimal d2);
+        public static bool operator <=(Decimal d1, Decimal d2);
+        public static Decimal operator %(Decimal d1, Decimal d2);
+        public static Decimal operator *(Decimal d1, Decimal d2);
+        public static Decimal operator -(Decimal d1, Decimal d2);
+        public static Decimal operator -(Decimal d);
+        public static Decimal operator +(Decimal d);
+        public static Decimal Parse(string s);
+        public static Decimal Parse(string s, NumberStyles style);
+        public static Decimal Parse(string s, NumberStyles style, IFormatProvider provider);
+        public static Decimal Parse(string s, IFormatProvider provider);
+        public static Decimal Remainder(Decimal d1, Decimal d2);
+        public static decimal Round(decimal d, int decimals);
+        public static Decimal Subtract(Decimal d1, Decimal d2);
+        int System.IComparable.CompareTo(object value);
+        TypeCode System.IConvertible.GetTypeCode();
+        bool System.IConvertible.ToBoolean(IFormatProvider provider);
+        byte System.IConvertible.ToByte(IFormatProvider provider);
+        char System.IConvertible.ToChar(IFormatProvider provider);
+        DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
+        Decimal System.IConvertible.ToDecimal(IFormatProvider provider);
+        double System.IConvertible.ToDouble(IFormatProvider provider);
+        short System.IConvertible.ToInt16(IFormatProvider provider);
+        int System.IConvertible.ToInt32(IFormatProvider provider);
+        long System.IConvertible.ToInt64(IFormatProvider provider);
+        sbyte System.IConvertible.ToSByte(IFormatProvider provider);
+        float System.IConvertible.ToSingle(IFormatProvider provider);
+        object System.IConvertible.ToType(Type type, IFormatProvider provider);
+        ushort System.IConvertible.ToUInt16(IFormatProvider provider);
+        uint System.IConvertible.ToUInt32(IFormatProvider provider);
+        ulong System.IConvertible.ToUInt64(IFormatProvider provider);
+        public static byte ToByte(Decimal value);
+        public static double ToDouble(Decimal d);
+        public static short ToInt16(Decimal value);
+        public static int ToInt32(Decimal d);
+        public static long ToInt64(Decimal d);
+        public static sbyte ToSByte(Decimal value);
+        public static float ToSingle(Decimal d);
+        public override string ToString();
+        public string ToString(IFormatProvider provider);
+        public string ToString(string format);
+        public string ToString(string format, IFormatProvider provider);
+        public static ushort ToUInt16(Decimal value);
+        public static uint ToUInt32(Decimal d);
+        public static ulong ToUInt64(Decimal d);
+        public static Decimal Truncate(Decimal d);
+        public static bool TryParse(string s, out Decimal result);
+        public static bool TryParse(string s, NumberStyles style, IFormatProvider provider, out Decimal result);
+    }
+    public abstract class Delegate {
+        protected Delegate(object target, string method);
+        protected Delegate(Type target, string method);
+        public MethodInfo Method { get; }
+        public object Target { get; }
+        public static Delegate Combine(Delegate a, Delegate b);
+        public static Delegate Combine(params Delegate[] delegates);
+        protected virtual Delegate CombineImpl(Delegate d);
+        public static Delegate CreateDelegate(Type type, object firstArgument, MethodInfo method);
+        [MethodImpl(NoInlining)]public static Delegate CreateDelegate(Type type, object firstArgument, MethodInfo method, bool throwOnBindFailure);
+        public static Delegate CreateDelegate(Type type, object target, string method);
+        public static Delegate CreateDelegate(Type type, object target, string method, bool ignoreCase);
+        public static Delegate CreateDelegate(Type type, object target, string method, bool ignoreCase, bool throwOnBindFailure);
+        public static Delegate CreateDelegate(Type type, MethodInfo method);
+        [MethodImpl(NoInlining)]public static Delegate CreateDelegate(Type type, MethodInfo method, bool throwOnBindFailure);
+        public static Delegate CreateDelegate(Type type, Type target, string method);
+        public static Delegate CreateDelegate(Type type, Type target, string method, bool ignoreCase);
+        public static Delegate CreateDelegate(Type type, Type target, string method, bool ignoreCase, bool throwOnBindFailure);
+        public object DynamicInvoke(params object[] args);
+        public override bool Equals(object obj);
+        public override int GetHashCode();
+        public virtual Delegate[] GetInvocationList();
+        public static bool operator ==(Delegate d1, Delegate d2);
+        public static bool operator !=(Delegate d1, Delegate d2);
+        public static Delegate Remove(Delegate source, Delegate value);
+        public static Delegate RemoveAll(Delegate source, Delegate value);
+        protected virtual Delegate RemoveImpl(Delegate d);
+    }
+    public class DivideByZeroException : ArithmeticException {
+        public DivideByZeroException();
+        public DivideByZeroException(string message);
+        public DivideByZeroException(string message, Exception innerException);
+    }
+    public class DllNotFoundException : TypeLoadException {
+        public DllNotFoundException();
+        public DllNotFoundException(string message);
+        public DllNotFoundException(string message, Exception inner);
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct Double : IComparable, IComparable<double>, IConvertible, IEquatable<double>, IFormattable {
+        public const double Epsilon = 4.94065645841247E-324;
+        public const double MaxValue = 1.7976931348623157E+308;
+        public const double MinValue = -1.7976931348623157E+308;
+        public const double NaN = 0.0 / 0.0;
+        public const double NegativeInfinity = -1.0 / 0.0;
+        public const double PositiveInfinity = 1.0 / 0.0;
+        public int CompareTo(double value);
+        public int CompareTo(object value);
+        public bool Equals(double obj);
+        public override bool Equals(object obj);
+        public override int GetHashCode();
+        public TypeCode GetTypeCode();
+        public static bool IsInfinity(double d);
+        public static bool IsNaN(double d);
+        public static bool IsNegativeInfinity(double d);
+        public static bool IsPositiveInfinity(double d);
+        public static bool operator ==(double left, double right);
+        public static bool operator >(double left, double right);
+        public static bool operator >=(double left, double right);
+        public static bool operator !=(double left, double right);
+        public static bool operator <(double left, double right);
+        public static bool operator <=(double left, double right);
+        public static double Parse(string s);
+        public static double Parse(string s, NumberStyles style);
+        public static double Parse(string s, NumberStyles style, IFormatProvider provider);
+        public static double Parse(string s, IFormatProvider provider);
+        int System.IComparable.CompareTo(object value);
+        TypeCode System.IConvertible.GetTypeCode();
+        bool System.IConvertible.ToBoolean(IFormatProvider provider);
+        byte System.IConvertible.ToByte(IFormatProvider provider);
+        char System.IConvertible.ToChar(IFormatProvider provider);
+        DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
+        Decimal System.IConvertible.ToDecimal(IFormatProvider provider);
+        double System.IConvertible.ToDouble(IFormatProvider provider);
+        short System.IConvertible.ToInt16(IFormatProvider provider);
+        int System.IConvertible.ToInt32(IFormatProvider provider);
+        long System.IConvertible.ToInt64(IFormatProvider provider);
+        sbyte System.IConvertible.ToSByte(IFormatProvider provider);
+        float System.IConvertible.ToSingle(IFormatProvider provider);
+        object System.IConvertible.ToType(Type type, IFormatProvider provider);
+        ushort System.IConvertible.ToUInt16(IFormatProvider provider);
+        uint System.IConvertible.ToUInt32(IFormatProvider provider);
+        ulong System.IConvertible.ToUInt64(IFormatProvider provider);
+        public override string ToString();
+        public string ToString(IFormatProvider provider);
+        public string ToString(string format);
+        public string ToString(string format, IFormatProvider provider);
+        public static bool TryParse(string s, out double result);
+        public static bool TryParse(string s, NumberStyles style, IFormatProvider provider, out double result);
+    }
+    public class EntryPointNotFoundException : TypeLoadException {
+        public EntryPointNotFoundException();
+        public EntryPointNotFoundException(string message);
+        public EntryPointNotFoundException(string message, Exception inner);
+    }
+    public abstract class Enum : ValueType, IComparable, IConvertible, IFormattable {
+        protected Enum();
+        public int CompareTo(object target);
+        public override bool Equals(object obj);
+        public static string Format(Type enumType, object value, string format);
+        public override int GetHashCode();
+        public static string GetName(Type enumType, object value);
+        public static string[] GetNames(Type enumType);
+        public TypeCode GetTypeCode();
+        public static Type GetUnderlyingType(Type enumType);
+        public static Array GetValues(Type enumType);
+        public bool HasFlag(Enum flag);
+        public static bool IsDefined(Type enumType, object value);
+        public static object Parse(Type enumType, string value);
+        public static object Parse(Type enumType, string value, bool ignoreCase);
+        TypeCode System.IConvertible.GetTypeCode();
+        bool System.IConvertible.ToBoolean(IFormatProvider provider);
+        byte System.IConvertible.ToByte(IFormatProvider provider);
+        char System.IConvertible.ToChar(IFormatProvider provider);
+        DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
+        Decimal System.IConvertible.ToDecimal(IFormatProvider provider);
+        double System.IConvertible.ToDouble(IFormatProvider provider);
+        short System.IConvertible.ToInt16(IFormatProvider provider);
+        int System.IConvertible.ToInt32(IFormatProvider provider);
+        long System.IConvertible.ToInt64(IFormatProvider provider);
+        sbyte System.IConvertible.ToSByte(IFormatProvider provider);
+        float System.IConvertible.ToSingle(IFormatProvider provider);
+        string System.IConvertible.ToString(IFormatProvider provider);
+        object System.IConvertible.ToType(Type type, IFormatProvider provider);
+        ushort System.IConvertible.ToUInt16(IFormatProvider provider);
+        uint System.IConvertible.ToUInt32(IFormatProvider provider);
+        ulong System.IConvertible.ToUInt64(IFormatProvider provider);
+        string System.IFormattable.ToString(string format, IFormatProvider provider);
+        public static object ToObject(Type enumType, object value);
+        public override string ToString();
+        public string ToString(IFormatProvider provider);
+        public string ToString(string format);
+        public string ToString(string format, IFormatProvider provider);
+        public static bool TryParse<TEnum>(string value, bool ignoreCase, out TEnum result) where TEnum : struct, ValueType;
+        public static bool TryParse<TEnum>(string value, out TEnum result) where TEnum : struct, ValueType;
+    }
+    public static class Environment {
+        public static int CurrentManagedThreadId { get; }
+        public static int ExitCode { [MethodImpl(InternalCall)]get; [MethodImpl(InternalCall)]set; }
+        public static bool HasShutdownStarted { get; }
+        public static string MachineName { get; }
+        public static string NewLine { get; }
+        public static OperatingSystem OSVersion { get; }
+        public static int ProcessorCount { get; }
+        public static string StackTrace { get; }
+        public static int TickCount { get; }
+        public static Version Version { get; }
+        public static void Exit(int exitCode);
+        public static string ExpandEnvironmentVariables(string name);
+        public static void FailFast(string message);
+        public static void FailFast(string message, Exception exception);
+        public static string[] GetCommandLineArgs();
+        public static string GetEnvironmentVariable(string variable);
+        public static IDictionary GetEnvironmentVariables();
+        public static void SetEnvironmentVariable(string variable, string value);
+    }
+    public class EventArgs {
+        public static readonly EventArgs Empty;
+        public EventArgs();
+    }
+    public delegate void EventHandler(object sender, EventArgs e);
+    public delegate void EventHandler<TEventArgs>(object sender, TEventArgs e);
+    public class Exception {
+        public Exception();
+        public Exception(string message);
+        public Exception(string message, Exception innerException);
+        public virtual IDictionary Data { get; }
+        public virtual string HelpLink { get; set; }
+        public int HResult { get; protected set; }
+        public Exception InnerException { get; }
+        public virtual string Message { get; }
+        public virtual string Source { get; set; }
+        public virtual string StackTrace { get; }
+        public virtual Exception GetBaseException();
+        public override string ToString();
+    }
+    public sealed class ExecutionEngineException : SystemException
+    public class FieldAccessException : MemberAccessException {
+        public FieldAccessException();
+        public FieldAccessException(string message);
+        public FieldAccessException(string message, Exception inner);
+    }
+    public class FlagsAttribute : Attribute {
+        public FlagsAttribute();
+    }
+    public class FormatException : Exception {
+        public FormatException();
+        public FormatException(string message);
+        public FormatException(string message, Exception innerException);
+    }
+    public abstract class FormattableString : IFormattable {
+        protected FormattableString();
+        public abstract int ArgumentCount { get; }
+        public abstract string Format { get; }
+        public abstract object GetArgument(int index);
+        public abstract object[] GetArguments();
+        public static string Invariant(FormattableString formattable);
+        string System.IFormattable.ToString(string ignored, IFormatProvider formatProvider);
+        public override string ToString();
+        public abstract string ToString(IFormatProvider formatProvider);
+    }
+    public delegate TResult Func<out TResult>();
+    public delegate TResult Func<in T, out TResult>(T arg);
+    public delegate TResult Func<in T1, in T2, out TResult>(T1 arg1, T2 arg2);
+    public delegate TResult Func<in T1, in T2, in T3, out TResult>(T1 arg1, T2 arg2, T3 arg3);
+    public delegate TResult Func<in T1, in T2, in T3, in T4, out TResult>(T1 arg1, T2 arg2, T3 arg3, T4 arg4);
+    public delegate TResult Func<in T1, in T2, in T3, in T4, in T5, out TResult>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5);
+    public delegate TResult Func<in T1, in T2, in T3, in T4, in T5, in T6, out TResult>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6);
+    public delegate TResult Func<in T1, in T2, in T3, in T4, in T5, in T6, in T7, out TResult>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7);
+    public delegate TResult Func<in T1, in T2, in T3, in T4, in T5, in T6, in T7, in T8, out TResult>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8);
+    public delegate TResult Func<in T1, in T2, in T3, in T4, in T5, in T6, in T7, in T8, in T9, out TResult>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9);
+    public delegate TResult Func<in T1, in T2, in T3, in T4, in T5, in T6, in T7, in T8, in T9, in T10, out TResult>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10);
+    public delegate TResult Func<in T1, in T2, in T3, in T4, in T5, in T6, in T7, in T8, in T9, in T10, in T11, out TResult>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11);
+    public delegate TResult Func<in T1, in T2, in T3, in T4, in T5, in T6, in T7, in T8, in T9, in T10, in T11, in T12, out TResult>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12);
+    public delegate TResult Func<in T1, in T2, in T3, in T4, in T5, in T6, in T7, in T8, in T9, in T10, in T11, in T12, in T13, out TResult>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13);
+    public delegate TResult Func<in T1, in T2, in T3, in T4, in T5, in T6, in T7, in T8, in T9, in T10, in T11, in T12, in T13, in T14, out TResult>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14);
+    public delegate TResult Func<in T1, in T2, in T3, in T4, in T5, in T6, in T7, in T8, in T9, in T10, in T11, in T12, in T13, in T14, in T15, out TResult>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14, T15 arg15);
+    public delegate TResult Func<in T1, in T2, in T3, in T4, in T5, in T6, in T7, in T8, in T9, in T10, in T11, in T12, in T13, in T14, in T15, in T16, out TResult>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14, T15 arg15, T16 arg16);
+    public static class GC {
+        public static int MaxGeneration { get; }
+        public static void AddMemoryPressure(long bytesAllocated);
+        public static void Collect();
+        public static void Collect(int generation);
+        public static void Collect(int generation, GCCollectionMode mode);
+        public static void Collect(int generation, GCCollectionMode mode, bool blocking);
+        public static void Collect(int generation, GCCollectionMode mode, bool blocking, bool compacting);
+        public static int CollectionCount(int generation);
+        public static int GetGeneration(object obj);
+        public static long GetTotalMemory(bool forceFullCollection);
+        public static void KeepAlive(object obj);
+        public static void RemoveMemoryPressure(long bytesAllocated);
+        public static void ReRegisterForFinalize(object obj);
+        public static void SuppressFinalize(object obj);
+        public static void WaitForPendingFinalizers();
+    }
+    public enum GCCollectionMode {
+        Default = 0,
+        Forced = 1,
+        Optimized = 2,
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct Guid : IComparable, IComparable<Guid>, IEquatable<Guid>, IFormattable {
+        public static readonly Guid Empty;
+        public Guid(byte[] b);
+        public Guid(int a, short b, short c, byte d, byte e, byte f, byte g, byte h, byte i, byte j, byte k);
+        public Guid(int a, short b, short c, byte[] d);
+        public Guid(string g);
+        public Guid(uint a, ushort b, ushort c, byte d, byte e, byte f, byte g, byte h, byte i, byte j, byte k);
+        public int CompareTo(Guid value);
+        public int CompareTo(object value);
+        public bool Equals(Guid g);
+        public override bool Equals(object o);
+        public override int GetHashCode();
+        public static Guid NewGuid();
+        public static bool operator ==(Guid a, Guid b);
+        public static bool operator !=(Guid a, Guid b);
+        public static Guid Parse(string input);
+        public static Guid ParseExact(string input, string format);
+        int System.IComparable.CompareTo(object value);
+        string System.IFormattable.ToString(string format, IFormatProvider provider);
+        public byte[] ToByteArray();
+        public override string ToString();
+        public string ToString(string format);
+        public string ToString(string format, IFormatProvider provider);
+        public static bool TryParse(string input, out Guid result);
+        public static bool TryParseExact(string input, string format, out Guid result);
+    }
+    public interface IAsyncResult {
+        object AsyncState { get; }
+        WaitHandle AsyncWaitHandle { get; }
+        bool CompletedSynchronously { get; }
+        bool IsCompleted { get; }
+    }
+    public interface IComparable {
+        int CompareTo(object obj);
+    }
+    public interface IComparable<in T> {
+        int CompareTo(T other);
+    }
+    public interface IConvertible {
+        TypeCode GetTypeCode();
+        bool ToBoolean(IFormatProvider provider);
+        byte ToByte(IFormatProvider provider);
+        char ToChar(IFormatProvider provider);
+        DateTime ToDateTime(IFormatProvider provider);
+        Decimal ToDecimal(IFormatProvider provider);
+        double ToDouble(IFormatProvider provider);
+        short ToInt16(IFormatProvider provider);
+        int ToInt32(IFormatProvider provider);
+        long ToInt64(IFormatProvider provider);
+        sbyte ToSByte(IFormatProvider provider);
+        float ToSingle(IFormatProvider provider);
+        string ToString(IFormatProvider provider);
+        object ToType(Type conversionType, IFormatProvider provider);
+        ushort ToUInt16(IFormatProvider provider);
+        uint ToUInt32(IFormatProvider provider);
+        ulong ToUInt64(IFormatProvider provider);
+    }
+    public interface ICustomFormatter {
+        string Format(string format, object arg, IFormatProvider formatProvider);
+    }
+    public interface IDisposable {
+        void Dispose();
+    }
+    public interface IEquatable<T> {
+        bool Equals(T other);
+    }
+    public interface IFormatProvider {
+        object GetFormat(Type formatType);
+    }
+    public interface IFormattable {
+        string ToString(string format, IFormatProvider formatProvider);
+    }
+    public sealed class IndexOutOfRangeException : Exception {
+        public IndexOutOfRangeException();
+        public IndexOutOfRangeException(string message);
+        public IndexOutOfRangeException(string message, Exception innerException);
+    }
+    public sealed class InsufficientExecutionStackException : Exception {
+        public InsufficientExecutionStackException();
+        public InsufficientExecutionStackException(string message);
+        public InsufficientExecutionStackException(string message, Exception innerException);
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct Int16 : IComparable, IComparable<short>, IConvertible, IEquatable<short>, IFormattable {
+        public const short MaxValue = (short)32767;
+        public const short MinValue = (short)-32768;
+        public int CompareTo(short value);
+        public int CompareTo(object value);
+        public bool Equals(short obj);
+        public override bool Equals(object obj);
+        public override int GetHashCode();
+        public TypeCode GetTypeCode();
+        public static short Parse(string s);
+        public static short Parse(string s, NumberStyles style);
+        public static short Parse(string s, NumberStyles style, IFormatProvider provider);
+        public static short Parse(string s, IFormatProvider provider);
+        int System.IComparable.CompareTo(object value);
+        TypeCode System.IConvertible.GetTypeCode();
+        bool System.IConvertible.ToBoolean(IFormatProvider provider);
+        byte System.IConvertible.ToByte(IFormatProvider provider);
+        char System.IConvertible.ToChar(IFormatProvider provider);
+        DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
+        Decimal System.IConvertible.ToDecimal(IFormatProvider provider);
+        double System.IConvertible.ToDouble(IFormatProvider provider);
+        short System.IConvertible.ToInt16(IFormatProvider provider);
+        int System.IConvertible.ToInt32(IFormatProvider provider);
+        long System.IConvertible.ToInt64(IFormatProvider provider);
+        sbyte System.IConvertible.ToSByte(IFormatProvider provider);
+        float System.IConvertible.ToSingle(IFormatProvider provider);
+        object System.IConvertible.ToType(Type type, IFormatProvider provider);
+        ushort System.IConvertible.ToUInt16(IFormatProvider provider);
+        uint System.IConvertible.ToUInt32(IFormatProvider provider);
+        ulong System.IConvertible.ToUInt64(IFormatProvider provider);
+        public override string ToString();
+        public string ToString(IFormatProvider provider);
+        public string ToString(string format);
+        public string ToString(string format, IFormatProvider provider);
+        public static bool TryParse(string s, NumberStyles style, IFormatProvider provider, out short result);
+        public static bool TryParse(string s, out short result);
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct Int32 : IComparable, IComparable<int>, IConvertible, IEquatable<int>, IFormattable {
+        public const int MaxValue = 2147483647;
+        public const int MinValue = -2147483648;
+        public int CompareTo(int value);
+        public int CompareTo(object value);
+        public bool Equals(int obj);
+        public override bool Equals(object obj);
+        public override int GetHashCode();
+        public TypeCode GetTypeCode();
+        public static int Parse(string s);
+        public static int Parse(string s, NumberStyles style);
+        public static int Parse(string s, NumberStyles style, IFormatProvider provider);
+        public static int Parse(string s, IFormatProvider provider);
+        int System.IComparable.CompareTo(object value);
+        TypeCode System.IConvertible.GetTypeCode();
+        bool System.IConvertible.ToBoolean(IFormatProvider provider);
+        byte System.IConvertible.ToByte(IFormatProvider provider);
+        char System.IConvertible.ToChar(IFormatProvider provider);
+        DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
+        Decimal System.IConvertible.ToDecimal(IFormatProvider provider);
+        double System.IConvertible.ToDouble(IFormatProvider provider);
+        short System.IConvertible.ToInt16(IFormatProvider provider);
+        int System.IConvertible.ToInt32(IFormatProvider provider);
+        long System.IConvertible.ToInt64(IFormatProvider provider);
+        sbyte System.IConvertible.ToSByte(IFormatProvider provider);
+        float System.IConvertible.ToSingle(IFormatProvider provider);
+        object System.IConvertible.ToType(Type type, IFormatProvider provider);
+        ushort System.IConvertible.ToUInt16(IFormatProvider provider);
+        uint System.IConvertible.ToUInt32(IFormatProvider provider);
+        ulong System.IConvertible.ToUInt64(IFormatProvider provider);
+        public override string ToString();
+        public string ToString(IFormatProvider provider);
+        public string ToString(string format);
+        public string ToString(string format, IFormatProvider provider);
+        public static bool TryParse(string s, NumberStyles style, IFormatProvider provider, out int result);
+        public static bool TryParse(string s, out int result);
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct Int64 : IComparable, IComparable<long>, IConvertible, IEquatable<long>, IFormattable {
+        public const long MaxValue = (long)9223372036854775807;
+        public const long MinValue = (long)-9223372036854775808;
+        public int CompareTo(long value);
+        public int CompareTo(object value);
+        public bool Equals(long obj);
+        public override bool Equals(object obj);
+        public override int GetHashCode();
+        public TypeCode GetTypeCode();
+        public static long Parse(string s);
+        public static long Parse(string s, NumberStyles style);
+        public static long Parse(string s, NumberStyles style, IFormatProvider provider);
+        public static long Parse(string s, IFormatProvider provider);
+        int System.IComparable.CompareTo(object value);
+        TypeCode System.IConvertible.GetTypeCode();
+        bool System.IConvertible.ToBoolean(IFormatProvider provider);
+        byte System.IConvertible.ToByte(IFormatProvider provider);
+        char System.IConvertible.ToChar(IFormatProvider provider);
+        DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
+        Decimal System.IConvertible.ToDecimal(IFormatProvider provider);
+        double System.IConvertible.ToDouble(IFormatProvider provider);
+        short System.IConvertible.ToInt16(IFormatProvider provider);
+        int System.IConvertible.ToInt32(IFormatProvider provider);
+        long System.IConvertible.ToInt64(IFormatProvider provider);
+        sbyte System.IConvertible.ToSByte(IFormatProvider provider);
+        float System.IConvertible.ToSingle(IFormatProvider provider);
+        object System.IConvertible.ToType(Type type, IFormatProvider provider);
+        ushort System.IConvertible.ToUInt16(IFormatProvider provider);
+        uint System.IConvertible.ToUInt32(IFormatProvider provider);
+        ulong System.IConvertible.ToUInt64(IFormatProvider provider);
+        public override string ToString();
+        public string ToString(IFormatProvider provider);
+        public string ToString(string format);
+        public string ToString(string format, IFormatProvider provider);
+        public static bool TryParse(string s, NumberStyles style, IFormatProvider provider, out long result);
+        public static bool TryParse(string s, out long result);
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct IntPtr {
+        public static readonly IntPtr Zero;
+        public IntPtr(int value);
+        public IntPtr(long value);
+        public unsafe IntPtr(void* value);
+        public static int Size { get; }
+        public static IntPtr Add(IntPtr pointer, int offset);
+        public override bool Equals(object obj);
+        public override int GetHashCode();
+        public static IntPtr operator +(IntPtr pointer, int offset);
+        public static bool operator ==(IntPtr value1, IntPtr value2);
+        public static explicit operator IntPtr (int value);
+        public static explicit operator IntPtr (long value);
+        public unsafe static explicit operator void* (IntPtr value);
+        public static explicit operator int (IntPtr value);
+        public static explicit operator long (IntPtr value);
+        public unsafe static explicit operator IntPtr (void* value);
+        public static bool operator !=(IntPtr value1, IntPtr value2);
+        public static IntPtr operator -(IntPtr pointer, int offset);
+        public static IntPtr Subtract(IntPtr pointer, int offset);
+        public int ToInt32();
+        public long ToInt64();
+        public unsafe void* ToPointer();
+        public override string ToString();
+        public string ToString(string format);
+    }
+    public class InvalidCastException : Exception {
+        public InvalidCastException();
+        public InvalidCastException(string message);
+        public InvalidCastException(string message, Exception innerException);
+        public InvalidCastException(string message, int errorCode);
+    }
+    public class InvalidOperationException : Exception {
+        public InvalidOperationException();
+        public InvalidOperationException(string message);
+        public InvalidOperationException(string message, Exception innerException);
+    }
+    public sealed class InvalidProgramException : Exception {
+        public InvalidProgramException();
+        public InvalidProgramException(string message);
+        public InvalidProgramException(string message, Exception inner);
+    }
+    public class InvalidTimeZoneException : Exception {
+        public InvalidTimeZoneException();
+        public InvalidTimeZoneException(string message);
+        public InvalidTimeZoneException(string message, Exception innerException);
+    }
+    public interface IObservable<out T> {
+        IDisposable Subscribe(IObserver<T> observer);
+    }
+    public interface IObserver<in T> {
+        void OnCompleted();
+        void OnError(Exception error);
+        void OnNext(T value);
+    }
+    public interface IProgress<in T> {
+        void Report(T value);
+    }
+    public interface IServiceProvider {
+        object GetService(Type serviceType);
+    }
+    public class Lazy<T> {
+        public Lazy();
+        public Lazy(bool isThreadSafe);
+        public Lazy(Func<T> valueFactory);
+        public Lazy(Func<T> valueFactory, bool isThreadSafe);
+        public Lazy(Func<T> valueFactory, LazyThreadSafetyMode mode);
+        public Lazy(LazyThreadSafetyMode mode);
+        public bool IsValueCreated { get; }
+        public T Value { get; }
+        public override string ToString();
+    }
+    public class Lazy<T, TMetadata> : Lazy<T> {
+        public Lazy(Func<T> valueFactory, TMetadata metadata);
+        public Lazy(Func<T> valueFactory, TMetadata metadata, bool isThreadSafe);
+        public Lazy(Func<T> valueFactory, TMetadata metadata, LazyThreadSafetyMode mode);
+        public Lazy(TMetadata metadata);
+        public Lazy(TMetadata metadata, bool isThreadSafe);
+        public Lazy(TMetadata metadata, LazyThreadSafetyMode mode);
+        public TMetadata Metadata { get; }
+    }
+    public static class Math {
+        public const double E = 2.7182818284590451;
+        public const double PI = 3.1415926535897931;
+        public static Decimal Abs(Decimal value);
+        public static double Abs(double value);
+        public static short Abs(short value);
+        public static int Abs(int value);
+        public static long Abs(long value);
+        public static sbyte Abs(sbyte value);
+        public static float Abs(float value);
+        public static double Acos(double d);
+        public static double Asin(double d);
+        public static double Atan(double d);
+        public static double Atan2(double y, double x);
+        public static Decimal Ceiling(Decimal d);
+        public static double Ceiling(double a);
+        public static double Cos(double d);
+        public static double Cosh(double value);
+        public static double Exp(double d);
+        public static Decimal Floor(Decimal d);
+        public static double Floor(double d);
+        public static double IEEERemainder(double x, double y);
+        public static double Log(double d);
+        public static double Log(double a, double newBase);
+        public static double Log10(double d);
+        public static byte Max(byte val1, byte val2);
+        public static Decimal Max(Decimal val1, Decimal val2);
+        public static double Max(double val1, double val2);
+        public static short Max(short val1, short val2);
+        public static int Max(int val1, int val2);
+        public static long Max(long val1, long val2);
+        public static sbyte Max(sbyte val1, sbyte val2);
+        public static float Max(float val1, float val2);
+        public static ushort Max(ushort val1, ushort val2);
+        public static uint Max(uint val1, uint val2);
+        public static ulong Max(ulong val1, ulong val2);
+        public static byte Min(byte val1, byte val2);
+        public static Decimal Min(Decimal val1, Decimal val2);
+        public static double Min(double val1, double val2);
+        public static short Min(short val1, short val2);
+        public static int Min(int val1, int val2);
+        public static long Min(long val1, long val2);
+        public static sbyte Min(sbyte val1, sbyte val2);
+        public static float Min(float val1, float val2);
+        public static ushort Min(ushort val1, ushort val2);
+        public static uint Min(uint val1, uint val2);
+        public static ulong Min(ulong val1, ulong val2);
+        public static double Pow(double x, double y);
+        public static Decimal Round(Decimal d);
+        public static Decimal Round(Decimal d, int decimals);
+        public static Decimal Round(Decimal d, int decimals, MidpointRounding mode);
+        public static Decimal Round(Decimal d, MidpointRounding mode);
+        public static double Round(double a);
+        public static double Round(double value, int digits);
+        public static double Round(double value, int digits, MidpointRounding mode);
+        public static double Round(double value, MidpointRounding mode);
+        public static int Sign(Decimal value);
+        public static int Sign(double value);
+        public static int Sign(short value);
+        public static int Sign(int value);
+        public static int Sign(long value);
+        public static int Sign(sbyte value);
+        public static int Sign(float value);
+        public static double Sin(double a);
+        public static double Sinh(double value);
+        public static double Sqrt(double d);
+        public static double Tan(double a);
+        public static double Tanh(double value);
+        public static Decimal Truncate(Decimal d);
+        public static double Truncate(double d);
+    }
+    public class MemberAccessException : Exception {
+        public MemberAccessException();
+        public MemberAccessException(string message);
+        public MemberAccessException(string message, Exception inner);
+    }
+    public class MethodAccessException : MemberAccessException {
+        public MethodAccessException();
+        public MethodAccessException(string message);
+        public MethodAccessException(string message, Exception inner);
+    }
+    public enum MidpointRounding {
+        AwayFromZero = 1,
+        ToEven = 0,
+    }
+    public class MissingFieldException : MissingMemberException {
+        public MissingFieldException();
+        public MissingFieldException(string message);
+        public MissingFieldException(string message, Exception inner);
+        public override string Message { get; }
+    }
+    public class MissingMemberException : MemberAccessException {
+        public MissingMemberException();
+        public MissingMemberException(string message);
+        public MissingMemberException(string message, Exception inner);
+        public override string Message { get; }
+    }
+    public class MissingMethodException : MissingMemberException {
+        public MissingMethodException();
+        public MissingMethodException(string message);
+        public MissingMethodException(string message, Exception inner);
+        public override string Message { get; }
+    }
+    public sealed class MTAThreadAttribute : Attribute {
+        public MTAThreadAttribute();
+    }
+    public abstract class MulticastDelegate : Delegate {
+        protected MulticastDelegate(object target, string method);
+        protected sealed override Delegate CombineImpl(Delegate follow);
+        public sealed override bool Equals(object obj);
+        public sealed override int GetHashCode();
+        public sealed override Delegate[] GetInvocationList();
+        public static bool operator ==(MulticastDelegate d1, MulticastDelegate d2);
+        public static bool operator !=(MulticastDelegate d1, MulticastDelegate d2);
+        protected sealed override Delegate RemoveImpl(Delegate value);
+    }
+    public sealed class MulticastNotSupportedException : SystemException {
+        public MulticastNotSupportedException();
+        public MulticastNotSupportedException(string message);
+        public MulticastNotSupportedException(string message, Exception inner);
+    }
+    public class NotFiniteNumberException : ArithmeticException {
+        public NotFiniteNumberException();
+        public NotFiniteNumberException(string message);
+        public NotFiniteNumberException(string message, Exception innerException);
+    }
+    public class NotImplementedException : Exception {
+        public NotImplementedException();
+        public NotImplementedException(string message);
+        public NotImplementedException(string message, Exception inner);
+    }
+    public class NotSupportedException : Exception {
+        public NotSupportedException();
+        public NotSupportedException(string message);
+        public NotSupportedException(string message, Exception innerException);
+    }
+    public static class Nullable {
+        public static int Compare<T>(Nullable<T> n1, Nullable<T> n2) where T : struct, ValueType;
+        public static bool Equals<T>(Nullable<T> n1, Nullable<T> n2) where T : struct, ValueType;
+        public static Type GetUnderlyingType(Type nullableType);
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct Nullable<T> where T : struct, ValueType {
+        public Nullable(T value);
+        public bool HasValue { get; }
+        public T Value { get; }
+        public override bool Equals(object other);
+        public override int GetHashCode();
+        public T GetValueOrDefault();
+        public T GetValueOrDefault(T defaultValue);
+        public static explicit operator T (Nullable<T> value);
+        public static implicit operator Nullable<T> (T value);
+        public override string ToString();
+    }
+    public class NullReferenceException : Exception {
+        public NullReferenceException();
+        public NullReferenceException(string message);
+        public NullReferenceException(string message, Exception innerException);
+    }
+    public class Object {
+        public Object();
+        public virtual bool Equals(object obj);
+        public static bool Equals(object objA, object objB);
+        ~Object();
+        public virtual int GetHashCode();
+        public Type GetType();
+        protected object MemberwiseClone();
+        public static bool ReferenceEquals(object objA, object objB);
+        public virtual string ToString();
+    }
+    public class ObjectDisposedException : InvalidOperationException {
+        public ObjectDisposedException(string objectName);
+        public ObjectDisposedException(string message, Exception innerException);
+        public ObjectDisposedException(string objectName, string message);
+        public override string Message { get; }
+        public string ObjectName { get; }
+    }
+    public sealed class ObsoleteAttribute : Attribute {
+        public ObsoleteAttribute();
+        public ObsoleteAttribute(string message);
+        public ObsoleteAttribute(string message, bool error);
+        public bool IsError { get; }
+        public string Message { get; }
+    }
+    public sealed class OperatingSystem {
+        public OperatingSystem(PlatformID platform, Version version);
+        public PlatformID Platform { get; }
+        public Version Version { get; }
+        public object Clone();
+        public override string ToString();
+    }
+    public class OperationCanceledException : Exception {
+        public OperationCanceledException();
+        public OperationCanceledException(string message);
+        public OperationCanceledException(string message, Exception innerException);
+        public OperationCanceledException(string message, Exception innerException, CancellationToken token);
+        public OperationCanceledException(string message, CancellationToken token);
+        public OperationCanceledException(CancellationToken token);
+        public CancellationToken CancellationToken { get; }
+    }
+    public class OutOfMemoryException : Exception {
+        public OutOfMemoryException();
+        public OutOfMemoryException(string message);
+        public OutOfMemoryException(string message, Exception innerException);
+    }
+    public class OverflowException : ArithmeticException {
+        public OverflowException();
+        public OverflowException(string message);
+        public OverflowException(string message, Exception innerException);
+    }
+    public sealed class ParamArrayAttribute : Attribute {
+        public ParamArrayAttribute();
+    }
+    public enum PlatformID {
+        MacOSX = 6,
+        Unix = 4,
+        Win32NT = 2,
+        Win32S = 0,
+        Win32Windows = 1,
+        WinCE = 3,
+        Xbox = 5,
+    }
+    public class PlatformNotSupportedException : NotSupportedException {
+        public PlatformNotSupportedException();
+        public PlatformNotSupportedException(string message);
+        public PlatformNotSupportedException(string message, Exception inner);
+    }
+    public delegate bool Predicate<in T>(T obj);
+    public class Progress<T> : IProgress<T> {
+        public Progress();
+        public Progress(Action<T> handler);
+        public event EventHandler<T> ProgressChanged;
+        protected virtual void OnReport(T value);
+        void System.IProgress<T>.Report(T value);
+    }
+    public class Random {
+        public Random();
+        public Random(int Seed);
+        public virtual int Next();
+        public virtual int Next(int maxValue);
+        public virtual int Next(int minValue, int maxValue);
+        public virtual void NextBytes(byte[] buffer);
+        public virtual double NextDouble();
+        protected virtual double Sample();
+    }
+    public class RankException : Exception {
+        public RankException();
+        public RankException(string message);
+        public RankException(string message, Exception innerException);
+    }
+    public class ResolveEventArgs : EventArgs {
+        public ResolveEventArgs(string name);
+        public ResolveEventArgs(string name, Assembly requestingAssembly);
+        public string Name { get; }
+        public Assembly RequestingAssembly { get; }
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct RuntimeArgumentHandle
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct RuntimeFieldHandle {
+        public override bool Equals(object obj);
+        public bool Equals(RuntimeFieldHandle handle);
+        public override int GetHashCode();
+        public static bool operator ==(RuntimeFieldHandle left, RuntimeFieldHandle right);
+        public static bool operator !=(RuntimeFieldHandle left, RuntimeFieldHandle right);
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct RuntimeMethodHandle {
+        public IntPtr Value { get; }
+        public override bool Equals(object obj);
+        public bool Equals(RuntimeMethodHandle handle);
+        public override int GetHashCode();
+        public static bool operator ==(RuntimeMethodHandle left, RuntimeMethodHandle right);
+        public static bool operator !=(RuntimeMethodHandle left, RuntimeMethodHandle right);
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct RuntimeTypeHandle {
+        public IntPtr Value { get; }
+        public override bool Equals(object obj);
+        public bool Equals(RuntimeTypeHandle handle);
+        public override int GetHashCode();
+        public static bool operator ==(object left, RuntimeTypeHandle right);
+        public static bool operator ==(RuntimeTypeHandle left, object right);
+        public static bool operator !=(object left, RuntimeTypeHandle right);
+        public static bool operator !=(RuntimeTypeHandle left, object right);
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct SByte : IComparable, IComparable<sbyte>, IConvertible, IEquatable<sbyte>, IFormattable {
+        public const sbyte MaxValue = (sbyte)127;
+        public const sbyte MinValue = (sbyte)-128;
+        public int CompareTo(object obj);
+        public int CompareTo(sbyte value);
+        public override bool Equals(object obj);
+        public bool Equals(sbyte obj);
+        public override int GetHashCode();
+        public TypeCode GetTypeCode();
+        public static sbyte Parse(string s);
+        public static sbyte Parse(string s, NumberStyles style);
+        public static sbyte Parse(string s, NumberStyles style, IFormatProvider provider);
+        public static sbyte Parse(string s, IFormatProvider provider);
+        int System.IComparable.CompareTo(object obj);
+        TypeCode System.IConvertible.GetTypeCode();
+        bool System.IConvertible.ToBoolean(IFormatProvider provider);
+        byte System.IConvertible.ToByte(IFormatProvider provider);
+        char System.IConvertible.ToChar(IFormatProvider provider);
+        DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
+        Decimal System.IConvertible.ToDecimal(IFormatProvider provider);
+        double System.IConvertible.ToDouble(IFormatProvider provider);
+        short System.IConvertible.ToInt16(IFormatProvider provider);
+        int System.IConvertible.ToInt32(IFormatProvider provider);
+        long System.IConvertible.ToInt64(IFormatProvider provider);
+        sbyte System.IConvertible.ToSByte(IFormatProvider provider);
+        float System.IConvertible.ToSingle(IFormatProvider provider);
+        object System.IConvertible.ToType(Type type, IFormatProvider provider);
+        ushort System.IConvertible.ToUInt16(IFormatProvider provider);
+        uint System.IConvertible.ToUInt32(IFormatProvider provider);
+        ulong System.IConvertible.ToUInt64(IFormatProvider provider);
+        public override string ToString();
+        public string ToString(IFormatProvider provider);
+        public string ToString(string format);
+        public string ToString(string format, IFormatProvider provider);
+        public static bool TryParse(string s, NumberStyles style, IFormatProvider provider, out sbyte result);
+        public static bool TryParse(string s, out sbyte result);
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct Single : IComparable, IComparable<float>, IConvertible, IEquatable<float>, IFormattable {
+        public const float Epsilon = 1.401298E-45f;
+        public const float MaxValue = 3.40282347E+38f;
+        public const float MinValue = -3.40282347E+38f;
+        public const float NaN = 0.0f / 0.0f;
+        public const float NegativeInfinity = -1.0f / 0.0f;
+        public const float PositiveInfinity = 1.0f / 0.0f;
+        public int CompareTo(object value);
+        public int CompareTo(float value);
+        public override bool Equals(object obj);
+        public bool Equals(float obj);
+        public override int GetHashCode();
+        public TypeCode GetTypeCode();
+        public static bool IsInfinity(float f);
+        public static bool IsNaN(float f);
+        public static bool IsNegativeInfinity(float f);
+        public static bool IsPositiveInfinity(float f);
+        public static bool operator ==(float left, float right);
+        public static bool operator >(float left, float right);
+        public static bool operator >=(float left, float right);
+        public static bool operator !=(float left, float right);
+        public static bool operator <(float left, float right);
+        public static bool operator <=(float left, float right);
+        public static float Parse(string s);
+        public static float Parse(string s, NumberStyles style);
+        public static float Parse(string s, NumberStyles style, IFormatProvider provider);
+        public static float Parse(string s, IFormatProvider provider);
+        int System.IComparable.CompareTo(object value);
+        TypeCode System.IConvertible.GetTypeCode();
+        bool System.IConvertible.ToBoolean(IFormatProvider provider);
+        byte System.IConvertible.ToByte(IFormatProvider provider);
+        char System.IConvertible.ToChar(IFormatProvider provider);
+        DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
+        Decimal System.IConvertible.ToDecimal(IFormatProvider provider);
+        double System.IConvertible.ToDouble(IFormatProvider provider);
+        short System.IConvertible.ToInt16(IFormatProvider provider);
+        int System.IConvertible.ToInt32(IFormatProvider provider);
+        long System.IConvertible.ToInt64(IFormatProvider provider);
+        sbyte System.IConvertible.ToSByte(IFormatProvider provider);
+        float System.IConvertible.ToSingle(IFormatProvider provider);
+        object System.IConvertible.ToType(Type type, IFormatProvider provider);
+        ushort System.IConvertible.ToUInt16(IFormatProvider provider);
+        uint System.IConvertible.ToUInt32(IFormatProvider provider);
+        ulong System.IConvertible.ToUInt64(IFormatProvider provider);
+        public override string ToString();
+        public string ToString(IFormatProvider provider);
+        public string ToString(string format);
+        public string ToString(string format, IFormatProvider provider);
+        public static bool TryParse(string s, NumberStyles style, IFormatProvider provider, out float result);
+        public static bool TryParse(string s, out float result);
+    }
+    public sealed class StackOverflowException : SystemException {
+        public StackOverflowException();
+        public StackOverflowException(string message);
+        public StackOverflowException(string message, Exception innerException);
+    }
+    public sealed class STAThreadAttribute : Attribute {
+        public STAThreadAttribute();
+    }
+    public sealed class String : IComparable, IComparable<string>, IConvertible, IEnumerable, IEnumerable<char>, IEquatable<string> {
+        public static readonly string Empty;
+        public unsafe String(char* value);
+        public unsafe String(char* value, int startIndex, int length);
+        public String(char c, int count);
+        public String(char[] value);
+        public String(char[] value, int startIndex, int length);
+        [MethodImpl(InternalCall)]public unsafe String(sbyte* value);
+        public int Length { get; }
+        [System.Runtime.CompilerServices.IndexerName("Chars")]
+        public char this[int index] { get; }
+        public static int Compare(string strA, int indexA, string strB, int indexB, int length);
+        public static int Compare(string strA, int indexA, string strB, int indexB, int length, CultureInfo culture, CompareOptions options);
+        public static int Compare(string strA, int indexA, string strB, int indexB, int length, StringComparison comparisonType);
+        public static int Compare(string strA, string strB);
+        public static int Compare(string strA, string strB, bool ignoreCase);
+        public static int Compare(string strA, string strB, CultureInfo culture, CompareOptions options);
+        public static int Compare(string strA, string strB, StringComparison comparisonType);
+        public static int CompareOrdinal(string strA, int indexA, string strB, int indexB, int length);
+        public static int CompareOrdinal(string strA, string strB);
+        public int CompareTo(object value);
+        public int CompareTo(string strB);
+        public static string Concat(IEnumerable<string> values);
+        public static string Concat(object arg0);
+        public static string Concat(object arg0, object arg1);
+        public static string Concat(object arg0, object arg1, object arg2);
+        public static string Concat(params object[] args);
+        public static string Concat(string str0, string str1);
+        public static string Concat(string str0, string str1, string str2);
+        public static string Concat(string str0, string str1, string str2, string str3);
+        public static string Concat(params string[] values);
+        public static string Concat<T>(IEnumerable<T> values);
+        public bool Contains(string value);
+        public static string Copy(string str);
+        public void CopyTo(int sourceIndex, char[] destination, int destinationIndex, int count);
+        public bool EndsWith(string value);
+        public bool EndsWith(string value, StringComparison comparisonType);
+        public override bool Equals(object obj);
+        public bool Equals(string value);
+        public static bool Equals(string a, string b);
+        public static bool Equals(string a, string b, StringComparison comparisonType);
+        public bool Equals(string value, StringComparison comparisonType);
+        public static string Format(IFormatProvider provider, string format, object arg0);
+        public static string Format(IFormatProvider provider, string format, object arg0, object arg1);
+        public static string Format(IFormatProvider provider, string format, object arg0, object arg1, object arg2);
+        public static string Format(IFormatProvider provider, string format, params object[] args);
+        public static string Format(string format, object arg0);
+        public static string Format(string format, object arg0, object arg1);
+        public static string Format(string format, object arg0, object arg1, object arg2);
+        public static string Format(string format, params object[] args);
+        public override int GetHashCode();
+        public TypeCode GetTypeCode();
+        public int IndexOf(char value);
+        public int IndexOf(char value, int startIndex);
+        public int IndexOf(char value, int startIndex, int count);
+        public int IndexOf(string value);
+        public int IndexOf(string value, int startIndex);
+        public int IndexOf(string value, int startIndex, int count);
+        public int IndexOf(string value, int startIndex, int count, StringComparison comparisonType);
+        public int IndexOf(string value, int startIndex, StringComparison comparisonType);
+        public int IndexOf(string value, StringComparison comparisonType);
+        public int IndexOfAny(char[] anyOf);
+        public int IndexOfAny(char[] anyOf, int startIndex);
+        public int IndexOfAny(char[] anyOf, int startIndex, int count);
+        public string Insert(int startIndex, string value);
+        public static string Intern(string str);
+        public static string IsInterned(string str);
+        public static bool IsNullOrEmpty(string value);
+        public static bool IsNullOrWhiteSpace(string value);
+        public static string Join(string separator, IEnumerable<string> values);
+        public static string Join(string separator, params object[] values);
+        public static string Join(string separator, params string[] value);
+        public static string Join(string separator, string[] value, int startIndex, int count);
+        public static string Join<T>(string separator, IEnumerable<T> values);
+        public int LastIndexOf(char value);
+        public int LastIndexOf(char value, int startIndex);
+        public int LastIndexOf(char value, int startIndex, int count);
+        public int LastIndexOf(string value);
+        public int LastIndexOf(string value, int startIndex);
+        public int LastIndexOf(string value, int startIndex, int count);
+        public int LastIndexOf(string value, int startIndex, int count, StringComparison comparisonType);
+        public int LastIndexOf(string value, int startIndex, StringComparison comparisonType);
+        public int LastIndexOf(string value, StringComparison comparisonType);
+        public int LastIndexOfAny(char[] anyOf);
+        public int LastIndexOfAny(char[] anyOf, int startIndex);
+        public int LastIndexOfAny(char[] anyOf, int startIndex, int count);
+        public static bool operator ==(string a, string b);
+        public static bool operator !=(string a, string b);
+        public string PadLeft(int totalWidth);
+        public string PadLeft(int totalWidth, char paddingChar);
+        public string PadRight(int totalWidth);
+        public string PadRight(int totalWidth, char paddingChar);
+        public string Remove(int startIndex);
+        public string Remove(int startIndex, int count);
+        public string Replace(char oldChar, char newChar);
+        public string Replace(string oldValue, string newValue);
+        public string[] Split(params char[] separator);
+        public string[] Split(char[] separator, int count);
+        public string[] Split(char[] separator, int count, StringSplitOptions options);
+        public string[] Split(char[] separator, StringSplitOptions options);
+        public string[] Split(string[] separator, int count, StringSplitOptions options);
+        public string[] Split(string[] separator, StringSplitOptions options);
+        public bool StartsWith(string value);
+        public bool StartsWith(string value, StringComparison comparisonType);
+        public string Substring(int startIndex);
+        public string Substring(int startIndex, int length);
+        IEnumerator<char> System.Collections.Generic.IEnumerable<System.Char>.GetEnumerator();
+        IEnumerator System.Collections.IEnumerable.GetEnumerator();
+        int System.IComparable.CompareTo(object value);
+        TypeCode System.IConvertible.GetTypeCode();
+        bool System.IConvertible.ToBoolean(IFormatProvider provider);
+        byte System.IConvertible.ToByte(IFormatProvider provider);
+        char System.IConvertible.ToChar(IFormatProvider provider);
+        DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
+        Decimal System.IConvertible.ToDecimal(IFormatProvider provider);
+        double System.IConvertible.ToDouble(IFormatProvider provider);
+        short System.IConvertible.ToInt16(IFormatProvider provider);
+        int System.IConvertible.ToInt32(IFormatProvider provider);
+        long System.IConvertible.ToInt64(IFormatProvider provider);
+        sbyte System.IConvertible.ToSByte(IFormatProvider provider);
+        float System.IConvertible.ToSingle(IFormatProvider provider);
+        string System.IConvertible.ToString(IFormatProvider provider);
+        object System.IConvertible.ToType(Type type, IFormatProvider provider);
+        ushort System.IConvertible.ToUInt16(IFormatProvider provider);
+        uint System.IConvertible.ToUInt32(IFormatProvider provider);
+        ulong System.IConvertible.ToUInt64(IFormatProvider provider);
+        public char[] ToCharArray();
+        public char[] ToCharArray(int startIndex, int length);
+        public string ToLower();
+        public string ToLower(CultureInfo culture);
+        public string ToLowerInvariant();
+        public override string ToString();
+        public string ToString(IFormatProvider provider);
+        public string ToUpper();
+        public string ToUpper(CultureInfo culture);
+        public string ToUpperInvariant();
+        public string Trim();
+        public string Trim(params char[] trimChars);
+        public string TrimEnd(params char[] trimChars);
+        public string TrimStart(params char[] trimChars);
+    }
+    public abstract class StringComparer : IComparer, IComparer<string>, IEqualityComparer, IEqualityComparer<string> {
+        protected StringComparer();
+        public static StringComparer CurrentCulture { get; }
+        public static StringComparer CurrentCultureIgnoreCase { get; }
+        public static StringComparer InvariantCulture { get; }
+        public static StringComparer InvariantCultureIgnoreCase { get; }
+        public static StringComparer Ordinal { get; }
+        public static StringComparer OrdinalIgnoreCase { get; }
+        public int Compare(object x, object y);
+        public abstract int Compare(string x, string y);
+        public static StringComparer Create(CultureInfo culture, bool ignoreCase);
+        public new bool Equals(object x, object y);
+        public abstract bool Equals(string x, string y);
+        public int GetHashCode(object obj);
+        public abstract int GetHashCode(string obj);
+        int System.Collections.IComparer.Compare(object x, object y);
+        bool System.Collections.IEqualityComparer.Equals(object x, object y);
+        int System.Collections.IEqualityComparer.GetHashCode(object obj);
+    }
+    public enum StringComparison {
+        CurrentCulture = 0,
+        CurrentCultureIgnoreCase = 1,
+        InvariantCulture = 2,
+        InvariantCultureIgnoreCase = 3,
+        Ordinal = 4,
+        OrdinalIgnoreCase = 5,
+    }
+    public static class StringNormalizationExtensions {
+        public static bool IsNormalized(this string value);
+        public static bool IsNormalized(this string value, NormalizationForm normalizationForm);
+        public static string Normalize(this string value);
+        public static string Normalize(this string value, NormalizationForm normalizationForm);
+    }
+    public enum StringSplitOptions {
+        None = 0,
+        RemoveEmptyEntries = 1,
+    }
+    public class SystemException : Exception {
+        public SystemException();
+        public SystemException(string message);
+        public SystemException(string message, Exception innerException);
+    }
+    public class ThreadStaticAttribute : Attribute {
+        public ThreadStaticAttribute();
+    }
+    public class TimeoutException : Exception {
+        public TimeoutException();
+        public TimeoutException(string message);
+        public TimeoutException(string message, Exception innerException);
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct TimeSpan : IComparable, IComparable<TimeSpan>, IEquatable<TimeSpan>, IFormattable {
+        public const long TicksPerDay = (long)864000000000;
+        public const long TicksPerHour = (long)36000000000;
+        public const long TicksPerMillisecond = (long)10000;
+        public const long TicksPerMinute = (long)600000000;
+        public const long TicksPerSecond = (long)10000000;
+        public static readonly TimeSpan MaxValue;
+        public static readonly TimeSpan MinValue;
+        public static readonly TimeSpan Zero;
+        public TimeSpan(int hours, int minutes, int seconds);
+        public TimeSpan(int days, int hours, int minutes, int seconds);
+        public TimeSpan(int days, int hours, int minutes, int seconds, int milliseconds);
+        public TimeSpan(long ticks);
+        public int Days { get; }
+        public int Hours { get; }
+        public int Milliseconds { get; }
+        public int Minutes { get; }
+        public int Seconds { get; }
+        public long Ticks { get; }
+        public double TotalDays { get; }
+        public double TotalHours { get; }
+        public double TotalMilliseconds { get; }
+        public double TotalMinutes { get; }
+        public double TotalSeconds { get; }
+        public TimeSpan Add(TimeSpan ts);
+        public static int Compare(TimeSpan t1, TimeSpan t2);
+        public int CompareTo(object value);
+        public int CompareTo(TimeSpan value);
+        public TimeSpan Duration();
+        public override bool Equals(object value);
+        public bool Equals(TimeSpan obj);
+        public static bool Equals(TimeSpan t1, TimeSpan t2);
+        public static TimeSpan FromDays(double value);
+        public static TimeSpan FromHours(double value);
+        public static TimeSpan FromMilliseconds(double value);
+        public static TimeSpan FromMinutes(double value);
+        public static TimeSpan FromSeconds(double value);
+        public static TimeSpan FromTicks(long value);
+        public override int GetHashCode();
+        public TimeSpan Negate();
+        public static TimeSpan operator +(TimeSpan t1, TimeSpan t2);
+        public static bool operator ==(TimeSpan t1, TimeSpan t2);
+        public static bool operator >(TimeSpan t1, TimeSpan t2);
+        public static bool operator >=(TimeSpan t1, TimeSpan t2);
+        public static bool operator !=(TimeSpan t1, TimeSpan t2);
+        public static bool operator <(TimeSpan t1, TimeSpan t2);
+        public static bool operator <=(TimeSpan t1, TimeSpan t2);
+        public static TimeSpan operator -(TimeSpan t1, TimeSpan t2);
+        public static TimeSpan operator -(TimeSpan t);
+        public static TimeSpan operator +(TimeSpan t);
+        public static TimeSpan Parse(string s);
+        public static TimeSpan Parse(string input, IFormatProvider formatProvider);
+        public static TimeSpan ParseExact(string input, string format, IFormatProvider formatProvider);
+        public static TimeSpan ParseExact(string input, string format, IFormatProvider formatProvider, TimeSpanStyles styles);
+        public static TimeSpan ParseExact(string input, string[] formats, IFormatProvider formatProvider);
+        public static TimeSpan ParseExact(string input, string[] formats, IFormatProvider formatProvider, TimeSpanStyles styles);
+        public TimeSpan Subtract(TimeSpan ts);
+        int System.IComparable.CompareTo(object value);
+        public override string ToString();
+        public string ToString(string format);
+        public string ToString(string format, IFormatProvider formatProvider);
+        public static bool TryParse(string input, IFormatProvider formatProvider, out TimeSpan result);
+        public static bool TryParse(string s, out TimeSpan result);
+        public static bool TryParseExact(string input, string format, IFormatProvider formatProvider, TimeSpanStyles styles, out TimeSpan result);
+        public static bool TryParseExact(string input, string format, IFormatProvider formatProvider, out TimeSpan result);
+        public static bool TryParseExact(string input, string[] formats, IFormatProvider formatProvider, TimeSpanStyles styles, out TimeSpan result);
+        public static bool TryParseExact(string input, string[] formats, IFormatProvider formatProvider, out TimeSpan result);
+    }
+    public sealed class TimeZoneInfo : IEquatable<TimeZoneInfo> {
+        public TimeSpan BaseUtcOffset { get; }
+        public string DaylightName { get; }
+        public string DisplayName { get; }
+        public string Id { get; }
+        public static TimeZoneInfo Local { get; }
+        public string StandardName { get; }
+        public bool SupportsDaylightSavingTime { get; }
+        public static TimeZoneInfo Utc { get; }
+        public static DateTime ConvertTime(DateTime dateTime, TimeZoneInfo destinationTimeZone);
+        public static DateTime ConvertTime(DateTime dateTime, TimeZoneInfo sourceTimeZone, TimeZoneInfo destinationTimeZone);
+        public static DateTimeOffset ConvertTime(DateTimeOffset dateTimeOffset, TimeZoneInfo destinationTimeZone);
+        public override bool Equals(object obj);
+        public bool Equals(TimeZoneInfo other);
+        public static TimeZoneInfo FindSystemTimeZoneById(string id);
+        public TimeSpan[] GetAmbiguousTimeOffsets(DateTime dateTime);
+        public TimeSpan[] GetAmbiguousTimeOffsets(DateTimeOffset dateTimeOffset);
+        public override int GetHashCode();
+        public static ReadOnlyCollection<TimeZoneInfo> GetSystemTimeZones();
+        public TimeSpan GetUtcOffset(DateTime dateTime);
+        public TimeSpan GetUtcOffset(DateTimeOffset dateTimeOffset);
+        public bool IsAmbiguousTime(DateTime dateTime);
+        public bool IsAmbiguousTime(DateTimeOffset dateTimeOffset);
+        public bool IsDaylightSavingTime(DateTime dateTime);
+        public bool IsDaylightSavingTime(DateTimeOffset dateTimeOffset);
+        public bool IsInvalidTime(DateTime dateTime);
+        public override string ToString();
+        public sealed class AdjustmentRule : IEquatable<TimeZoneInfo.AdjustmentRule> {
+            public static TimeZoneInfo.AdjustmentRule CreateAdjustmentRule(DateTime dateStart, DateTime dateEnd, TimeSpan daylightDelta, TimeZoneInfo.TransitionTime daylightTransitionStart, TimeZoneInfo.TransitionTime daylightTransitionEnd);
+            public bool Equals(TimeZoneInfo.AdjustmentRule other);
+            public override int GetHashCode();
+        }
+        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+        public struct TransitionTime : IEquatable<TimeZoneInfo.TransitionTime> {
+            public override bool Equals(object obj);
+            public bool Equals(TimeZoneInfo.TransitionTime other);
+            public override int GetHashCode();
+        }
+    }
+    public static class Tuple {
+        public static Tuple<T1, T2, T3, T4, T5, T6, T7, Tuple<T8>> Create<T1, T2, T3, T4, T5, T6, T7, T8>(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7, T8 item8);
+        public static Tuple<T1, T2, T3, T4, T5, T6, T7> Create<T1, T2, T3, T4, T5, T6, T7>(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7);
+        public static Tuple<T1, T2, T3, T4, T5, T6> Create<T1, T2, T3, T4, T5, T6>(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6);
+        public static Tuple<T1, T2, T3, T4, T5> Create<T1, T2, T3, T4, T5>(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5);
+        public static Tuple<T1, T2, T3, T4> Create<T1, T2, T3, T4>(T1 item1, T2 item2, T3 item3, T4 item4);
+        public static Tuple<T1, T2, T3> Create<T1, T2, T3>(T1 item1, T2 item2, T3 item3);
+        public static Tuple<T1, T2> Create<T1, T2>(T1 item1, T2 item2);
+        public static Tuple<T1> Create<T1>(T1 item1);
+    }
+    public class Tuple<T1> : IComparable, IStructuralComparable, IStructuralEquatable {
+        public Tuple(T1 item1);
+        public T1 Item1 { get; }
+        public override bool Equals(object obj);
+        public override int GetHashCode();
+        int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
+        bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
+        int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
+        int System.IComparable.CompareTo(object obj);
+        public override string ToString();
+    }
+    public class Tuple<T1, T2> : IComparable, IStructuralComparable, IStructuralEquatable {
+        public Tuple(T1 item1, T2 item2);
+        public T1 Item1 { get; }
+        public T2 Item2 { get; }
+        public override bool Equals(object obj);
+        public override int GetHashCode();
+        int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
+        bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
+        int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
+        int System.IComparable.CompareTo(object obj);
+        public override string ToString();
+    }
+    public class Tuple<T1, T2, T3> : IComparable, IStructuralComparable, IStructuralEquatable {
+        public Tuple(T1 item1, T2 item2, T3 item3);
+        public T1 Item1 { get; }
+        public T2 Item2 { get; }
+        public T3 Item3 { get; }
+        public override bool Equals(object obj);
+        public override int GetHashCode();
+        int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
+        bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
+        int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
+        int System.IComparable.CompareTo(object obj);
+        public override string ToString();
+    }
+    public class Tuple<T1, T2, T3, T4> : IComparable, IStructuralComparable, IStructuralEquatable {
+        public Tuple(T1 item1, T2 item2, T3 item3, T4 item4);
+        public T1 Item1 { get; }
+        public T2 Item2 { get; }
+        public T3 Item3 { get; }
+        public T4 Item4 { get; }
+        public override bool Equals(object obj);
+        public override int GetHashCode();
+        int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
+        bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
+        int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
+        int System.IComparable.CompareTo(object obj);
+        public override string ToString();
+    }
+    public class Tuple<T1, T2, T3, T4, T5> : IComparable, IStructuralComparable, IStructuralEquatable {
+        public Tuple(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5);
+        public T1 Item1 { get; }
+        public T2 Item2 { get; }
+        public T3 Item3 { get; }
+        public T4 Item4 { get; }
+        public T5 Item5 { get; }
+        public override bool Equals(object obj);
+        public override int GetHashCode();
+        int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
+        bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
+        int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
+        int System.IComparable.CompareTo(object obj);
+        public override string ToString();
+    }
+    public class Tuple<T1, T2, T3, T4, T5, T6> : IComparable, IStructuralComparable, IStructuralEquatable {
+        public Tuple(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6);
+        public T1 Item1 { get; }
+        public T2 Item2 { get; }
+        public T3 Item3 { get; }
+        public T4 Item4 { get; }
+        public T5 Item5 { get; }
+        public T6 Item6 { get; }
+        public override bool Equals(object obj);
+        public override int GetHashCode();
+        int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
+        bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
+        int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
+        int System.IComparable.CompareTo(object obj);
+        public override string ToString();
+    }
+    public class Tuple<T1, T2, T3, T4, T5, T6, T7> : IComparable, IStructuralComparable, IStructuralEquatable {
+        public Tuple(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7);
+        public T1 Item1 { get; }
+        public T2 Item2 { get; }
+        public T3 Item3 { get; }
+        public T4 Item4 { get; }
+        public T5 Item5 { get; }
+        public T6 Item6 { get; }
+        public T7 Item7 { get; }
+        public override bool Equals(object obj);
+        public override int GetHashCode();
+        int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
+        bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
+        int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
+        int System.IComparable.CompareTo(object obj);
+        public override string ToString();
+    }
+    public class Tuple<T1, T2, T3, T4, T5, T6, T7, TRest> : IComparable, IStructuralComparable, IStructuralEquatable {
+        public Tuple(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7, TRest rest);
+        public T1 Item1 { get; }
+        public T2 Item2 { get; }
+        public T3 Item3 { get; }
+        public T4 Item4 { get; }
+        public T5 Item5 { get; }
+        public T6 Item6 { get; }
+        public T7 Item7 { get; }
+        public TRest Rest { get; }
+        public override bool Equals(object obj);
+        public override int GetHashCode();
+        int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
+        bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
+        int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
+        int System.IComparable.CompareTo(object obj);
+        public override string ToString();
+    }
+    public abstract class Type {
+        public static readonly char Delimiter;
+        public static readonly object Missing;
+        public static readonly MemberFilter FilterNameIgnoreCase;
+        public static readonly Type[] EmptyTypes;
+        protected Type();
+        public abstract Assembly Assembly { get; }
+        public abstract string AssemblyQualifiedName { get; }
+        public TypeAttributes Attributes { get; }
+        public abstract Type BaseType { get; }
+        public virtual bool ContainsGenericParameters { get; }
+        public virtual MethodBase DeclaringMethod { get; }
+        public abstract Type DeclaringType { get; }
+        public static Binder DefaultBinder { get; }
+        public abstract string FullName { get; }
+        public virtual GenericParameterAttributes GenericParameterAttributes { get; }
+        public abstract int GenericParameterPosition { get; }
+        public abstract Type[] GenericTypeArguments { get; }
+        public abstract Guid GUID { get; }
+        public bool HasElementType { get; }
+        public bool IsAbstract { get; }
+        public bool IsAnsiClass { get; }
+        public virtual bool IsArray { get; }
+        public bool IsAutoClass { get; }
+        public bool IsAutoLayout { get; }
+        public virtual bool IsByRef { get; }
+        public bool IsClass { get; }
+        public bool IsCOMObject { get; }
+        public abstract bool IsConstructedGenericType { get; }
+        public bool IsEnum { get; }
+        public bool IsExplicitLayout { get; }
+        public abstract bool IsGenericParameter { get; }
+        public virtual bool IsGenericType { get; }
+        public virtual bool IsGenericTypeDefinition { get; }
+        public bool IsImport { get; }
+        public bool IsInterface { get; }
+        public bool IsLayoutSequential { get; }
+        public bool IsMarshalByRef { get; }
+        public bool IsNested { get; }
+        public bool IsNestedAssembly { get; }
+        public bool IsNestedFamANDAssem { get; }
+        public bool IsNestedFamily { get; }
+        public bool IsNestedFamORAssem { get; }
+        public bool IsNestedPrivate { get; }
+        public bool IsNestedPublic { get; }
+        public bool IsNotPublic { get; }
+        public virtual bool IsPointer { get; }
+        public bool IsPrimitive { get; }
+        public bool IsPublic { get; }
+        public bool IsSealed { get; }
+        public virtual bool IsSerializable { get; }
+        public bool IsSpecialName { get; }
+        public bool IsUnicodeClass { get; }
+        public bool IsValueType { get; }
+        public bool IsVisible { get; }
+        public override MemberTypes MemberType { get; }
+        public abstract new Module Module { get; }
+        public abstract string Name { get; }
+        public abstract string Namespace { get; }
+        public override Type ReflectedType { get; }
+        public virtual StructLayoutAttribute StructLayoutAttribute { get; }
+        public virtual RuntimeTypeHandle TypeHandle { get; }
+        public ConstructorInfo TypeInitializer { get; }
+        public abstract Type UnderlyingSystemType { get; }
+        public override bool Equals(object o);
+        public bool Equals(Type o);
+        public virtual Type[] FindInterfaces(TypeFilter filter, object filterCriteria);
+        public virtual MemberInfo[] FindMembers(MemberTypes memberType, BindingFlags bindingAttr, MemberFilter filter, object filterCriteria);
+        public abstract int GetArrayRank();
+        protected abstract TypeAttributes GetAttributeFlagsImpl();
+        public ConstructorInfo GetConstructor(BindingFlags bindingAttr, Binder binder, Type[] types, ParameterModifier[] modifiers);
+        public ConstructorInfo GetConstructor(Type[] types);
+        protected abstract ConstructorInfo GetConstructorImpl(BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
+        public ConstructorInfo[] GetConstructors();
+        public abstract ConstructorInfo[] GetConstructors(BindingFlags bindingAttr);
+        public virtual MemberInfo[] GetDefaultMembers();
+        public abstract Type GetElementType();
+        public virtual string GetEnumName(object value);
+        public virtual string[] GetEnumNames();
+        public virtual Type GetEnumUnderlyingType();
+        public virtual Array GetEnumValues();
+        public EventInfo GetEvent(string name);
+        public abstract EventInfo GetEvent(string name, BindingFlags bindingAttr);
+        public virtual EventInfo[] GetEvents();
+        public abstract EventInfo[] GetEvents(BindingFlags bindingAttr);
+        public FieldInfo GetField(string name);
+        public abstract FieldInfo GetField(string name, BindingFlags bindingAttr);
+        public FieldInfo[] GetFields();
+        public abstract FieldInfo[] GetFields(BindingFlags bindingAttr);
+        public virtual Type[] GetGenericArguments();
+        public virtual Type[] GetGenericParameterConstraints();
+        public abstract Type GetGenericTypeDefinition();
+        public override int GetHashCode();
+        public Type GetInterface(string name);
+        public abstract Type GetInterface(string name, bool ignoreCase);
+        public virtual InterfaceMapping GetInterfaceMap(Type interfaceType);
+        public abstract Type[] GetInterfaces();
+        public MemberInfo[] GetMember(string name);
+        public virtual MemberInfo[] GetMember(string name, BindingFlags bindingAttr);
+        public virtual MemberInfo[] GetMember(string name, MemberTypes type, BindingFlags bindingAttr);
+        public MemberInfo[] GetMembers();
+        public abstract MemberInfo[] GetMembers(BindingFlags bindingAttr);
+        public MethodInfo GetMethod(string name);
+        public MethodInfo GetMethod(string name, BindingFlags bindingAttr);
+        public MethodInfo GetMethod(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
+        public MethodInfo GetMethod(string name, BindingFlags bindingAttr, Binder binder, Type[] types, ParameterModifier[] modifiers);
+        public MethodInfo GetMethod(string name, Type[] types);
+        public MethodInfo GetMethod(string name, Type[] types, ParameterModifier[] modifiers);
+        protected abstract MethodInfo GetMethodImpl(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
+        public MethodInfo[] GetMethods();
+        public abstract MethodInfo[] GetMethods(BindingFlags bindingAttr);
+        public Type GetNestedType(string name);
+        public abstract Type GetNestedType(string name, BindingFlags bindingAttr);
+        public Type[] GetNestedTypes();
+        public abstract Type[] GetNestedTypes(BindingFlags bindingAttr);
+        public PropertyInfo[] GetProperties();
+        public abstract PropertyInfo[] GetProperties(BindingFlags bindingAttr);
+        public PropertyInfo GetProperty(string name);
+        public PropertyInfo GetProperty(string name, BindingFlags bindingAttr);
+        public PropertyInfo GetProperty(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers);
+        public PropertyInfo GetProperty(string name, Type returnType);
+        public PropertyInfo GetProperty(string name, Type returnType, Type[] types);
+        public PropertyInfo GetProperty(string name, Type returnType, Type[] types, ParameterModifier[] modifiers);
+        public PropertyInfo GetProperty(string name, Type[] types);
+        protected abstract PropertyInfo GetPropertyImpl(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers);
+        public static Type GetType(string typeName);
+        public static Type GetType(string typeName, bool throwOnError);
+        public static Type GetType(string typeName, bool throwOnError, bool ignoreCase);
+        public static TypeCode GetTypeCode(Type type);
+        public static Type GetTypeFromHandle(RuntimeTypeHandle handle);
+        public static RuntimeTypeHandle GetTypeHandle(object o);
+        protected abstract bool HasElementTypeImpl();
+        public object InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, object[] args);
+        public abstract object InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, object[] args, ParameterModifier[] modifiers, CultureInfo culture, string[] namedParameters);
+        protected abstract bool IsArrayImpl();
+        public virtual bool IsAssignableFrom(Type c);
+        protected abstract bool IsByRefImpl();
+        protected abstract bool IsCOMObjectImpl();
+        public virtual bool IsEnumDefined(object value);
+        public virtual bool IsEquivalentTo(Type other);
+        public virtual bool IsInstanceOfType(object o);
+        protected abstract bool IsPointerImpl();
+        protected abstract bool IsPrimitiveImpl();
+        public virtual bool IsSubclassOf(Type c);
+        protected virtual bool IsValueTypeImpl();
+        public abstract Type MakeArrayType();
+        public abstract Type MakeArrayType(int rank);
+        public abstract Type MakeByRefType();
+        public abstract Type MakeGenericType(params Type[] typeArguments);
+        public abstract Type MakePointerType();
+        public override string ToString();
+    }
+    public class TypeAccessException : TypeLoadException {
+        public TypeAccessException();
+        public TypeAccessException(string message);
+        public TypeAccessException(string message, Exception inner);
+    }
+    public enum TypeCode {
+        Boolean = 3,
+        Byte = 6,
+        Char = 4,
+        DateTime = 16,
+        DBNull = 2,
+        Decimal = 15,
+        Double = 14,
+        Empty = 0,
+        Int16 = 7,
+        Int32 = 9,
+        Int64 = 11,
+        Object = 1,
+        SByte = 5,
+        Single = 13,
+        String = 18,
+        UInt16 = 8,
+        UInt32 = 10,
+        UInt64 = 12,
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct TypedReference {
+        public override bool Equals(object o);
+        public override int GetHashCode();
+    }
+    public sealed class TypeInitializationException : Exception {
+        public TypeInitializationException(string fullTypeName, Exception innerException);
+        public string TypeName { get; }
+    }
+    public class TypeLoadException : Exception {
+        public TypeLoadException();
+        public TypeLoadException(string message);
+        public TypeLoadException(string message, Exception inner);
+        public override string Message { get; }
+        public string TypeName { get; }
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct UInt16 : IComparable, IComparable<ushort>, IConvertible, IEquatable<ushort>, IFormattable {
+        public const ushort MaxValue = (ushort)65535;
+        public const ushort MinValue = (ushort)0;
+        public int CompareTo(object value);
+        public int CompareTo(ushort value);
+        public override bool Equals(object obj);
+        public bool Equals(ushort obj);
+        public override int GetHashCode();
+        public TypeCode GetTypeCode();
+        public static ushort Parse(string s);
+        public static ushort Parse(string s, NumberStyles style);
+        public static ushort Parse(string s, NumberStyles style, IFormatProvider provider);
+        public static ushort Parse(string s, IFormatProvider provider);
+        int System.IComparable.CompareTo(object value);
+        TypeCode System.IConvertible.GetTypeCode();
+        bool System.IConvertible.ToBoolean(IFormatProvider provider);
+        byte System.IConvertible.ToByte(IFormatProvider provider);
+        char System.IConvertible.ToChar(IFormatProvider provider);
+        DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
+        Decimal System.IConvertible.ToDecimal(IFormatProvider provider);
+        double System.IConvertible.ToDouble(IFormatProvider provider);
+        short System.IConvertible.ToInt16(IFormatProvider provider);
+        int System.IConvertible.ToInt32(IFormatProvider provider);
+        long System.IConvertible.ToInt64(IFormatProvider provider);
+        sbyte System.IConvertible.ToSByte(IFormatProvider provider);
+        float System.IConvertible.ToSingle(IFormatProvider provider);
+        object System.IConvertible.ToType(Type type, IFormatProvider provider);
+        ushort System.IConvertible.ToUInt16(IFormatProvider provider);
+        uint System.IConvertible.ToUInt32(IFormatProvider provider);
+        ulong System.IConvertible.ToUInt64(IFormatProvider provider);
+        public override string ToString();
+        public string ToString(IFormatProvider provider);
+        public string ToString(string format);
+        public string ToString(string format, IFormatProvider provider);
+        public static bool TryParse(string s, NumberStyles style, IFormatProvider provider, out ushort result);
+        public static bool TryParse(string s, out ushort result);
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct UInt32 : IComparable, IComparable<uint>, IConvertible, IEquatable<uint>, IFormattable {
+        public const uint MaxValue = (uint)4294967295;
+        public const uint MinValue = (uint)0;
+        public int CompareTo(object value);
+        public int CompareTo(uint value);
+        public override bool Equals(object obj);
+        public bool Equals(uint obj);
+        public override int GetHashCode();
+        public TypeCode GetTypeCode();
+        public static uint Parse(string s);
+        public static uint Parse(string s, NumberStyles style);
+        public static uint Parse(string s, NumberStyles style, IFormatProvider provider);
+        public static uint Parse(string s, IFormatProvider provider);
+        int System.IComparable.CompareTo(object value);
+        TypeCode System.IConvertible.GetTypeCode();
+        bool System.IConvertible.ToBoolean(IFormatProvider provider);
+        byte System.IConvertible.ToByte(IFormatProvider provider);
+        char System.IConvertible.ToChar(IFormatProvider provider);
+        DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
+        Decimal System.IConvertible.ToDecimal(IFormatProvider provider);
+        double System.IConvertible.ToDouble(IFormatProvider provider);
+        short System.IConvertible.ToInt16(IFormatProvider provider);
+        int System.IConvertible.ToInt32(IFormatProvider provider);
+        long System.IConvertible.ToInt64(IFormatProvider provider);
+        sbyte System.IConvertible.ToSByte(IFormatProvider provider);
+        float System.IConvertible.ToSingle(IFormatProvider provider);
+        object System.IConvertible.ToType(Type type, IFormatProvider provider);
+        ushort System.IConvertible.ToUInt16(IFormatProvider provider);
+        uint System.IConvertible.ToUInt32(IFormatProvider provider);
+        ulong System.IConvertible.ToUInt64(IFormatProvider provider);
+        public override string ToString();
+        public string ToString(IFormatProvider provider);
+        public string ToString(string format);
+        public string ToString(string format, IFormatProvider provider);
+        public static bool TryParse(string s, NumberStyles style, IFormatProvider provider, out uint result);
+        public static bool TryParse(string s, out uint result);
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct UInt64 : IComparable, IComparable<ulong>, IConvertible, IEquatable<ulong>, IFormattable {
+        public const ulong MaxValue = (ulong)18446744073709551615;
+        public const ulong MinValue = (ulong)0;
+        public int CompareTo(object value);
+        public int CompareTo(ulong value);
+        public override bool Equals(object obj);
+        public bool Equals(ulong obj);
+        public override int GetHashCode();
+        public TypeCode GetTypeCode();
+        public static ulong Parse(string s);
+        public static ulong Parse(string s, NumberStyles style);
+        public static ulong Parse(string s, NumberStyles style, IFormatProvider provider);
+        public static ulong Parse(string s, IFormatProvider provider);
+        int System.IComparable.CompareTo(object value);
+        TypeCode System.IConvertible.GetTypeCode();
+        bool System.IConvertible.ToBoolean(IFormatProvider provider);
+        byte System.IConvertible.ToByte(IFormatProvider provider);
+        char System.IConvertible.ToChar(IFormatProvider provider);
+        DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
+        Decimal System.IConvertible.ToDecimal(IFormatProvider provider);
+        double System.IConvertible.ToDouble(IFormatProvider provider);
+        short System.IConvertible.ToInt16(IFormatProvider provider);
+        int System.IConvertible.ToInt32(IFormatProvider provider);
+        long System.IConvertible.ToInt64(IFormatProvider provider);
+        sbyte System.IConvertible.ToSByte(IFormatProvider provider);
+        float System.IConvertible.ToSingle(IFormatProvider provider);
+        object System.IConvertible.ToType(Type type, IFormatProvider provider);
+        ushort System.IConvertible.ToUInt16(IFormatProvider provider);
+        uint System.IConvertible.ToUInt32(IFormatProvider provider);
+        ulong System.IConvertible.ToUInt64(IFormatProvider provider);
+        public override string ToString();
+        public string ToString(IFormatProvider provider);
+        public string ToString(string format);
+        public string ToString(string format, IFormatProvider provider);
+        public static bool TryParse(string s, NumberStyles style, IFormatProvider provider, out ulong result);
+        public static bool TryParse(string s, out ulong result);
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct UIntPtr {
+        public static readonly UIntPtr Zero;
+        public UIntPtr(uint value);
+        public UIntPtr(ulong value);
+        public unsafe UIntPtr(void* value);
+        public static int Size { get; }
+        public static UIntPtr Add(UIntPtr pointer, int offset);
+        public override bool Equals(object obj);
+        public override int GetHashCode();
+        public static UIntPtr operator +(UIntPtr pointer, int offset);
+        public static bool operator ==(UIntPtr value1, UIntPtr value2);
+        public static explicit operator UIntPtr (uint value);
+        public static explicit operator UIntPtr (ulong value);
+        public static explicit operator uint (UIntPtr value);
+        public static explicit operator ulong (UIntPtr value);
+        public unsafe static explicit operator void* (UIntPtr value);
+        public unsafe static explicit operator UIntPtr (void* value);
+        public static bool operator !=(UIntPtr value1, UIntPtr value2);
+        public static UIntPtr operator -(UIntPtr pointer, int offset);
+        public static UIntPtr Subtract(UIntPtr pointer, int offset);
+        public unsafe void* ToPointer();
+        public override string ToString();
+        public uint ToUInt32();
+        public ulong ToUInt64();
+    }
+    public class UnauthorizedAccessException : Exception {
+        public UnauthorizedAccessException();
+        public UnauthorizedAccessException(string message);
+        public UnauthorizedAccessException(string message, Exception inner);
+    }
+    public class UnhandledExceptionEventArgs : EventArgs {
+        public UnhandledExceptionEventArgs(object exception, bool isTerminating);
+        public object ExceptionObject { get; }
+        public bool IsTerminating { get; }
+    }
+    public delegate void UnhandledExceptionEventHandler(object sender, UnhandledExceptionEventArgs e);
+    public class Uri {
+        public Uri(string uriString);
+        public Uri(string uriString, UriKind uriKind);
+        public Uri(Uri baseUri, string relativeUri);
+        public Uri(Uri baseUri, Uri relativeUri);
+        public string AbsolutePath { get; }
+        public string AbsoluteUri { get; }
+        public string Authority { get; }
+        public string DnsSafeHost { get; }
+        public string Fragment { get; }
+        public string Host { get; }
+        public UriHostNameType HostNameType { get; }
+        public string IdnHost { get; }
+        public bool IsAbsoluteUri { get; }
+        public bool IsDefaultPort { get; }
+        public bool IsFile { get; }
+        public bool IsLoopback { get; }
+        public bool IsUnc { get; }
+        public string LocalPath { get; }
+        public string OriginalString { get; }
+        public string PathAndQuery { get; }
+        public int Port { get; }
+        public string Query { get; }
+        public string Scheme { get; }
+        public string[] Segments { get; }
+        public bool UserEscaped { get; }
+        public string UserInfo { get; }
+        public static UriHostNameType CheckHostName(string name);
+        public static bool CheckSchemeName(string schemeName);
+        public static int Compare(Uri uri1, Uri uri2, UriComponents partsToCompare, UriFormat compareFormat, StringComparison comparisonType);
+        public override bool Equals(object comparand);
+        public static string EscapeDataString(string stringToEscape);
+        public static string EscapeUriString(string stringToEscape);
+        public string GetComponents(UriComponents components, UriFormat format);
+        public override int GetHashCode();
+        public bool IsBaseOf(Uri uri);
+        public bool IsWellFormedOriginalString();
+        public static bool IsWellFormedUriString(string uriString, UriKind uriKind);
+        public Uri MakeRelativeUri(Uri uri);
+        public static bool operator ==(Uri uri1, Uri uri2);
+        public static bool operator !=(Uri uri1, Uri uri2);
+        public override string ToString();
+        public static bool TryCreate(string uriString, UriKind uriKind, out Uri result);
+        public static bool TryCreate(Uri baseUri, string relativeUri, out Uri result);
+        public static bool TryCreate(Uri baseUri, Uri relativeUri, out Uri result);
+        public static string UnescapeDataString(string stringToUnescape);
+    }
+    public class UriBuilder {
+        public UriBuilder();
+        public UriBuilder(string uri);
+        public UriBuilder(string schemeName, string hostName);
+        public UriBuilder(string scheme, string host, int portNumber);
+        public UriBuilder(string scheme, string host, int port, string pathValue);
+        public UriBuilder(string scheme, string host, int port, string path, string extraValue);
+        public UriBuilder(Uri uri);
+        public string Fragment { get; set; }
+        public string Host { get; set; }
+        public string Password { get; set; }
+        public string Path { get; set; }
+        public int Port { get; set; }
+        public string Query { get; set; }
+        public string Scheme { get; set; }
+        public Uri Uri { get; }
+        public string UserName { get; set; }
+        public override bool Equals(object rparam);
+        public override int GetHashCode();
+        public override string ToString();
+    }
+    public enum UriComponents {
+        AbsoluteUri = 127,
+        Fragment = 64,
+        Host = 4,
+        HostAndPort = 132,
+        HttpRequestUrl = 61,
+        KeepDelimiter = 1073741824,
+        NormalizedHost = 256,
+        Path = 16,
+        PathAndQuery = 48,
+        Port = 8,
+        Query = 32,
+        Scheme = 1,
+        SchemeAndServer = 13,
+        SerializationInfoString = -2147483648,
+        StrongAuthority = 134,
+        StrongPort = 128,
+        UserInfo = 2,
+    }
+    public enum UriFormat {
+        SafeUnescaped = 3,
+        Unescaped = 2,
+        UriEscaped = 1,
+    }
+    public class UriFormatException : FormatException {
+        public UriFormatException();
+        public UriFormatException(string textString);
+        public UriFormatException(string textString, Exception e);
+    }
+    public enum UriHostNameType {
+        Basic = 1,
+        Dns = 2,
+        IPv4 = 3,
+        IPv6 = 4,
+        Unknown = 0,
+    }
+    public enum UriKind {
+        Absolute = 1,
+        Relative = 2,
+        RelativeOrAbsolute = 0,
+    }
+    public class UriTypeConverter : TypeConverter {
+        public UriTypeConverter();
+        public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
+        public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
+        public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
+        public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
+    }
+    public abstract class ValueType {
+        protected ValueType();
+        public override bool Equals(object obj);
+        public override int GetHashCode();
+        public override string ToString();
+    }
+    public sealed class Version : IComparable, IComparable<Version>, IEquatable<Version> {
+        public Version(int major, int minor);
+        public Version(int major, int minor, int build);
+        public Version(int major, int minor, int build, int revision);
+        public Version(string version);
+        public int Build { get; }
+        public int Major { get; }
+        public short MajorRevision { get; }
+        public int Minor { get; }
+        public short MinorRevision { get; }
+        public int Revision { get; }
+        public object Clone();
+        public int CompareTo(object version);
+        public int CompareTo(Version value);
+        public override bool Equals(object obj);
+        public bool Equals(Version obj);
+        public override int GetHashCode();
+        public static bool operator ==(Version v1, Version v2);
+        public static bool operator >(Version v1, Version v2);
+        public static bool operator >=(Version v1, Version v2);
+        public static bool operator !=(Version v1, Version v2);
+        public static bool operator <(Version v1, Version v2);
+        public static bool operator <=(Version v1, Version v2);
+        public static Version Parse(string input);
+        int System.IComparable.CompareTo(object version);
+        public override string ToString();
+        public string ToString(int fieldCount);
+        public static bool TryParse(string input, out Version result);
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Size=1)]
+    public struct Void
+    public class WeakReference {
+        protected WeakReference();
+        public WeakReference(object target);
+        public WeakReference(object target, bool trackResurrection);
+        public virtual bool IsAlive { get; }
+        public virtual object Target { get; set; }
+        public virtual bool TrackResurrection { get; }
+        ~WeakReference();
+    }
+    public sealed class WeakReference<T> where T : class {
+        public WeakReference(T target);
+        public WeakReference(T target, bool trackResurrection);
+        ~WeakReference();
+        public void SetTarget(T target);
+        public bool TryGetTarget(out T target);
+    }
+}
```

## System.Buffers

```c#
+namespace System.Buffers {
+    public abstract class ArrayPool<T> {
+        protected ArrayPool();
+        public static ArrayPool<T> Shared { [MethodImpl(AggressiveInlining)]get; }
+        public static ArrayPool<T> Create();
+        public static ArrayPool<T> Create(int maxArrayLength, int maxArraysPerBucket);
+        public abstract T[] Rent(int minimumLength);
+        public abstract void Return(T[] array, bool clearArray=false);
+    }
+}
```

## System.CodeDom.Compiler

```c#
+namespace System.CodeDom.Compiler {
+    public sealed class GeneratedCodeAttribute : Attribute {
+        public GeneratedCodeAttribute(string tool, string version);
+        public string Tool { get; }
+        public string Version { get; }
+    }
+}
```

## System.Collections

```c#
+namespace System.Collections {
+    public class ArrayList : ICollection, IEnumerable, IList {
+        public ArrayList();
+        public ArrayList(ICollection c);
+        public ArrayList(int capacity);
+        public virtual int Capacity { get; set; }
+        public virtual int Count { get; }
+        public virtual bool IsFixedSize { get; }
+        public virtual bool IsReadOnly { get; }
+        public virtual bool IsSynchronized { get; }
+        public virtual object SyncRoot { get; }
+        public virtual object this[int index] { get; set; }
+        public static ArrayList Adapter(IList list);
+        public virtual int Add(object value);
+        public virtual void AddRange(ICollection c);
+        public virtual int BinarySearch(int index, int count, object value, IComparer comparer);
+        public virtual int BinarySearch(object value);
+        public virtual int BinarySearch(object value, IComparer comparer);
+        public virtual void Clear();
+        public virtual object Clone();
+        public virtual bool Contains(object item);
+        public virtual void CopyTo(Array array);
+        public virtual void CopyTo(Array array, int arrayIndex);
+        public virtual void CopyTo(int index, Array array, int arrayIndex, int count);
+        public static ArrayList FixedSize(ArrayList list);
+        public static IList FixedSize(IList list);
+        public virtual IEnumerator GetEnumerator();
+        public virtual IEnumerator GetEnumerator(int index, int count);
+        public virtual ArrayList GetRange(int index, int count);
+        public virtual int IndexOf(object value);
+        public virtual int IndexOf(object value, int startIndex);
+        public virtual int IndexOf(object value, int startIndex, int count);
+        public virtual void Insert(int index, object value);
+        public virtual void InsertRange(int index, ICollection c);
+        public virtual int LastIndexOf(object value);
+        public virtual int LastIndexOf(object value, int startIndex);
+        public virtual int LastIndexOf(object value, int startIndex, int count);
+        public static ArrayList ReadOnly(ArrayList list);
+        public static IList ReadOnly(IList list);
+        public virtual void Remove(object obj);
+        public virtual void RemoveAt(int index);
+        public virtual void RemoveRange(int index, int count);
+        public static ArrayList Repeat(object value, int count);
+        public virtual void Reverse();
+        public virtual void Reverse(int index, int count);
+        public virtual void SetRange(int index, ICollection c);
+        public virtual void Sort();
+        public virtual void Sort(IComparer comparer);
+        public virtual void Sort(int index, int count, IComparer comparer);
+        public static ArrayList Synchronized(ArrayList list);
+        public static IList Synchronized(IList list);
+        public virtual object[] ToArray();
+        public virtual Array ToArray(Type type);
+        public virtual void TrimToSize();
+    }
+    public sealed class BitArray : ICollection, IEnumerable {
+        public BitArray(bool[] values);
+        public BitArray(byte[] bytes);
+        public BitArray(BitArray bits);
+        public BitArray(int length);
+        public BitArray(int length, bool defaultValue);
+        public BitArray(int[] values);
+        public int Count { get; }
+        public bool IsReadOnly { get; }
+        public bool IsSynchronized { get; }
+        public int Length { get; set; }
+        public object SyncRoot { get; }
+        int System.Collections.ICollection.Count { get; }
+        bool System.Collections.ICollection.IsSynchronized { get; }
+        object System.Collections.ICollection.SyncRoot { get; }
+        public bool this[int index] { get; set; }
+        public BitArray And(BitArray value);
+        public object Clone();
+        public void CopyTo(Array array, int index);
+        public bool Get(int index);
+        public IEnumerator GetEnumerator();
+        public BitArray Not();
+        public BitArray Or(BitArray value);
+        public void Set(int index, bool value);
+        public void SetAll(bool value);
+        void System.Collections.ICollection.CopyTo(Array array, int index);
+        public BitArray Xor(BitArray value);
+    }
+    public class CaseInsensitiveComparer : IComparer {
+        public CaseInsensitiveComparer();
+        public CaseInsensitiveComparer(CultureInfo culture);
+        public static CaseInsensitiveComparer Default { get; }
+        public static CaseInsensitiveComparer DefaultInvariant { get; }
+        public int Compare(object a, object b);
+    }
+    public abstract class CollectionBase : ICollection, IEnumerable, IList {
+        protected CollectionBase();
+        protected CollectionBase(int capacity);
+        public int Capacity { get; set; }
+        public int Count { get; }
+        protected ArrayList InnerList { get; }
+        protected IList List { get; }
+        bool System.Collections.ICollection.IsSynchronized { get; }
+        object System.Collections.ICollection.SyncRoot { get; }
+        bool System.Collections.IList.IsFixedSize { get; }
+        bool System.Collections.IList.IsReadOnly { get; }
+        object System.Collections.IList.this[int index] { get; set; }
+        public void Clear();
+        public IEnumerator GetEnumerator();
+        protected virtual void OnClear();
+        protected virtual void OnClearComplete();
+        protected virtual void OnInsert(int index, object value);
+        protected virtual void OnInsertComplete(int index, object value);
+        protected virtual void OnRemove(int index, object value);
+        protected virtual void OnRemoveComplete(int index, object value);
+        protected virtual void OnSet(int index, object oldValue, object newValue);
+        protected virtual void OnSetComplete(int index, object oldValue, object newValue);
+        protected virtual void OnValidate(object value);
+        public void RemoveAt(int index);
+        void System.Collections.ICollection.CopyTo(Array array, int index);
+        int System.Collections.IList.Add(object value);
+        bool System.Collections.IList.Contains(object value);
+        int System.Collections.IList.IndexOf(object value);
+        void System.Collections.IList.Insert(int index, object value);
+        void System.Collections.IList.Remove(object value);
+    }
+    public sealed class Comparer : IComparer {
+        public static readonly Comparer Default;
+        public static readonly Comparer DefaultInvariant;
+        public Comparer(CultureInfo culture);
+        public int Compare(object a, object b);
+    }
+    public abstract class DictionaryBase : ICollection, IDictionary, IEnumerable {
+        protected DictionaryBase();
+        public int Count { get; }
+        protected IDictionary Dictionary { get; }
+        protected Hashtable InnerHashtable { get; }
+        bool System.Collections.ICollection.IsSynchronized { get; }
+        object System.Collections.ICollection.SyncRoot { get; }
+        bool System.Collections.IDictionary.IsFixedSize { get; }
+        bool System.Collections.IDictionary.IsReadOnly { get; }
+        object System.Collections.IDictionary.this[object key] { get; set; }
+        ICollection System.Collections.IDictionary.Keys { get; }
+        ICollection System.Collections.IDictionary.Values { get; }
+        public void Clear();
+        public void CopyTo(Array array, int index);
+        public IDictionaryEnumerator GetEnumerator();
+        protected virtual void OnClear();
+        protected virtual void OnClearComplete();
+        protected virtual object OnGet(object key, object currentValue);
+        protected virtual void OnInsert(object key, object value);
+        protected virtual void OnInsertComplete(object key, object value);
+        protected virtual void OnRemove(object key, object value);
+        protected virtual void OnRemoveComplete(object key, object value);
+        protected virtual void OnSet(object key, object oldValue, object newValue);
+        protected virtual void OnSetComplete(object key, object oldValue, object newValue);
+        protected virtual void OnValidate(object key, object value);
+        void System.Collections.IDictionary.Add(object key, object value);
+        bool System.Collections.IDictionary.Contains(object key);
+        void System.Collections.IDictionary.Remove(object key);
+        IEnumerator System.Collections.IEnumerable.GetEnumerator();
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct DictionaryEntry {
+        public DictionaryEntry(object key, object value);
+        public object Key { get; set; }
+        public object Value { get; set; }
+    }
+    public class Hashtable : ICollection, IDictionary, IEnumerable {
+        public Hashtable();
+        public Hashtable(IDictionary d);
+        public Hashtable(IDictionary d, IEqualityComparer equalityComparer);
+        public Hashtable(IDictionary d, float loadFactor);
+        public Hashtable(IDictionary d, float loadFactor, IEqualityComparer equalityComparer);
+        public Hashtable(IEqualityComparer equalityComparer);
+        public Hashtable(int capacity);
+        public Hashtable(int capacity, IEqualityComparer equalityComparer);
+        public Hashtable(int capacity, float loadFactor);
+        public Hashtable(int capacity, float loadFactor, IEqualityComparer equalityComparer);
+        public virtual int Count { get; }
+        protected IEqualityComparer EqualityComparer { get; }
+        public virtual bool IsFixedSize { get; }
+        public virtual bool IsReadOnly { get; }
+        public virtual bool IsSynchronized { get; }
+        public virtual ICollection Keys { get; }
+        public virtual object SyncRoot { get; }
+        public virtual object this[object key] { get; set; }
+        public virtual ICollection Values { get; }
+        public virtual void Add(object key, object value);
+        public virtual void Clear();
+        public virtual object Clone();
+        public virtual bool Contains(object key);
+        public virtual bool ContainsKey(object key);
+        public virtual bool ContainsValue(object value);
+        public virtual void CopyTo(Array array, int arrayIndex);
+        public virtual IDictionaryEnumerator GetEnumerator();
+        protected virtual int GetHash(object key);
+        protected virtual bool KeyEquals(object item, object key);
+        public virtual void Remove(object key);
+        public static Hashtable Synchronized(Hashtable table);
+        IEnumerator System.Collections.IEnumerable.GetEnumerator();
+    }
+    public interface ICollection : IEnumerable {
+        int Count { get; }
+        bool IsSynchronized { get; }
+        object SyncRoot { get; }
+        void CopyTo(Array array, int index);
+    }
+    public interface IComparer {
+        int Compare(object x, object y);
+    }
+    public interface IDictionary : ICollection, IEnumerable {
+        bool IsFixedSize { get; }
+        bool IsReadOnly { get; }
+        ICollection Keys { get; }
+        object this[object key] { get; set; }
+        ICollection Values { get; }
+        void Add(object key, object value);
+        void Clear();
+        bool Contains(object key);
+        new IDictionaryEnumerator GetEnumerator();
+        void Remove(object key);
+    }
+    public interface IDictionaryEnumerator : IEnumerator {
+        DictionaryEntry Entry { get; }
+        object Key { get; }
+        object Value { get; }
+    }
+    public interface IEnumerable {
+        IEnumerator GetEnumerator();
+    }
+    public interface IEnumerator {
+        object Current { get; }
+        bool MoveNext();
+        void Reset();
+    }
+    public interface IEqualityComparer {
+        bool Equals(object x, object y);
+        int GetHashCode(object obj);
+    }
+    public interface IList : ICollection, IEnumerable {
+        bool IsFixedSize { get; }
+        bool IsReadOnly { get; }
+        object this[int index] { get; set; }
+        int Add(object value);
+        void Clear();
+        bool Contains(object value);
+        int IndexOf(object value);
+        void Insert(int index, object value);
+        void Remove(object value);
+        void RemoveAt(int index);
+    }
+    public interface IStructuralComparable {
+        int CompareTo(object other, IComparer comparer);
+    }
+    public interface IStructuralEquatable {
+        bool Equals(object other, IEqualityComparer comparer);
+        int GetHashCode(IEqualityComparer comparer);
+    }
+    public class Queue : ICollection, IEnumerable {
+        public Queue();
+        public Queue(ICollection col);
+        public Queue(int capacity);
+        public Queue(int capacity, float growFactor);
+        public virtual int Count { get; }
+        public virtual bool IsSynchronized { get; }
+        public virtual object SyncRoot { get; }
+        public virtual void Clear();
+        public virtual object Clone();
+        public virtual bool Contains(object obj);
+        public virtual void CopyTo(Array array, int index);
+        public virtual object Dequeue();
+        public virtual void Enqueue(object obj);
+        public virtual IEnumerator GetEnumerator();
+        public virtual object Peek();
+        public static Queue Synchronized(Queue queue);
+        public virtual object[] ToArray();
+        public virtual void TrimToSize();
+    }
+    public abstract class ReadOnlyCollectionBase : ICollection, IEnumerable {
+        protected ReadOnlyCollectionBase();
+        public virtual int Count { get; }
+        protected ArrayList InnerList { get; }
+        bool System.Collections.ICollection.IsSynchronized { get; }
+        object System.Collections.ICollection.SyncRoot { get; }
+        public virtual IEnumerator GetEnumerator();
+        void System.Collections.ICollection.CopyTo(Array array, int index);
+    }
+    public class SortedList : ICollection, IDictionary, IEnumerable {
+        public SortedList();
+        public SortedList(IComparer comparer);
+        public SortedList(IComparer comparer, int capacity);
+        public SortedList(IDictionary d);
+        public SortedList(IDictionary d, IComparer comparer);
+        public SortedList(int initialCapacity);
+        public virtual int Capacity { get; set; }
+        public virtual int Count { get; }
+        public virtual bool IsFixedSize { get; }
+        public virtual bool IsReadOnly { get; }
+        public virtual bool IsSynchronized { get; }
+        public virtual ICollection Keys { get; }
+        public virtual object SyncRoot { get; }
+        public virtual object this[object key] { get; set; }
+        public virtual ICollection Values { get; }
+        public virtual void Add(object key, object value);
+        public virtual void Clear();
+        public virtual object Clone();
+        public virtual bool Contains(object key);
+        public virtual bool ContainsKey(object key);
+        public virtual bool ContainsValue(object value);
+        public virtual void CopyTo(Array array, int arrayIndex);
+        public virtual object GetByIndex(int index);
+        public virtual IDictionaryEnumerator GetEnumerator();
+        public virtual object GetKey(int index);
+        public virtual IList GetKeyList();
+        public virtual IList GetValueList();
+        public virtual int IndexOfKey(object key);
+        public virtual int IndexOfValue(object value);
+        public virtual void Remove(object key);
+        public virtual void RemoveAt(int index);
+        public virtual void SetByIndex(int index, object value);
+        public static SortedList Synchronized(SortedList list);
+        IEnumerator System.Collections.IEnumerable.GetEnumerator();
+        public virtual void TrimToSize();
+    }
+    public class Stack : ICollection, IEnumerable {
+        public Stack();
+        public Stack(ICollection col);
+        public Stack(int initialCapacity);
+        public virtual int Count { get; }
+        public virtual bool IsSynchronized { get; }
+        public virtual object SyncRoot { get; }
+        public virtual void Clear();
+        public virtual object Clone();
+        public virtual bool Contains(object obj);
+        public virtual void CopyTo(Array array, int index);
+        public virtual IEnumerator GetEnumerator();
+        public virtual object Peek();
+        public virtual object Pop();
+        public virtual void Push(object obj);
+        public static Stack Synchronized(Stack stack);
+        public virtual object[] ToArray();
+    }
+    public static class StructuralComparisons {
+        public static IComparer StructuralComparer { get; }
+        public static IEqualityComparer StructuralEqualityComparer { get; }
+    }
+}
```

## System.Collections.Concurrent

```c#
+namespace System.Collections.Concurrent {
+    public class BlockingCollection<T> : ICollection, IDisposable, IEnumerable, IEnumerable<T>, IReadOnlyCollection<T> {
+        public BlockingCollection();
+        public BlockingCollection(IProducerConsumerCollection<T> collection);
+        public BlockingCollection(IProducerConsumerCollection<T> collection, int boundedCapacity);
+        public BlockingCollection(int boundedCapacity);
+        public int BoundedCapacity { get; }
+        public int Count { get; }
+        public bool IsAddingCompleted { get; }
+        public bool IsCompleted { get; }
+        bool System.Collections.ICollection.IsSynchronized { get; }
+        object System.Collections.ICollection.SyncRoot { get; }
+        public void Add(T item);
+        public void Add(T item, CancellationToken cancellationToken);
+        public static int AddToAny(BlockingCollection<T>[] collections, T item);
+        public static int AddToAny(BlockingCollection<T>[] collections, T item, CancellationToken cancellationToken);
+        public void CompleteAdding();
+        public void CopyTo(T[] array, int index);
+        public void Dispose();
+        protected virtual void Dispose(bool disposing);
+        public IEnumerable<T> GetConsumingEnumerable();
+        public IEnumerable<T> GetConsumingEnumerable(CancellationToken cancellationToken);
+        IEnumerator<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
+        void System.Collections.ICollection.CopyTo(Array array, int index);
+        IEnumerator System.Collections.IEnumerable.GetEnumerator();
+        public T Take();
+        public T Take(CancellationToken cancellationToken);
+        public static int TakeFromAny(BlockingCollection<T>[] collections, out T item);
+        public static int TakeFromAny(BlockingCollection<T>[] collections, out T item, CancellationToken cancellationToken);
+        public T[] ToArray();
+        public bool TryAdd(T item);
+        public bool TryAdd(T item, int millisecondsTimeout);
+        public bool TryAdd(T item, int millisecondsTimeout, CancellationToken cancellationToken);
+        public bool TryAdd(T item, TimeSpan timeout);
+        public static int TryAddToAny(BlockingCollection<T>[] collections, T item);
+        public static int TryAddToAny(BlockingCollection<T>[] collections, T item, int millisecondsTimeout);
+        public static int TryAddToAny(BlockingCollection<T>[] collections, T item, int millisecondsTimeout, CancellationToken cancellationToken);
+        public static int TryAddToAny(BlockingCollection<T>[] collections, T item, TimeSpan timeout);
+        public bool TryTake(out T item);
+        public bool TryTake(out T item, int millisecondsTimeout);
+        public bool TryTake(out T item, int millisecondsTimeout, CancellationToken cancellationToken);
+        public bool TryTake(out T item, TimeSpan timeout);
+        public static int TryTakeFromAny(BlockingCollection<T>[] collections, out T item);
+        public static int TryTakeFromAny(BlockingCollection<T>[] collections, out T item, int millisecondsTimeout);
+        public static int TryTakeFromAny(BlockingCollection<T>[] collections, out T item, int millisecondsTimeout, CancellationToken cancellationToken);
+        public static int TryTakeFromAny(BlockingCollection<T>[] collections, out T item, TimeSpan timeout);
+    }
+    public class ConcurrentBag<T> : ICollection, IEnumerable, IEnumerable<T>, IProducerConsumerCollection<T>, IReadOnlyCollection<T> {
+        public ConcurrentBag();
+        public ConcurrentBag(IEnumerable<T> collection);
+        public int Count { get; }
+        public bool IsEmpty { get; }
+        bool System.Collections.ICollection.IsSynchronized { get; }
+        object System.Collections.ICollection.SyncRoot { get; }
+        public void Add(T item);
+        public void CopyTo(T[] array, int index);
+        public IEnumerator<T> GetEnumerator();
+        bool System.Collections.Concurrent.IProducerConsumerCollection<T>.TryAdd(T item);
+        void System.Collections.ICollection.CopyTo(Array array, int index);
+        IEnumerator System.Collections.IEnumerable.GetEnumerator();
+        public T[] ToArray();
+        public bool TryPeek(out T result);
+        public bool TryTake(out T result);
+    }
+    public class ConcurrentDictionary<TKey, TValue> : ICollection, ICollection<KeyValuePair<TKey, TValue>>, IDictionary, IDictionary<TKey, TValue>, IEnumerable, IEnumerable<KeyValuePair<TKey, TValue>>, IReadOnlyCollection<KeyValuePair<TKey, TValue>>, IReadOnlyDictionary<TKey, TValue> {
+        public ConcurrentDictionary();
+        public ConcurrentDictionary(IEnumerable<KeyValuePair<TKey, TValue>> collection);
+        public ConcurrentDictionary(IEnumerable<KeyValuePair<TKey, TValue>> collection, IEqualityComparer<TKey> comparer);
+        public ConcurrentDictionary(IEqualityComparer<TKey> comparer);
+        public ConcurrentDictionary(int concurrencyLevel, IEnumerable<KeyValuePair<TKey, TValue>> collection, IEqualityComparer<TKey> comparer);
+        public ConcurrentDictionary(int concurrencyLevel, int capacity);
+        public ConcurrentDictionary(int concurrencyLevel, int capacity, IEqualityComparer<TKey> comparer);
+        public int Count { get; }
+        public bool IsEmpty { get; }
+        public ICollection<TKey> Keys { get; }
+        bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.IsReadOnly { get; }
+        IEnumerable<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Keys { get; }
+        IEnumerable<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Values { get; }
+        bool System.Collections.ICollection.IsSynchronized { get; }
+        object System.Collections.ICollection.SyncRoot { get; }
+        bool System.Collections.IDictionary.IsFixedSize { get; }
+        bool System.Collections.IDictionary.IsReadOnly { get; }
+        object System.Collections.IDictionary.this[object key] { get; set; }
+        ICollection System.Collections.IDictionary.Keys { get; }
+        ICollection System.Collections.IDictionary.Values { get; }
+        public TValue this[TKey key] { get; set; }
+        public ICollection<TValue> Values { get; }
+        public TValue AddOrUpdate(TKey key, Func<TKey, TValue> addValueFactory, Func<TKey, TValue, TValue> updateValueFactory);
+        public TValue AddOrUpdate(TKey key, TValue addValue, Func<TKey, TValue, TValue> updateValueFactory);
+        public void Clear();
+        public bool ContainsKey(TKey key);
+        public IEnumerator<KeyValuePair<TKey, TValue>> GetEnumerator();
+        public TValue GetOrAdd(TKey key, Func<TKey, TValue> valueFactory);
+        public TValue GetOrAdd(TKey key, TValue value);
+        void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Add(KeyValuePair<TKey, TValue> keyValuePair);
+        bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Contains(KeyValuePair<TKey, TValue> keyValuePair);
+        void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.CopyTo(KeyValuePair<TKey, TValue>[] array, int index);
+        bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Remove(KeyValuePair<TKey, TValue> keyValuePair);
+        void System.Collections.Generic.IDictionary<TKey,TValue>.Add(TKey key, TValue value);
+        bool System.Collections.Generic.IDictionary<TKey,TValue>.Remove(TKey key);
+        void System.Collections.ICollection.CopyTo(Array array, int index);
+        void System.Collections.IDictionary.Add(object key, object value);
+        bool System.Collections.IDictionary.Contains(object key);
+        IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator();
+        void System.Collections.IDictionary.Remove(object key);
+        IEnumerator System.Collections.IEnumerable.GetEnumerator();
+        public KeyValuePair<TKey, TValue>[] ToArray();
+        public bool TryAdd(TKey key, TValue value);
+        public bool TryGetValue(TKey key, out TValue value);
+        public bool TryRemove(TKey key, out TValue value);
+        public bool TryUpdate(TKey key, TValue newValue, TValue comparisonValue);
+    }
+    public class ConcurrentQueue<T> : ICollection, IEnumerable, IEnumerable<T>, IProducerConsumerCollection<T>, IReadOnlyCollection<T> {
+        public ConcurrentQueue();
+        public ConcurrentQueue(IEnumerable<T> collection);
+        public int Count { get; }
+        public bool IsEmpty { get; }
+        bool System.Collections.ICollection.IsSynchronized { get; }
+        object System.Collections.ICollection.SyncRoot { get; }
+        public void CopyTo(T[] array, int index);
+        public void Enqueue(T item);
+        public IEnumerator<T> GetEnumerator();
+        bool System.Collections.Concurrent.IProducerConsumerCollection<T>.TryAdd(T item);
+        bool System.Collections.Concurrent.IProducerConsumerCollection<T>.TryTake(out T item);
+        void System.Collections.ICollection.CopyTo(Array array, int index);
+        IEnumerator System.Collections.IEnumerable.GetEnumerator();
+        public T[] ToArray();
+        public bool TryDequeue(out T result);
+        public bool TryPeek(out T result);
+    }
+    public class ConcurrentStack<T> : ICollection, IEnumerable, IEnumerable<T>, IProducerConsumerCollection<T>, IReadOnlyCollection<T> {
+        public ConcurrentStack();
+        public ConcurrentStack(IEnumerable<T> collection);
+        public int Count { get; }
+        public bool IsEmpty { get; }
+        bool System.Collections.ICollection.IsSynchronized { get; }
+        object System.Collections.ICollection.SyncRoot { get; }
+        public void Clear();
+        public void CopyTo(T[] array, int index);
+        public IEnumerator<T> GetEnumerator();
+        public void Push(T item);
+        public void PushRange(T[] items);
+        public void PushRange(T[] items, int startIndex, int count);
+        bool System.Collections.Concurrent.IProducerConsumerCollection<T>.TryAdd(T item);
+        bool System.Collections.Concurrent.IProducerConsumerCollection<T>.TryTake(out T item);
+        void System.Collections.ICollection.CopyTo(Array array, int index);
+        IEnumerator System.Collections.IEnumerable.GetEnumerator();
+        public T[] ToArray();
+        public bool TryPeek(out T result);
+        public bool TryPop(out T result);
+        public int TryPopRange(T[] items);
+        public int TryPopRange(T[] items, int startIndex, int count);
+    }
+    public enum EnumerablePartitionerOptions {
+        NoBuffering = 1,
+        None = 0,
+    }
+    public interface IProducerConsumerCollection<T> : ICollection, IEnumerable, IEnumerable<T> {
+        void CopyTo(T[] array, int index);
+        T[] ToArray();
+        bool TryAdd(T item);
+        bool TryTake(out T item);
+    }
+    public abstract class OrderablePartitioner<TSource> : Partitioner<TSource> {
+        protected OrderablePartitioner(bool keysOrderedInEachPartition, bool keysOrderedAcrossPartitions, bool keysNormalized);
+        public bool KeysNormalized { get; }
+        public bool KeysOrderedAcrossPartitions { get; }
+        public bool KeysOrderedInEachPartition { get; }
+        public override IEnumerable<TSource> GetDynamicPartitions();
+        public virtual IEnumerable<KeyValuePair<long, TSource>> GetOrderableDynamicPartitions();
+        public abstract IList<IEnumerator<KeyValuePair<long, TSource>>> GetOrderablePartitions(int partitionCount);
+        public override IList<IEnumerator<TSource>> GetPartitions(int partitionCount);
+    }
+    public static class Partitioner {
+        public static OrderablePartitioner<Tuple<int, int>> Create(int fromInclusive, int toExclusive);
+        public static OrderablePartitioner<Tuple<int, int>> Create(int fromInclusive, int toExclusive, int rangeSize);
+        public static OrderablePartitioner<Tuple<long, long>> Create(long fromInclusive, long toExclusive);
+        public static OrderablePartitioner<Tuple<long, long>> Create(long fromInclusive, long toExclusive, long rangeSize);
+        public static OrderablePartitioner<TSource> Create<TSource>(IEnumerable<TSource> source);
+        public static OrderablePartitioner<TSource> Create<TSource>(IEnumerable<TSource> source, EnumerablePartitionerOptions partitionerOptions);
+        public static OrderablePartitioner<TSource> Create<TSource>(IList<TSource> list, bool loadBalance);
+        public static OrderablePartitioner<TSource> Create<TSource>(TSource[] array, bool loadBalance);
+    }
+    public abstract class Partitioner<TSource> {
+        protected Partitioner();
+        public virtual bool SupportsDynamicPartitions { get; }
+        public virtual IEnumerable<TSource> GetDynamicPartitions();
+        public abstract IList<IEnumerator<TSource>> GetPartitions(int partitionCount);
+    }
+}
```

## System.Collections.Generic

```c#
+namespace System.Collections.Generic {
+    public abstract class Comparer<T> : IComparer, IComparer<T> {
+        protected Comparer();
+        public static Comparer<T> Default { get; }
+        public abstract int Compare(T x, T y);
+        public static Comparer<T> Create(Comparison<T> comparison);
+        int System.Collections.IComparer.Compare(object x, object y);
+    }
+    public class Dictionary<TKey, TValue> : ICollection, ICollection<KeyValuePair<TKey, TValue>>, IDictionary, IDictionary<TKey, TValue>, IEnumerable, IEnumerable<KeyValuePair<TKey, TValue>>, IReadOnlyCollection<KeyValuePair<TKey, TValue>>, IReadOnlyDictionary<TKey, TValue> {
+        public Dictionary();
+        public Dictionary(IDictionary<TKey, TValue> dictionary);
+        public Dictionary(IDictionary<TKey, TValue> dictionary, IEqualityComparer<TKey> comparer);
+        public Dictionary(IEqualityComparer<TKey> comparer);
+        public Dictionary(int capacity);
+        public Dictionary(int capacity, IEqualityComparer<TKey> comparer);
+        public IEqualityComparer<TKey> Comparer { get; }
+        public int Count { get; }
+        public Dictionary<TKey, TValue>.KeyCollection Keys { get; }
+        bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.IsReadOnly { get; }
+        ICollection<TKey> System.Collections.Generic.IDictionary<TKey,TValue>.Keys { get; }
+        ICollection<TValue> System.Collections.Generic.IDictionary<TKey,TValue>.Values { get; }
+        IEnumerable<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Keys { get; }
+        IEnumerable<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Values { get; }
+        bool System.Collections.ICollection.IsSynchronized { get; }
+        object System.Collections.ICollection.SyncRoot { get; }
+        bool System.Collections.IDictionary.IsFixedSize { get; }
+        bool System.Collections.IDictionary.IsReadOnly { get; }
+        object System.Collections.IDictionary.this[object key] { get; set; }
+        ICollection System.Collections.IDictionary.Keys { get; }
+        ICollection System.Collections.IDictionary.Values { get; }
+        public TValue this[TKey key] { get; set; }
+        public Dictionary<TKey, TValue>.ValueCollection Values { get; }
+        public void Add(TKey key, TValue value);
+        public void Clear();
+        public bool ContainsKey(TKey key);
+        public bool ContainsValue(TValue value);
+        public Dictionary<TKey, TValue>.Enumerator GetEnumerator();
+        public bool Remove(TKey key);
+        void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Add(KeyValuePair<TKey, TValue> keyValuePair);
+        bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Contains(KeyValuePair<TKey, TValue> keyValuePair);
+        void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.CopyTo(KeyValuePair<TKey, TValue>[] array, int index);
+        bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Remove(KeyValuePair<TKey, TValue> keyValuePair);
+        IEnumerator<KeyValuePair<TKey, TValue>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey,TValue>>.GetEnumerator();
+        void System.Collections.ICollection.CopyTo(Array array, int index);
+        void System.Collections.IDictionary.Add(object key, object value);
+        bool System.Collections.IDictionary.Contains(object key);
+        IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator();
+        void System.Collections.IDictionary.Remove(object key);
+        IEnumerator System.Collections.IEnumerable.GetEnumerator();
+        public bool TryGetValue(TKey key, out TValue value);
+        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+        public struct Enumerator : IDictionaryEnumerator, IDisposable, IEnumerator, IEnumerator<KeyValuePair<TKey, TValue>> {
+            public KeyValuePair<TKey, TValue> Current { get; }
+            DictionaryEntry System.Collections.IDictionaryEnumerator.Entry { get; }
+            object System.Collections.IDictionaryEnumerator.Key { get; }
+            object System.Collections.IDictionaryEnumerator.Value { get; }
+            object System.Collections.IEnumerator.Current { get; }
+            public void Dispose();
+            public bool MoveNext();
+            void System.Collections.IEnumerator.Reset();
+        }
+        public sealed class KeyCollection : ICollection, ICollection<TKey>, IEnumerable, IEnumerable<TKey>, IReadOnlyCollection<TKey> {
+            public KeyCollection(Dictionary<TKey, TValue> dictionary);
+            public int Count { get; }
+            bool System.Collections.Generic.ICollection<TKey>.IsReadOnly { get; }
+            bool System.Collections.ICollection.IsSynchronized { get; }
+            object System.Collections.ICollection.SyncRoot { get; }
+            public void CopyTo(TKey[] array, int index);
+            public Dictionary<TKey, TValue>.KeyCollection.Enumerator GetEnumerator();
+            void System.Collections.Generic.ICollection<TKey>.Add(TKey item);
+            void System.Collections.Generic.ICollection<TKey>.Clear();
+            bool System.Collections.Generic.ICollection<TKey>.Contains(TKey item);
+            bool System.Collections.Generic.ICollection<TKey>.Remove(TKey item);
+            IEnumerator<TKey> System.Collections.Generic.IEnumerable<TKey>.GetEnumerator();
+            void System.Collections.ICollection.CopyTo(Array array, int index);
+            IEnumerator System.Collections.IEnumerable.GetEnumerator();
+            [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+            public struct Enumerator : IDisposable, IEnumerator, IEnumerator<TKey> {
+                public TKey Current { get; }
+                object System.Collections.IEnumerator.Current { get; }
+                public void Dispose();
+                public bool MoveNext();
+                void System.Collections.IEnumerator.Reset();
+            }
+        }
+        public sealed class ValueCollection : ICollection, ICollection<TValue>, IEnumerable, IEnumerable<TValue>, IReadOnlyCollection<TValue> {
+            public ValueCollection(Dictionary<TKey, TValue> dictionary);
+            public int Count { get; }
+            bool System.Collections.Generic.ICollection<TValue>.IsReadOnly { get; }
+            bool System.Collections.ICollection.IsSynchronized { get; }
+            object System.Collections.ICollection.SyncRoot { get; }
+            public void CopyTo(TValue[] array, int index);
+            public Dictionary<TKey, TValue>.ValueCollection.Enumerator GetEnumerator();
+            void System.Collections.Generic.ICollection<TValue>.Add(TValue item);
+            void System.Collections.Generic.ICollection<TValue>.Clear();
+            bool System.Collections.Generic.ICollection<TValue>.Contains(TValue item);
+            bool System.Collections.Generic.ICollection<TValue>.Remove(TValue item);
+            IEnumerator<TValue> System.Collections.Generic.IEnumerable<TValue>.GetEnumerator();
+            void System.Collections.ICollection.CopyTo(Array array, int index);
+            IEnumerator System.Collections.IEnumerable.GetEnumerator();
+            [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+            public struct Enumerator : IDisposable, IEnumerator, IEnumerator<TValue> {
+                public TValue Current { get; }
+                object System.Collections.IEnumerator.Current { get; }
+                public void Dispose();
+                public bool MoveNext();
+                void System.Collections.IEnumerator.Reset();
+            }
+        }
+    }
+    public abstract class EqualityComparer<T> : IEqualityComparer, IEqualityComparer<T> {
+        protected EqualityComparer();
+        public static EqualityComparer<T> Default { get; }
+        public abstract bool Equals(T x, T y);
+        public abstract int GetHashCode(T obj);
+        bool System.Collections.IEqualityComparer.Equals(object x, object y);
+        int System.Collections.IEqualityComparer.GetHashCode(object obj);
+    }
+    public class HashSet<T> : ICollection<T>, IEnumerable, IEnumerable<T>, IReadOnlyCollection<T>, ISet<T> {
+        public HashSet();
+        public HashSet(IEnumerable<T> collection);
+        public HashSet(IEnumerable<T> collection, IEqualityComparer<T> comparer);
+        public HashSet(IEqualityComparer<T> comparer);
+        public IEqualityComparer<T> Comparer { get; }
+        public int Count { get; }
+        bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
+        public bool Add(T item);
+        public void Clear();
+        public bool Contains(T item);
+        public void CopyTo(T[] array);
+        public void CopyTo(T[] array, int arrayIndex);
+        public void CopyTo(T[] array, int arrayIndex, int count);
+        public void ExceptWith(IEnumerable<T> other);
+        public HashSet<T>.Enumerator GetEnumerator();
+        public void IntersectWith(IEnumerable<T> other);
+        public bool IsProperSubsetOf(IEnumerable<T> other);
+        public bool IsProperSupersetOf(IEnumerable<T> other);
+        public bool IsSubsetOf(IEnumerable<T> other);
+        public bool IsSupersetOf(IEnumerable<T> other);
+        public bool Overlaps(IEnumerable<T> other);
+        public bool Remove(T item);
+        public int RemoveWhere(Predicate<T> match);
+        public bool SetEquals(IEnumerable<T> other);
+        public void SymmetricExceptWith(IEnumerable<T> other);
+        void System.Collections.Generic.ICollection<T>.Add(T item);
+        IEnumerator<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
+        IEnumerator System.Collections.IEnumerable.GetEnumerator();
+        public void TrimExcess();
+        public void UnionWith(IEnumerable<T> other);
+        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+        public struct Enumerator : IDisposable, IEnumerator, IEnumerator<T> {
+            public T Current { get; }
+            object System.Collections.IEnumerator.Current { get; }
+            public void Dispose();
+            public bool MoveNext();
+            void System.Collections.IEnumerator.Reset();
+        }
+    }
+    public interface ICollection<T> : IEnumerable, IEnumerable<T> {
+        int Count { get; }
+        bool IsReadOnly { get; }
+        void Add(T item);
+        void Clear();
+        bool Contains(T item);
+        void CopyTo(T[] array, int arrayIndex);
+        bool Remove(T item);
+    }
+    public interface IComparer<in T> {
+        int Compare(T x, T y);
+    }
+    public interface IDictionary<TKey, TValue> : ICollection<KeyValuePair<TKey, TValue>>, IEnumerable, IEnumerable<KeyValuePair<TKey, TValue>> {
+        ICollection<TKey> Keys { get; }
+        TValue this[TKey key] { get; set; }
+        ICollection<TValue> Values { get; }
+        void Add(TKey key, TValue value);
+        bool ContainsKey(TKey key);
+        bool Remove(TKey key);
+        bool TryGetValue(TKey key, out TValue value);
+    }
+    public interface IEnumerable<out T> : IEnumerable {
+        new IEnumerator<T> GetEnumerator();
+    }
+    public interface IEnumerator<out T> : IDisposable, IEnumerator {
+        new T Current { get; }
+    }
+    public interface IEqualityComparer<in T> {
+        bool Equals(T x, T y);
+        int GetHashCode(T obj);
+    }
+    public interface IList<T> : ICollection<T>, IEnumerable, IEnumerable<T> {
+        T this[int index] { get; set; }
+        int IndexOf(T item);
+        void Insert(int index, T item);
+        void RemoveAt(int index);
+    }
+    public interface IReadOnlyCollection<out T> : IEnumerable, IEnumerable<T> {
+        int Count { get; }
+    }
+    public interface IReadOnlyDictionary<TKey, TValue> : IEnumerable, IEnumerable<KeyValuePair<TKey, TValue>>, IReadOnlyCollection<KeyValuePair<TKey, TValue>> {
+        IEnumerable<TKey> Keys { get; }
+        TValue this[TKey key] { get; }
+        IEnumerable<TValue> Values { get; }
+        bool ContainsKey(TKey key);
+        bool TryGetValue(TKey key, out TValue value);
+    }
+    public interface IReadOnlyList<out T> : IEnumerable, IEnumerable<T>, IReadOnlyCollection<T> {
+        T this[int index] { get; }
+    }
+    public interface ISet<T> : ICollection<T>, IEnumerable, IEnumerable<T> {
+        new bool Add(T item);
+        void ExceptWith(IEnumerable<T> other);
+        void IntersectWith(IEnumerable<T> other);
+        bool IsProperSubsetOf(IEnumerable<T> other);
+        bool IsProperSupersetOf(IEnumerable<T> other);
+        bool IsSubsetOf(IEnumerable<T> other);
+        bool IsSupersetOf(IEnumerable<T> other);
+        bool Overlaps(IEnumerable<T> other);
+        bool SetEquals(IEnumerable<T> other);
+        void SymmetricExceptWith(IEnumerable<T> other);
+        void UnionWith(IEnumerable<T> other);
+    }
+    public class KeyedByTypeCollection<TItem> : KeyedCollection<Type, TItem> {
+        public KeyedByTypeCollection();
+        public KeyedByTypeCollection(IEnumerable<TItem> items);
+        public T Find<T>();
+        public Collection<T> FindAll<T>();
+        protected override Type GetKeyForItem(TItem item);
+        protected override void InsertItem(int index, TItem item);
+        public T Remove<T>();
+        public Collection<T> RemoveAll<T>();
+        protected override void SetItem(int index, TItem item);
+    }
+    public class KeyNotFoundException : Exception {
+        public KeyNotFoundException();
+        public KeyNotFoundException(string message);
+        public KeyNotFoundException(string message, Exception innerException);
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct KeyValuePair<TKey, TValue> {
+        public KeyValuePair(TKey key, TValue value);
+        public TKey Key { get; }
+        public TValue Value { get; }
+        public override string ToString();
+    }
+    public class LinkedList<T> : ICollection, ICollection<T>, IEnumerable, IEnumerable<T>, IReadOnlyCollection<T> {
+        public LinkedList();
+        public LinkedList(IEnumerable<T> collection);
+        public int Count { get; }
+        public LinkedListNode<T> First { get; }
+        public LinkedListNode<T> Last { get; }
+        bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
+        bool System.Collections.ICollection.IsSynchronized { get; }
+        object System.Collections.ICollection.SyncRoot { get; }
+        public void AddAfter(LinkedListNode<T> node, LinkedListNode<T> newNode);
+        public LinkedListNode<T> AddAfter(LinkedListNode<T> node, T value);
+        public void AddBefore(LinkedListNode<T> node, LinkedListNode<T> newNode);
+        public LinkedListNode<T> AddBefore(LinkedListNode<T> node, T value);
+        public void AddFirst(LinkedListNode<T> node);
+        public LinkedListNode<T> AddFirst(T value);
+        public void AddLast(LinkedListNode<T> node);
+        public LinkedListNode<T> AddLast(T value);
+        public void Clear();
+        public bool Contains(T value);
+        public void CopyTo(T[] array, int index);
+        public LinkedListNode<T> Find(T value);
+        public LinkedListNode<T> FindLast(T value);
+        public LinkedList<T>.Enumerator GetEnumerator();
+        public void Remove(LinkedListNode<T> node);
+        public bool Remove(T value);
+        public void RemoveFirst();
+        public void RemoveLast();
+        void System.Collections.Generic.ICollection<T>.Add(T value);
+        IEnumerator<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
+        void System.Collections.ICollection.CopyTo(Array array, int index);
+        IEnumerator System.Collections.IEnumerable.GetEnumerator();
+        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+        public struct Enumerator : IDisposable, IEnumerator, IEnumerator<T> {
+            public T Current { get; }
+            object System.Collections.IEnumerator.Current { get; }
+            public void Dispose();
+            public bool MoveNext();
+            void System.Collections.IEnumerator.Reset();
+        }
+    }
+    public sealed class LinkedListNode<T> {
+        public LinkedListNode(T value);
+        public LinkedList<T> List { get; }
+        public LinkedListNode<T> Next { get; }
+        public LinkedListNode<T> Previous { get; }
+        public T Value { get; set; }
+    }
+    public class List<T> : ICollection, ICollection<T>, IEnumerable, IEnumerable<T>, IList, IList<T>, IReadOnlyCollection<T>, IReadOnlyList<T> {
+        public List();
+        public List(IEnumerable<T> collection);
+        public List(int capacity);
+        public int Capacity { get; set; }
+        public int Count { get; }
+        bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
+        bool System.Collections.ICollection.IsSynchronized { get; }
+        object System.Collections.ICollection.SyncRoot { get; }
+        bool System.Collections.IList.IsFixedSize { get; }
+        bool System.Collections.IList.IsReadOnly { get; }
+        object System.Collections.IList.this[int index] { get; set; }
+        public T this[int index] { get; set; }
+        public void Add(T item);
+        public void AddRange(IEnumerable<T> collection);
+        public ReadOnlyCollection<T> AsReadOnly();
+        public int BinarySearch(int index, int count, T item, IComparer<T> comparer);
+        public int BinarySearch(T item);
+        public int BinarySearch(T item, IComparer<T> comparer);
+        public void Clear();
+        public bool Contains(T item);
+        public void CopyTo(int index, T[] array, int arrayIndex, int count);
+        public void CopyTo(T[] array);
+        public void CopyTo(T[] array, int arrayIndex);
+        public bool Exists(Predicate<T> match);
+        public T Find(Predicate<T> match);
+        public List<T> FindAll(Predicate<T> match);
+        public int FindIndex(int startIndex, int count, Predicate<T> match);
+        public int FindIndex(int startIndex, Predicate<T> match);
+        public int FindIndex(Predicate<T> match);
+        public T FindLast(Predicate<T> match);
+        public int FindLastIndex(int startIndex, int count, Predicate<T> match);
+        public int FindLastIndex(int startIndex, Predicate<T> match);
+        public int FindLastIndex(Predicate<T> match);
+        public void ForEach(Action<T> action);
+        public List<T>.Enumerator GetEnumerator();
+        public List<T> GetRange(int index, int count);
+        public int IndexOf(T item);
+        public int IndexOf(T item, int index);
+        public int IndexOf(T item, int index, int count);
+        public void Insert(int index, T item);
+        public void InsertRange(int index, IEnumerable<T> collection);
+        public int LastIndexOf(T item);
+        public int LastIndexOf(T item, int index);
+        public int LastIndexOf(T item, int index, int count);
+        public bool Remove(T item);
+        public int RemoveAll(Predicate<T> match);
+        public void RemoveAt(int index);
+        public void RemoveRange(int index, int count);
+        public void Reverse();
+        public void Reverse(int index, int count);
+        public void Sort();
+        public void Sort(IComparer<T> comparer);
+        public void Sort(Comparison<T> comparison);
+        public void Sort(int index, int count, IComparer<T> comparer);
+        IEnumerator<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
+        void System.Collections.ICollection.CopyTo(Array array, int arrayIndex);
+        IEnumerator System.Collections.IEnumerable.GetEnumerator();
+        int System.Collections.IList.Add(object item);
+        bool System.Collections.IList.Contains(object item);
+        int System.Collections.IList.IndexOf(object item);
+        void System.Collections.IList.Insert(int index, object item);
+        void System.Collections.IList.Remove(object item);
+        public T[] ToArray();
+        public void TrimExcess();
+        public bool TrueForAll(Predicate<T> match);
+        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+        public struct Enumerator : IDisposable, IEnumerator, IEnumerator<T> {
+            public T Current { get; }
+            object System.Collections.IEnumerator.Current { get; }
+            public void Dispose();
+            public bool MoveNext();
+            void System.Collections.IEnumerator.Reset();
+        }
+    }
+    public class Queue<T> : ICollection, IEnumerable, IEnumerable<T>, IReadOnlyCollection<T> {
+        public Queue();
+        public Queue(IEnumerable<T> collection);
+        public Queue(int capacity);
+        public int Count { get; }
+        bool System.Collections.ICollection.IsSynchronized { get; }
+        object System.Collections.ICollection.SyncRoot { get; }
+        public void Clear();
+        public bool Contains(T item);
+        public void CopyTo(T[] array, int arrayIndex);
+        public T Dequeue();
+        public void Enqueue(T item);
+        public Queue<T>.Enumerator GetEnumerator();
+        public T Peek();
+        IEnumerator<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
+        void System.Collections.ICollection.CopyTo(Array array, int index);
+        IEnumerator System.Collections.IEnumerable.GetEnumerator();
+        public T[] ToArray();
+        public void TrimExcess();
+        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+        public struct Enumerator : IDisposable, IEnumerator, IEnumerator<T> {
+            public T Current { get; }
+            object System.Collections.IEnumerator.Current { get; }
+            public void Dispose();
+            public bool MoveNext();
+            void System.Collections.IEnumerator.Reset();
+        }
+    }
+    public class SortedDictionary<TKey, TValue> : ICollection, ICollection<KeyValuePair<TKey, TValue>>, IDictionary, IDictionary<TKey, TValue>, IEnumerable, IEnumerable<KeyValuePair<TKey, TValue>>, IReadOnlyCollection<KeyValuePair<TKey, TValue>>, IReadOnlyDictionary<TKey, TValue> {
+        public SortedDictionary();
+        public SortedDictionary(IComparer<TKey> comparer);
+        public SortedDictionary(IDictionary<TKey, TValue> dictionary);
+        public SortedDictionary(IDictionary<TKey, TValue> dictionary, IComparer<TKey> comparer);
+        public IComparer<TKey> Comparer { get; }
+        public int Count { get; }
+        public SortedDictionary<TKey, TValue>.KeyCollection Keys { get; }
+        bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.IsReadOnly { get; }
+        ICollection<TKey> System.Collections.Generic.IDictionary<TKey,TValue>.Keys { get; }
+        ICollection<TValue> System.Collections.Generic.IDictionary<TKey,TValue>.Values { get; }
+        IEnumerable<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Keys { get; }
+        IEnumerable<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Values { get; }
+        bool System.Collections.ICollection.IsSynchronized { get; }
+        object System.Collections.ICollection.SyncRoot { get; }
+        bool System.Collections.IDictionary.IsFixedSize { get; }
+        bool System.Collections.IDictionary.IsReadOnly { get; }
+        object System.Collections.IDictionary.this[object key] { get; set; }
+        ICollection System.Collections.IDictionary.Keys { get; }
+        ICollection System.Collections.IDictionary.Values { get; }
+        public TValue this[TKey key] { get; set; }
+        public SortedDictionary<TKey, TValue>.ValueCollection Values { get; }
+        public void Add(TKey key, TValue value);
+        public void Clear();
+        public bool ContainsKey(TKey key);
+        public bool ContainsValue(TValue value);
+        public void CopyTo(KeyValuePair<TKey, TValue>[] array, int index);
+        public SortedDictionary<TKey, TValue>.Enumerator GetEnumerator();
+        public bool Remove(TKey key);
+        void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Add(KeyValuePair<TKey, TValue> keyValuePair);
+        bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Contains(KeyValuePair<TKey, TValue> keyValuePair);
+        bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Remove(KeyValuePair<TKey, TValue> keyValuePair);
+        IEnumerator<KeyValuePair<TKey, TValue>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey,TValue>>.GetEnumerator();
+        void System.Collections.ICollection.CopyTo(Array array, int index);
+        void System.Collections.IDictionary.Add(object key, object value);
+        bool System.Collections.IDictionary.Contains(object key);
+        IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator();
+        void System.Collections.IDictionary.Remove(object key);
+        IEnumerator System.Collections.IEnumerable.GetEnumerator();
+        public bool TryGetValue(TKey key, out TValue value);
+        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+        public struct Enumerator : IDictionaryEnumerator, IDisposable, IEnumerator, IEnumerator<KeyValuePair<TKey, TValue>> {
+            public KeyValuePair<TKey, TValue> Current { get; }
+            DictionaryEntry System.Collections.IDictionaryEnumerator.Entry { get; }
+            object System.Collections.IDictionaryEnumerator.Key { get; }
+            object System.Collections.IDictionaryEnumerator.Value { get; }
+            object System.Collections.IEnumerator.Current { get; }
+            public void Dispose();
+            public bool MoveNext();
+            void System.Collections.IEnumerator.Reset();
+        }
+        public sealed class KeyCollection : ICollection, ICollection<TKey>, IEnumerable, IEnumerable<TKey>, IReadOnlyCollection<TKey> {
+            public KeyCollection(SortedDictionary<TKey, TValue> dictionary);
+            public int Count { get; }
+            bool System.Collections.Generic.ICollection<TKey>.IsReadOnly { get; }
+            bool System.Collections.ICollection.IsSynchronized { get; }
+            object System.Collections.ICollection.SyncRoot { get; }
+            public void CopyTo(TKey[] array, int index);
+            public SortedDictionary<TKey, TValue>.KeyCollection.Enumerator GetEnumerator();
+            void System.Collections.Generic.ICollection<TKey>.Add(TKey item);
+            void System.Collections.Generic.ICollection<TKey>.Clear();
+            bool System.Collections.Generic.ICollection<TKey>.Contains(TKey item);
+            bool System.Collections.Generic.ICollection<TKey>.Remove(TKey item);
+            IEnumerator<TKey> System.Collections.Generic.IEnumerable<TKey>.GetEnumerator();
+            void System.Collections.ICollection.CopyTo(Array array, int index);
+            IEnumerator System.Collections.IEnumerable.GetEnumerator();
+            [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+            public struct Enumerator : IDisposable, IEnumerator, IEnumerator<TKey> {
+                public TKey Current { get; }
+                object System.Collections.IEnumerator.Current { get; }
+                public void Dispose();
+                public bool MoveNext();
+                void System.Collections.IEnumerator.Reset();
+            }
+        }
+        public sealed class ValueCollection : ICollection, ICollection<TValue>, IEnumerable, IEnumerable<TValue>, IReadOnlyCollection<TValue> {
+            public ValueCollection(SortedDictionary<TKey, TValue> dictionary);
+            public int Count { get; }
+            bool System.Collections.Generic.ICollection<TValue>.IsReadOnly { get; }
+            bool System.Collections.ICollection.IsSynchronized { get; }
+            object System.Collections.ICollection.SyncRoot { get; }
+            public void CopyTo(TValue[] array, int index);
+            public SortedDictionary<TKey, TValue>.ValueCollection.Enumerator GetEnumerator();
+            void System.Collections.Generic.ICollection<TValue>.Add(TValue item);
+            void System.Collections.Generic.ICollection<TValue>.Clear();
+            bool System.Collections.Generic.ICollection<TValue>.Contains(TValue item);
+            bool System.Collections.Generic.ICollection<TValue>.Remove(TValue item);
+            IEnumerator<TValue> System.Collections.Generic.IEnumerable<TValue>.GetEnumerator();
+            void System.Collections.ICollection.CopyTo(Array array, int index);
+            IEnumerator System.Collections.IEnumerable.GetEnumerator();
+            [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+            public struct Enumerator : IDisposable, IEnumerator, IEnumerator<TValue> {
+                public TValue Current { get; }
+                object System.Collections.IEnumerator.Current { get; }
+                public void Dispose();
+                public bool MoveNext();
+                void System.Collections.IEnumerator.Reset();
+            }
+        }
+    }
+    public class SortedList<TKey, TValue> : ICollection, ICollection<KeyValuePair<TKey, TValue>>, IDictionary, IDictionary<TKey, TValue>, IEnumerable, IEnumerable<KeyValuePair<TKey, TValue>>, IReadOnlyCollection<KeyValuePair<TKey, TValue>>, IReadOnlyDictionary<TKey, TValue> {
+        public SortedList();
+        public SortedList(IComparer<TKey> comparer);
+        public SortedList(IDictionary<TKey, TValue> dictionary);
+        public SortedList(IDictionary<TKey, TValue> dictionary, IComparer<TKey> comparer);
+        public SortedList(int capacity);
+        public SortedList(int capacity, IComparer<TKey> comparer);
+        public int Capacity { get; set; }
+        public IComparer<TKey> Comparer { get; }
+        public int Count { get; }
+        public IList<TKey> Keys { get; }
+        bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.IsReadOnly { get; }
+        ICollection<TKey> System.Collections.Generic.IDictionary<TKey,TValue>.Keys { get; }
+        ICollection<TValue> System.Collections.Generic.IDictionary<TKey,TValue>.Values { get; }
+        IEnumerable<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Keys { get; }
+        IEnumerable<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Values { get; }
+        bool System.Collections.ICollection.IsSynchronized { get; }
+        object System.Collections.ICollection.SyncRoot { get; }
+        bool System.Collections.IDictionary.IsFixedSize { get; }
+        bool System.Collections.IDictionary.IsReadOnly { get; }
+        object System.Collections.IDictionary.this[object key] { get; set; }
+        ICollection System.Collections.IDictionary.Keys { get; }
+        ICollection System.Collections.IDictionary.Values { get; }
+        public TValue this[TKey key] { get; set; }
+        public IList<TValue> Values { get; }
+        public void Add(TKey key, TValue value);
+        public void Clear();
+        public bool ContainsKey(TKey key);
+        public bool ContainsValue(TValue value);
+        public IEnumerator<KeyValuePair<TKey, TValue>> GetEnumerator();
+        public int IndexOfKey(TKey key);
+        public int IndexOfValue(TValue value);
+        public bool Remove(TKey key);
+        public void RemoveAt(int index);
+        void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Add(KeyValuePair<TKey, TValue> keyValuePair);
+        bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Contains(KeyValuePair<TKey, TValue> keyValuePair);
+        void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.CopyTo(KeyValuePair<TKey, TValue>[] array, int arrayIndex);
+        bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Remove(KeyValuePair<TKey, TValue> keyValuePair);
+        IEnumerator<KeyValuePair<TKey, TValue>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey,TValue>>.GetEnumerator();
+        void System.Collections.ICollection.CopyTo(Array array, int arrayIndex);
+        void System.Collections.IDictionary.Add(object key, object value);
+        bool System.Collections.IDictionary.Contains(object key);
+        IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator();
+        void System.Collections.IDictionary.Remove(object key);
+        IEnumerator System.Collections.IEnumerable.GetEnumerator();
+        public void TrimExcess();
+        public bool TryGetValue(TKey key, out TValue value);
+    }
+    public class SortedSet<T> : ICollection, ICollection<T>, IEnumerable, IEnumerable<T>, IReadOnlyCollection<T>, ISet<T> {
+        public SortedSet();
+        public SortedSet(IComparer<T> comparer);
+        public SortedSet(IEnumerable<T> collection);
+        public SortedSet(IEnumerable<T> collection, IComparer<T> comparer);
+        public IComparer<T> Comparer { get; }
+        public int Count { get; }
+        public T Max { get; }
+        public T Min { get; }
+        bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
+        bool System.Collections.ICollection.IsSynchronized { get; }
+        object System.Collections.ICollection.SyncRoot { get; }
+        public bool Add(T item);
+        public virtual void Clear();
+        public virtual bool Contains(T item);
+        public void CopyTo(T[] array);
+        public void CopyTo(T[] array, int index);
+        public void CopyTo(T[] array, int index, int count);
+        public void ExceptWith(IEnumerable<T> other);
+        public SortedSet<T>.Enumerator GetEnumerator();
+        public virtual SortedSet<T> GetViewBetween(T lowerValue, T upperValue);
+        public virtual void IntersectWith(IEnumerable<T> other);
+        public bool IsProperSubsetOf(IEnumerable<T> other);
+        public bool IsProperSupersetOf(IEnumerable<T> other);
+        public bool IsSubsetOf(IEnumerable<T> other);
+        public bool IsSupersetOf(IEnumerable<T> other);
+        public bool Overlaps(IEnumerable<T> other);
+        public bool Remove(T item);
+        public int RemoveWhere(Predicate<T> match);
+        public IEnumerable<T> Reverse();
+        public bool SetEquals(IEnumerable<T> other);
+        public void SymmetricExceptWith(IEnumerable<T> other);
+        void System.Collections.Generic.ICollection<T>.Add(T item);
+        IEnumerator<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
+        void System.Collections.ICollection.CopyTo(Array array, int index);
+        IEnumerator System.Collections.IEnumerable.GetEnumerator();
+        public void UnionWith(IEnumerable<T> other);
+        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+        public struct Enumerator : IDisposable, IEnumerator, IEnumerator<T> {
+            public T Current { get; }
+            object System.Collections.IEnumerator.Current { get; }
+            public void Dispose();
+            public bool MoveNext();
+            void System.Collections.IEnumerator.Reset();
+        }
+    }
+    public class Stack<T> : ICollection, IEnumerable, IEnumerable<T>, IReadOnlyCollection<T> {
+        public Stack();
+        public Stack(IEnumerable<T> collection);
+        public Stack(int capacity);
+        public int Count { get; }
+        bool System.Collections.ICollection.IsSynchronized { get; }
+        object System.Collections.ICollection.SyncRoot { get; }
+        public void Clear();
+        public bool Contains(T item);
+        public void CopyTo(T[] array, int arrayIndex);
+        public Stack<T>.Enumerator GetEnumerator();
+        public T Peek();
+        public T Pop();
+        public void Push(T item);
+        IEnumerator<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
+        void System.Collections.ICollection.CopyTo(Array array, int arrayIndex);
+        IEnumerator System.Collections.IEnumerable.GetEnumerator();
+        public T[] ToArray();
+        public void TrimExcess();
+        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+        public struct Enumerator : IDisposable, IEnumerator, IEnumerator<T> {
+            public T Current { get; }
+            object System.Collections.IEnumerator.Current { get; }
+            public void Dispose();
+            public bool MoveNext();
+            void System.Collections.IEnumerator.Reset();
+        }
+    }
+    public class SynchronizedCollection<T> : ICollection, ICollection<T>, IEnumerable, IEnumerable<T>, IList, IList<T> {
+        public SynchronizedCollection();
+        public SynchronizedCollection(object syncRoot);
+        public SynchronizedCollection(object syncRoot, IEnumerable<T> list);
+        public SynchronizedCollection(object syncRoot, params T[] list);
+        public int Count { get; }
+        protected List<T> Items { get; }
+        public object SyncRoot { get; }
+        bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
+        bool System.Collections.ICollection.IsSynchronized { get; }
+        object System.Collections.ICollection.SyncRoot { get; }
+        bool System.Collections.IList.IsFixedSize { get; }
+        bool System.Collections.IList.IsReadOnly { get; }
+        object System.Collections.IList.this[int index] { get; set; }
+        public T this[int index] { get; set; }
+        public void Add(T item);
+        public void Clear();
+        protected virtual void ClearItems();
+        public bool Contains(T item);
+        public void CopyTo(T[] array, int index);
+        public IEnumerator<T> GetEnumerator();
+        public int IndexOf(T item);
+        public void Insert(int index, T item);
+        protected virtual void InsertItem(int index, T item);
+        public bool Remove(T item);
+        public void RemoveAt(int index);
+        protected virtual void RemoveItem(int index);
+        protected virtual void SetItem(int index, T item);
+        void System.Collections.ICollection.CopyTo(Array array, int index);
+        IEnumerator System.Collections.IEnumerable.GetEnumerator();
+        int System.Collections.IList.Add(object value);
+        bool System.Collections.IList.Contains(object value);
+        int System.Collections.IList.IndexOf(object value);
+        void System.Collections.IList.Insert(int index, object value);
+        void System.Collections.IList.Remove(object value);
+    }
+    public abstract class SynchronizedKeyedCollection<K, T> : SynchronizedCollection<T> {
+        protected SynchronizedKeyedCollection();
+        protected SynchronizedKeyedCollection(object syncRoot);
+        protected SynchronizedKeyedCollection(object syncRoot, IEqualityComparer<K> comparer);
+        protected SynchronizedKeyedCollection(object syncRoot, IEqualityComparer<K> comparer, int dictionaryCreationThreshold);
+        protected IDictionary<K, T> Dictionary { get; }
+        public T this[K key] { get; }
+        protected void ChangeItemKey(T item, K newKey);
+        protected override void ClearItems();
+        public bool Contains(K key);
+        protected abstract K GetKeyForItem(T item);
+        protected override void InsertItem(int index, T item);
+        public bool Remove(K key);
+        protected override void RemoveItem(int index);
+        protected override void SetItem(int index, T item);
+    }
+    public class SynchronizedReadOnlyCollection<T> : ICollection, ICollection<T>, IEnumerable, IEnumerable<T>, IList, IList<T> {
+        public SynchronizedReadOnlyCollection();
+        public SynchronizedReadOnlyCollection(object syncRoot);
+        public SynchronizedReadOnlyCollection(object syncRoot, IEnumerable<T> list);
+        public SynchronizedReadOnlyCollection(object syncRoot, params T[] list);
+        public int Count { get; }
+        protected IList<T> Items { get; }
+        bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
+        T System.Collections.Generic.IList<T>.this[int index] { get; set; }
+        bool System.Collections.ICollection.IsSynchronized { get; }
+        object System.Collections.ICollection.SyncRoot { get; }
+        bool System.Collections.IList.IsFixedSize { get; }
+        bool System.Collections.IList.IsReadOnly { get; }
+        object System.Collections.IList.this[int index] { get; set; }
+        public T this[int index] { get; }
+        public bool Contains(T value);
+        public void CopyTo(T[] array, int index);
+        public IEnumerator<T> GetEnumerator();
+        public int IndexOf(T value);
+        void System.Collections.Generic.ICollection<T>.Add(T value);
+        void System.Collections.Generic.ICollection<T>.Clear();
+        bool System.Collections.Generic.ICollection<T>.Remove(T value);
+        void System.Collections.Generic.IList<T>.Insert(int index, T value);
+        void System.Collections.Generic.IList<T>.RemoveAt(int index);
+        void System.Collections.ICollection.CopyTo(Array array, int index);
+        IEnumerator System.Collections.IEnumerable.GetEnumerator();
+        int System.Collections.IList.Add(object value);
+        void System.Collections.IList.Clear();
+        bool System.Collections.IList.Contains(object value);
+        int System.Collections.IList.IndexOf(object value);
+        void System.Collections.IList.Insert(int index, object value);
+        void System.Collections.IList.Remove(object value);
+        void System.Collections.IList.RemoveAt(int index);
+    }
+}
```

## System.Collections.Immutable

```c#
+namespace System.Collections.Immutable {
+    public interface IImmutableDictionary<TKey, TValue> : IEnumerable, IEnumerable<KeyValuePair<TKey, TValue>>, IReadOnlyCollection<KeyValuePair<TKey, TValue>>, IReadOnlyDictionary<TKey, TValue> {
+        IImmutableDictionary<TKey, TValue> Add(TKey key, TValue value);
+        IImmutableDictionary<TKey, TValue> AddRange(IEnumerable<KeyValuePair<TKey, TValue>> pairs);
+        IImmutableDictionary<TKey, TValue> Clear();
+        bool Contains(KeyValuePair<TKey, TValue> pair);
+        IImmutableDictionary<TKey, TValue> Remove(TKey key);
+        IImmutableDictionary<TKey, TValue> RemoveRange(IEnumerable<TKey> keys);
+        IImmutableDictionary<TKey, TValue> SetItem(TKey key, TValue value);
+        IImmutableDictionary<TKey, TValue> SetItems(IEnumerable<KeyValuePair<TKey, TValue>> items);
+        bool TryGetKey(TKey equalKey, out TKey actualKey);
+    }
+    public interface IImmutableList<T> : IEnumerable, IEnumerable<T>, IReadOnlyCollection<T>, IReadOnlyList<T> {
+        IImmutableList<T> Add(T value);
+        IImmutableList<T> AddRange(IEnumerable<T> items);
+        IImmutableList<T> Clear();
+        int IndexOf(T item, int index, int count, IEqualityComparer<T> equalityComparer);
+        IImmutableList<T> Insert(int index, T element);
+        IImmutableList<T> InsertRange(int index, IEnumerable<T> items);
+        int LastIndexOf(T item, int index, int count, IEqualityComparer<T> equalityComparer);
+        IImmutableList<T> Remove(T value, IEqualityComparer<T> equalityComparer);
+        IImmutableList<T> RemoveAll(Predicate<T> match);
+        IImmutableList<T> RemoveAt(int index);
+        IImmutableList<T> RemoveRange(IEnumerable<T> items, IEqualityComparer<T> equalityComparer);
+        IImmutableList<T> RemoveRange(int index, int count);
+        IImmutableList<T> Replace(T oldValue, T newValue, IEqualityComparer<T> equalityComparer);
+        IImmutableList<T> SetItem(int index, T value);
+    }
+    public interface IImmutableQueue<T> : IEnumerable, IEnumerable<T> {
+        bool IsEmpty { get; }
+        IImmutableQueue<T> Clear();
+        IImmutableQueue<T> Dequeue();
+        IImmutableQueue<T> Enqueue(T value);
+        T Peek();
+    }
+    public interface IImmutableSet<T> : IEnumerable, IEnumerable<T>, IReadOnlyCollection<T> {
+        IImmutableSet<T> Add(T value);
+        IImmutableSet<T> Clear();
+        bool Contains(T value);
+        IImmutableSet<T> Except(IEnumerable<T> other);
+        IImmutableSet<T> Intersect(IEnumerable<T> other);
+        bool IsProperSubsetOf(IEnumerable<T> other);
+        bool IsProperSupersetOf(IEnumerable<T> other);
+        bool IsSubsetOf(IEnumerable<T> other);
+        bool IsSupersetOf(IEnumerable<T> other);
+        bool Overlaps(IEnumerable<T> other);
+        IImmutableSet<T> Remove(T value);
+        bool SetEquals(IEnumerable<T> other);
+        IImmutableSet<T> SymmetricExcept(IEnumerable<T> other);
+        bool TryGetValue(T equalValue, out T actualValue);
+        IImmutableSet<T> Union(IEnumerable<T> other);
+    }
+    public interface IImmutableStack<T> : IEnumerable, IEnumerable<T> {
+        bool IsEmpty { get; }
+        IImmutableStack<T> Clear();
+        T Peek();
+        IImmutableStack<T> Pop();
+        IImmutableStack<T> Push(T value);
+    }
+    public static class ImmutableArray {
+        public static int BinarySearch<T>(this ImmutableArray<T> array, int index, int length, T value);
+        public static int BinarySearch<T>(this ImmutableArray<T> array, int index, int length, T value, IComparer<T> comparer);
+        public static int BinarySearch<T>(this ImmutableArray<T> array, T value);
+        public static int BinarySearch<T>(this ImmutableArray<T> array, T value, IComparer<T> comparer);
+        public static ImmutableArray<T> Create<T>();
+        public static ImmutableArray<T> Create<T>(ImmutableArray<T> items, int start, int length);
+        public static ImmutableArray<T> Create<T>(T item);
+        public static ImmutableArray<T> Create<T>(T item1, T item2);
+        public static ImmutableArray<T> Create<T>(T item1, T item2, T item3);
+        public static ImmutableArray<T> Create<T>(T item1, T item2, T item3, T item4);
+        public static ImmutableArray<T> Create<T>(params T[] items);
+        public static ImmutableArray<T> Create<T>(T[] items, int start, int length);
+        public static ImmutableArray<T>.Builder CreateBuilder<T>();
+        public static ImmutableArray<T>.Builder CreateBuilder<T>(int initialCapacity);
+        public static ImmutableArray<T> CreateRange<T>(IEnumerable<T> items);
+        public static ImmutableArray<TResult> CreateRange<TSource, TArg, TResult>(ImmutableArray<TSource> items, Func<TSource, TArg, TResult> selector, TArg arg);
+        public static ImmutableArray<TResult> CreateRange<TSource, TArg, TResult>(ImmutableArray<TSource> items, int start, int length, Func<TSource, TArg, TResult> selector, TArg arg);
+        public static ImmutableArray<TResult> CreateRange<TSource, TResult>(ImmutableArray<TSource> items, Func<TSource, TResult> selector);
+        public static ImmutableArray<TResult> CreateRange<TSource, TResult>(ImmutableArray<TSource> items, int start, int length, Func<TSource, TResult> selector);
+        public static ImmutableArray<TSource> ToImmutableArray<TSource>(this IEnumerable<TSource> items);
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct ImmutableArray<T> : ICollection, ICollection<T>, IEnumerable, IEnumerable<T>, IEquatable<ImmutableArray<T>>, IImmutableArray, IImmutableList<T>, IList, IList<T>, IReadOnlyCollection<T>, IReadOnlyList<T>, IStructuralComparable, IStructuralEquatable {
+        public static readonly ImmutableArray<T> Empty;
+        public bool IsDefault { get; }
+        public bool IsDefaultOrEmpty { get; }
+        public bool IsEmpty { get; }
+        public int Length { get; }
+        int System.Collections.Generic.ICollection<T>.Count { get; }
+        bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
+        T System.Collections.Generic.IList<T>.this[int index] { get; set; }
+        int System.Collections.Generic.IReadOnlyCollection<T>.Count { get; }
+        T System.Collections.Generic.IReadOnlyList<T>.this[int index] { get; }
+        int System.Collections.ICollection.Count { get; }
+        bool System.Collections.ICollection.IsSynchronized { get; }
+        object System.Collections.ICollection.SyncRoot { get; }
+        bool System.Collections.IList.IsFixedSize { get; }
+        bool System.Collections.IList.IsReadOnly { get; }
+        object System.Collections.IList.this[int index] { get; set; }
+        public T this[int index] { get; }
+        public ImmutableArray<T> Add(T item);
+        public ImmutableArray<T> AddRange(IEnumerable<T> items);
+        public ImmutableArray<T> AddRange(ImmutableArray<T> items);
+        public ImmutableArray<TOther> As<TOther>() where TOther : class;
+        public ImmutableArray<TOther> CastArray<TOther>() where TOther : class;
+        public static ImmutableArray<T> CastUp<TDerived>(ImmutableArray<TDerived> items) where TDerived : class, T;
+        public ImmutableArray<T> Clear();
+        public bool Contains(T item);
+        public void CopyTo(int sourceIndex, T[] destination, int destinationIndex, int length);
+        public void CopyTo(T[] destination);
+        public void CopyTo(T[] destination, int destinationIndex);
+        public bool Equals(ImmutableArray<T> other);
+        public override bool Equals(object obj);
+        public ImmutableArray<T>.Enumerator GetEnumerator();
+        public override int GetHashCode();
+        public int IndexOf(T item);
+        public int IndexOf(T item, int startIndex);
+        public int IndexOf(T item, int startIndex, IEqualityComparer<T> equalityComparer);
+        public int IndexOf(T item, int startIndex, int count);
+        public int IndexOf(T item, int startIndex, int count, IEqualityComparer<T> equalityComparer);
+        public ImmutableArray<T> Insert(int index, T item);
+        public ImmutableArray<T> InsertRange(int index, IEnumerable<T> items);
+        public ImmutableArray<T> InsertRange(int index, ImmutableArray<T> items);
+        public int LastIndexOf(T item);
+        public int LastIndexOf(T item, int startIndex);
+        public int LastIndexOf(T item, int startIndex, int count);
+        public int LastIndexOf(T item, int startIndex, int count, IEqualityComparer<T> equalityComparer);
+        public IEnumerable<TResult> OfType<TResult>();
+        public static bool operator ==(ImmutableArray<T> left, ImmutableArray<T> right);
+        public static bool operator ==(Nullable<ImmutableArray<T>> left, Nullable<ImmutableArray<T>> right);
+        public static bool operator !=(ImmutableArray<T> left, ImmutableArray<T> right);
+        public static bool operator !=(Nullable<ImmutableArray<T>> left, Nullable<ImmutableArray<T>> right);
+        public ImmutableArray<T> Remove(T item);
+        public ImmutableArray<T> Remove(T item, IEqualityComparer<T> equalityComparer);
+        public ImmutableArray<T> RemoveAll(Predicate<T> match);
+        public ImmutableArray<T> RemoveAt(int index);
+        public ImmutableArray<T> RemoveRange(IEnumerable<T> items);
+        public ImmutableArray<T> RemoveRange(IEnumerable<T> items, IEqualityComparer<T> equalityComparer);
+        public ImmutableArray<T> RemoveRange(ImmutableArray<T> items);
+        public ImmutableArray<T> RemoveRange(ImmutableArray<T> items, IEqualityComparer<T> equalityComparer);
+        public ImmutableArray<T> RemoveRange(int index, int length);
+        public ImmutableArray<T> Replace(T oldValue, T newValue);
+        public ImmutableArray<T> Replace(T oldValue, T newValue, IEqualityComparer<T> equalityComparer);
+        public ImmutableArray<T> SetItem(int index, T item);
+        public ImmutableArray<T> Sort();
+        public ImmutableArray<T> Sort(IComparer<T> comparer);
+        public ImmutableArray<T> Sort(Comparison<T> comparison);
+        public ImmutableArray<T> Sort(int index, int count, IComparer<T> comparer);
+        void System.Collections.Generic.ICollection<T>.Add(T item);
+        void System.Collections.Generic.ICollection<T>.Clear();
+        bool System.Collections.Generic.ICollection<T>.Remove(T item);
+        IEnumerator<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
+        void System.Collections.Generic.IList<T>.Insert(int index, T item);
+        void System.Collections.Generic.IList<T>.RemoveAt(int index);
+        void System.Collections.ICollection.CopyTo(Array array, int index);
+        IEnumerator System.Collections.IEnumerable.GetEnumerator();
+        int System.Collections.IList.Add(object value);
+        void System.Collections.IList.Clear();
+        bool System.Collections.IList.Contains(object value);
+        int System.Collections.IList.IndexOf(object value);
+        void System.Collections.IList.Insert(int index, object value);
+        void System.Collections.IList.Remove(object value);
+        void System.Collections.IList.RemoveAt(int index);
+        IImmutableList<T> System.Collections.Immutable.IImmutableList<T>.Add(T value);
+        IImmutableList<T> System.Collections.Immutable.IImmutableList<T>.AddRange(IEnumerable<T> items);
+        IImmutableList<T> System.Collections.Immutable.IImmutableList<T>.Clear();
+        IImmutableList<T> System.Collections.Immutable.IImmutableList<T>.Insert(int index, T element);
+        IImmutableList<T> System.Collections.Immutable.IImmutableList<T>.InsertRange(int index, IEnumerable<T> items);
+        IImmutableList<T> System.Collections.Immutable.IImmutableList<T>.Remove(T value, IEqualityComparer<T> equalityComparer);
+        IImmutableList<T> System.Collections.Immutable.IImmutableList<T>.RemoveAll(Predicate<T> match);
+        IImmutableList<T> System.Collections.Immutable.IImmutableList<T>.RemoveAt(int index);
+        IImmutableList<T> System.Collections.Immutable.IImmutableList<T>.RemoveRange(IEnumerable<T> items, IEqualityComparer<T> equalityComparer);
+        IImmutableList<T> System.Collections.Immutable.IImmutableList<T>.RemoveRange(int index, int count);
+        IImmutableList<T> System.Collections.Immutable.IImmutableList<T>.Replace(T oldValue, T newValue, IEqualityComparer<T> equalityComparer);
+        IImmutableList<T> System.Collections.Immutable.IImmutableList<T>.SetItem(int index, T value);
+        int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
+        bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
+        int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
+        public ImmutableArray<T>.Builder ToBuilder();
+        public sealed class Builder : ICollection<T>, IEnumerable, IEnumerable<T>, IList<T>, IReadOnlyCollection<T>, IReadOnlyList<T> {
+            public int Capacity { get; set; }
+            public int Count { get; set; }
+            bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
+            public T this[int index] { get; set; }
+            public void Add(T item);
+            public void AddRange(ImmutableArray<T>.Builder items);
+            public void AddRange(IEnumerable<T> items);
+            public void AddRange(ImmutableArray<T> items);
+            public void AddRange(ImmutableArray<T> items, int length);
+            public void AddRange(params T[] items);
+            public void AddRange(T[] items, int length);
+            public void AddRange<TDerived>(ImmutableArray<TDerived>.Builder items) where TDerived : T;
+            public void AddRange<TDerived>(ImmutableArray<TDerived> items) where TDerived : T;
+            public void AddRange<TDerived>(TDerived[] items) where TDerived : T;
+            public void Clear();
+            public bool Contains(T item);
+            public void CopyTo(T[] array, int index);
+            public IEnumerator<T> GetEnumerator();
+            public int IndexOf(T item);
+            public int IndexOf(T item, int startIndex);
+            public int IndexOf(T item, int startIndex, int count);
+            public int IndexOf(T item, int startIndex, int count, IEqualityComparer<T> equalityComparer);
+            public void Insert(int index, T item);
+            public int LastIndexOf(T item);
+            public int LastIndexOf(T item, int startIndex);
+            public int LastIndexOf(T item, int startIndex, int count);
+            public int LastIndexOf(T item, int startIndex, int count, IEqualityComparer<T> equalityComparer);
+            public ImmutableArray<T> MoveToImmutable();
+            public bool Remove(T element);
+            public void RemoveAt(int index);
+            public void Reverse();
+            public void Sort();
+            public void Sort(IComparer<T> comparer);
+            public void Sort(Comparison<T> comparison);
+            public void Sort(int index, int count, IComparer<T> comparer);
+            IEnumerator<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
+            IEnumerator System.Collections.IEnumerable.GetEnumerator();
+            public T[] ToArray();
+            public ImmutableArray<T> ToImmutable();
+        }
+        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+        public struct Enumerator {
+            public T Current { get; }
+            public bool MoveNext();
+        }
+    }
+    public static class ImmutableDictionary {
+        public static bool Contains<TKey, TValue>(this IImmutableDictionary<TKey, TValue> map, TKey key, TValue value);
+        public static ImmutableDictionary<TKey, TValue> Create<TKey, TValue>();
+        public static ImmutableDictionary<TKey, TValue> Create<TKey, TValue>(IEqualityComparer<TKey> keyComparer);
+        public static ImmutableDictionary<TKey, TValue> Create<TKey, TValue>(IEqualityComparer<TKey> keyComparer, IEqualityComparer<TValue> valueComparer);
+        public static ImmutableDictionary<TKey, TValue>.Builder CreateBuilder<TKey, TValue>();
+        public static ImmutableDictionary<TKey, TValue>.Builder CreateBuilder<TKey, TValue>(IEqualityComparer<TKey> keyComparer);
+        public static ImmutableDictionary<TKey, TValue>.Builder CreateBuilder<TKey, TValue>(IEqualityComparer<TKey> keyComparer, IEqualityComparer<TValue> valueComparer);
+        public static ImmutableDictionary<TKey, TValue> CreateRange<TKey, TValue>(IEnumerable<KeyValuePair<TKey, TValue>> items);
+        public static ImmutableDictionary<TKey, TValue> CreateRange<TKey, TValue>(IEqualityComparer<TKey> keyComparer, IEnumerable<KeyValuePair<TKey, TValue>> items);
+        public static ImmutableDictionary<TKey, TValue> CreateRange<TKey, TValue>(IEqualityComparer<TKey> keyComparer, IEqualityComparer<TValue> valueComparer, IEnumerable<KeyValuePair<TKey, TValue>> items);
+        public static TValue GetValueOrDefault<TKey, TValue>(this IImmutableDictionary<TKey, TValue> dictionary, TKey key);
+        public static TValue GetValueOrDefault<TKey, TValue>(this IImmutableDictionary<TKey, TValue> dictionary, TKey key, TValue defaultValue);
+        public static ImmutableDictionary<TKey, TValue> ToImmutableDictionary<TKey, TValue>(this IEnumerable<KeyValuePair<TKey, TValue>> source);
+        public static ImmutableDictionary<TKey, TValue> ToImmutableDictionary<TKey, TValue>(this IEnumerable<KeyValuePair<TKey, TValue>> source, IEqualityComparer<TKey> keyComparer);
+        public static ImmutableDictionary<TKey, TValue> ToImmutableDictionary<TKey, TValue>(this IEnumerable<KeyValuePair<TKey, TValue>> source, IEqualityComparer<TKey> keyComparer, IEqualityComparer<TValue> valueComparer);
+        public static ImmutableDictionary<TKey, TValue> ToImmutableDictionary<TSource, TKey, TValue>(this IEnumerable<TSource> source, Func<TSource, TKey> keySelector, Func<TSource, TValue> elementSelector);
+        public static ImmutableDictionary<TKey, TValue> ToImmutableDictionary<TSource, TKey, TValue>(this IEnumerable<TSource> source, Func<TSource, TKey> keySelector, Func<TSource, TValue> elementSelector, IEqualityComparer<TKey> keyComparer);
+        public static ImmutableDictionary<TKey, TValue> ToImmutableDictionary<TSource, TKey, TValue>(this IEnumerable<TSource> source, Func<TSource, TKey> keySelector, Func<TSource, TValue> elementSelector, IEqualityComparer<TKey> keyComparer, IEqualityComparer<TValue> valueComparer);
+        public static ImmutableDictionary<TKey, TSource> ToImmutableDictionary<TSource, TKey>(this IEnumerable<TSource> source, Func<TSource, TKey> keySelector);
+        public static ImmutableDictionary<TKey, TSource> ToImmutableDictionary<TSource, TKey>(this IEnumerable<TSource> source, Func<TSource, TKey> keySelector, IEqualityComparer<TKey> keyComparer);
+    }
+    public sealed class ImmutableDictionary<TKey, TValue> : ICollection, ICollection<KeyValuePair<TKey, TValue>>, IDictionary, IDictionary<TKey, TValue>, IEnumerable, IEnumerable<KeyValuePair<TKey, TValue>>, IHashKeyCollection<TKey>, IImmutableDictionary<TKey, TValue>, IImmutableDictionaryInternal<TKey, TValue>, IReadOnlyCollection<KeyValuePair<TKey, TValue>>, IReadOnlyDictionary<TKey, TValue> {
+        public static readonly ImmutableDictionary<TKey, TValue> Empty;
+        public int Count { get; }
+        public bool IsEmpty { get; }
+        public IEqualityComparer<TKey> KeyComparer { get; }
+        public IEnumerable<TKey> Keys { get; }
+        bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.IsReadOnly { get; }
+        TValue System.Collections.Generic.IDictionary<TKey,TValue>.this[TKey key] { get; set; }
+        ICollection<TKey> System.Collections.Generic.IDictionary<TKey,TValue>.Keys { get; }
+        ICollection<TValue> System.Collections.Generic.IDictionary<TKey,TValue>.Values { get; }
+        bool System.Collections.ICollection.IsSynchronized { get; }
+        object System.Collections.ICollection.SyncRoot { get; }
+        bool System.Collections.IDictionary.IsFixedSize { get; }
+        bool System.Collections.IDictionary.IsReadOnly { get; }
+        object System.Collections.IDictionary.this[object key] { get; set; }
+        ICollection System.Collections.IDictionary.Keys { get; }
+        ICollection System.Collections.IDictionary.Values { get; }
+        public TValue this[TKey key] { get; }
+        public IEqualityComparer<TValue> ValueComparer { get; }
+        public IEnumerable<TValue> Values { get; }
+        public ImmutableDictionary<TKey, TValue> Add(TKey key, TValue value);
+        public ImmutableDictionary<TKey, TValue> AddRange(IEnumerable<KeyValuePair<TKey, TValue>> pairs);
+        public ImmutableDictionary<TKey, TValue> Clear();
+        public bool Contains(KeyValuePair<TKey, TValue> pair);
+        public bool ContainsKey(TKey key);
+        public bool ContainsValue(TValue value);
+        public ImmutableDictionary<TKey, TValue>.Enumerator GetEnumerator();
+        public ImmutableDictionary<TKey, TValue> Remove(TKey key);
+        public ImmutableDictionary<TKey, TValue> RemoveRange(IEnumerable<TKey> keys);
+        public ImmutableDictionary<TKey, TValue> SetItem(TKey key, TValue value);
+        public ImmutableDictionary<TKey, TValue> SetItems(IEnumerable<KeyValuePair<TKey, TValue>> items);
+        void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Add(KeyValuePair<TKey, TValue> item);
+        void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Clear();
+        void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.CopyTo(KeyValuePair<TKey, TValue>[] array, int arrayIndex);
+        bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Remove(KeyValuePair<TKey, TValue> item);
+        void System.Collections.Generic.IDictionary<TKey,TValue>.Add(TKey key, TValue value);
+        bool System.Collections.Generic.IDictionary<TKey,TValue>.Remove(TKey key);
+        IEnumerator<KeyValuePair<TKey, TValue>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey,TValue>>.GetEnumerator();
+        void System.Collections.ICollection.CopyTo(Array array, int arrayIndex);
+        void System.Collections.IDictionary.Add(object key, object value);
+        void System.Collections.IDictionary.Clear();
+        bool System.Collections.IDictionary.Contains(object key);
+        IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator();
+        void System.Collections.IDictionary.Remove(object key);
+        IEnumerator System.Collections.IEnumerable.GetEnumerator();
+        IImmutableDictionary<TKey, TValue> System.Collections.Immutable.IImmutableDictionary<TKey,TValue>.Add(TKey key, TValue value);
+        IImmutableDictionary<TKey, TValue> System.Collections.Immutable.IImmutableDictionary<TKey,TValue>.AddRange(IEnumerable<KeyValuePair<TKey, TValue>> pairs);
+        IImmutableDictionary<TKey, TValue> System.Collections.Immutable.IImmutableDictionary<TKey,TValue>.Clear();
+        IImmutableDictionary<TKey, TValue> System.Collections.Immutable.IImmutableDictionary<TKey,TValue>.Remove(TKey key);
+        IImmutableDictionary<TKey, TValue> System.Collections.Immutable.IImmutableDictionary<TKey,TValue>.RemoveRange(IEnumerable<TKey> keys);
+        IImmutableDictionary<TKey, TValue> System.Collections.Immutable.IImmutableDictionary<TKey,TValue>.SetItem(TKey key, TValue value);
+        IImmutableDictionary<TKey, TValue> System.Collections.Immutable.IImmutableDictionary<TKey,TValue>.SetItems(IEnumerable<KeyValuePair<TKey, TValue>> items);
+        public ImmutableDictionary<TKey, TValue>.Builder ToBuilder();
+        public bool TryGetKey(TKey equalKey, out TKey actualKey);
+        public bool TryGetValue(TKey key, out TValue value);
+        public ImmutableDictionary<TKey, TValue> WithComparers(IEqualityComparer<TKey> keyComparer);
+        public ImmutableDictionary<TKey, TValue> WithComparers(IEqualityComparer<TKey> keyComparer, IEqualityComparer<TValue> valueComparer);
+        public sealed class Builder : ICollection, ICollection<KeyValuePair<TKey, TValue>>, IDictionary, IDictionary<TKey, TValue>, IEnumerable, IEnumerable<KeyValuePair<TKey, TValue>>, IReadOnlyCollection<KeyValuePair<TKey, TValue>>, IReadOnlyDictionary<TKey, TValue> {
+            public int Count { get; }
+            public IEqualityComparer<TKey> KeyComparer { get; set; }
+            public IEnumerable<TKey> Keys { get; }
+            bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.IsReadOnly { get; }
+            ICollection<TKey> System.Collections.Generic.IDictionary<TKey,TValue>.Keys { get; }
+            ICollection<TValue> System.Collections.Generic.IDictionary<TKey,TValue>.Values { get; }
+            bool System.Collections.ICollection.IsSynchronized { get; }
+            object System.Collections.ICollection.SyncRoot { get; }
+            bool System.Collections.IDictionary.IsFixedSize { get; }
+            bool System.Collections.IDictionary.IsReadOnly { get; }
+            object System.Collections.IDictionary.this[object key] { get; set; }
+            ICollection System.Collections.IDictionary.Keys { get; }
+            ICollection System.Collections.IDictionary.Values { get; }
+            public TValue this[TKey key] { get; set; }
+            public IEqualityComparer<TValue> ValueComparer { get; set; }
+            public IEnumerable<TValue> Values { get; }
+            public void Add(KeyValuePair<TKey, TValue> item);
+            public void Add(TKey key, TValue value);
+            public void AddRange(IEnumerable<KeyValuePair<TKey, TValue>> items);
+            public void Clear();
+            public bool Contains(KeyValuePair<TKey, TValue> item);
+            public bool ContainsKey(TKey key);
+            public bool ContainsValue(TValue value);
+            public ImmutableDictionary<TKey, TValue>.Enumerator GetEnumerator();
+            public TValue GetValueOrDefault(TKey key);
+            public TValue GetValueOrDefault(TKey key, TValue defaultValue);
+            public bool Remove(KeyValuePair<TKey, TValue> item);
+            public bool Remove(TKey key);
+            public void RemoveRange(IEnumerable<TKey> keys);
+            void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.CopyTo(KeyValuePair<TKey, TValue>[] array, int arrayIndex);
+            IEnumerator<KeyValuePair<TKey, TValue>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey,TValue>>.GetEnumerator();
+            void System.Collections.ICollection.CopyTo(Array array, int arrayIndex);
+            void System.Collections.IDictionary.Add(object key, object value);
+            bool System.Collections.IDictionary.Contains(object key);
+            IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator();
+            void System.Collections.IDictionary.Remove(object key);
+            IEnumerator System.Collections.IEnumerable.GetEnumerator();
+            public ImmutableDictionary<TKey, TValue> ToImmutable();
+            public bool TryGetKey(TKey equalKey, out TKey actualKey);
+            public bool TryGetValue(TKey key, out TValue value);
+        }
+        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+        public struct Enumerator : IDisposable, IEnumerator, IEnumerator<KeyValuePair<TKey, TValue>> {
+            public KeyValuePair<TKey, TValue> Current { get; }
+            object System.Collections.IEnumerator.Current { get; }
+            public void Dispose();
+            public bool MoveNext();
+            public void Reset();
+        }
+    }
+    public static class ImmutableHashSet {
+        public static ImmutableHashSet<T> Create<T>();
+        public static ImmutableHashSet<T> Create<T>(IEqualityComparer<T> equalityComparer);
+        public static ImmutableHashSet<T> Create<T>(IEqualityComparer<T> equalityComparer, T item);
+        public static ImmutableHashSet<T> Create<T>(IEqualityComparer<T> equalityComparer, params T[] items);
+        public static ImmutableHashSet<T> Create<T>(T item);
+        public static ImmutableHashSet<T> Create<T>(params T[] items);
+        public static ImmutableHashSet<T>.Builder CreateBuilder<T>();
+        public static ImmutableHashSet<T>.Builder CreateBuilder<T>(IEqualityComparer<T> equalityComparer);
+        public static ImmutableHashSet<T> CreateRange<T>(IEnumerable<T> items);
+        public static ImmutableHashSet<T> CreateRange<T>(IEqualityComparer<T> equalityComparer, IEnumerable<T> items);
+        public static ImmutableHashSet<TSource> ToImmutableHashSet<TSource>(this IEnumerable<TSource> source);
+        public static ImmutableHashSet<TSource> ToImmutableHashSet<TSource>(this IEnumerable<TSource> source, IEqualityComparer<TSource> equalityComparer);
+    }
+    public sealed class ImmutableHashSet<T> : ICollection, ICollection<T>, IEnumerable, IEnumerable<T>, IHashKeyCollection<T>, IImmutableSet<T>, IReadOnlyCollection<T>, ISet<T>, IStrongEnumerable<T, ImmutableHashSet<T>.Enumerator> {
+        public static readonly ImmutableHashSet<T> Empty;
+        public int Count { get; }
+        public bool IsEmpty { get; }
+        public IEqualityComparer<T> KeyComparer { get; }
+        bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
+        bool System.Collections.ICollection.IsSynchronized { get; }
+        object System.Collections.ICollection.SyncRoot { get; }
+        public ImmutableHashSet<T> Add(T item);
+        public ImmutableHashSet<T> Clear();
+        public bool Contains(T item);
+        public ImmutableHashSet<T> Except(IEnumerable<T> other);
+        public ImmutableHashSet<T>.Enumerator GetEnumerator();
+        public ImmutableHashSet<T> Intersect(IEnumerable<T> other);
+        public bool IsProperSubsetOf(IEnumerable<T> other);
+        public bool IsProperSupersetOf(IEnumerable<T> other);
+        public bool IsSubsetOf(IEnumerable<T> other);
+        public bool IsSupersetOf(IEnumerable<T> other);
+        public bool Overlaps(IEnumerable<T> other);
+        public ImmutableHashSet<T> Remove(T item);
+        public bool SetEquals(IEnumerable<T> other);
+        public ImmutableHashSet<T> SymmetricExcept(IEnumerable<T> other);
+        void System.Collections.Generic.ICollection<T>.Add(T item);
+        void System.Collections.Generic.ICollection<T>.Clear();
+        void System.Collections.Generic.ICollection<T>.CopyTo(T[] array, int arrayIndex);
+        bool System.Collections.Generic.ICollection<T>.Remove(T item);
+        IEnumerator<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
+        bool System.Collections.Generic.ISet<T>.Add(T item);
+        void System.Collections.Generic.ISet<T>.ExceptWith(IEnumerable<T> other);
+        void System.Collections.Generic.ISet<T>.IntersectWith(IEnumerable<T> other);
+        void System.Collections.Generic.ISet<T>.SymmetricExceptWith(IEnumerable<T> other);
+        void System.Collections.Generic.ISet<T>.UnionWith(IEnumerable<T> other);
+        void System.Collections.ICollection.CopyTo(Array array, int arrayIndex);
+        IEnumerator System.Collections.IEnumerable.GetEnumerator();
+        IImmutableSet<T> System.Collections.Immutable.IImmutableSet<T>.Add(T item);
+        IImmutableSet<T> System.Collections.Immutable.IImmutableSet<T>.Clear();
+        IImmutableSet<T> System.Collections.Immutable.IImmutableSet<T>.Except(IEnumerable<T> other);
+        IImmutableSet<T> System.Collections.Immutable.IImmutableSet<T>.Intersect(IEnumerable<T> other);
+        IImmutableSet<T> System.Collections.Immutable.IImmutableSet<T>.Remove(T item);
+        IImmutableSet<T> System.Collections.Immutable.IImmutableSet<T>.SymmetricExcept(IEnumerable<T> other);
+        IImmutableSet<T> System.Collections.Immutable.IImmutableSet<T>.Union(IEnumerable<T> other);
+        public ImmutableHashSet<T>.Builder ToBuilder();
+        public bool TryGetValue(T equalValue, out T actualValue);
+        public ImmutableHashSet<T> Union(IEnumerable<T> other);
+        public ImmutableHashSet<T> WithComparer(IEqualityComparer<T> equalityComparer);
+        public sealed class Builder : ICollection<T>, IEnumerable, IEnumerable<T>, IReadOnlyCollection<T>, ISet<T> {
+            public int Count { get; }
+            public IEqualityComparer<T> KeyComparer { get; set; }
+            bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
+            public bool Add(T item);
+            public void Clear();
+            public bool Contains(T item);
+            public void ExceptWith(IEnumerable<T> other);
+            public ImmutableHashSet<T>.Enumerator GetEnumerator();
+            public void IntersectWith(IEnumerable<T> other);
+            public bool IsProperSubsetOf(IEnumerable<T> other);
+            public bool IsProperSupersetOf(IEnumerable<T> other);
+            public bool IsSubsetOf(IEnumerable<T> other);
+            public bool IsSupersetOf(IEnumerable<T> other);
+            public bool Overlaps(IEnumerable<T> other);
+            public bool Remove(T item);
+            public bool SetEquals(IEnumerable<T> other);
+            public void SymmetricExceptWith(IEnumerable<T> other);
+            void System.Collections.Generic.ICollection<T>.Add(T item);
+            void System.Collections.Generic.ICollection<T>.CopyTo(T[] array, int arrayIndex);
+            IEnumerator<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
+            IEnumerator System.Collections.IEnumerable.GetEnumerator();
+            public ImmutableHashSet<T> ToImmutable();
+            public void UnionWith(IEnumerable<T> other);
+        }
+        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+        public struct Enumerator : IDisposable, IEnumerator, IEnumerator<T>, IStrongEnumerator<T> {
+            public T Current { get; }
+            object System.Collections.IEnumerator.Current { get; }
+            public void Dispose();
+            public bool MoveNext();
+            public void Reset();
+        }
+    }
+    public static class ImmutableInterlocked {
+        public static TValue AddOrUpdate<TKey, TValue>(ref ImmutableDictionary<TKey, TValue> location, TKey key, Func<TKey, TValue> addValueFactory, Func<TKey, TValue, TValue> updateValueFactory);
+        public static TValue AddOrUpdate<TKey, TValue>(ref ImmutableDictionary<TKey, TValue> location, TKey key, TValue addValue, Func<TKey, TValue, TValue> updateValueFactory);
+        public static void Enqueue<T>(ref ImmutableQueue<T> location, T value);
+        public static TValue GetOrAdd<TKey, TValue, TArg>(ref ImmutableDictionary<TKey, TValue> location, TKey key, Func<TKey, TArg, TValue> valueFactory, TArg factoryArgument);
+        public static TValue GetOrAdd<TKey, TValue>(ref ImmutableDictionary<TKey, TValue> location, TKey key, Func<TKey, TValue> valueFactory);
+        public static TValue GetOrAdd<TKey, TValue>(ref ImmutableDictionary<TKey, TValue> location, TKey key, TValue value);
+        public static ImmutableArray<T> InterlockedCompareExchange<T>(ref ImmutableArray<T> location, ImmutableArray<T> value, ImmutableArray<T> comparand);
+        public static ImmutableArray<T> InterlockedExchange<T>(ref ImmutableArray<T> location, ImmutableArray<T> value);
+        public static bool InterlockedInitialize<T>(ref ImmutableArray<T> location, ImmutableArray<T> value);
+        public static void Push<T>(ref ImmutableStack<T> location, T value);
+        public static bool TryAdd<TKey, TValue>(ref ImmutableDictionary<TKey, TValue> location, TKey key, TValue value);
+        public static bool TryDequeue<T>(ref ImmutableQueue<T> location, out T value);
+        public static bool TryPop<T>(ref ImmutableStack<T> location, out T value);
+        public static bool TryRemove<TKey, TValue>(ref ImmutableDictionary<TKey, TValue> location, TKey key, out TValue value);
+        public static bool TryUpdate<TKey, TValue>(ref ImmutableDictionary<TKey, TValue> location, TKey key, TValue newValue, TValue comparisonValue);
+        public static bool Update<T, TArg>(ref T location, Func<T, TArg, T> transformer, TArg transformerArgument) where T : class;
+        public static bool Update<T>(ref T location, Func<T, T> transformer) where T : class;
+    }
+    public static class ImmutableList {
+        public static ImmutableList<T> Create<T>();
+        public static ImmutableList<T> Create<T>(T item);
+        public static ImmutableList<T> Create<T>(params T[] items);
+        public static ImmutableList<T>.Builder CreateBuilder<T>();
+        public static ImmutableList<T> CreateRange<T>(IEnumerable<T> items);
+        public static int IndexOf<T>(this IImmutableList<T> list, T item);
+        public static int IndexOf<T>(this IImmutableList<T> list, T item, IEqualityComparer<T> equalityComparer);
+        public static int IndexOf<T>(this IImmutableList<T> list, T item, int startIndex);
+        public static int IndexOf<T>(this IImmutableList<T> list, T item, int startIndex, int count);
+        public static int LastIndexOf<T>(this IImmutableList<T> list, T item);
+        public static int LastIndexOf<T>(this IImmutableList<T> list, T item, IEqualityComparer<T> equalityComparer);
+        public static int LastIndexOf<T>(this IImmutableList<T> list, T item, int startIndex);
+        public static int LastIndexOf<T>(this IImmutableList<T> list, T item, int startIndex, int count);
+        public static IImmutableList<T> Remove<T>(this IImmutableList<T> list, T value);
+        public static IImmutableList<T> RemoveRange<T>(this IImmutableList<T> list, IEnumerable<T> items);
+        public static IImmutableList<T> Replace<T>(this IImmutableList<T> list, T oldValue, T newValue);
+        public static ImmutableList<TSource> ToImmutableList<TSource>(this IEnumerable<TSource> source);
+    }
+    public sealed class ImmutableList<T> : ICollection, ICollection<T>, IEnumerable, IEnumerable<T>, IImmutableList<T>, IImmutableListQueries<T>, IList, IList<T>, IOrderedCollection<T>, IReadOnlyCollection<T>, IReadOnlyList<T>, IStrongEnumerable<T, ImmutableList<T>.Enumerator> {
+        public static readonly ImmutableList<T> Empty;
+        public int Count { get; }
+        public bool IsEmpty { get; }
+        bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
+        T System.Collections.Generic.IList<T>.this[int index] { get; set; }
+        bool System.Collections.ICollection.IsSynchronized { get; }
+        object System.Collections.ICollection.SyncRoot { get; }
+        bool System.Collections.IList.IsFixedSize { get; }
+        bool System.Collections.IList.IsReadOnly { get; }
+        object System.Collections.IList.this[int index] { get; set; }
+        public T this[int index] { get; }
+        public ImmutableList<T> Add(T value);
+        public ImmutableList<T> AddRange(IEnumerable<T> items);
+        public int BinarySearch(int index, int count, T item, IComparer<T> comparer);
+        public int BinarySearch(T item);
+        public int BinarySearch(T item, IComparer<T> comparer);
+        public ImmutableList<T> Clear();
+        public bool Contains(T value);
+        public ImmutableList<TOutput> ConvertAll<TOutput>(Func<T, TOutput> converter);
+        public void CopyTo(int index, T[] array, int arrayIndex, int count);
+        public void CopyTo(T[] array);
+        public void CopyTo(T[] array, int arrayIndex);
+        public bool Exists(Predicate<T> match);
+        public T Find(Predicate<T> match);
+        public ImmutableList<T> FindAll(Predicate<T> match);
+        public int FindIndex(int startIndex, int count, Predicate<T> match);
+        public int FindIndex(int startIndex, Predicate<T> match);
+        public int FindIndex(Predicate<T> match);
+        public T FindLast(Predicate<T> match);
+        public int FindLastIndex(int startIndex, int count, Predicate<T> match);
+        public int FindLastIndex(int startIndex, Predicate<T> match);
+        public int FindLastIndex(Predicate<T> match);
+        public void ForEach(Action<T> action);
+        public ImmutableList<T>.Enumerator GetEnumerator();
+        public ImmutableList<T> GetRange(int index, int count);
+        public int IndexOf(T value);
+        public int IndexOf(T item, int index, int count, IEqualityComparer<T> equalityComparer);
+        public ImmutableList<T> Insert(int index, T item);
+        public ImmutableList<T> InsertRange(int index, IEnumerable<T> items);
+        public int LastIndexOf(T item, int index, int count, IEqualityComparer<T> equalityComparer);
+        public ImmutableList<T> Remove(T value);
+        public ImmutableList<T> Remove(T value, IEqualityComparer<T> equalityComparer);
+        public ImmutableList<T> RemoveAll(Predicate<T> match);
+        public ImmutableList<T> RemoveAt(int index);
+        public ImmutableList<T> RemoveRange(IEnumerable<T> items);
+        public ImmutableList<T> RemoveRange(IEnumerable<T> items, IEqualityComparer<T> equalityComparer);
+        public ImmutableList<T> RemoveRange(int index, int count);
+        public ImmutableList<T> Replace(T oldValue, T newValue);
+        public ImmutableList<T> Replace(T oldValue, T newValue, IEqualityComparer<T> equalityComparer);
+        public ImmutableList<T> Reverse();
+        public ImmutableList<T> Reverse(int index, int count);
+        public ImmutableList<T> SetItem(int index, T value);
+        public ImmutableList<T> Sort();
+        public ImmutableList<T> Sort(IComparer<T> comparer);
+        public ImmutableList<T> Sort(Comparison<T> comparison);
+        public ImmutableList<T> Sort(int index, int count, IComparer<T> comparer);
+        void System.Collections.Generic.ICollection<T>.Add(T item);
+        void System.Collections.Generic.ICollection<T>.Clear();
+        bool System.Collections.Generic.ICollection<T>.Remove(T item);
+        IEnumerator<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
+        void System.Collections.Generic.IList<T>.Insert(int index, T item);
+        void System.Collections.Generic.IList<T>.RemoveAt(int index);
+        void System.Collections.ICollection.CopyTo(Array array, int arrayIndex);
+        IEnumerator System.Collections.IEnumerable.GetEnumerator();
+        int System.Collections.IList.Add(object value);
+        void System.Collections.IList.Clear();
+        bool System.Collections.IList.Contains(object value);
+        int System.Collections.IList.IndexOf(object value);
+        void System.Collections.IList.Insert(int index, object value);
+        void System.Collections.IList.Remove(object value);
+        void System.Collections.IList.RemoveAt(int index);
+        IImmutableList<T> System.Collections.Immutable.IImmutableList<T>.Add(T value);
+        IImmutableList<T> System.Collections.Immutable.IImmutableList<T>.AddRange(IEnumerable<T> items);
+        IImmutableList<T> System.Collections.Immutable.IImmutableList<T>.Clear();
+        IImmutableList<T> System.Collections.Immutable.IImmutableList<T>.Insert(int index, T item);
+        IImmutableList<T> System.Collections.Immutable.IImmutableList<T>.InsertRange(int index, IEnumerable<T> items);
+        IImmutableList<T> System.Collections.Immutable.IImmutableList<T>.Remove(T value, IEqualityComparer<T> equalityComparer);
+        IImmutableList<T> System.Collections.Immutable.IImmutableList<T>.RemoveAll(Predicate<T> match);
+        IImmutableList<T> System.Collections.Immutable.IImmutableList<T>.RemoveAt(int index);
+        IImmutableList<T> System.Collections.Immutable.IImmutableList<T>.RemoveRange(IEnumerable<T> items, IEqualityComparer<T> equalityComparer);
+        IImmutableList<T> System.Collections.Immutable.IImmutableList<T>.RemoveRange(int index, int count);
+        IImmutableList<T> System.Collections.Immutable.IImmutableList<T>.Replace(T oldValue, T newValue, IEqualityComparer<T> equalityComparer);
+        IImmutableList<T> System.Collections.Immutable.IImmutableList<T>.SetItem(int index, T value);
+        public ImmutableList<T>.Builder ToBuilder();
+        public bool TrueForAll(Predicate<T> match);
+        public sealed class Builder : ICollection, ICollection<T>, IEnumerable, IEnumerable<T>, IImmutableListQueries<T>, IList, IList<T>, IOrderedCollection<T>, IReadOnlyCollection<T>, IReadOnlyList<T> {
+            public int Count { get; }
+            bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
+            bool System.Collections.ICollection.IsSynchronized { get; }
+            object System.Collections.ICollection.SyncRoot { get; }
+            bool System.Collections.IList.IsFixedSize { get; }
+            bool System.Collections.IList.IsReadOnly { get; }
+            object System.Collections.IList.this[int index] { get; set; }
+            public T this[int index] { get; set; }
+            public void Add(T item);
+            public void AddRange(IEnumerable<T> items);
+            public int BinarySearch(int index, int count, T item, IComparer<T> comparer);
+            public int BinarySearch(T item);
+            public int BinarySearch(T item, IComparer<T> comparer);
+            public void Clear();
+            public bool Contains(T item);
+            public ImmutableList<TOutput> ConvertAll<TOutput>(Func<T, TOutput> converter);
+            public void CopyTo(int index, T[] array, int arrayIndex, int count);
+            public void CopyTo(T[] array);
+            public void CopyTo(T[] array, int arrayIndex);
+            public bool Exists(Predicate<T> match);
+            public T Find(Predicate<T> match);
+            public ImmutableList<T> FindAll(Predicate<T> match);
+            public int FindIndex(int startIndex, int count, Predicate<T> match);
+            public int FindIndex(int startIndex, Predicate<T> match);
+            public int FindIndex(Predicate<T> match);
+            public T FindLast(Predicate<T> match);
+            public int FindLastIndex(int startIndex, int count, Predicate<T> match);
+            public int FindLastIndex(int startIndex, Predicate<T> match);
+            public int FindLastIndex(Predicate<T> match);
+            public void ForEach(Action<T> action);
+            public ImmutableList<T>.Enumerator GetEnumerator();
+            public ImmutableList<T> GetRange(int index, int count);
+            public int IndexOf(T item);
+            public int IndexOf(T item, int index);
+            public int IndexOf(T item, int index, int count);
+            public int IndexOf(T item, int index, int count, IEqualityComparer<T> equalityComparer);
+            public void Insert(int index, T item);
+            public void InsertRange(int index, IEnumerable<T> items);
+            public int LastIndexOf(T item);
+            public int LastIndexOf(T item, int startIndex);
+            public int LastIndexOf(T item, int startIndex, int count);
+            public int LastIndexOf(T item, int startIndex, int count, IEqualityComparer<T> equalityComparer);
+            public bool Remove(T item);
+            public int RemoveAll(Predicate<T> match);
+            public void RemoveAt(int index);
+            public void Reverse();
+            public void Reverse(int index, int count);
+            public void Sort();
+            public void Sort(IComparer<T> comparer);
+            public void Sort(Comparison<T> comparison);
+            public void Sort(int index, int count, IComparer<T> comparer);
+            IEnumerator<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
+            void System.Collections.ICollection.CopyTo(Array array, int arrayIndex);
+            IEnumerator System.Collections.IEnumerable.GetEnumerator();
+            int System.Collections.IList.Add(object value);
+            void System.Collections.IList.Clear();
+            bool System.Collections.IList.Contains(object value);
+            int System.Collections.IList.IndexOf(object value);
+            void System.Collections.IList.Insert(int index, object value);
+            void System.Collections.IList.Remove(object value);
+            public ImmutableList<T> ToImmutable();
+            public bool TrueForAll(Predicate<T> match);
+        }
+        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+        public struct Enumerator : IDisposable, IEnumerator, IEnumerator<T>, ISecurePooledObjectUser, IStrongEnumerator<T> {
+            public T Current { get; }
+            object System.Collections.IEnumerator.Current { get; }
+            public void Dispose();
+            public bool MoveNext();
+            public void Reset();
+        }
+    }
+    public static class ImmutableQueue {
+        public static ImmutableQueue<T> Create<T>();
+        public static ImmutableQueue<T> Create<T>(T item);
+        public static ImmutableQueue<T> Create<T>(params T[] items);
+        public static ImmutableQueue<T> CreateRange<T>(IEnumerable<T> items);
+        public static IImmutableQueue<T> Dequeue<T>(this IImmutableQueue<T> queue, out T value);
+    }
+    public sealed class ImmutableQueue<T> : IEnumerable, IEnumerable<T>, IImmutableQueue<T> {
+        public static ImmutableQueue<T> Empty { get; }
+        public bool IsEmpty { get; }
+        public ImmutableQueue<T> Clear();
+        public ImmutableQueue<T> Dequeue();
+        public ImmutableQueue<T> Dequeue(out T value);
+        public ImmutableQueue<T> Enqueue(T value);
+        public ImmutableQueue<T>.Enumerator GetEnumerator();
+        public T Peek();
+        IEnumerator<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
+        IEnumerator System.Collections.IEnumerable.GetEnumerator();
+        IImmutableQueue<T> System.Collections.Immutable.IImmutableQueue<T>.Clear();
+        IImmutableQueue<T> System.Collections.Immutable.IImmutableQueue<T>.Dequeue();
+        IImmutableQueue<T> System.Collections.Immutable.IImmutableQueue<T>.Enqueue(T value);
+        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+        public struct Enumerator {
+            public T Current { get; }
+            public bool MoveNext();
+        }
+    }
+    public static class ImmutableSortedDictionary {
+        public static ImmutableSortedDictionary<TKey, TValue> Create<TKey, TValue>();
+        public static ImmutableSortedDictionary<TKey, TValue> Create<TKey, TValue>(IComparer<TKey> keyComparer);
+        public static ImmutableSortedDictionary<TKey, TValue> Create<TKey, TValue>(IComparer<TKey> keyComparer, IEqualityComparer<TValue> valueComparer);
+        public static ImmutableSortedDictionary<TKey, TValue>.Builder CreateBuilder<TKey, TValue>();
+        public static ImmutableSortedDictionary<TKey, TValue>.Builder CreateBuilder<TKey, TValue>(IComparer<TKey> keyComparer);
+        public static ImmutableSortedDictionary<TKey, TValue>.Builder CreateBuilder<TKey, TValue>(IComparer<TKey> keyComparer, IEqualityComparer<TValue> valueComparer);
+        public static ImmutableSortedDictionary<TKey, TValue> CreateRange<TKey, TValue>(IComparer<TKey> keyComparer, IEnumerable<KeyValuePair<TKey, TValue>> items);
+        public static ImmutableSortedDictionary<TKey, TValue> CreateRange<TKey, TValue>(IComparer<TKey> keyComparer, IEqualityComparer<TValue> valueComparer, IEnumerable<KeyValuePair<TKey, TValue>> items);
+        public static ImmutableSortedDictionary<TKey, TValue> CreateRange<TKey, TValue>(IEnumerable<KeyValuePair<TKey, TValue>> items);
+        public static ImmutableSortedDictionary<TKey, TValue> ToImmutableSortedDictionary<TKey, TValue>(this IEnumerable<KeyValuePair<TKey, TValue>> source);
+        public static ImmutableSortedDictionary<TKey, TValue> ToImmutableSortedDictionary<TKey, TValue>(this IEnumerable<KeyValuePair<TKey, TValue>> source, IComparer<TKey> keyComparer);
+        public static ImmutableSortedDictionary<TKey, TValue> ToImmutableSortedDictionary<TKey, TValue>(this IEnumerable<KeyValuePair<TKey, TValue>> source, IComparer<TKey> keyComparer, IEqualityComparer<TValue> valueComparer);
+        public static ImmutableSortedDictionary<TKey, TValue> ToImmutableSortedDictionary<TSource, TKey, TValue>(this IEnumerable<TSource> source, Func<TSource, TKey> keySelector, Func<TSource, TValue> elementSelector);
+        public static ImmutableSortedDictionary<TKey, TValue> ToImmutableSortedDictionary<TSource, TKey, TValue>(this IEnumerable<TSource> source, Func<TSource, TKey> keySelector, Func<TSource, TValue> elementSelector, IComparer<TKey> keyComparer);
+        public static ImmutableSortedDictionary<TKey, TValue> ToImmutableSortedDictionary<TSource, TKey, TValue>(this IEnumerable<TSource> source, Func<TSource, TKey> keySelector, Func<TSource, TValue> elementSelector, IComparer<TKey> keyComparer, IEqualityComparer<TValue> valueComparer);
+    }
+    public sealed class ImmutableSortedDictionary<TKey, TValue> : ICollection, ICollection<KeyValuePair<TKey, TValue>>, IDictionary, IDictionary<TKey, TValue>, IEnumerable, IEnumerable<KeyValuePair<TKey, TValue>>, IImmutableDictionary<TKey, TValue>, IReadOnlyCollection<KeyValuePair<TKey, TValue>>, IReadOnlyDictionary<TKey, TValue>, ISortKeyCollection<TKey> {
+        public static readonly ImmutableSortedDictionary<TKey, TValue> Empty;
+        public int Count { get; }
+        public bool IsEmpty { get; }
+        public IComparer<TKey> KeyComparer { get; }
+        public IEnumerable<TKey> Keys { get; }
+        bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.IsReadOnly { get; }
+        TValue System.Collections.Generic.IDictionary<TKey,TValue>.this[TKey key] { get; set; }
+        ICollection<TKey> System.Collections.Generic.IDictionary<TKey,TValue>.Keys { get; }
+        ICollection<TValue> System.Collections.Generic.IDictionary<TKey,TValue>.Values { get; }
+        bool System.Collections.ICollection.IsSynchronized { get; }
+        object System.Collections.ICollection.SyncRoot { get; }
+        bool System.Collections.IDictionary.IsFixedSize { get; }
+        bool System.Collections.IDictionary.IsReadOnly { get; }
+        object System.Collections.IDictionary.this[object key] { get; set; }
+        ICollection System.Collections.IDictionary.Keys { get; }
+        ICollection System.Collections.IDictionary.Values { get; }
+        public TValue this[TKey key] { get; }
+        public IEqualityComparer<TValue> ValueComparer { get; }
+        public IEnumerable<TValue> Values { get; }
+        public ImmutableSortedDictionary<TKey, TValue> Add(TKey key, TValue value);
+        public ImmutableSortedDictionary<TKey, TValue> AddRange(IEnumerable<KeyValuePair<TKey, TValue>> items);
+        public ImmutableSortedDictionary<TKey, TValue> Clear();
+        public bool Contains(KeyValuePair<TKey, TValue> pair);
+        public bool ContainsKey(TKey key);
+        public bool ContainsValue(TValue value);
+        public ImmutableSortedDictionary<TKey, TValue>.Enumerator GetEnumerator();
+        public ImmutableSortedDictionary<TKey, TValue> Remove(TKey value);
+        public ImmutableSortedDictionary<TKey, TValue> RemoveRange(IEnumerable<TKey> keys);
+        public ImmutableSortedDictionary<TKey, TValue> SetItem(TKey key, TValue value);
+        public ImmutableSortedDictionary<TKey, TValue> SetItems(IEnumerable<KeyValuePair<TKey, TValue>> items);
+        void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Add(KeyValuePair<TKey, TValue> item);
+        void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Clear();
+        void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.CopyTo(KeyValuePair<TKey, TValue>[] array, int arrayIndex);
+        bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Remove(KeyValuePair<TKey, TValue> item);
+        void System.Collections.Generic.IDictionary<TKey,TValue>.Add(TKey key, TValue value);
+        bool System.Collections.Generic.IDictionary<TKey,TValue>.Remove(TKey key);
+        IEnumerator<KeyValuePair<TKey, TValue>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey,TValue>>.GetEnumerator();
+        void System.Collections.ICollection.CopyTo(Array array, int index);
+        void System.Collections.IDictionary.Add(object key, object value);
+        void System.Collections.IDictionary.Clear();
+        bool System.Collections.IDictionary.Contains(object key);
+        IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator();
+        void System.Collections.IDictionary.Remove(object key);
+        IEnumerator System.Collections.IEnumerable.GetEnumerator();
+        IImmutableDictionary<TKey, TValue> System.Collections.Immutable.IImmutableDictionary<TKey,TValue>.Add(TKey key, TValue value);
+        IImmutableDictionary<TKey, TValue> System.Collections.Immutable.IImmutableDictionary<TKey,TValue>.AddRange(IEnumerable<KeyValuePair<TKey, TValue>> pairs);
+        IImmutableDictionary<TKey, TValue> System.Collections.Immutable.IImmutableDictionary<TKey,TValue>.Clear();
+        IImmutableDictionary<TKey, TValue> System.Collections.Immutable.IImmutableDictionary<TKey,TValue>.Remove(TKey key);
+        IImmutableDictionary<TKey, TValue> System.Collections.Immutable.IImmutableDictionary<TKey,TValue>.RemoveRange(IEnumerable<TKey> keys);
+        IImmutableDictionary<TKey, TValue> System.Collections.Immutable.IImmutableDictionary<TKey,TValue>.SetItem(TKey key, TValue value);
+        IImmutableDictionary<TKey, TValue> System.Collections.Immutable.IImmutableDictionary<TKey,TValue>.SetItems(IEnumerable<KeyValuePair<TKey, TValue>> items);
+        public ImmutableSortedDictionary<TKey, TValue>.Builder ToBuilder();
+        public bool TryGetKey(TKey equalKey, out TKey actualKey);
+        public bool TryGetValue(TKey key, out TValue value);
+        public ImmutableSortedDictionary<TKey, TValue> WithComparers(IComparer<TKey> keyComparer);
+        public ImmutableSortedDictionary<TKey, TValue> WithComparers(IComparer<TKey> keyComparer, IEqualityComparer<TValue> valueComparer);
+        public sealed class Builder : ICollection, ICollection<KeyValuePair<TKey, TValue>>, IDictionary, IDictionary<TKey, TValue>, IEnumerable, IEnumerable<KeyValuePair<TKey, TValue>>, IReadOnlyCollection<KeyValuePair<TKey, TValue>>, IReadOnlyDictionary<TKey, TValue> {
+            public int Count { get; }
+            public IComparer<TKey> KeyComparer { get; set; }
+            public IEnumerable<TKey> Keys { get; }
+            bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.IsReadOnly { get; }
+            ICollection<TKey> System.Collections.Generic.IDictionary<TKey,TValue>.Keys { get; }
+            ICollection<TValue> System.Collections.Generic.IDictionary<TKey,TValue>.Values { get; }
+            bool System.Collections.ICollection.IsSynchronized { get; }
+            object System.Collections.ICollection.SyncRoot { get; }
+            bool System.Collections.IDictionary.IsFixedSize { get; }
+            bool System.Collections.IDictionary.IsReadOnly { get; }
+            object System.Collections.IDictionary.this[object key] { get; set; }
+            ICollection System.Collections.IDictionary.Keys { get; }
+            ICollection System.Collections.IDictionary.Values { get; }
+            public TValue this[TKey key] { get; set; }
+            public IEqualityComparer<TValue> ValueComparer { get; set; }
+            public IEnumerable<TValue> Values { get; }
+            public void Add(KeyValuePair<TKey, TValue> item);
+            public void Add(TKey key, TValue value);
+            public void AddRange(IEnumerable<KeyValuePair<TKey, TValue>> items);
+            public void Clear();
+            public bool Contains(KeyValuePair<TKey, TValue> item);
+            public bool ContainsKey(TKey key);
+            public bool ContainsValue(TValue value);
+            public ImmutableSortedDictionary<TKey, TValue>.Enumerator GetEnumerator();
+            public TValue GetValueOrDefault(TKey key);
+            public TValue GetValueOrDefault(TKey key, TValue defaultValue);
+            public bool Remove(KeyValuePair<TKey, TValue> item);
+            public bool Remove(TKey key);
+            public void RemoveRange(IEnumerable<TKey> keys);
+            void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.CopyTo(KeyValuePair<TKey, TValue>[] array, int arrayIndex);
+            IEnumerator<KeyValuePair<TKey, TValue>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey,TValue>>.GetEnumerator();
+            void System.Collections.ICollection.CopyTo(Array array, int index);
+            void System.Collections.IDictionary.Add(object key, object value);
+            bool System.Collections.IDictionary.Contains(object key);
+            IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator();
+            void System.Collections.IDictionary.Remove(object key);
+            IEnumerator System.Collections.IEnumerable.GetEnumerator();
+            public ImmutableSortedDictionary<TKey, TValue> ToImmutable();
+            public bool TryGetKey(TKey equalKey, out TKey actualKey);
+            public bool TryGetValue(TKey key, out TValue value);
+        }
+        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+        public struct Enumerator : IDisposable, IEnumerator, IEnumerator<KeyValuePair<TKey, TValue>>, ISecurePooledObjectUser {
+            public KeyValuePair<TKey, TValue> Current { get; }
+            object System.Collections.IEnumerator.Current { get; }
+            public void Dispose();
+            public bool MoveNext();
+            public void Reset();
+        }
+    }
+    public static class ImmutableSortedSet {
+        public static ImmutableSortedSet<T> Create<T>();
+        public static ImmutableSortedSet<T> Create<T>(IComparer<T> comparer);
+        public static ImmutableSortedSet<T> Create<T>(IComparer<T> comparer, T item);
+        public static ImmutableSortedSet<T> Create<T>(IComparer<T> comparer, params T[] items);
+        public static ImmutableSortedSet<T> Create<T>(T item);
+        public static ImmutableSortedSet<T> Create<T>(params T[] items);
+        public static ImmutableSortedSet<T>.Builder CreateBuilder<T>();
+        public static ImmutableSortedSet<T>.Builder CreateBuilder<T>(IComparer<T> comparer);
+        public static ImmutableSortedSet<T> CreateRange<T>(IComparer<T> comparer, IEnumerable<T> items);
+        public static ImmutableSortedSet<T> CreateRange<T>(IEnumerable<T> items);
+        public static ImmutableSortedSet<TSource> ToImmutableSortedSet<TSource>(this IEnumerable<TSource> source);
+        public static ImmutableSortedSet<TSource> ToImmutableSortedSet<TSource>(this IEnumerable<TSource> source, IComparer<TSource> comparer);
+    }
+    public sealed class ImmutableSortedSet<T> : ICollection, ICollection<T>, IEnumerable, IEnumerable<T>, IImmutableSet<T>, IList, IList<T>, IReadOnlyCollection<T>, IReadOnlyList<T>, ISet<T>, ISortKeyCollection<T>, IStrongEnumerable<T, ImmutableSortedSet<T>.Enumerator> {
+        public static readonly ImmutableSortedSet<T> Empty;
+        public int Count { get; }
+        public bool IsEmpty { get; }
+        public IComparer<T> KeyComparer { get; }
+        public T Max { get; }
+        public T Min { get; }
+        bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
+        T System.Collections.Generic.IList<T>.this[int index] { get; set; }
+        bool System.Collections.ICollection.IsSynchronized { get; }
+        object System.Collections.ICollection.SyncRoot { get; }
+        bool System.Collections.IList.IsFixedSize { get; }
+        bool System.Collections.IList.IsReadOnly { get; }
+        object System.Collections.IList.this[int index] { get; set; }
+        public T this[int index] { get; }
+        public ImmutableSortedSet<T> Add(T value);
+        public ImmutableSortedSet<T> Clear();
+        public bool Contains(T value);
+        public ImmutableSortedSet<T> Except(IEnumerable<T> other);
+        public ImmutableSortedSet<T>.Enumerator GetEnumerator();
+        public int IndexOf(T item);
+        public ImmutableSortedSet<T> Intersect(IEnumerable<T> other);
+        public bool IsProperSubsetOf(IEnumerable<T> other);
+        public bool IsProperSupersetOf(IEnumerable<T> other);
+        public bool IsSubsetOf(IEnumerable<T> other);
+        public bool IsSupersetOf(IEnumerable<T> other);
+        public bool Overlaps(IEnumerable<T> other);
+        public ImmutableSortedSet<T> Remove(T value);
+        public IEnumerable<T> Reverse();
+        public bool SetEquals(IEnumerable<T> other);
+        public ImmutableSortedSet<T> SymmetricExcept(IEnumerable<T> other);
+        void System.Collections.Generic.ICollection<T>.Add(T item);
+        void System.Collections.Generic.ICollection<T>.Clear();
+        void System.Collections.Generic.ICollection<T>.CopyTo(T[] array, int arrayIndex);
+        bool System.Collections.Generic.ICollection<T>.Remove(T item);
+        IEnumerator<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
+        void System.Collections.Generic.IList<T>.Insert(int index, T item);
+        void System.Collections.Generic.IList<T>.RemoveAt(int index);
+        bool System.Collections.Generic.ISet<T>.Add(T item);
+        void System.Collections.Generic.ISet<T>.ExceptWith(IEnumerable<T> other);
+        void System.Collections.Generic.ISet<T>.IntersectWith(IEnumerable<T> other);
+        void System.Collections.Generic.ISet<T>.SymmetricExceptWith(IEnumerable<T> other);
+        void System.Collections.Generic.ISet<T>.UnionWith(IEnumerable<T> other);
+        void System.Collections.ICollection.CopyTo(Array array, int index);
+        IEnumerator System.Collections.IEnumerable.GetEnumerator();
+        int System.Collections.IList.Add(object value);
+        void System.Collections.IList.Clear();
+        bool System.Collections.IList.Contains(object value);
+        int System.Collections.IList.IndexOf(object value);
+        void System.Collections.IList.Insert(int index, object value);
+        void System.Collections.IList.Remove(object value);
+        void System.Collections.IList.RemoveAt(int index);
+        IImmutableSet<T> System.Collections.Immutable.IImmutableSet<T>.Add(T value);
+        IImmutableSet<T> System.Collections.Immutable.IImmutableSet<T>.Clear();
+        IImmutableSet<T> System.Collections.Immutable.IImmutableSet<T>.Except(IEnumerable<T> other);
+        IImmutableSet<T> System.Collections.Immutable.IImmutableSet<T>.Intersect(IEnumerable<T> other);
+        IImmutableSet<T> System.Collections.Immutable.IImmutableSet<T>.Remove(T value);
+        IImmutableSet<T> System.Collections.Immutable.IImmutableSet<T>.SymmetricExcept(IEnumerable<T> other);
+        IImmutableSet<T> System.Collections.Immutable.IImmutableSet<T>.Union(IEnumerable<T> other);
+        public ImmutableSortedSet<T>.Builder ToBuilder();
+        public bool TryGetValue(T equalValue, out T actualValue);
+        public ImmutableSortedSet<T> Union(IEnumerable<T> other);
+        public ImmutableSortedSet<T> WithComparer(IComparer<T> comparer);
+        public sealed class Builder : ICollection, ICollection<T>, IEnumerable, IEnumerable<T>, IReadOnlyCollection<T>, ISet<T>, ISortKeyCollection<T> {
+            public int Count { get; }
+            public IComparer<T> KeyComparer { get; set; }
+            public T Max { get; }
+            public T Min { get; }
+            bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
+            bool System.Collections.ICollection.IsSynchronized { get; }
+            object System.Collections.ICollection.SyncRoot { get; }
+            public T this[int index] { get; }
+            public bool Add(T item);
+            public void Clear();
+            public bool Contains(T item);
+            public void ExceptWith(IEnumerable<T> other);
+            public ImmutableSortedSet<T>.Enumerator GetEnumerator();
+            public void IntersectWith(IEnumerable<T> other);
+            public bool IsProperSubsetOf(IEnumerable<T> other);
+            public bool IsProperSupersetOf(IEnumerable<T> other);
+            public bool IsSubsetOf(IEnumerable<T> other);
+            public bool IsSupersetOf(IEnumerable<T> other);
+            public bool Overlaps(IEnumerable<T> other);
+            public bool Remove(T item);
+            public IEnumerable<T> Reverse();
+            public bool SetEquals(IEnumerable<T> other);
+            public void SymmetricExceptWith(IEnumerable<T> other);
+            void System.Collections.Generic.ICollection<T>.Add(T item);
+            void System.Collections.Generic.ICollection<T>.CopyTo(T[] array, int arrayIndex);
+            IEnumerator<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
+            void System.Collections.ICollection.CopyTo(Array array, int arrayIndex);
+            IEnumerator System.Collections.IEnumerable.GetEnumerator();
+            public ImmutableSortedSet<T> ToImmutable();
+            public void UnionWith(IEnumerable<T> other);
+        }
+        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+        public struct Enumerator : IDisposable, IEnumerator, IEnumerator<T>, ISecurePooledObjectUser, IStrongEnumerator<T> {
+            public T Current { get; }
+            object System.Collections.IEnumerator.Current { get; }
+            public void Dispose();
+            public bool MoveNext();
+            public void Reset();
+        }
+    }
+    public static class ImmutableStack {
+        public static ImmutableStack<T> Create<T>();
+        public static ImmutableStack<T> Create<T>(T item);
+        public static ImmutableStack<T> Create<T>(params T[] items);
+        public static ImmutableStack<T> CreateRange<T>(IEnumerable<T> items);
+        public static IImmutableStack<T> Pop<T>(this IImmutableStack<T> stack, out T value);
+    }
+    public sealed class ImmutableStack<T> : IEnumerable, IEnumerable<T>, IImmutableStack<T> {
+        public static ImmutableStack<T> Empty { get; }
+        public bool IsEmpty { get; }
+        public ImmutableStack<T> Clear();
+        public ImmutableStack<T>.Enumerator GetEnumerator();
+        public T Peek();
+        public ImmutableStack<T> Pop();
+        public ImmutableStack<T> Pop(out T value);
+        public ImmutableStack<T> Push(T value);
+        IEnumerator<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
+        IEnumerator System.Collections.IEnumerable.GetEnumerator();
+        IImmutableStack<T> System.Collections.Immutable.IImmutableStack<T>.Clear();
+        IImmutableStack<T> System.Collections.Immutable.IImmutableStack<T>.Pop();
+        IImmutableStack<T> System.Collections.Immutable.IImmutableStack<T>.Push(T value);
+        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+        public struct Enumerator {
+            public T Current { get; }
+            public bool MoveNext();
+        }
+    }
+}
```

## System.Collections.ObjectModel

```c#
+namespace System.Collections.ObjectModel {
+    public class Collection<T> : ICollection, ICollection<T>, IEnumerable, IEnumerable<T>, IList, IList<T>, IReadOnlyCollection<T>, IReadOnlyList<T> {
+        public Collection();
+        public Collection(IList<T> list);
+        public int Count { get; }
+        protected IList<T> Items { get; }
+        bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
+        bool System.Collections.ICollection.IsSynchronized { get; }
+        object System.Collections.ICollection.SyncRoot { get; }
+        bool System.Collections.IList.IsFixedSize { get; }
+        bool System.Collections.IList.IsReadOnly { get; }
+        object System.Collections.IList.this[int index] { get; set; }
+        public T this[int index] { get; set; }
+        public void Add(T item);
+        public void Clear();
+        protected virtual void ClearItems();
+        public bool Contains(T item);
+        public void CopyTo(T[] array, int index);
+        public IEnumerator<T> GetEnumerator();
+        public int IndexOf(T item);
+        public void Insert(int index, T item);
+        protected virtual void InsertItem(int index, T item);
+        public bool Remove(T item);
+        public void RemoveAt(int index);
+        protected virtual void RemoveItem(int index);
+        protected virtual void SetItem(int index, T item);
+        void System.Collections.ICollection.CopyTo(Array array, int index);
+        IEnumerator System.Collections.IEnumerable.GetEnumerator();
+        int System.Collections.IList.Add(object value);
+        bool System.Collections.IList.Contains(object value);
+        int System.Collections.IList.IndexOf(object value);
+        void System.Collections.IList.Insert(int index, object value);
+        void System.Collections.IList.Remove(object value);
+    }
+    public abstract class KeyedCollection<TKey, TItem> : Collection<TItem> {
+        protected KeyedCollection();
+        protected KeyedCollection(IEqualityComparer<TKey> comparer);
+        protected KeyedCollection(IEqualityComparer<TKey> comparer, int dictionaryCreationThreshold);
+        public IEqualityComparer<TKey> Comparer { get; }
+        protected IDictionary<TKey, TItem> Dictionary { get; }
+        public TItem this[TKey key] { get; }
+        protected void ChangeItemKey(TItem item, TKey newKey);
+        protected override void ClearItems();
+        public bool Contains(TKey key);
+        protected abstract TKey GetKeyForItem(TItem item);
+        protected override void InsertItem(int index, TItem item);
+        public bool Remove(TKey key);
+        protected override void RemoveItem(int index);
+        protected override void SetItem(int index, TItem item);
+    }
+    public class ObservableCollection<T> : Collection<T>, INotifyCollectionChanged, INotifyPropertyChanged {
+        public ObservableCollection();
+        public ObservableCollection(IEnumerable<T> collection);
+        public virtual event NotifyCollectionChangedEventHandler CollectionChanged;
+        protected virtual event PropertyChangedEventHandler PropertyChanged;
+        event PropertyChangedEventHandler System.ComponentModel.INotifyPropertyChanged.PropertyChanged;
+        protected IDisposable BlockReentrancy();
+        protected void CheckReentrancy();
+        protected override void ClearItems();
+        protected override void InsertItem(int index, T item);
+        public void Move(int oldIndex, int newIndex);
+        protected virtual void MoveItem(int oldIndex, int newIndex);
+        protected virtual void OnCollectionChanged(NotifyCollectionChangedEventArgs e);
+        protected virtual void OnPropertyChanged(PropertyChangedEventArgs e);
+        protected override void RemoveItem(int index);
+        protected override void SetItem(int index, T item);
+    }
+    public class ReadOnlyCollection<T> : ICollection, ICollection<T>, IEnumerable, IEnumerable<T>, IList, IList<T>, IReadOnlyCollection<T>, IReadOnlyList<T> {
+        public ReadOnlyCollection(IList<T> list);
+        public int Count { get; }
+        protected IList<T> Items { get; }
+        bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
+        T System.Collections.Generic.IList<T>.this[int index] { get; set; }
+        bool System.Collections.ICollection.IsSynchronized { get; }
+        object System.Collections.ICollection.SyncRoot { get; }
+        bool System.Collections.IList.IsFixedSize { get; }
+        bool System.Collections.IList.IsReadOnly { get; }
+        object System.Collections.IList.this[int index] { get; set; }
+        public T this[int index] { get; }
+        public bool Contains(T value);
+        public void CopyTo(T[] array, int index);
+        public IEnumerator<T> GetEnumerator();
+        public int IndexOf(T value);
+        void System.Collections.Generic.ICollection<T>.Add(T value);
+        void System.Collections.Generic.ICollection<T>.Clear();
+        bool System.Collections.Generic.ICollection<T>.Remove(T value);
+        void System.Collections.Generic.IList<T>.Insert(int index, T value);
+        void System.Collections.Generic.IList<T>.RemoveAt(int index);
+        void System.Collections.ICollection.CopyTo(Array array, int index);
+        IEnumerator System.Collections.IEnumerable.GetEnumerator();
+        int System.Collections.IList.Add(object value);
+        void System.Collections.IList.Clear();
+        bool System.Collections.IList.Contains(object value);
+        int System.Collections.IList.IndexOf(object value);
+        void System.Collections.IList.Insert(int index, object value);
+        void System.Collections.IList.Remove(object value);
+        void System.Collections.IList.RemoveAt(int index);
+    }
+    public class ReadOnlyDictionary<TKey, TValue> : ICollection, ICollection<KeyValuePair<TKey, TValue>>, IDictionary, IDictionary<TKey, TValue>, IEnumerable, IEnumerable<KeyValuePair<TKey, TValue>>, IReadOnlyCollection<KeyValuePair<TKey, TValue>>, IReadOnlyDictionary<TKey, TValue> {
+        public ReadOnlyDictionary(IDictionary<TKey, TValue> dictionary);
+        public int Count { get; }
+        protected IDictionary<TKey, TValue> Dictionary { get; }
+        public ReadOnlyDictionary<TKey, TValue>.KeyCollection Keys { get; }
+        bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.IsReadOnly { get; }
+        TValue System.Collections.Generic.IDictionary<TKey,TValue>.this[TKey key] { get; set; }
+        ICollection<TKey> System.Collections.Generic.IDictionary<TKey,TValue>.Keys { get; }
+        ICollection<TValue> System.Collections.Generic.IDictionary<TKey,TValue>.Values { get; }
+        IEnumerable<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Keys { get; }
+        IEnumerable<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Values { get; }
+        bool System.Collections.ICollection.IsSynchronized { get; }
+        object System.Collections.ICollection.SyncRoot { get; }
+        bool System.Collections.IDictionary.IsFixedSize { get; }
+        bool System.Collections.IDictionary.IsReadOnly { get; }
+        object System.Collections.IDictionary.this[object key] { get; set; }
+        ICollection System.Collections.IDictionary.Keys { get; }
+        ICollection System.Collections.IDictionary.Values { get; }
+        public TValue this[TKey key] { get; }
+        public ReadOnlyDictionary<TKey, TValue>.ValueCollection Values { get; }
+        public bool ContainsKey(TKey key);
+        public IEnumerator<KeyValuePair<TKey, TValue>> GetEnumerator();
+        void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Add(KeyValuePair<TKey, TValue> item);
+        void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Clear();
+        bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Contains(KeyValuePair<TKey, TValue> item);
+        void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.CopyTo(KeyValuePair<TKey, TValue>[] array, int arrayIndex);
+        bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Remove(KeyValuePair<TKey, TValue> item);
+        void System.Collections.Generic.IDictionary<TKey,TValue>.Add(TKey key, TValue value);
+        bool System.Collections.Generic.IDictionary<TKey,TValue>.Remove(TKey key);
+        void System.Collections.ICollection.CopyTo(Array array, int index);
+        void System.Collections.IDictionary.Add(object key, object value);
+        void System.Collections.IDictionary.Clear();
+        bool System.Collections.IDictionary.Contains(object key);
+        IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator();
+        void System.Collections.IDictionary.Remove(object key);
+        IEnumerator System.Collections.IEnumerable.GetEnumerator();
+        public bool TryGetValue(TKey key, out TValue value);
+        public sealed class KeyCollection : ICollection, ICollection<TKey>, IEnumerable, IEnumerable<TKey>, IReadOnlyCollection<TKey> {
+            public int Count { get; }
+            bool System.Collections.Generic.ICollection<TKey>.IsReadOnly { get; }
+            bool System.Collections.ICollection.IsSynchronized { get; }
+            object System.Collections.ICollection.SyncRoot { get; }
+            public void CopyTo(TKey[] array, int arrayIndex);
+            public IEnumerator<TKey> GetEnumerator();
+            void System.Collections.Generic.ICollection<TKey>.Add(TKey item);
+            void System.Collections.Generic.ICollection<TKey>.Clear();
+            bool System.Collections.Generic.ICollection<TKey>.Contains(TKey item);
+            bool System.Collections.Generic.ICollection<TKey>.Remove(TKey item);
+            void System.Collections.ICollection.CopyTo(Array array, int index);
+            IEnumerator System.Collections.IEnumerable.GetEnumerator();
+        }
+        public sealed class ValueCollection : ICollection, ICollection<TValue>, IEnumerable, IEnumerable<TValue>, IReadOnlyCollection<TValue> {
+            public int Count { get; }
+            bool System.Collections.Generic.ICollection<TValue>.IsReadOnly { get; }
+            bool System.Collections.ICollection.IsSynchronized { get; }
+            object System.Collections.ICollection.SyncRoot { get; }
+            public void CopyTo(TValue[] array, int arrayIndex);
+            public IEnumerator<TValue> GetEnumerator();
+            void System.Collections.Generic.ICollection<TValue>.Add(TValue item);
+            void System.Collections.Generic.ICollection<TValue>.Clear();
+            bool System.Collections.Generic.ICollection<TValue>.Contains(TValue item);
+            bool System.Collections.Generic.ICollection<TValue>.Remove(TValue item);
+            void System.Collections.ICollection.CopyTo(Array array, int index);
+            IEnumerator System.Collections.IEnumerable.GetEnumerator();
+        }
+    }
+    public class ReadOnlyObservableCollection<T> : ReadOnlyCollection<T>, INotifyCollectionChanged, INotifyPropertyChanged {
+        public ReadOnlyObservableCollection(ObservableCollection<T> list);
+        protected virtual event NotifyCollectionChangedEventHandler CollectionChanged;
+        protected virtual event PropertyChangedEventHandler PropertyChanged;
+        event NotifyCollectionChangedEventHandler System.Collections.Specialized.INotifyCollectionChanged.CollectionChanged;
+        event PropertyChangedEventHandler System.ComponentModel.INotifyPropertyChanged.PropertyChanged;
+        protected virtual void OnCollectionChanged(NotifyCollectionChangedEventArgs args);
+        protected virtual void OnPropertyChanged(PropertyChangedEventArgs args);
+    }
+}
```

## System.Collections.Specialized

```c#
+namespace System.Collections.Specialized {
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct BitVector32 {
+        public BitVector32(BitVector32 value);
+        public BitVector32(int data);
+        public int Data { get; }
+        public int this[BitVector32.Section section] { get; set; }
+        public bool this[int bit] { get; set; }
+        public static int CreateMask();
+        public static int CreateMask(int previous);
+        public static BitVector32.Section CreateSection(short maxValue);
+        public static BitVector32.Section CreateSection(short maxValue, BitVector32.Section previous);
+        public override bool Equals(object o);
+        public override int GetHashCode();
+        public override string ToString();
+        public static string ToString(BitVector32 value);
+        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+        public struct Section {
+            public short Mask { get; }
+            public short Offset { get; }
+            public bool Equals(BitVector32.Section obj);
+            public override bool Equals(object o);
+            public override int GetHashCode();
+            public static bool operator ==(BitVector32.Section a, BitVector32.Section b);
+            public static bool operator !=(BitVector32.Section a, BitVector32.Section b);
+            public override string ToString();
+            public static string ToString(BitVector32.Section value);
+        }
+    }
+    public class CollectionsUtil {
+        public CollectionsUtil();
+        public static Hashtable CreateCaseInsensitiveHashtable();
+        public static Hashtable CreateCaseInsensitiveHashtable(IDictionary d);
+        public static Hashtable CreateCaseInsensitiveHashtable(int capacity);
+        public static SortedList CreateCaseInsensitiveSortedList();
+    }
+    public class HybridDictionary : ICollection, IDictionary, IEnumerable {
+        public HybridDictionary();
+        public HybridDictionary(bool caseInsensitive);
+        public HybridDictionary(int initialSize);
+        public HybridDictionary(int initialSize, bool caseInsensitive);
+        public int Count { get; }
+        public bool IsFixedSize { get; }
+        public bool IsReadOnly { get; }
+        public bool IsSynchronized { get; }
+        public ICollection Keys { get; }
+        public object SyncRoot { get; }
+        public object this[object key] { get; set; }
+        public ICollection Values { get; }
+        public void Add(object key, object value);
+        public void Clear();
+        public bool Contains(object key);
+        public void CopyTo(Array array, int index);
+        public IDictionaryEnumerator GetEnumerator();
+        public void Remove(object key);
+        IEnumerator System.Collections.IEnumerable.GetEnumerator();
+    }
+    public interface INotifyCollectionChanged {
+        event NotifyCollectionChangedEventHandler CollectionChanged;
+    }
+    public interface IOrderedDictionary : ICollection, IDictionary, IEnumerable {
+        object this[int index] { get; set; }
+        new IDictionaryEnumerator GetEnumerator();
+        void Insert(int index, object key, object value);
+        void RemoveAt(int index);
+    }
+    public class ListDictionary : ICollection, IDictionary, IEnumerable {
+        public ListDictionary();
+        public ListDictionary(IComparer comparer);
+        public int Count { get; }
+        public bool IsFixedSize { get; }
+        public bool IsReadOnly { get; }
+        public bool IsSynchronized { get; }
+        public ICollection Keys { get; }
+        public object SyncRoot { get; }
+        public object this[object key] { get; set; }
+        public ICollection Values { get; }
+        public void Add(object key, object value);
+        public void Clear();
+        public bool Contains(object key);
+        public void CopyTo(Array array, int index);
+        public IDictionaryEnumerator GetEnumerator();
+        public void Remove(object key);
+        IEnumerator System.Collections.IEnumerable.GetEnumerator();
+    }
+    public abstract class NameObjectCollectionBase : ICollection, IEnumerable {
+        protected NameObjectCollectionBase();
+        protected NameObjectCollectionBase(IEqualityComparer equalityComparer);
+        protected NameObjectCollectionBase(int capacity);
+        protected NameObjectCollectionBase(int capacity, IEqualityComparer equalityComparer);
+        public virtual int Count { get; }
+        protected bool IsReadOnly { get; set; }
+        public virtual NameObjectCollectionBase.KeysCollection Keys { get; }
+        bool System.Collections.ICollection.IsSynchronized { get; }
+        object System.Collections.ICollection.SyncRoot { get; }
+        protected void BaseAdd(string name, object value);
+        protected void BaseClear();
+        protected object BaseGet(int index);
+        protected object BaseGet(string name);
+        protected string[] BaseGetAllKeys();
+        protected object[] BaseGetAllValues();
+        protected object[] BaseGetAllValues(Type type);
+        protected string BaseGetKey(int index);
+        protected bool BaseHasKeys();
+        protected void BaseRemove(string name);
+        protected void BaseRemoveAt(int index);
+        protected void BaseSet(int index, object value);
+        protected void BaseSet(string name, object value);
+        public virtual IEnumerator GetEnumerator();
+        void System.Collections.ICollection.CopyTo(Array array, int index);
+        public class KeysCollection : ICollection, IEnumerable {
+            public int Count { get; }
+            bool System.Collections.ICollection.IsSynchronized { get; }
+            object System.Collections.ICollection.SyncRoot { get; }
+            public string this[int index] { get; }
+            public virtual string Get(int index);
+            public IEnumerator GetEnumerator();
+            void System.Collections.ICollection.CopyTo(Array array, int index);
+        }
+    }
+    public class NameValueCollection : NameObjectCollectionBase {
+        public NameValueCollection();
+        public NameValueCollection(IEqualityComparer equalityComparer);
+        public NameValueCollection(NameValueCollection col);
+        public NameValueCollection(int capacity);
+        public NameValueCollection(int capacity, IEqualityComparer equalityComparer);
+        public NameValueCollection(int capacity, NameValueCollection col);
+        public virtual string[] AllKeys { get; }
+        public string this[int index] { get; }
+        public string this[string name] { get; set; }
+        public void Add(NameValueCollection c);
+        public virtual void Add(string name, string value);
+        public virtual void Clear();
+        public void CopyTo(Array dest, int index);
+        public virtual string Get(int index);
+        public virtual string Get(string name);
+        public virtual string GetKey(int index);
+        public virtual string[] GetValues(int index);
+        public virtual string[] GetValues(string name);
+        public bool HasKeys();
+        protected void InvalidateCachedArrays();
+        public virtual void Remove(string name);
+        public virtual void Set(string name, string value);
+    }
+    public enum NotifyCollectionChangedAction {
+        Add = 0,
+        Move = 3,
+        Remove = 1,
+        Replace = 2,
+        Reset = 4,
+    }
+    public class NotifyCollectionChangedEventArgs : EventArgs {
+        public NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction action);
+        public NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction action, IList changedItems);
+        public NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction action, IList newItems, IList oldItems);
+        public NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction action, IList newItems, IList oldItems, int startingIndex);
+        public NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction action, IList changedItems, int startingIndex);
+        public NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction action, IList changedItems, int index, int oldIndex);
+        public NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction action, object changedItem);
+        public NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction action, object changedItem, int index);
+        public NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction action, object changedItem, int index, int oldIndex);
+        public NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction action, object newItem, object oldItem);
+        public NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction action, object newItem, object oldItem, int index);
+        public NotifyCollectionChangedAction Action { get; }
+        public IList NewItems { get; }
+        public int NewStartingIndex { get; }
+        public IList OldItems { get; }
+        public int OldStartingIndex { get; }
+    }
+    public delegate void NotifyCollectionChangedEventHandler(object sender, NotifyCollectionChangedEventArgs e);
+    public class OrderedDictionary : ICollection, IDictionary, IEnumerable, IOrderedDictionary {
+        public OrderedDictionary();
+        public OrderedDictionary(IEqualityComparer comparer);
+        public OrderedDictionary(int capacity);
+        public OrderedDictionary(int capacity, IEqualityComparer comparer);
+        public int Count { get; }
+        public bool IsReadOnly { get; }
+        public ICollection Keys { get; }
+        bool System.Collections.ICollection.IsSynchronized { get; }
+        object System.Collections.ICollection.SyncRoot { get; }
+        bool System.Collections.IDictionary.IsFixedSize { get; }
+        public object this[int index] { get; set; }
+        public object this[object key] { get; set; }
+        public ICollection Values { get; }
+        public void Add(object key, object value);
+        public OrderedDictionary AsReadOnly();
+        public void Clear();
+        public bool Contains(object key);
+        public void CopyTo(Array array, int index);
+        public virtual IDictionaryEnumerator GetEnumerator();
+        public void Insert(int index, object key, object value);
+        public void Remove(object key);
+        public void RemoveAt(int index);
+        IEnumerator System.Collections.IEnumerable.GetEnumerator();
+    }
+    public class StringCollection : ICollection, IEnumerable, IList {
+        public StringCollection();
+        public int Count { get; }
+        public bool IsReadOnly { get; }
+        public bool IsSynchronized { get; }
+        public object SyncRoot { get; }
+        bool System.Collections.IList.IsFixedSize { get; }
+        bool System.Collections.IList.IsReadOnly { get; }
+        object System.Collections.IList.this[int index] { get; set; }
+        public string this[int index] { get; set; }
+        public int Add(string value);
+        public void AddRange(string[] value);
+        public void Clear();
+        public bool Contains(string value);
+        public void CopyTo(string[] array, int index);
+        public StringEnumerator GetEnumerator();
+        public int IndexOf(string value);
+        public void Insert(int index, string value);
+        public void Remove(string value);
+        public void RemoveAt(int index);
+        void System.Collections.ICollection.CopyTo(Array array, int index);
+        IEnumerator System.Collections.IEnumerable.GetEnumerator();
+        int System.Collections.IList.Add(object value);
+        bool System.Collections.IList.Contains(object value);
+        int System.Collections.IList.IndexOf(object value);
+        void System.Collections.IList.Insert(int index, object value);
+        void System.Collections.IList.Remove(object value);
+    }
+    public class StringDictionary : IEnumerable {
+        public StringDictionary();
+        public virtual int Count { get; }
+        public virtual bool IsSynchronized { get; }
+        public virtual ICollection Keys { get; }
+        public virtual object SyncRoot { get; }
+        public virtual string this[string key] { get; set; }
+        public virtual ICollection Values { get; }
+        public virtual void Add(string key, string value);
+        public virtual void Clear();
+        public virtual bool ContainsKey(string key);
+        public virtual bool ContainsValue(string value);
+        public virtual void CopyTo(Array array, int index);
+        public virtual IEnumerator GetEnumerator();
+        public virtual void Remove(string key);
+    }
+    public class StringEnumerator {
+        public string Current { get; }
+        public bool MoveNext();
+        public void Reset();
+    }
+}
```

## System.ComponentModel

```c#
+namespace System.ComponentModel {
+    public class ArrayConverter : CollectionConverter {
+        public ArrayConverter();
+        public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
+        public override PropertyDescriptorCollection GetProperties(ITypeDescriptorContext context, object value, Attribute[] attributes);
+        public override bool GetPropertiesSupported(ITypeDescriptorContext context);
+    }
+    public class AsyncCompletedEventArgs : EventArgs {
+        public AsyncCompletedEventArgs(Exception error, bool cancelled, object userState);
+        public bool Cancelled { get; }
+        public Exception Error { get; }
+        public object UserState { get; }
+        protected void RaiseExceptionIfNecessary();
+    }
+    public delegate void AsyncCompletedEventHandler(object sender, AsyncCompletedEventArgs e);
+    public sealed class AsyncOperation {
+        public SynchronizationContext SynchronizationContext { get; }
+        public object UserSuppliedState { get; }
+        ~AsyncOperation();
+        public void OperationCompleted();
+        public void Post(SendOrPostCallback d, object arg);
+        public void PostOperationCompleted(SendOrPostCallback d, object arg);
+    }
+    public static class AsyncOperationManager {
+        public static SynchronizationContext SynchronizationContext { get; set; }
+        public static AsyncOperation CreateOperation(object userSuppliedState);
+    }
+    public class AttributeCollection : ICollection, IEnumerable {
+        public static readonly AttributeCollection Empty;
+        protected AttributeCollection();
+        public AttributeCollection(params Attribute[] attributes);
+        protected virtual Attribute[] Attributes { get; }
+        public int Count { get; }
+        bool System.Collections.ICollection.IsSynchronized { get; }
+        object System.Collections.ICollection.SyncRoot { get; }
+        public virtual Attribute this[int index] { get; }
+        public virtual Attribute this[Type attributeType] { get; }
+        public bool Contains(Attribute attribute);
+        public bool Contains(Attribute[] attributes);
+        public void CopyTo(Array array, int index);
+        public static AttributeCollection FromExisting(AttributeCollection existing, params Attribute[] newAttributes);
+        protected Attribute GetDefaultAttribute(Type attributeType);
+        public IEnumerator GetEnumerator();
+        public bool Matches(Attribute attribute);
+        public bool Matches(Attribute[] attributes);
+    }
+    public class AttributeProviderAttribute : Attribute {
+        public AttributeProviderAttribute(string typeName);
+        public AttributeProviderAttribute(string typeName, string propertyName);
+        public AttributeProviderAttribute(Type type);
+        public string PropertyName { get; }
+        public string TypeName { get; }
+    }
+    public class BackgroundWorker : IDisposable {
+        public BackgroundWorker();
+        public bool CancellationPending { get; }
+        public bool IsBusy { get; }
+        public bool WorkerReportsProgress { get; set; }
+        public bool WorkerSupportsCancellation { get; set; }
+        public event DoWorkEventHandler DoWork;
+        public event ProgressChangedEventHandler ProgressChanged;
+        public event RunWorkerCompletedEventHandler RunWorkerCompleted;
+        public void CancelAsync();
+        public void Dispose();
+        protected virtual void Dispose(bool disposing);
+        protected virtual void OnDoWork(DoWorkEventArgs e);
+        protected virtual void OnProgressChanged(ProgressChangedEventArgs e);
+        protected virtual void OnRunWorkerCompleted(RunWorkerCompletedEventArgs e);
+        public void ReportProgress(int percentProgress);
+        public void ReportProgress(int percentProgress, object userState);
+        public void RunWorkerAsync();
+        public void RunWorkerAsync(object argument);
+    }
+    public abstract class BaseNumberConverter : TypeConverter {
+        protected BaseNumberConverter();
+        public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
+        public override bool CanConvertTo(ITypeDescriptorContext context, Type t);
+        public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
+        public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
+    }
+    public class BooleanConverter : TypeConverter {
+        public BooleanConverter();
+        public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
+        public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
+        public override TypeConverter.StandardValuesCollection GetStandardValues(ITypeDescriptorContext context);
+        public override bool GetStandardValuesExclusive(ITypeDescriptorContext context);
+        public override bool GetStandardValuesSupported(ITypeDescriptorContext context);
+    }
+    public sealed class BrowsableAttribute : Attribute {
+        public static readonly BrowsableAttribute Default;
+        public static readonly BrowsableAttribute No;
+        public static readonly BrowsableAttribute Yes;
+        public BrowsableAttribute(bool browsable);
+        public bool Browsable { get; }
+        public override bool Equals(object obj);
+        public override int GetHashCode();
+    }
+    public class ByteConverter : BaseNumberConverter {
+        public ByteConverter();
+    }
+    public class CancelEventArgs : EventArgs {
+        public CancelEventArgs();
+        public CancelEventArgs(bool cancel);
+        public bool Cancel { get; set; }
+    }
+    public delegate void CancelEventHandler(object sender, CancelEventArgs e);
+    public class CategoryAttribute : Attribute {
+        public CategoryAttribute();
+        public CategoryAttribute(string category);
+        public static CategoryAttribute Action { get; }
+        public static CategoryAttribute Appearance { get; }
+        public static CategoryAttribute Asynchronous { get; }
+        public static CategoryAttribute Behavior { get; }
+        public string Category { get; }
+        public static CategoryAttribute Data { get; }
+        public static CategoryAttribute Default { get; }
+        public static CategoryAttribute Design { get; }
+        public static CategoryAttribute DragDrop { get; }
+        public static CategoryAttribute Focus { get; }
+        public static CategoryAttribute Format { get; }
+        public static CategoryAttribute Key { get; }
+        public static CategoryAttribute Layout { get; }
+        public static CategoryAttribute Mouse { get; }
+        public static CategoryAttribute WindowStyle { get; }
+        public override bool Equals(object obj);
+        public override int GetHashCode();
+        protected virtual string GetLocalizedString(string value);
+    }
+    public class CharConverter : TypeConverter {
+        public CharConverter();
+        public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
+        public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
+        public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
+    }
+    public enum CollectionChangeAction {
+        Add = 1,
+        Refresh = 3,
+        Remove = 2,
+    }
+    public class CollectionChangeEventArgs : EventArgs {
+        public CollectionChangeEventArgs(CollectionChangeAction action, object element);
+        public virtual CollectionChangeAction Action { get; }
+        public virtual object Element { get; }
+    }
+    public delegate void CollectionChangeEventHandler(object sender, CollectionChangeEventArgs e);
+    public class CollectionConverter : TypeConverter {
+        public CollectionConverter();
+        public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
+        public override PropertyDescriptorCollection GetProperties(ITypeDescriptorContext context, object value, Attribute[] attributes);
+        public override bool GetPropertiesSupported(ITypeDescriptorContext context);
+    }
+    public class ComponentCollection
+    public abstract class CustomTypeDescriptor : ICustomTypeDescriptor {
+        protected CustomTypeDescriptor();
+        protected CustomTypeDescriptor(ICustomTypeDescriptor parent);
+        public virtual AttributeCollection GetAttributes();
+        public virtual string GetClassName();
+        public virtual string GetComponentName();
+        public virtual TypeConverter GetConverter();
+        public virtual EventDescriptor GetDefaultEvent();
+        public virtual PropertyDescriptor GetDefaultProperty();
+        public virtual object GetEditor(Type editorBaseType);
+        public virtual EventDescriptorCollection GetEvents();
+        public virtual EventDescriptorCollection GetEvents(Attribute[] attributes);
+        public virtual PropertyDescriptorCollection GetProperties();
+        public virtual PropertyDescriptorCollection GetProperties(Attribute[] attributes);
+        public virtual object GetPropertyOwner(PropertyDescriptor pd);
+    }
+    public class DataErrorsChangedEventArgs : EventArgs {
+        public DataErrorsChangedEventArgs(string propertyName);
+        public virtual string PropertyName { get; }
+    }
+    public class DateTimeConverter : TypeConverter {
+        public DateTimeConverter();
+        public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
+        public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
+        public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
+        public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
+    }
+    public class DateTimeOffsetConverter : TypeConverter {
+        public DateTimeOffsetConverter();
+        public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
+        public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
+        public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
+        public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
+    }
+    public class DecimalConverter : BaseNumberConverter {
+        public DecimalConverter();
+        public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
+        public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
+    }
+    public sealed class DefaultEventAttribute : Attribute {
+        public static readonly DefaultEventAttribute Default;
+        public DefaultEventAttribute(string name);
+        public string Name { get; }
+        public override bool Equals(object obj);
+        public override int GetHashCode();
+    }
+    public sealed class DefaultPropertyAttribute : Attribute {
+        public static readonly DefaultPropertyAttribute Default;
+        public DefaultPropertyAttribute(string name);
+        public string Name { get; }
+        public override bool Equals(object obj);
+        public override int GetHashCode();
+    }
+    public class DefaultValueAttribute : Attribute {
+        public DefaultValueAttribute(bool value);
+        public DefaultValueAttribute(byte value);
+        public DefaultValueAttribute(char value);
+        public DefaultValueAttribute(double value);
+        public DefaultValueAttribute(short value);
+        public DefaultValueAttribute(int value);
+        public DefaultValueAttribute(long value);
+        public DefaultValueAttribute(object value);
+        public DefaultValueAttribute(float value);
+        public DefaultValueAttribute(string value);
+        public DefaultValueAttribute(Type type, string value);
+        public virtual object Value { get; }
+        public override bool Equals(object obj);
+        public override int GetHashCode();
+    }
+    public class DescriptionAttribute : Attribute {
+        public static readonly DescriptionAttribute Default;
+        public DescriptionAttribute();
+        public DescriptionAttribute(string description);
+        public virtual string Description { get; }
+        protected string DescriptionValue { get; set; }
+        public override bool Equals(object obj);
+        public override int GetHashCode();
+    }
+    public sealed class DesignerCategoryAttribute : Attribute {
+        public static readonly DesignerCategoryAttribute Component;
+        public static readonly DesignerCategoryAttribute Default;
+        public static readonly DesignerCategoryAttribute Form;
+        public static readonly DesignerCategoryAttribute Generic;
+        public DesignerCategoryAttribute();
+        public DesignerCategoryAttribute(string category);
+        public string Category { get; }
+        public override bool Equals(object obj);
+        public override int GetHashCode();
+    }
+    public enum DesignerSerializationVisibility {
+        Content = 2,
+        Hidden = 0,
+        Visible = 1,
+    }
+    public sealed class DesignerSerializationVisibilityAttribute : Attribute {
+        public static readonly DesignerSerializationVisibilityAttribute Content;
+        public static readonly DesignerSerializationVisibilityAttribute Default;
+        public static readonly DesignerSerializationVisibilityAttribute Hidden;
+        public static readonly DesignerSerializationVisibilityAttribute Visible;
+        public DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility visibility);
+        public DesignerSerializationVisibility Visibility { get; }
+        public override bool Equals(object obj);
+        public override int GetHashCode();
+    }
+    public sealed class DesignOnlyAttribute : Attribute {
+        public static readonly DesignOnlyAttribute Default;
+        public static readonly DesignOnlyAttribute No;
+        public static readonly DesignOnlyAttribute Yes;
+        public DesignOnlyAttribute(bool isDesignOnly);
+        public bool IsDesignOnly { get; }
+        public override bool Equals(object obj);
+        public override int GetHashCode();
+    }
+    public class DisplayNameAttribute : Attribute {
+        public static readonly DisplayNameAttribute Default;
+        public DisplayNameAttribute();
+        public DisplayNameAttribute(string displayName);
+        public virtual string DisplayName { get; }
+        protected string DisplayNameValue { get; set; }
+        public override bool Equals(object obj);
+        public override int GetHashCode();
+    }
+    public class DoubleConverter : BaseNumberConverter {
+        public DoubleConverter();
+    }
+    public class DoWorkEventArgs : EventArgs {
+        public DoWorkEventArgs(object argument);
+        public object Argument { get; }
+        public bool Cancel { get; set; }
+        public object Result { get; set; }
+    }
+    public delegate void DoWorkEventHandler(object sender, DoWorkEventArgs e);
+    public sealed class EditorBrowsableAttribute : Attribute {
+        public EditorBrowsableAttribute(EditorBrowsableState state);
+        public EditorBrowsableState State { get; }
+        public override bool Equals(object obj);
+        public override int GetHashCode();
+    }
+    public enum EditorBrowsableState {
+        Advanced = 2,
+        Always = 0,
+        Never = 1,
+    }
+    public class EnumConverter : TypeConverter {
+        public EnumConverter(Type type);
+        protected virtual IComparer Comparer { get; }
+        protected Type EnumType { get; }
+        protected TypeConverter.StandardValuesCollection Values { get; set; }
+        public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
+        public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
+        public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
+        public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
+        public override TypeConverter.StandardValuesCollection GetStandardValues(ITypeDescriptorContext context);
+        public override bool GetStandardValuesExclusive(ITypeDescriptorContext context);
+        public override bool GetStandardValuesSupported(ITypeDescriptorContext context);
+        public override bool IsValid(ITypeDescriptorContext context, object value);
+    }
+    public abstract class EventDescriptor : MemberDescriptor {
+        protected EventDescriptor(MemberDescriptor descr);
+        protected EventDescriptor(MemberDescriptor descr, Attribute[] attrs);
+        protected EventDescriptor(string name, Attribute[] attrs);
+        public abstract Type ComponentType { get; }
+        public abstract Type EventType { get; }
+        public abstract bool IsMulticast { get; }
+        public abstract void AddEventHandler(object component, Delegate value);
+        public abstract void RemoveEventHandler(object component, Delegate value);
+    }
+    public class EventDescriptorCollection : ICollection, IEnumerable, IList {
+        public static readonly EventDescriptorCollection Empty;
+        public EventDescriptorCollection(EventDescriptor[] events);
+        public EventDescriptorCollection(EventDescriptor[] events, bool readOnly);
+        public int Count { get; }
+        bool System.Collections.ICollection.IsSynchronized { get; }
+        object System.Collections.ICollection.SyncRoot { get; }
+        bool System.Collections.IList.IsFixedSize { get; }
+        bool System.Collections.IList.IsReadOnly { get; }
+        object System.Collections.IList.this[int index] { get; set; }
+        public virtual EventDescriptor this[int index] { get; }
+        public virtual EventDescriptor this[string name] { get; }
+        public int Add(EventDescriptor value);
+        public void Clear();
+        public bool Contains(EventDescriptor value);
+        public virtual EventDescriptor Find(string name, bool ignoreCase);
+        public IEnumerator GetEnumerator();
+        public int IndexOf(EventDescriptor value);
+        public void Insert(int index, EventDescriptor value);
+        protected void InternalSort(IComparer sorter);
+        protected void InternalSort(string[] names);
+        public void Remove(EventDescriptor value);
+        public void RemoveAt(int index);
+        public virtual EventDescriptorCollection Sort();
+        public virtual EventDescriptorCollection Sort(IComparer comparer);
+        public virtual EventDescriptorCollection Sort(string[] names);
+        public virtual EventDescriptorCollection Sort(string[] names, IComparer comparer);
+        void System.Collections.ICollection.CopyTo(Array array, int index);
+        int System.Collections.IList.Add(object value);
+        bool System.Collections.IList.Contains(object value);
+        int System.Collections.IList.IndexOf(object value);
+        void System.Collections.IList.Insert(int index, object value);
+        void System.Collections.IList.Remove(object value);
+    }
+    public sealed class EventHandlerList : IDisposable {
+        public EventHandlerList();
+        public Delegate this[object key] { get; set; }
+        public void AddHandler(object key, Delegate value);
+        public void AddHandlers(EventHandlerList listToAddFrom);
+        public void Dispose();
+        public void RemoveHandler(object key, Delegate value);
+    }
+    public sealed class ExtenderProvidedPropertyAttribute : Attribute {
+        public ExtenderProvidedPropertyAttribute();
+        public PropertyDescriptor ExtenderProperty { get; }
+        public IExtenderProvider Provider { get; }
+        public Type ReceiverType { get; }
+        public override bool Equals(object obj);
+        public override int GetHashCode();
+    }
+    public class GuidConverter : TypeConverter {
+        public GuidConverter();
+        public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
+        public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
+        public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
+        public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
+    }
+    public class HandledEventArgs : EventArgs {
+        public HandledEventArgs();
+        public HandledEventArgs(bool defaultHandledValue);
+        public bool Handled { get; set; }
+    }
+    public delegate void HandledEventHandler(object sender, HandledEventArgs e);
+    public interface IChangeTracking {
+        bool IsChanged { get; }
+        void AcceptChanges();
+    }
+    public interface IComponent : IDisposable {
+        ISite Site { get; set; }
+        event EventHandler Disposed;
+    }
+    public interface IContainer : IDisposable {
+        ComponentCollection Components { get; }
+        void Add(IComponent component);
+        void Add(IComponent component, string name);
+        void Remove(IComponent component);
+    }
+    public interface ICustomTypeDescriptor {
+        AttributeCollection GetAttributes();
+        string GetClassName();
+        string GetComponentName();
+        TypeConverter GetConverter();
+        EventDescriptor GetDefaultEvent();
+        PropertyDescriptor GetDefaultProperty();
+        object GetEditor(Type editorBaseType);
+        EventDescriptorCollection GetEvents();
+        EventDescriptorCollection GetEvents(Attribute[] attributes);
+        PropertyDescriptorCollection GetProperties();
+        PropertyDescriptorCollection GetProperties(Attribute[] attributes);
+        object GetPropertyOwner(PropertyDescriptor pd);
+    }
+    public interface IEditableObject {
+        void BeginEdit();
+        void CancelEdit();
+        void EndEdit();
+    }
+    public interface IExtenderProvider {
+        bool CanExtend(object extendee);
+    }
+    public interface IListSource {
+        bool ContainsListCollection { get; }
+        IList GetList();
+    }
+    public sealed class ImmutableObjectAttribute : Attribute {
+        public static readonly ImmutableObjectAttribute Default;
+        public static readonly ImmutableObjectAttribute No;
+        public static readonly ImmutableObjectAttribute Yes;
+        public ImmutableObjectAttribute(bool immutable);
+        public bool Immutable { get; }
+        public override bool Equals(object obj);
+        public override int GetHashCode();
+    }
+    public sealed class InitializationEventAttribute : Attribute {
+        public InitializationEventAttribute(string eventName);
+        public string EventName { get; }
+    }
+    public interface INotifyDataErrorInfo {
+        bool HasErrors { get; }
+        event EventHandler<DataErrorsChangedEventArgs> ErrorsChanged;
+        IEnumerable GetErrors(string propertyName);
+    }
+    public interface INotifyPropertyChanged {
+        event PropertyChangedEventHandler PropertyChanged;
+    }
+    public interface INotifyPropertyChanging {
+        event PropertyChangingEventHandler PropertyChanging;
+    }
+    public class Int16Converter : BaseNumberConverter {
+        public Int16Converter();
+    }
+    public class Int32Converter : BaseNumberConverter {
+        public Int32Converter();
+    }
+    public class Int64Converter : BaseNumberConverter {
+        public Int64Converter();
+    }
+    public class InvalidAsynchronousStateException : ArgumentException {
+        public InvalidAsynchronousStateException();
+        public InvalidAsynchronousStateException(string message);
+        public InvalidAsynchronousStateException(string message, Exception innerException);
+    }
+    public class InvalidEnumArgumentException : ArgumentException {
+        public InvalidEnumArgumentException();
+        public InvalidEnumArgumentException(string message);
+        public InvalidEnumArgumentException(string message, Exception innerException);
+        public InvalidEnumArgumentException(string argumentName, int invalidValue, Type enumClass);
+    }
+    public interface IRevertibleChangeTracking : IChangeTracking {
+        void RejectChanges();
+    }
+    public interface ISite : IServiceProvider {
+        IComponent Component { get; }
+        IContainer Container { get; }
+        bool DesignMode { get; }
+        string Name { get; set; }
+    }
+    public interface ITypeDescriptorContext : IServiceProvider {
+        IContainer Container { get; }
+        object Instance { get; }
+        PropertyDescriptor PropertyDescriptor { get; }
+        void OnComponentChanged();
+        bool OnComponentChanging();
+    }
+    public interface ITypedList {
+        PropertyDescriptorCollection GetItemProperties(PropertyDescriptor[] listAccessors);
+        string GetListName(PropertyDescriptor[] listAccessors);
+    }
+    public sealed class LocalizableAttribute : Attribute {
+        public static readonly LocalizableAttribute Default;
+        public static readonly LocalizableAttribute No;
+        public static readonly LocalizableAttribute Yes;
+        public LocalizableAttribute(bool isLocalizable);
+        public bool IsLocalizable { get; }
+        public override bool Equals(object obj);
+        public override int GetHashCode();
+    }
+    public abstract class MemberDescriptor {
+        protected MemberDescriptor(MemberDescriptor descr);
+        protected MemberDescriptor(MemberDescriptor oldMemberDescriptor, Attribute[] newAttributes);
+        protected MemberDescriptor(string name);
+        protected MemberDescriptor(string name, Attribute[] attributes);
+        protected virtual Attribute[] AttributeArray { get; set; }
+        public virtual AttributeCollection Attributes { get; }
+        public virtual string Category { get; }
+        public virtual string Description { get; }
+        public virtual bool DesignTimeOnly { get; }
+        public virtual string DisplayName { get; }
+        public virtual bool IsBrowsable { get; }
+        public virtual string Name { get; }
+        protected virtual int NameHashCode { get; }
+        protected virtual AttributeCollection CreateAttributeCollection();
+        public override bool Equals(object obj);
+        protected virtual void FillAttributes(IList attributeList);
+        protected static MethodInfo FindMethod(Type componentClass, string name, Type[] args, Type returnType);
+        protected static MethodInfo FindMethod(Type componentClass, string name, Type[] args, Type returnType, bool publicOnly);
+        public override int GetHashCode();
+        protected virtual object GetInvocationTarget(Type type, object instance);
+        protected static ISite GetSite(object component);
+    }
+    public sealed class MergablePropertyAttribute : Attribute {
+        public static readonly MergablePropertyAttribute Default;
+        public static readonly MergablePropertyAttribute No;
+        public static readonly MergablePropertyAttribute Yes;
+        public MergablePropertyAttribute(bool allowMerge);
+        public bool AllowMerge { get; }
+        public override bool Equals(object obj);
+        public override int GetHashCode();
+    }
+    public class MultilineStringConverter : TypeConverter {
+        public MultilineStringConverter();
+        public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
+        public override PropertyDescriptorCollection GetProperties(ITypeDescriptorContext context, object value, Attribute[] attributes);
+        public override bool GetPropertiesSupported(ITypeDescriptorContext context);
+    }
+    public sealed class NotifyParentPropertyAttribute : Attribute {
+        public static readonly NotifyParentPropertyAttribute Default;
+        public static readonly NotifyParentPropertyAttribute No;
+        public static readonly NotifyParentPropertyAttribute Yes;
+        public NotifyParentPropertyAttribute(bool notifyParent);
+        public bool NotifyParent { get; }
+        public override bool Equals(object obj);
+        public override int GetHashCode();
+    }
+    public class NullableConverter : TypeConverter {
+        public NullableConverter(Type type);
+        public Type NullableType { get; }
+        public Type UnderlyingType { get; }
+        public TypeConverter UnderlyingTypeConverter { get; }
+        public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
+        public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
+        public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
+        public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
+        public override object CreateInstance(ITypeDescriptorContext context, IDictionary propertyValues);
+        public override bool GetCreateInstanceSupported(ITypeDescriptorContext context);
+        public override PropertyDescriptorCollection GetProperties(ITypeDescriptorContext context, object value, Attribute[] attributes);
+        public override bool GetPropertiesSupported(ITypeDescriptorContext context);
+        public override TypeConverter.StandardValuesCollection GetStandardValues(ITypeDescriptorContext context);
+        public override bool GetStandardValuesExclusive(ITypeDescriptorContext context);
+        public override bool GetStandardValuesSupported(ITypeDescriptorContext context);
+        public override bool IsValid(ITypeDescriptorContext context, object value);
+    }
+    public sealed class ParenthesizePropertyNameAttribute : Attribute {
+        public static readonly ParenthesizePropertyNameAttribute Default;
+        public ParenthesizePropertyNameAttribute();
+        public ParenthesizePropertyNameAttribute(bool needParenthesis);
+        public bool NeedParenthesis { get; }
+        public override bool Equals(object o);
+        public override int GetHashCode();
+    }
+    public class ProgressChangedEventArgs : EventArgs {
+        public ProgressChangedEventArgs(int progressPercentage, object userState);
+        public int ProgressPercentage { get; }
+        public object UserState { get; }
+    }
+    public delegate void ProgressChangedEventHandler(object sender, ProgressChangedEventArgs e);
+    public class PropertyChangedEventArgs : EventArgs {
+        public PropertyChangedEventArgs(string propertyName);
+        public virtual string PropertyName { get; }
+    }
+    public delegate void PropertyChangedEventHandler(object sender, PropertyChangedEventArgs e);
+    public class PropertyChangingEventArgs : EventArgs {
+        public PropertyChangingEventArgs(string propertyName);
+        public virtual string PropertyName { get; }
+    }
+    public delegate void PropertyChangingEventHandler(object sender, PropertyChangingEventArgs e);
+    public abstract class PropertyDescriptor : MemberDescriptor {
+        protected PropertyDescriptor(MemberDescriptor descr);
+        protected PropertyDescriptor(MemberDescriptor descr, Attribute[] attrs);
+        protected PropertyDescriptor(string name, Attribute[] attrs);
+        public abstract Type ComponentType { get; }
+        public virtual TypeConverter Converter { get; }
+        public virtual bool IsLocalizable { get; }
+        public abstract bool IsReadOnly { get; }
+        public abstract Type PropertyType { get; }
+        public DesignerSerializationVisibility SerializationVisibility { get; }
+        public virtual bool SupportsChangeEvents { get; }
+        public virtual void AddValueChanged(object component, EventHandler handler);
+        public abstract bool CanResetValue(object component);
+        protected object CreateInstance(Type type);
+        public override bool Equals(object obj);
+        protected override void FillAttributes(IList attributeList);
+        public PropertyDescriptorCollection GetChildProperties();
+        public PropertyDescriptorCollection GetChildProperties(Attribute[] filter);
+        public PropertyDescriptorCollection GetChildProperties(object instance);
+        public virtual PropertyDescriptorCollection GetChildProperties(object instance, Attribute[] filter);
+        public virtual object GetEditor(Type editorBaseType);
+        public override int GetHashCode();
+        protected override object GetInvocationTarget(Type type, object instance);
+        protected Type GetTypeFromName(string typeName);
+        public abstract object GetValue(object component);
+        protected internal EventHandler GetValueChangedHandler(object component);
+        protected virtual void OnValueChanged(object component, EventArgs e);
+        public virtual void RemoveValueChanged(object component, EventHandler handler);
+        public abstract void ResetValue(object component);
+        public abstract void SetValue(object component, object value);
+        public abstract bool ShouldSerializeValue(object component);
+    }
+    public class PropertyDescriptorCollection : ICollection, IDictionary, IEnumerable, IList {
+        public static readonly PropertyDescriptorCollection Empty;
+        public PropertyDescriptorCollection(PropertyDescriptor[] properties);
+        public PropertyDescriptorCollection(PropertyDescriptor[] properties, bool readOnly);
+        public int Count { get; }
+        bool System.Collections.ICollection.IsSynchronized { get; }
+        object System.Collections.ICollection.SyncRoot { get; }
+        bool System.Collections.IDictionary.IsFixedSize { get; }
+        bool System.Collections.IDictionary.IsReadOnly { get; }
+        object System.Collections.IDictionary.this[object key] { get; set; }
+        ICollection System.Collections.IDictionary.Keys { get; }
+        ICollection System.Collections.IDictionary.Values { get; }
+        bool System.Collections.IList.IsFixedSize { get; }
+        bool System.Collections.IList.IsReadOnly { get; }
+        object System.Collections.IList.this[int index] { get; set; }
+        public virtual PropertyDescriptor this[int index] { get; }
+        public virtual PropertyDescriptor this[string name] { get; }
+        public int Add(PropertyDescriptor value);
+        public void Clear();
+        public bool Contains(PropertyDescriptor value);
+        public void CopyTo(Array array, int index);
+        public virtual PropertyDescriptor Find(string name, bool ignoreCase);
+        public virtual IEnumerator GetEnumerator();
+        public int IndexOf(PropertyDescriptor value);
+        public void Insert(int index, PropertyDescriptor value);
+        protected void InternalSort(IComparer sorter);
+        protected void InternalSort(string[] names);
+        public void Remove(PropertyDescriptor value);
+        public void RemoveAt(int index);
+        public virtual PropertyDescriptorCollection Sort();
+        public virtual PropertyDescriptorCollection Sort(IComparer comparer);
+        public virtual PropertyDescriptorCollection Sort(string[] names);
+        public virtual PropertyDescriptorCollection Sort(string[] names, IComparer comparer);
+        void System.Collections.IDictionary.Add(object key, object value);
+        bool System.Collections.IDictionary.Contains(object key);
+        IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator();
+        void System.Collections.IDictionary.Remove(object key);
+        int System.Collections.IList.Add(object value);
+        bool System.Collections.IList.Contains(object value);
+        int System.Collections.IList.IndexOf(object value);
+        void System.Collections.IList.Insert(int index, object value);
+        void System.Collections.IList.Remove(object value);
+    }
+    public sealed class ProvidePropertyAttribute : Attribute {
+        public ProvidePropertyAttribute(string propertyName, string receiverTypeName);
+        public ProvidePropertyAttribute(string propertyName, Type receiverType);
+        public string PropertyName { get; }
+        public string ReceiverTypeName { get; }
+        public override bool Equals(object obj);
+        public override int GetHashCode();
+    }
+    public sealed class ReadOnlyAttribute : Attribute {
+        public static readonly ReadOnlyAttribute Default;
+        public static readonly ReadOnlyAttribute No;
+        public static readonly ReadOnlyAttribute Yes;
+        public ReadOnlyAttribute(bool isReadOnly);
+        public bool IsReadOnly { get; }
+        public override bool Equals(object value);
+        public override int GetHashCode();
+    }
+    public class RefreshEventArgs : EventArgs {
+        public RefreshEventArgs(object componentChanged);
+        public RefreshEventArgs(Type typeChanged);
+        public object ComponentChanged { get; }
+        public Type TypeChanged { get; }
+    }
+    public delegate void RefreshEventHandler(RefreshEventArgs e);
+    public enum RefreshProperties {
+        All = 1,
+        None = 0,
+        Repaint = 2,
+    }
+    public sealed class RefreshPropertiesAttribute : Attribute {
+        public static readonly RefreshPropertiesAttribute All;
+        public static readonly RefreshPropertiesAttribute Default;
+        public static readonly RefreshPropertiesAttribute Repaint;
+        public RefreshPropertiesAttribute(RefreshProperties refresh);
+        public RefreshProperties RefreshProperties { get; }
+        public override bool Equals(object value);
+        public override int GetHashCode();
+    }
+    public class RunWorkerCompletedEventArgs : AsyncCompletedEventArgs {
+        public RunWorkerCompletedEventArgs(object result, Exception error, bool cancelled);
+        public object Result { get; }
+        public new object UserState { get; }
+    }
+    public delegate void RunWorkerCompletedEventHandler(object sender, RunWorkerCompletedEventArgs e);
+    public class SByteConverter : BaseNumberConverter {
+        public SByteConverter();
+    }
+    public class SingleConverter : BaseNumberConverter {
+        public SingleConverter();
+    }
+    public class StringConverter : TypeConverter {
+        public StringConverter();
+        public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
+        public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
+    }
+    public class TimeSpanConverter : TypeConverter {
+        public TimeSpanConverter();
+        public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
+        public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
+        public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
+        public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
+    }
+    public class TypeConverter {
+        public TypeConverter();
+        public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
+        public bool CanConvertFrom(Type sourceType);
+        public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
+        public bool CanConvertTo(Type destinationType);
+        public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
+        public object ConvertFrom(object value);
+        public object ConvertFromInvariantString(ITypeDescriptorContext context, string text);
+        public object ConvertFromInvariantString(string text);
+        public object ConvertFromString(ITypeDescriptorContext context, CultureInfo culture, string text);
+        public object ConvertFromString(ITypeDescriptorContext context, string text);
+        public object ConvertFromString(string text);
+        public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
+        public object ConvertTo(object value, Type destinationType);
+        public string ConvertToInvariantString(ITypeDescriptorContext context, object value);
+        public string ConvertToInvariantString(object value);
+        public string ConvertToString(ITypeDescriptorContext context, CultureInfo culture, object value);
+        public string ConvertToString(ITypeDescriptorContext context, object value);
+        public string ConvertToString(object value);
+        public object CreateInstance(IDictionary propertyValues);
+        public virtual object CreateInstance(ITypeDescriptorContext context, IDictionary propertyValues);
+        protected Exception GetConvertFromException(object value);
+        protected Exception GetConvertToException(object value, Type destinationType);
+        public bool GetCreateInstanceSupported();
+        public virtual bool GetCreateInstanceSupported(ITypeDescriptorContext context);
+        public PropertyDescriptorCollection GetProperties(ITypeDescriptorContext context, object value);
+        public virtual PropertyDescriptorCollection GetProperties(ITypeDescriptorContext context, object value, Attribute[] attributes);
+        public PropertyDescriptorCollection GetProperties(object value);
+        public bool GetPropertiesSupported();
+        public virtual bool GetPropertiesSupported(ITypeDescriptorContext context);
+        public ICollection GetStandardValues();
+        public virtual TypeConverter.StandardValuesCollection GetStandardValues(ITypeDescriptorContext context);
+        public bool GetStandardValuesExclusive();
+        public virtual bool GetStandardValuesExclusive(ITypeDescriptorContext context);
+        public bool GetStandardValuesSupported();
+        public virtual bool GetStandardValuesSupported(ITypeDescriptorContext context);
+        public virtual bool IsValid(ITypeDescriptorContext context, object value);
+        public bool IsValid(object value);
+        protected PropertyDescriptorCollection SortProperties(PropertyDescriptorCollection props, string[] names);
+        protected abstract class SimplePropertyDescriptor : PropertyDescriptor {
+            protected SimplePropertyDescriptor(Type componentType, string name, Type propertyType);
+            protected SimplePropertyDescriptor(Type componentType, string name, Type propertyType, Attribute[] attributes);
+            public override Type ComponentType { get; }
+            public override bool IsReadOnly { get; }
+            public override Type PropertyType { get; }
+            public override bool CanResetValue(object component);
+            public override void ResetValue(object component);
+            public override bool ShouldSerializeValue(object component);
+        }
+        public class StandardValuesCollection : ICollection, IEnumerable {
+            public StandardValuesCollection(ICollection values);
+            public int Count { get; }
+            bool System.Collections.ICollection.IsSynchronized { get; }
+            object System.Collections.ICollection.SyncRoot { get; }
+            public object this[int index] { get; }
+            public void CopyTo(Array array, int index);
+            public IEnumerator GetEnumerator();
+        }
+    }
+    public sealed class TypeConverterAttribute : Attribute {
+        public static readonly TypeConverterAttribute Default;
+        public TypeConverterAttribute();
+        public TypeConverterAttribute(string typeName);
+        public TypeConverterAttribute(Type type);
+        public string ConverterTypeName { get; }
+        public override bool Equals(object obj);
+        public override int GetHashCode();
+    }
+    public abstract class TypeDescriptionProvider {
+        protected TypeDescriptionProvider();
+        protected TypeDescriptionProvider(TypeDescriptionProvider parent);
+        public virtual object CreateInstance(IServiceProvider provider, Type objectType, Type[] argTypes, object[] args);
+        public virtual IDictionary GetCache(object instance);
+        public virtual ICustomTypeDescriptor GetExtendedTypeDescriptor(object instance);
+        protected internal virtual IExtenderProvider[] GetExtenderProviders(object instance);
+        public virtual string GetFullComponentName(object component);
+        public Type GetReflectionType(object instance);
+        public Type GetReflectionType(Type objectType);
+        public virtual Type GetReflectionType(Type objectType, object instance);
+        public virtual Type GetRuntimeType(Type reflectionType);
+        public ICustomTypeDescriptor GetTypeDescriptor(object instance);
+        public ICustomTypeDescriptor GetTypeDescriptor(Type objectType);
+        public virtual ICustomTypeDescriptor GetTypeDescriptor(Type objectType, object instance);
+        public virtual bool IsSupportedType(Type type);
+    }
+    public sealed class TypeDescriptionProviderAttribute : Attribute {
+        public TypeDescriptionProviderAttribute(string typeName);
+        public TypeDescriptionProviderAttribute(Type type);
+        public string TypeName { get; }
+    }
+    public sealed class TypeDescriptor {
+        public static Type InterfaceType { get; }
+        public static event RefreshEventHandler Refreshed;
+        public static TypeDescriptionProvider AddAttributes(object instance, params Attribute[] attributes);
+        public static TypeDescriptionProvider AddAttributes(Type type, params Attribute[] attributes);
+        public static void AddEditorTable(Type editorBaseType, Hashtable table);
+        public static void AddProvider(TypeDescriptionProvider provider, object instance);
+        public static void AddProvider(TypeDescriptionProvider provider, Type type);
+        public static void AddProviderTransparent(TypeDescriptionProvider provider, object instance);
+        public static void AddProviderTransparent(TypeDescriptionProvider provider, Type type);
+        public static void CreateAssociation(object primary, object secondary);
+        public static EventDescriptor CreateEvent(Type componentType, EventDescriptor oldEventDescriptor, params Attribute[] attributes);
+        public static EventDescriptor CreateEvent(Type componentType, string name, Type type, params Attribute[] attributes);
+        public static object CreateInstance(IServiceProvider provider, Type objectType, Type[] argTypes, object[] args);
+        public static PropertyDescriptor CreateProperty(Type componentType, PropertyDescriptor oldPropertyDescriptor, params Attribute[] attributes);
+        public static PropertyDescriptor CreateProperty(Type componentType, string name, Type type, params Attribute[] attributes);
+        public static object GetAssociation(Type type, object primary);
+        public static AttributeCollection GetAttributes(object component);
+        public static AttributeCollection GetAttributes(object component, bool noCustomTypeDesc);
+        public static AttributeCollection GetAttributes(Type componentType);
+        public static string GetClassName(object component);
+        public static string GetClassName(object component, bool noCustomTypeDesc);
+        public static string GetClassName(Type componentType);
+        public static string GetComponentName(object component);
+        public static string GetComponentName(object component, bool noCustomTypeDesc);
+        public static TypeConverter GetConverter(object component);
+        public static TypeConverter GetConverter(object component, bool noCustomTypeDesc);
+        public static TypeConverter GetConverter(Type type);
+        public static EventDescriptor GetDefaultEvent(object component);
+        public static EventDescriptor GetDefaultEvent(object component, bool noCustomTypeDesc);
+        public static EventDescriptor GetDefaultEvent(Type componentType);
+        public static PropertyDescriptor GetDefaultProperty(object component);
+        public static PropertyDescriptor GetDefaultProperty(object component, bool noCustomTypeDesc);
+        public static PropertyDescriptor GetDefaultProperty(Type componentType);
+        public static object GetEditor(object component, Type editorBaseType);
+        public static object GetEditor(object component, Type editorBaseType, bool noCustomTypeDesc);
+        public static object GetEditor(Type type, Type editorBaseType);
+        public static EventDescriptorCollection GetEvents(object component);
+        public static EventDescriptorCollection GetEvents(object component, Attribute[] attributes);
+        public static EventDescriptorCollection GetEvents(object component, Attribute[] attributes, bool noCustomTypeDesc);
+        public static EventDescriptorCollection GetEvents(object component, bool noCustomTypeDesc);
+        public static EventDescriptorCollection GetEvents(Type componentType);
+        public static EventDescriptorCollection GetEvents(Type componentType, Attribute[] attributes);
+        public static string GetFullComponentName(object component);
+        public static PropertyDescriptorCollection GetProperties(object component);
+        public static PropertyDescriptorCollection GetProperties(object component, Attribute[] attributes);
+        public static PropertyDescriptorCollection GetProperties(object component, Attribute[] attributes, bool noCustomTypeDesc);
+        public static PropertyDescriptorCollection GetProperties(object component, bool noCustomTypeDesc);
+        public static PropertyDescriptorCollection GetProperties(Type componentType);
+        public static PropertyDescriptorCollection GetProperties(Type componentType, Attribute[] attributes);
+        public static TypeDescriptionProvider GetProvider(object instance);
+        public static TypeDescriptionProvider GetProvider(Type type);
+        public static Type GetReflectionType(object instance);
+        public static Type GetReflectionType(Type type);
+        public static void Refresh(object component);
+        public static void Refresh(Assembly assembly);
+        public static void Refresh(Module module);
+        public static void Refresh(Type type);
+        public static void RemoveAssociation(object primary, object secondary);
+        public static void RemoveAssociations(object primary);
+        public static void RemoveProvider(TypeDescriptionProvider provider, object instance);
+        public static void RemoveProvider(TypeDescriptionProvider provider, Type type);
+        public static void RemoveProviderTransparent(TypeDescriptionProvider provider, object instance);
+        public static void RemoveProviderTransparent(TypeDescriptionProvider provider, Type type);
+        public static void SortDescriptorArray(IList infos);
+    }
+    public abstract class TypeListConverter : TypeConverter {
+        protected TypeListConverter(Type[] types);
+        public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
+        public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
+        public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
+        public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
+        public override TypeConverter.StandardValuesCollection GetStandardValues(ITypeDescriptorContext context);
+        public override bool GetStandardValuesExclusive(ITypeDescriptorContext context);
+        public override bool GetStandardValuesSupported(ITypeDescriptorContext context);
+    }
+    public class UInt16Converter : BaseNumberConverter {
+        public UInt16Converter();
+    }
+    public class UInt32Converter : BaseNumberConverter {
+        public UInt32Converter();
+    }
+    public class UInt64Converter : BaseNumberConverter {
+        public UInt64Converter();
+    }
+    public class Win32Exception : Exception {
+        public Win32Exception();
+        public Win32Exception(int error);
+        public Win32Exception(int error, string message);
+        public Win32Exception(string message);
+        public Win32Exception(string message, Exception innerException);
+        public int NativeErrorCode { get; }
+    }
+}
```

## System.ComponentModel.DataAnnotations

```c#
+namespace System.ComponentModel.DataAnnotations {
+    public sealed class AssociationAttribute : Attribute {
+        public AssociationAttribute(string name, string thisKey, string otherKey);
+        public bool IsForeignKey { get; set; }
+        public string Name { get; }
+        public string OtherKey { get; }
+        public IEnumerable<string> OtherKeyMembers { get; }
+        public string ThisKey { get; }
+        public IEnumerable<string> ThisKeyMembers { get; }
+    }
+    public class CompareAttribute : ValidationAttribute {
+        public CompareAttribute(string otherProperty);
+        public string OtherProperty { get; }
+        public string OtherPropertyDisplayName { get; }
+        public override bool RequiresValidationContext { get; }
+        public override string FormatErrorMessage(string name);
+        protected override ValidationResult IsValid(object value, ValidationContext validationContext);
+    }
+    public sealed class ConcurrencyCheckAttribute : Attribute {
+        public ConcurrencyCheckAttribute();
+    }
+    public sealed class CreditCardAttribute : DataTypeAttribute {
+        public CreditCardAttribute();
+        public override bool IsValid(object value);
+    }
+    public sealed class CustomValidationAttribute : ValidationAttribute {
+        public CustomValidationAttribute(Type validatorType, string method);
+        public string Method { get; }
+        public Type ValidatorType { get; }
+        public override string FormatErrorMessage(string name);
+        protected override ValidationResult IsValid(object value, ValidationContext validationContext);
+    }
+    public enum DataType {
+        CreditCard = 14,
+        Currency = 6,
+        Custom = 0,
+        Date = 2,
+        DateTime = 1,
+        Duration = 4,
+        EmailAddress = 10,
+        Html = 8,
+        ImageUrl = 13,
+        MultilineText = 9,
+        Password = 11,
+        PhoneNumber = 5,
+        PostalCode = 15,
+        Text = 7,
+        Time = 3,
+        Upload = 16,
+        Url = 12,
+    }
+    public class DataTypeAttribute : ValidationAttribute {
+        public DataTypeAttribute(DataType dataType);
+        public DataTypeAttribute(string customDataType);
+        public string CustomDataType { get; }
+        public DataType DataType { get; }
+        public DisplayFormatAttribute DisplayFormat { get; protected set; }
+        public virtual string GetDataTypeName();
+        public override bool IsValid(object value);
+    }
+    public sealed class DisplayAttribute : Attribute {
+        public DisplayAttribute();
+        public bool AutoGenerateField { get; set; }
+        public bool AutoGenerateFilter { get; set; }
+        public string Description { get; set; }
+        public string GroupName { get; set; }
+        public string Name { get; set; }
+        public int Order { get; set; }
+        public string Prompt { get; set; }
+        public Type ResourceType { get; set; }
+        public string ShortName { get; set; }
+        public Nullable<bool> GetAutoGenerateField();
+        public Nullable<bool> GetAutoGenerateFilter();
+        public string GetDescription();
+        public string GetGroupName();
+        public string GetName();
+        public Nullable<int> GetOrder();
+        public string GetPrompt();
+        public string GetShortName();
+    }
+    public class DisplayColumnAttribute : Attribute {
+        public DisplayColumnAttribute(string displayColumn);
+        public DisplayColumnAttribute(string displayColumn, string sortColumn);
+        public DisplayColumnAttribute(string displayColumn, string sortColumn, bool sortDescending);
+        public string DisplayColumn { get; }
+        public string SortColumn { get; }
+        public bool SortDescending { get; }
+    }
+    public class DisplayFormatAttribute : Attribute {
+        public DisplayFormatAttribute();
+        public bool ApplyFormatInEditMode { get; set; }
+        public bool ConvertEmptyStringToNull { get; set; }
+        public string DataFormatString { get; set; }
+        public bool HtmlEncode { get; set; }
+        public string NullDisplayText { get; set; }
+    }
+    public sealed class EditableAttribute : Attribute {
+        public EditableAttribute(bool allowEdit);
+        public bool AllowEdit { get; }
+        public bool AllowInitialValue { get; set; }
+    }
+    public sealed class EmailAddressAttribute : DataTypeAttribute {
+        public EmailAddressAttribute();
+        public override bool IsValid(object value);
+    }
+    public sealed class EnumDataTypeAttribute : DataTypeAttribute {
+        public EnumDataTypeAttribute(Type enumType);
+        public Type EnumType { get; }
+        public override bool IsValid(object value);
+    }
+    public sealed class FileExtensionsAttribute : DataTypeAttribute {
+        public FileExtensionsAttribute();
+        public string Extensions { get; set; }
+        public override string FormatErrorMessage(string name);
+        public override bool IsValid(object value);
+    }
+    public sealed class FilterUIHintAttribute : Attribute {
+        public FilterUIHintAttribute(string filterUIHint);
+        public FilterUIHintAttribute(string filterUIHint, string presentationLayer);
+        public FilterUIHintAttribute(string filterUIHint, string presentationLayer, params object[] controlParameters);
+        public IDictionary<string, object> ControlParameters { get; }
+        public string FilterUIHint { get; }
+        public string PresentationLayer { get; }
+        public override bool Equals(object obj);
+        public override int GetHashCode();
+    }
+    public interface IValidatableObject {
+        IEnumerable<ValidationResult> Validate(ValidationContext validationContext);
+    }
+    public sealed class KeyAttribute : Attribute {
+        public KeyAttribute();
+    }
+    public class MaxLengthAttribute : ValidationAttribute {
+        public MaxLengthAttribute();
+        public MaxLengthAttribute(int length);
+        public int Length { get; }
+        public override string FormatErrorMessage(string name);
+        public override bool IsValid(object value);
+    }
+    public class MinLengthAttribute : ValidationAttribute {
+        public MinLengthAttribute(int length);
+        public int Length { get; }
+        public override string FormatErrorMessage(string name);
+        public override bool IsValid(object value);
+    }
+    public sealed class PhoneAttribute : DataTypeAttribute {
+        public PhoneAttribute();
+        public override bool IsValid(object value);
+    }
+    public class RangeAttribute : ValidationAttribute {
+        public RangeAttribute(double minimum, double maximum);
+        public RangeAttribute(int minimum, int maximum);
+        public RangeAttribute(Type type, string minimum, string maximum);
+        public object Maximum { get; }
+        public object Minimum { get; }
+        public Type OperandType { get; }
+        public override string FormatErrorMessage(string name);
+        public override bool IsValid(object value);
+    }
+    public class RegularExpressionAttribute : ValidationAttribute {
+        public RegularExpressionAttribute(string pattern);
+        public int MatchTimeoutInMilliseconds { get; set; }
+        public string Pattern { get; }
+        public override string FormatErrorMessage(string name);
+        public override bool IsValid(object value);
+    }
+    public class RequiredAttribute : ValidationAttribute {
+        public RequiredAttribute();
+        public bool AllowEmptyStrings { get; set; }
+        public override bool IsValid(object value);
+    }
+    public class ScaffoldColumnAttribute : Attribute {
+        public ScaffoldColumnAttribute(bool scaffold);
+        public bool Scaffold { get; }
+    }
+    public class StringLengthAttribute : ValidationAttribute {
+        public StringLengthAttribute(int maximumLength);
+        public int MaximumLength { get; }
+        public int MinimumLength { get; set; }
+        public override string FormatErrorMessage(string name);
+        public override bool IsValid(object value);
+    }
+    public sealed class TimestampAttribute : Attribute {
+        public TimestampAttribute();
+    }
+    public class UIHintAttribute : Attribute {
+        public UIHintAttribute(string uiHint);
+        public UIHintAttribute(string uiHint, string presentationLayer);
+        public UIHintAttribute(string uiHint, string presentationLayer, params object[] controlParameters);
+        public IDictionary<string, object> ControlParameters { get; }
+        public string PresentationLayer { get; }
+        public string UIHint { get; }
+        public override bool Equals(object obj);
+        public override int GetHashCode();
+    }
+    public sealed class UrlAttribute : DataTypeAttribute {
+        public UrlAttribute();
+        public override bool IsValid(object value);
+    }
+    public abstract class ValidationAttribute : Attribute {
+        protected ValidationAttribute();
+        protected ValidationAttribute(Func<string> errorMessageAccessor);
+        protected ValidationAttribute(string errorMessage);
+        public string ErrorMessage { get; set; }
+        public string ErrorMessageResourceName { get; set; }
+        public Type ErrorMessageResourceType { get; set; }
+        protected string ErrorMessageString { get; }
+        public virtual bool RequiresValidationContext { get; }
+        public virtual string FormatErrorMessage(string name);
+        public ValidationResult GetValidationResult(object value, ValidationContext validationContext);
+        public virtual bool IsValid(object value);
+        protected virtual ValidationResult IsValid(object value, ValidationContext validationContext);
+        public void Validate(object value, ValidationContext validationContext);
+        public void Validate(object value, string name);
+    }
+    public sealed class ValidationContext : IServiceProvider {
+        public ValidationContext(object instance);
+        public ValidationContext(object instance, IDictionary<object, object> items);
+        public ValidationContext(object instance, IServiceProvider serviceProvider, IDictionary<object, object> items);
+        public string DisplayName { get; set; }
+        public IDictionary<object, object> Items { get; }
+        public string MemberName { get; set; }
+        public object ObjectInstance { get; }
+        public Type ObjectType { get; }
+        public object GetService(Type serviceType);
+        public void InitializeServiceProvider(Func<Type, object> serviceProvider);
+    }
+    public class ValidationException : Exception {
+        public ValidationException();
+        public ValidationException(ValidationResult validationResult, ValidationAttribute validatingAttribute, object value);
+        public ValidationException(string message);
+        public ValidationException(string errorMessage, ValidationAttribute validatingAttribute, object value);
+        public ValidationException(string message, Exception innerException);
+        public ValidationAttribute ValidationAttribute { get; }
+        public ValidationResult ValidationResult { get; }
+        public object Value { get; }
+    }
+    public class ValidationResult {
+        public static readonly ValidationResult Success;
+        protected ValidationResult(ValidationResult validationResult);
+        public ValidationResult(string errorMessage);
+        public ValidationResult(string errorMessage, IEnumerable<string> memberNames);
+        public string ErrorMessage { get; set; }
+        public IEnumerable<string> MemberNames { get; }
+        public override string ToString();
+    }
+    public static class Validator {
+        public static bool TryValidateObject(object instance, ValidationContext validationContext, ICollection<ValidationResult> validationResults);
+        public static bool TryValidateObject(object instance, ValidationContext validationContext, ICollection<ValidationResult> validationResults, bool validateAllProperties);
+        public static bool TryValidateProperty(object value, ValidationContext validationContext, ICollection<ValidationResult> validationResults);
+        public static bool TryValidateValue(object value, ValidationContext validationContext, ICollection<ValidationResult> validationResults, IEnumerable<ValidationAttribute> validationAttributes);
+        public static void ValidateObject(object instance, ValidationContext validationContext);
+        public static void ValidateObject(object instance, ValidationContext validationContext, bool validateAllProperties);
+        public static void ValidateProperty(object value, ValidationContext validationContext);
+        public static void ValidateValue(object value, ValidationContext validationContext, IEnumerable<ValidationAttribute> validationAttributes);
+    }
+}
```

## System.ComponentModel.DataAnnotations.Schema

```c#
+namespace System.ComponentModel.DataAnnotations.Schema {
+    public class ColumnAttribute : Attribute {
+        public ColumnAttribute();
+        public ColumnAttribute(string name);
+        public string Name { get; }
+        public int Order { get; set; }
+        public string TypeName { get; set; }
+    }
+    public class ComplexTypeAttribute : Attribute {
+        public ComplexTypeAttribute();
+    }
+    public class DatabaseGeneratedAttribute : Attribute {
+        public DatabaseGeneratedAttribute(DatabaseGeneratedOption databaseGeneratedOption);
+        public DatabaseGeneratedOption DatabaseGeneratedOption { get; }
+    }
+    public enum DatabaseGeneratedOption {
+        Computed = 2,
+        Identity = 1,
+        None = 0,
+    }
+    public class ForeignKeyAttribute : Attribute {
+        public ForeignKeyAttribute(string name);
+        public string Name { get; }
+    }
+    public class InversePropertyAttribute : Attribute {
+        public InversePropertyAttribute(string property);
+        public string Property { get; }
+    }
+    public class NotMappedAttribute : Attribute {
+        public NotMappedAttribute();
+    }
+    public class TableAttribute : Attribute {
+        public TableAttribute(string name);
+        public string Name { get; }
+        public string Schema { get; set; }
+    }
+}
```

## System.Configuration.Assemblies

```c#
+namespace System.Configuration.Assemblies {
+    public enum AssemblyHashAlgorithm {
+        MD5 = 32771,
+        None = 0,
+        SHA1 = 32772,
+        SHA256 = 32780,
+        SHA384 = 32781,
+        SHA512 = 32782,
+    }
+}
```

## System.Data

```c#
+namespace System.Data {
+    public enum CommandBehavior {
+        CloseConnection = 32,
+        Default = 0,
+        KeyInfo = 4,
+        SchemaOnly = 2,
+        SequentialAccess = 16,
+        SingleResult = 1,
+        SingleRow = 8,
+    }
+    public enum CommandType {
+        StoredProcedure = 4,
+        TableDirect = 512,
+        Text = 1,
+    }
+    public enum ConnectionState {
+        Broken = 16,
+        Closed = 0,
+        Connecting = 2,
+        Executing = 4,
+        Fetching = 8,
+        Open = 1,
+    }
+    public enum DataRowVersion {
+        Default = 1536,
+    }
+    public class DataTable
+    public enum DbType {
+        AnsiString = 0,
+        AnsiStringFixedLength = 22,
+        Binary = 1,
+        Boolean = 3,
+        Byte = 2,
+        Currency = 4,
+        Date = 5,
+        DateTime = 6,
+        DateTime2 = 26,
+        DateTimeOffset = 27,
+        Decimal = 7,
+        Double = 8,
+        Guid = 9,
+        Int16 = 10,
+        Int32 = 11,
+        Int64 = 12,
+        Object = 13,
+        SByte = 14,
+        Single = 15,
+        String = 16,
+        StringFixedLength = 23,
+        Time = 17,
+        UInt16 = 18,
+        UInt32 = 19,
+        UInt64 = 20,
+        VarNumeric = 21,
+        Xml = 25,
+    }
+    public interface IDataParameter {
+        DbType DbType { get; set; }
+        ParameterDirection Direction { get; set; }
+        bool IsNullable { get; }
+        string ParameterName { get; set; }
+        string SourceColumn { get; set; }
+        DataRowVersion SourceVersion { get; set; }
+        object Value { get; set; }
+    }
+    public interface IDataParameterCollection : ICollection, IEnumerable, IList {
+        object this[string parameterName] { get; set; }
+        bool Contains(string parameterName);
+        int IndexOf(string parameterName);
+        void RemoveAt(string parameterName);
+    }
+    public interface IDataReader : IDataRecord, IDisposable {
+        int Depth { get; }
+        bool IsClosed { get; }
+        int RecordsAffected { get; }
+        void Close();
+        DataTable GetSchemaTable();
+        bool NextResult();
+        bool Read();
+    }
+    public interface IDataRecord {
+        int FieldCount { get; }
+        object this[int i] { get; }
+        object this[string name] { get; }
+        bool GetBoolean(int i);
+        byte GetByte(int i);
+        long GetBytes(int i, long fieldOffset, byte[] buffer, int bufferoffset, int length);
+        char GetChar(int i);
+        long GetChars(int i, long fieldoffset, char[] buffer, int bufferoffset, int length);
+        IDataReader GetData(int i);
+        string GetDataTypeName(int i);
+        DateTime GetDateTime(int i);
+        Decimal GetDecimal(int i);
+        double GetDouble(int i);
+        Type GetFieldType(int i);
+        float GetFloat(int i);
+        Guid GetGuid(int i);
+        short GetInt16(int i);
+        int GetInt32(int i);
+        long GetInt64(int i);
+        string GetName(int i);
+        int GetOrdinal(string name);
+        string GetString(int i);
+        object GetValue(int i);
+        int GetValues(object[] values);
+        bool IsDBNull(int i);
+    }
+    public interface IDbCommand : IDisposable {
+        string CommandText { get; set; }
+        int CommandTimeout { get; set; }
+        CommandType CommandType { get; set; }
+        IDbConnection Connection { get; set; }
+        IDataParameterCollection Parameters { get; }
+        IDbTransaction Transaction { get; set; }
+        UpdateRowSource UpdatedRowSource { get; set; }
+        void Cancel();
+        IDbDataParameter CreateParameter();
+        int ExecuteNonQuery();
+        IDataReader ExecuteReader();
+        IDataReader ExecuteReader(CommandBehavior behavior);
+        object ExecuteScalar();
+        void Prepare();
+    }
+    public interface IDbConnection : IDisposable {
+        string ConnectionString { get; set; }
+        int ConnectionTimeout { get; }
+        string Database { get; }
+        ConnectionState State { get; }
+        IDbTransaction BeginTransaction();
+        IDbTransaction BeginTransaction(IsolationLevel il);
+        void ChangeDatabase(string databaseName);
+        void Close();
+        IDbCommand CreateCommand();
+        void Open();
+    }
+    public interface IDbDataParameter : IDataParameter {
+        byte Precision { get; set; }
+        byte Scale { get; set; }
+        int Size { get; set; }
+    }
+    public interface IDbTransaction : IDisposable {
+        IDbConnection Connection { get; }
+        IsolationLevel IsolationLevel { get; }
+        void Commit();
+        void Rollback();
+    }
+    public enum IsolationLevel {
+        Chaos = 16,
+        ReadCommitted = 4096,
+        ReadUncommitted = 256,
+        RepeatableRead = 65536,
+        Serializable = 1048576,
+        Snapshot = 16777216,
+        Unspecified = -1,
+    }
+    public enum ParameterDirection {
+        Input = 1,
+        InputOutput = 3,
+        Output = 2,
+        ReturnValue = 6,
+    }
+    public enum SqlDbType {
+        BigInt = 0,
+        Binary = 1,
+        Bit = 2,
+        Char = 3,
+        Date = 31,
+        DateTime = 4,
+        DateTime2 = 33,
+        DateTimeOffset = 34,
+        Decimal = 5,
+        Float = 6,
+        Image = 7,
+        Int = 8,
+        Money = 9,
+        NChar = 10,
+        NText = 11,
+        NVarChar = 12,
+        Real = 13,
+        SmallDateTime = 15,
+        SmallInt = 16,
+        SmallMoney = 17,
+        Structured = 30,
+        Text = 18,
+        Time = 32,
+        Timestamp = 19,
+        TinyInt = 20,
+        Udt = 29,
+        UniqueIdentifier = 14,
+        VarBinary = 21,
+        VarChar = 22,
+        Variant = 23,
+        Xml = 25,
+    }
+    public sealed class StateChangeEventArgs : EventArgs {
+        public StateChangeEventArgs(ConnectionState originalState, ConnectionState currentState);
+        public ConnectionState CurrentState { get; }
+        public ConnectionState OriginalState { get; }
+    }
+    public delegate void StateChangeEventHandler(object sender, StateChangeEventArgs e);
+    public sealed class StatementCompletedEventArgs : EventArgs {
+        public StatementCompletedEventArgs(int recordCount);
+        public int RecordCount { get; }
+    }
+    public delegate void StatementCompletedEventHandler(object sender, StatementCompletedEventArgs e);
+    public enum UpdateRowSource {
+        Both = 3,
+        FirstReturnedRecord = 2,
+        None = 0,
+        OutputParameters = 1,
+    }
+}
```

## System.Data.Common

```c#
+namespace System.Data.Common {
+    public abstract class DbColumn {
+        protected DbColumn();
+        public Nullable<bool> AllowDBNull { get; protected set; }
+        public string BaseCatalogName { get; protected set; }
+        public string BaseColumnName { get; protected set; }
+        public string BaseSchemaName { get; protected set; }
+        public string BaseServerName { get; protected set; }
+        public string BaseTableName { get; protected set; }
+        public string ColumnName { get; protected set; }
+        public Nullable<int> ColumnOrdinal { get; protected set; }
+        public Nullable<int> ColumnSize { get; protected set; }
+        public Type DataType { get; protected set; }
+        public string DataTypeName { get; protected set; }
+        public Nullable<bool> IsAliased { get; protected set; }
+        public Nullable<bool> IsAutoIncrement { get; protected set; }
+        public Nullable<bool> IsExpression { get; protected set; }
+        public Nullable<bool> IsHidden { get; protected set; }
+        public Nullable<bool> IsIdentity { get; protected set; }
+        public Nullable<bool> IsKey { get; protected set; }
+        public Nullable<bool> IsLong { get; protected set; }
+        public Nullable<bool> IsReadOnly { get; protected set; }
+        public Nullable<bool> IsUnique { get; protected set; }
+        public Nullable<int> NumericPrecision { get; protected set; }
+        public Nullable<int> NumericScale { get; protected set; }
+        public virtual object this[string property] { get; }
+        public string UdtAssemblyQualifiedName { get; protected set; }
+    }
+    public abstract class DbCommand : IDbCommand, IDisposable {
+        protected DbCommand();
+        public abstract string CommandText { get; set; }
+        public abstract int CommandTimeout { get; set; }
+        public abstract CommandType CommandType { get; set; }
+        public DbConnection Connection { get; set; }
+        protected abstract DbConnection DbConnection { get; set; }
+        protected abstract DbParameterCollection DbParameterCollection { get; }
+        protected abstract DbTransaction DbTransaction { get; set; }
+        public abstract bool DesignTimeVisible { get; set; }
+        public DbParameterCollection Parameters { get; }
+        IDbConnection System.Data.IDbCommand.Connection { get; set; }
+        IDataParameterCollection System.Data.IDbCommand.Parameters { get; }
+        IDbTransaction System.Data.IDbCommand.Transaction { get; set; }
+        public DbTransaction Transaction { get; set; }
+        public abstract UpdateRowSource UpdatedRowSource { get; set; }
+        public abstract void Cancel();
+        protected abstract DbParameter CreateDbParameter();
+        public DbParameter CreateParameter();
+        public void Dispose();
+        protected virtual void Dispose(bool disposing);
+        protected abstract DbDataReader ExecuteDbDataReader(CommandBehavior behavior);
+        protected virtual Task<DbDataReader> ExecuteDbDataReaderAsync(CommandBehavior behavior, CancellationToken cancellationToken);
+        public abstract int ExecuteNonQuery();
+        public Task<int> ExecuteNonQueryAsync();
+        public virtual Task<int> ExecuteNonQueryAsync(CancellationToken cancellationToken);
+        public DbDataReader ExecuteReader();
+        public DbDataReader ExecuteReader(CommandBehavior behavior);
+        public Task<DbDataReader> ExecuteReaderAsync();
+        public Task<DbDataReader> ExecuteReaderAsync(CommandBehavior behavior);
+        public Task<DbDataReader> ExecuteReaderAsync(CommandBehavior behavior, CancellationToken cancellationToken);
+        public Task<DbDataReader> ExecuteReaderAsync(CancellationToken cancellationToken);
+        public abstract object ExecuteScalar();
+        public Task<object> ExecuteScalarAsync();
+        public virtual Task<object> ExecuteScalarAsync(CancellationToken cancellationToken);
+        public abstract void Prepare();
+        IDbDataParameter System.Data.IDbCommand.CreateParameter();
+        IDataReader System.Data.IDbCommand.ExecuteReader();
+        IDataReader System.Data.IDbCommand.ExecuteReader(CommandBehavior behavior);
+    }
+    public abstract class DbConnection : IDbConnection, IDisposable {
+        protected DbConnection();
+        public abstract string ConnectionString { get; set; }
+        public virtual int ConnectionTimeout { get; }
+        public abstract string Database { get; }
+        public abstract string DataSource { get; }
+        public abstract string ServerVersion { get; }
+        public abstract ConnectionState State { get; }
+        public virtual event StateChangeEventHandler StateChange;
+        protected abstract DbTransaction BeginDbTransaction(IsolationLevel isolationLevel);
+        public DbTransaction BeginTransaction();
+        public DbTransaction BeginTransaction(IsolationLevel isolationLevel);
+        public abstract void ChangeDatabase(string databaseName);
+        public abstract void Close();
+        public DbCommand CreateCommand();
+        protected abstract DbCommand CreateDbCommand();
+        public void Dispose();
+        protected virtual void Dispose(bool disposing);
+        protected virtual void OnStateChange(StateChangeEventArgs stateChange);
+        public abstract void Open();
+        public Task OpenAsync();
+        public virtual Task OpenAsync(CancellationToken cancellationToken);
+        IDbTransaction System.Data.IDbConnection.BeginTransaction();
+        IDbTransaction System.Data.IDbConnection.BeginTransaction(IsolationLevel isolationLevel);
+        IDbCommand System.Data.IDbConnection.CreateCommand();
+    }
+    public class DbConnectionStringBuilder : ICollection, IDictionary, IEnumerable {
+        public DbConnectionStringBuilder();
+        public string ConnectionString { get; set; }
+        public virtual int Count { get; }
+        public virtual ICollection Keys { get; }
+        bool System.Collections.ICollection.IsSynchronized { get; }
+        object System.Collections.ICollection.SyncRoot { get; }
+        bool System.Collections.IDictionary.IsFixedSize { get; }
+        bool System.Collections.IDictionary.IsReadOnly { get; }
+        object System.Collections.IDictionary.this[object keyword] { get; set; }
+        public virtual object this[string keyword] { get; set; }
+        public virtual ICollection Values { get; }
+        public void Add(string keyword, object value);
+        public static void AppendKeyValuePair(StringBuilder builder, string keyword, string value);
+        public virtual void Clear();
+        public virtual bool ContainsKey(string keyword);
+        public virtual bool EquivalentTo(DbConnectionStringBuilder connectionStringBuilder);
+        public virtual bool Remove(string keyword);
+        public virtual bool ShouldSerialize(string keyword);
+        void System.Collections.ICollection.CopyTo(Array array, int index);
+        void System.Collections.IDictionary.Add(object keyword, object value);
+        bool System.Collections.IDictionary.Contains(object keyword);
+        IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator();
+        void System.Collections.IDictionary.Remove(object keyword);
+        IEnumerator System.Collections.IEnumerable.GetEnumerator();
+        public override string ToString();
+        public virtual bool TryGetValue(string keyword, out object value);
+    }
+    public abstract class DbDataReader : IDataReader, IDataRecord, IDisposable, IEnumerable {
+        protected DbDataReader();
+        public abstract int Depth { get; }
+        public abstract int FieldCount { get; }
+        public abstract bool HasRows { get; }
+        public abstract bool IsClosed { get; }
+        public abstract int RecordsAffected { get; }
+        public abstract object this[int ordinal] { get; }
+        public abstract object this[string name] { get; }
+        public virtual int VisibleFieldCount { get; }
+        public void Dispose();
+        protected virtual void Dispose(bool disposing);
+        public abstract bool GetBoolean(int ordinal);
+        public abstract byte GetByte(int ordinal);
+        public abstract long GetBytes(int ordinal, long dataOffset, byte[] buffer, int bufferOffset, int length);
+        public abstract char GetChar(int ordinal);
+        public abstract long GetChars(int ordinal, long dataOffset, char[] buffer, int bufferOffset, int length);
+        public DbDataReader GetData(int ordinal);
+        public abstract string GetDataTypeName(int ordinal);
+        public abstract DateTime GetDateTime(int ordinal);
+        protected virtual DbDataReader GetDbDataReader(int ordinal);
+        public abstract Decimal GetDecimal(int ordinal);
+        public abstract double GetDouble(int ordinal);
+        public abstract IEnumerator GetEnumerator();
+        public abstract Type GetFieldType(int ordinal);
+        public virtual T GetFieldValue<T>(int ordinal);
+        public Task<T> GetFieldValueAsync<T>(int ordinal);
+        public virtual Task<T> GetFieldValueAsync<T>(int ordinal, CancellationToken cancellationToken);
+        public abstract float GetFloat(int ordinal);
+        public abstract Guid GetGuid(int ordinal);
+        public abstract short GetInt16(int ordinal);
+        public abstract int GetInt32(int ordinal);
+        public abstract long GetInt64(int ordinal);
+        public abstract string GetName(int ordinal);
+        public abstract int GetOrdinal(string name);
+        public virtual Type GetProviderSpecificFieldType(int ordinal);
+        public virtual object GetProviderSpecificValue(int ordinal);
+        public virtual int GetProviderSpecificValues(object[] values);
+        public virtual Stream GetStream(int ordinal);
+        public abstract string GetString(int ordinal);
+        public virtual TextReader GetTextReader(int ordinal);
+        public abstract object GetValue(int ordinal);
+        public abstract int GetValues(object[] values);
+        public abstract bool IsDBNull(int ordinal);
+        public Task<bool> IsDBNullAsync(int ordinal);
+        public virtual Task<bool> IsDBNullAsync(int ordinal, CancellationToken cancellationToken);
+        public abstract bool NextResult();
+        public Task<bool> NextResultAsync();
+        public virtual Task<bool> NextResultAsync(CancellationToken cancellationToken);
+        public abstract bool Read();
+        public Task<bool> ReadAsync();
+        public virtual Task<bool> ReadAsync(CancellationToken cancellationToken);
+        void System.Data.IDataReader.Close();
+        DataTable System.Data.IDataReader.GetSchemaTable();
+        IDataReader System.Data.IDataRecord.GetData(int ordinal);
+    }
+    public static class DbDataReaderExtensions {
+        public static bool CanGetColumnSchema(this DbDataReader reader);
+        public static ReadOnlyCollection<DbColumn> GetColumnSchema(this DbDataReader reader);
+    }
+    public abstract class DbDataRecord : IDataRecord {
+        protected DbDataRecord();
+        public abstract int FieldCount { get; }
+        public abstract object this[int i] { get; }
+        public abstract object this[string name] { get; }
+        public abstract bool GetBoolean(int i);
+        public abstract byte GetByte(int i);
+        public abstract long GetBytes(int i, long dataIndex, byte[] buffer, int bufferIndex, int length);
+        public abstract char GetChar(int i);
+        public abstract long GetChars(int i, long dataIndex, char[] buffer, int bufferIndex, int length);
+        public IDataReader GetData(int i);
+        public abstract string GetDataTypeName(int i);
+        public abstract DateTime GetDateTime(int i);
+        protected virtual DbDataReader GetDbDataReader(int i);
+        public abstract Decimal GetDecimal(int i);
+        public abstract double GetDouble(int i);
+        public abstract Type GetFieldType(int i);
+        public abstract float GetFloat(int i);
+        public abstract Guid GetGuid(int i);
+        public abstract short GetInt16(int i);
+        public abstract int GetInt32(int i);
+        public abstract long GetInt64(int i);
+        public abstract string GetName(int i);
+        public abstract int GetOrdinal(string name);
+        public abstract string GetString(int i);
+        public abstract object GetValue(int i);
+        public abstract int GetValues(object[] values);
+        public abstract bool IsDBNull(int i);
+    }
+    public class DbEnumerator : IEnumerator {
+        public DbEnumerator(IDataReader reader, bool closeReader);
+        public object Current { get; }
+        public bool MoveNext();
+        public void Reset();
+    }
+    public abstract class DbException : Exception {
+        protected DbException();
+        protected DbException(string message);
+        protected DbException(string message, Exception innerException);
+    }
+    public abstract class DbParameter : IDataParameter, IDbDataParameter {
+        protected DbParameter();
+        public abstract DbType DbType { get; set; }
+        public abstract ParameterDirection Direction { get; set; }
+        public abstract bool IsNullable { get; set; }
+        public abstract string ParameterName { get; set; }
+        public virtual byte Precision { get; set; }
+        public virtual byte Scale { get; set; }
+        public abstract int Size { get; set; }
+        public abstract string SourceColumn { get; set; }
+        public abstract bool SourceColumnNullMapping { get; set; }
+        DataRowVersion System.Data.IDataParameter.SourceVersion { get; set; }
+        byte System.Data.IDbDataParameter.Precision { get; set; }
+        byte System.Data.IDbDataParameter.Scale { get; set; }
+        public abstract object Value { get; set; }
+        public abstract void ResetDbType();
+    }
+    public abstract class DbParameterCollection : ICollection, IDataParameterCollection, IEnumerable, IList {
+        protected DbParameterCollection();
+        public abstract int Count { get; }
+        public abstract object SyncRoot { get; }
+        bool System.Collections.ICollection.IsSynchronized { get; }
+        bool System.Collections.IList.IsFixedSize { get; }
+        bool System.Collections.IList.IsReadOnly { get; }
+        object System.Collections.IList.this[int index] { get; set; }
+        object System.Data.IDataParameterCollection.this[string parameterName] { get; set; }
+        public DbParameter this[int index] { get; set; }
+        public DbParameter this[string parameterName] { get; set; }
+        public abstract int Add(object value);
+        public abstract void AddRange(Array values);
+        public abstract void Clear();
+        public abstract bool Contains(object value);
+        public abstract bool Contains(string value);
+        public abstract void CopyTo(Array array, int index);
+        public abstract IEnumerator GetEnumerator();
+        protected abstract DbParameter GetParameter(int index);
+        protected abstract DbParameter GetParameter(string parameterName);
+        public abstract int IndexOf(object value);
+        public abstract int IndexOf(string parameterName);
+        public abstract void Insert(int index, object value);
+        public abstract void Remove(object value);
+        public abstract void RemoveAt(int index);
+        public abstract void RemoveAt(string parameterName);
+        protected abstract void SetParameter(int index, DbParameter value);
+        protected abstract void SetParameter(string parameterName, DbParameter value);
+    }
+    public abstract class DbProviderFactory {
+        protected DbProviderFactory();
+        public virtual DbCommand CreateCommand();
+        public virtual DbConnection CreateConnection();
+        public virtual DbConnectionStringBuilder CreateConnectionStringBuilder();
+        public virtual DbParameter CreateParameter();
+    }
+    public abstract class DbTransaction : IDbTransaction, IDisposable {
+        protected DbTransaction();
+        public DbConnection Connection { get; }
+        protected abstract DbConnection DbConnection { get; }
+        public abstract IsolationLevel IsolationLevel { get; }
+        IDbConnection System.Data.IDbTransaction.Connection { get; }
+        public abstract void Commit();
+        public void Dispose();
+        protected virtual void Dispose(bool disposing);
+        public abstract void Rollback();
+    }
+    public interface IDbColumnSchemaGenerator {
+        ReadOnlyCollection<DbColumn> GetColumnSchema();
+    }
+}
```

## System.Data.SqlClient

```c#
+namespace System.Data.SqlClient {
+    public enum ApplicationIntent {
+        ReadOnly = 1,
+        ReadWrite = 0,
+    }
+    public enum SortOrder {
+        Ascending = 0,
+        Descending = 1,
+        Unspecified = -1,
+    }
+    public sealed class SqlBulkCopy : IDisposable {
+        public SqlBulkCopy(SqlConnection connection);
+        public SqlBulkCopy(SqlConnection connection, SqlBulkCopyOptions copyOptions, SqlTransaction externalTransaction);
+        public SqlBulkCopy(string connectionString);
+        public SqlBulkCopy(string connectionString, SqlBulkCopyOptions copyOptions);
+        public int BatchSize { get; set; }
+        public int BulkCopyTimeout { get; set; }
+        public SqlBulkCopyColumnMappingCollection ColumnMappings { get; }
+        public string DestinationTableName { get; set; }
+        public bool EnableStreaming { get; set; }
+        public int NotifyAfter { get; set; }
+        public event SqlRowsCopiedEventHandler SqlRowsCopied;
+        public void Close();
+        void System.IDisposable.Dispose();
+        public void WriteToServer(DbDataReader reader);
+        public Task WriteToServerAsync(DbDataReader reader);
+        public Task WriteToServerAsync(DbDataReader reader, CancellationToken cancellationToken);
+    }
+    public sealed class SqlBulkCopyColumnMapping {
+        public SqlBulkCopyColumnMapping();
+        public SqlBulkCopyColumnMapping(int sourceColumnOrdinal, int destinationOrdinal);
+        public SqlBulkCopyColumnMapping(int sourceColumnOrdinal, string destinationColumn);
+        public SqlBulkCopyColumnMapping(string sourceColumn, int destinationOrdinal);
+        public SqlBulkCopyColumnMapping(string sourceColumn, string destinationColumn);
+        public string DestinationColumn { get; set; }
+        public int DestinationOrdinal { get; set; }
+        public string SourceColumn { get; set; }
+        public int SourceOrdinal { get; set; }
+    }
+    public sealed class SqlBulkCopyColumnMappingCollection : ICollection, IEnumerable, IList {
+        public int Count { get; }
+        bool System.Collections.ICollection.IsSynchronized { get; }
+        object System.Collections.ICollection.SyncRoot { get; }
+        bool System.Collections.IList.IsFixedSize { get; }
+        bool System.Collections.IList.IsReadOnly { get; }
+        object System.Collections.IList.this[int index] { get; set; }
+        public SqlBulkCopyColumnMapping this[int index] { get; }
+        public SqlBulkCopyColumnMapping Add(SqlBulkCopyColumnMapping bulkCopyColumnMapping);
+        public SqlBulkCopyColumnMapping Add(int sourceColumnIndex, int destinationColumnIndex);
+        public SqlBulkCopyColumnMapping Add(int sourceColumnIndex, string destinationColumn);
+        public SqlBulkCopyColumnMapping Add(string sourceColumn, int destinationColumnIndex);
+        public SqlBulkCopyColumnMapping Add(string sourceColumn, string destinationColumn);
+        public void Clear();
+        public bool Contains(SqlBulkCopyColumnMapping value);
+        public void CopyTo(SqlBulkCopyColumnMapping[] array, int index);
+        public IEnumerator GetEnumerator();
+        public int IndexOf(SqlBulkCopyColumnMapping value);
+        public void Insert(int index, SqlBulkCopyColumnMapping value);
+        public void Remove(SqlBulkCopyColumnMapping value);
+        public void RemoveAt(int index);
+        void System.Collections.ICollection.CopyTo(Array array, int index);
+        int System.Collections.IList.Add(object value);
+        bool System.Collections.IList.Contains(object value);
+        int System.Collections.IList.IndexOf(object value);
+        void System.Collections.IList.Insert(int index, object value);
+        void System.Collections.IList.Remove(object value);
+    }
+    public enum SqlBulkCopyOptions {
+        CheckConstraints = 2,
+        Default = 0,
+        FireTriggers = 16,
+        KeepIdentity = 1,
+        KeepNulls = 8,
+        TableLock = 4,
+        UseInternalTransaction = 32,
+    }
+    public sealed class SqlClientFactory : DbProviderFactory {
+        public static readonly SqlClientFactory Instance;
+        public override DbCommand CreateCommand();
+        public override DbConnection CreateConnection();
+        public override DbConnectionStringBuilder CreateConnectionStringBuilder();
+        public override DbParameter CreateParameter();
+    }
+    public sealed class SqlCommand : DbCommand {
+        public SqlCommand();
+        public SqlCommand(string cmdText);
+        public SqlCommand(string cmdText, SqlConnection connection);
+        public SqlCommand(string cmdText, SqlConnection connection, SqlTransaction transaction);
+        public override string CommandText { get; set; }
+        public override int CommandTimeout { get; set; }
+        public override CommandType CommandType { get; set; }
+        public new SqlConnection Connection { get; set; }
+        protected override DbConnection DbConnection { get; set; }
+        protected override DbParameterCollection DbParameterCollection { get; }
+        protected override DbTransaction DbTransaction { get; set; }
+        public override bool DesignTimeVisible { get; set; }
+        public new SqlParameterCollection Parameters { get; }
+        public new SqlTransaction Transaction { get; set; }
+        public override UpdateRowSource UpdatedRowSource { get; set; }
+        public event StatementCompletedEventHandler StatementCompleted;
+        public override void Cancel();
+        protected override DbParameter CreateDbParameter();
+        public new SqlParameter CreateParameter();
+        protected override void Dispose(bool disposing);
+        protected override DbDataReader ExecuteDbDataReader(CommandBehavior behavior);
+        protected override Task<DbDataReader> ExecuteDbDataReaderAsync(CommandBehavior behavior, CancellationToken cancellationToken);
+        public override int ExecuteNonQuery();
+        public override Task<int> ExecuteNonQueryAsync(CancellationToken cancellationToken);
+        public new SqlDataReader ExecuteReader();
+        public new SqlDataReader ExecuteReader(CommandBehavior behavior);
+        public new Task<SqlDataReader> ExecuteReaderAsync();
+        public new Task<SqlDataReader> ExecuteReaderAsync(CommandBehavior behavior);
+        public new Task<SqlDataReader> ExecuteReaderAsync(CommandBehavior behavior, CancellationToken cancellationToken);
+        public new Task<SqlDataReader> ExecuteReaderAsync(CancellationToken cancellationToken);
+        public override object ExecuteScalar();
+        public override Task<object> ExecuteScalarAsync(CancellationToken cancellationToken);
+        public XmlReader ExecuteXmlReader();
+        public Task<XmlReader> ExecuteXmlReaderAsync();
+        public Task<XmlReader> ExecuteXmlReaderAsync(CancellationToken cancellationToken);
+        public override void Prepare();
+    }
+    public sealed class SqlConnection : DbConnection {
+        public SqlConnection();
+        public SqlConnection(string connectionString);
+        public Guid ClientConnectionId { get; }
+        public override string ConnectionString { get; set; }
+        public override int ConnectionTimeout { get; }
+        public override string Database { get; }
+        public override string DataSource { get; }
+        public bool FireInfoMessageEventOnUserErrors { get; set; }
+        public int PacketSize { get; }
+        public override string ServerVersion { get; }
+        public override ConnectionState State { get; }
+        public bool StatisticsEnabled { get; set; }
+        public string WorkstationId { get; }
+        public event SqlInfoMessageEventHandler InfoMessage;
+        protected override DbTransaction BeginDbTransaction(IsolationLevel isolationLevel);
+        public new SqlTransaction BeginTransaction();
+        public new SqlTransaction BeginTransaction(IsolationLevel iso);
+        public SqlTransaction BeginTransaction(IsolationLevel iso, string transactionName);
+        public SqlTransaction BeginTransaction(string transactionName);
+        public override void ChangeDatabase(string database);
+        public static void ClearAllPools();
+        public static void ClearPool(SqlConnection connection);
+        public override void Close();
+        public new SqlCommand CreateCommand();
+        protected override DbCommand CreateDbCommand();
+        protected override void Dispose(bool disposing);
+        public override void Open();
+        public override Task OpenAsync(CancellationToken cancellationToken);
+        public void ResetStatistics();
+        public IDictionary RetrieveStatistics();
+    }
+    public sealed class SqlConnectionStringBuilder : DbConnectionStringBuilder {
+        public SqlConnectionStringBuilder();
+        public SqlConnectionStringBuilder(string connectionString);
+        public ApplicationIntent ApplicationIntent { get; set; }
+        public string ApplicationName { get; set; }
+        public string AttachDBFilename { get; set; }
+        public int ConnectRetryCount { get; set; }
+        public int ConnectRetryInterval { get; set; }
+        public int ConnectTimeout { get; set; }
+        public string CurrentLanguage { get; set; }
+        public string DataSource { get; set; }
+        public bool Encrypt { get; set; }
+        public string FailoverPartner { get; set; }
+        public string InitialCatalog { get; set; }
+        public bool IntegratedSecurity { get; set; }
+        public override ICollection Keys { get; }
+        public int LoadBalanceTimeout { get; set; }
+        public int MaxPoolSize { get; set; }
+        public int MinPoolSize { get; set; }
+        public bool MultipleActiveResultSets { get; set; }
+        public bool MultiSubnetFailover { get; set; }
+        public int PacketSize { get; set; }
+        public string Password { get; set; }
+        public bool PersistSecurityInfo { get; set; }
+        public bool Pooling { get; set; }
+        public bool Replication { get; set; }
+        public override object this[string keyword] { get; set; }
+        public bool TrustServerCertificate { get; set; }
+        public string TypeSystemVersion { get; set; }
+        public string UserID { get; set; }
+        public bool UserInstance { get; set; }
+        public override ICollection Values { get; }
+        public string WorkstationID { get; set; }
+        public override void Clear();
+        public override bool ContainsKey(string keyword);
+        public override bool Remove(string keyword);
+        public override bool ShouldSerialize(string keyword);
+        public override bool TryGetValue(string keyword, out object value);
+    }
+    public class SqlDataReader : DbDataReader, IDisposable {
+        protected SqlConnection Connection { get; }
+        public override int Depth { get; }
+        public override int FieldCount { get; }
+        public override bool HasRows { get; }
+        public override bool IsClosed { get; }
+        public override int RecordsAffected { get; }
+        public override object this[int i] { get; }
+        public override object this[string name] { get; }
+        public override int VisibleFieldCount { get; }
+        public override bool GetBoolean(int i);
+        public override byte GetByte(int i);
+        public override long GetBytes(int i, long dataIndex, byte[] buffer, int bufferIndex, int length);
+        public override char GetChar(int i);
+        public override long GetChars(int i, long dataIndex, char[] buffer, int bufferIndex, int length);
+        public override string GetDataTypeName(int i);
+        public override DateTime GetDateTime(int i);
+        public virtual DateTimeOffset GetDateTimeOffset(int i);
+        public override Decimal GetDecimal(int i);
+        public override double GetDouble(int i);
+        public override IEnumerator GetEnumerator();
+        public override Type GetFieldType(int i);
+        public override T GetFieldValue<T>(int i);
+        public override Task<T> GetFieldValueAsync<T>(int i, CancellationToken cancellationToken);
+        public override float GetFloat(int i);
+        public override Guid GetGuid(int i);
+        public override short GetInt16(int i);
+        public override int GetInt32(int i);
+        public override long GetInt64(int i);
+        public override string GetName(int i);
+        public override int GetOrdinal(string name);
+        public override Type GetProviderSpecificFieldType(int i);
+        public override object GetProviderSpecificValue(int i);
+        public override int GetProviderSpecificValues(object[] values);
+        public virtual SqlBinary GetSqlBinary(int i);
+        public virtual SqlBoolean GetSqlBoolean(int i);
+        public virtual SqlByte GetSqlByte(int i);
+        public virtual SqlBytes GetSqlBytes(int i);
+        public virtual SqlChars GetSqlChars(int i);
+        public virtual SqlDateTime GetSqlDateTime(int i);
+        public virtual SqlDecimal GetSqlDecimal(int i);
+        public virtual SqlDouble GetSqlDouble(int i);
+        public virtual SqlGuid GetSqlGuid(int i);
+        public virtual SqlInt16 GetSqlInt16(int i);
+        public virtual SqlInt32 GetSqlInt32(int i);
+        public virtual SqlInt64 GetSqlInt64(int i);
+        public virtual SqlMoney GetSqlMoney(int i);
+        public virtual SqlSingle GetSqlSingle(int i);
+        public virtual SqlString GetSqlString(int i);
+        public virtual object GetSqlValue(int i);
+        public virtual int GetSqlValues(object[] values);
+        public virtual SqlXml GetSqlXml(int i);
+        public override Stream GetStream(int i);
+        public override string GetString(int i);
+        public override TextReader GetTextReader(int i);
+        public virtual TimeSpan GetTimeSpan(int i);
+        public override object GetValue(int i);
+        public override int GetValues(object[] values);
+        public virtual XmlReader GetXmlReader(int i);
+        public override bool IsDBNull(int i);
+        public override Task<bool> IsDBNullAsync(int i, CancellationToken cancellationToken);
+        public override bool NextResult();
+        public override Task<bool> NextResultAsync(CancellationToken cancellationToken);
+        public override bool Read();
+        public override Task<bool> ReadAsync(CancellationToken cancellationToken);
+    }
+    public sealed class SqlError {
+        public byte Class { get; }
+        public int LineNumber { get; }
+        public string Message { get; }
+        public int Number { get; }
+        public string Procedure { get; }
+        public string Server { get; }
+        public string Source { get; }
+        public byte State { get; }
+        public override string ToString();
+    }
+    public sealed class SqlErrorCollection : ICollection, IEnumerable {
+        public int Count { get; }
+        bool System.Collections.ICollection.IsSynchronized { get; }
+        object System.Collections.ICollection.SyncRoot { get; }
+        public SqlError this[int index] { get; }
+        public void CopyTo(Array array, int index);
+        public void CopyTo(SqlError[] array, int index);
+        public IEnumerator GetEnumerator();
+    }
+    public sealed class SqlException : DbException {
+        public byte Class { get; }
+        public Guid ClientConnectionId { get; }
+        public SqlErrorCollection Errors { get; }
+        public int LineNumber { get; }
+        public int Number { get; }
+        public string Procedure { get; }
+        public string Server { get; }
+        public override string Source { get; }
+        public byte State { get; }
+        public override string ToString();
+    }
+    public sealed class SqlInfoMessageEventArgs : EventArgs {
+        public SqlErrorCollection Errors { get; }
+        public string Message { get; }
+        public string Source { get; }
+        public override string ToString();
+    }
+    public delegate void SqlInfoMessageEventHandler(object sender, SqlInfoMessageEventArgs e);
+    public sealed class SqlParameter : DbParameter {
+        public SqlParameter();
+        public SqlParameter(string parameterName, SqlDbType dbType);
+        public SqlParameter(string parameterName, SqlDbType dbType, int size);
+        public SqlParameter(string parameterName, SqlDbType dbType, int size, string sourceColumn);
+        public SqlParameter(string parameterName, object value);
+        public SqlCompareOptions CompareInfo { get; set; }
+        public override DbType DbType { get; set; }
+        public override ParameterDirection Direction { get; set; }
+        public override bool IsNullable { get; set; }
+        public int LocaleId { get; set; }
+        public int Offset { get; set; }
+        public override string ParameterName { get; set; }
+        public new byte Precision { get; set; }
+        public new byte Scale { get; set; }
+        public override int Size { get; set; }
+        public override string SourceColumn { get; set; }
+        public override bool SourceColumnNullMapping { get; set; }
+        public SqlDbType SqlDbType { get; set; }
+        public object SqlValue { get; set; }
+        public string TypeName { get; set; }
+        public override object Value { get; set; }
+        public string XmlSchemaCollectionDatabase { get; set; }
+        public string XmlSchemaCollectionName { get; set; }
+        public string XmlSchemaCollectionOwningSchema { get; set; }
+        public override void ResetDbType();
+        public void ResetSqlDbType();
+        public override string ToString();
+    }
+    public sealed class SqlParameterCollection : DbParameterCollection {
+        public override int Count { get; }
+        public override object SyncRoot { get; }
+        public new SqlParameter this[int index] { get; set; }
+        public new SqlParameter this[string parameterName] { get; set; }
+        public SqlParameter Add(SqlParameter value);
+        public override int Add(object value);
+        public SqlParameter Add(string parameterName, SqlDbType sqlDbType);
+        public SqlParameter Add(string parameterName, SqlDbType sqlDbType, int size);
+        public override void AddRange(Array values);
+        public void AddRange(SqlParameter[] values);
+        public SqlParameter AddWithValue(string parameterName, object value);
+        public override void Clear();
+        public bool Contains(SqlParameter value);
+        public override bool Contains(object value);
+        public override bool Contains(string value);
+        public override void CopyTo(Array array, int index);
+        public void CopyTo(SqlParameter[] array, int index);
+        public override IEnumerator GetEnumerator();
+        protected override DbParameter GetParameter(int index);
+        protected override DbParameter GetParameter(string parameterName);
+        public int IndexOf(SqlParameter value);
+        public override int IndexOf(object value);
+        public override int IndexOf(string parameterName);
+        public void Insert(int index, SqlParameter value);
+        public override void Insert(int index, object value);
+        public void Remove(SqlParameter value);
+        public override void Remove(object value);
+        public override void RemoveAt(int index);
+        public override void RemoveAt(string parameterName);
+        protected override void SetParameter(int index, DbParameter value);
+        protected override void SetParameter(string parameterName, DbParameter value);
+    }
+    public class SqlRowsCopiedEventArgs : EventArgs {
+        public SqlRowsCopiedEventArgs(long rowsCopied);
+        public bool Abort { get; set; }
+        public long RowsCopied { get; }
+    }
+    public delegate void SqlRowsCopiedEventHandler(object sender, SqlRowsCopiedEventArgs e);
+    public sealed class SqlTransaction : DbTransaction {
+        public new SqlConnection Connection { get; }
+        protected override DbConnection DbConnection { get; }
+        public override IsolationLevel IsolationLevel { get; }
+        public override void Commit();
+        protected override void Dispose(bool disposing);
+        public override void Rollback();
+        public void Rollback(string transactionName);
+        public void Save(string savePointName);
+    }
+}
```

## System.Data.SqlTypes

```c#
+namespace System.Data.SqlTypes {
+    public interface INullable {
+        bool IsNull { get; }
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct SqlBinary : IComparable, INullable {
+        public static readonly SqlBinary Null;
+        public SqlBinary(byte[] value);
+        public bool IsNull { get; }
+        public int Length { get; }
+        public byte this[int index] { get; }
+        public byte[] Value { get; }
+        public static SqlBinary Add(SqlBinary x, SqlBinary y);
+        public int CompareTo(SqlBinary value);
+        public int CompareTo(object value);
+        public static SqlBinary Concat(SqlBinary x, SqlBinary y);
+        public static SqlBoolean Equals(SqlBinary x, SqlBinary y);
+        public override bool Equals(object value);
+        public override int GetHashCode();
+        public static SqlBoolean GreaterThan(SqlBinary x, SqlBinary y);
+        public static SqlBoolean GreaterThanOrEqual(SqlBinary x, SqlBinary y);
+        public static SqlBoolean LessThan(SqlBinary x, SqlBinary y);
+        public static SqlBoolean LessThanOrEqual(SqlBinary x, SqlBinary y);
+        public static SqlBoolean NotEquals(SqlBinary x, SqlBinary y);
+        public static SqlBinary operator +(SqlBinary x, SqlBinary y);
+        public static SqlBoolean operator ==(SqlBinary x, SqlBinary y);
+        public static explicit operator byte[] (SqlBinary x);
+        public static explicit operator SqlBinary (SqlGuid x);
+        public static SqlBoolean operator >(SqlBinary x, SqlBinary y);
+        public static SqlBoolean operator >=(SqlBinary x, SqlBinary y);
+        public static implicit operator SqlBinary (byte[] x);
+        public static SqlBoolean operator !=(SqlBinary x, SqlBinary y);
+        public static SqlBoolean operator <(SqlBinary x, SqlBinary y);
+        public static SqlBoolean operator <=(SqlBinary x, SqlBinary y);
+        public SqlGuid ToSqlGuid();
+        public override string ToString();
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct SqlBoolean : IComparable, INullable {
+        public static readonly SqlBoolean False;
+        public static readonly SqlBoolean Null;
+        public static readonly SqlBoolean One;
+        public static readonly SqlBoolean True;
+        public static readonly SqlBoolean Zero;
+        public SqlBoolean(bool value);
+        public SqlBoolean(int value);
+        public byte ByteValue { get; }
+        public bool IsFalse { get; }
+        public bool IsNull { get; }
+        public bool IsTrue { get; }
+        public bool Value { get; }
+        public static SqlBoolean And(SqlBoolean x, SqlBoolean y);
+        public int CompareTo(SqlBoolean value);
+        public int CompareTo(object value);
+        public static SqlBoolean Equals(SqlBoolean x, SqlBoolean y);
+        public override bool Equals(object value);
+        public override int GetHashCode();
+        public static SqlBoolean GreaterThan(SqlBoolean x, SqlBoolean y);
+        public static SqlBoolean GreaterThanOrEquals(SqlBoolean x, SqlBoolean y);
+        public static SqlBoolean LessThan(SqlBoolean x, SqlBoolean y);
+        public static SqlBoolean LessThanOrEquals(SqlBoolean x, SqlBoolean y);
+        public static SqlBoolean NotEquals(SqlBoolean x, SqlBoolean y);
+        public static SqlBoolean OnesComplement(SqlBoolean x);
+        public static SqlBoolean operator &(SqlBoolean x, SqlBoolean y);
+        public static SqlBoolean operator |(SqlBoolean x, SqlBoolean y);
+        public static SqlBoolean operator ==(SqlBoolean x, SqlBoolean y);
+        public static SqlBoolean operator ^(SqlBoolean x, SqlBoolean y);
+        public static explicit operator bool (SqlBoolean x);
+        public static explicit operator SqlBoolean (SqlByte x);
+        public static explicit operator SqlBoolean (SqlDecimal x);
+        public static explicit operator SqlBoolean (SqlDouble x);
+        public static explicit operator SqlBoolean (SqlInt16 x);
+        public static explicit operator SqlBoolean (SqlInt32 x);
+        public static explicit operator SqlBoolean (SqlInt64 x);
+        public static explicit operator SqlBoolean (SqlMoney x);
+        public static explicit operator SqlBoolean (SqlSingle x);
+        public static explicit operator SqlBoolean (SqlString x);
+        public static bool operator false(SqlBoolean x);
+        public static SqlBoolean operator >(SqlBoolean x, SqlBoolean y);
+        public static SqlBoolean operator >=(SqlBoolean x, SqlBoolean y);
+        public static implicit operator SqlBoolean (bool x);
+        public static SqlBoolean operator !=(SqlBoolean x, SqlBoolean y);
+        public static SqlBoolean operator <(SqlBoolean x, SqlBoolean y);
+        public static SqlBoolean operator <=(SqlBoolean x, SqlBoolean y);
+        public static SqlBoolean operator !(SqlBoolean x);
+        public static SqlBoolean operator ~(SqlBoolean x);
+        public static bool operator true(SqlBoolean x);
+        public static SqlBoolean Or(SqlBoolean x, SqlBoolean y);
+        public static SqlBoolean Parse(string s);
+        public SqlByte ToSqlByte();
+        public SqlDecimal ToSqlDecimal();
+        public SqlDouble ToSqlDouble();
+        public SqlInt16 ToSqlInt16();
+        public SqlInt32 ToSqlInt32();
+        public SqlInt64 ToSqlInt64();
+        public SqlMoney ToSqlMoney();
+        public SqlSingle ToSqlSingle();
+        public SqlString ToSqlString();
+        public override string ToString();
+        public static SqlBoolean Xor(SqlBoolean x, SqlBoolean y);
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct SqlByte : IComparable, INullable {
+        public static readonly SqlByte MaxValue;
+        public static readonly SqlByte MinValue;
+        public static readonly SqlByte Null;
+        public static readonly SqlByte Zero;
+        public SqlByte(byte value);
+        public bool IsNull { get; }
+        public byte Value { get; }
+        public static SqlByte Add(SqlByte x, SqlByte y);
+        public static SqlByte BitwiseAnd(SqlByte x, SqlByte y);
+        public static SqlByte BitwiseOr(SqlByte x, SqlByte y);
+        public int CompareTo(SqlByte value);
+        public int CompareTo(object value);
+        public static SqlByte Divide(SqlByte x, SqlByte y);
+        public static SqlBoolean Equals(SqlByte x, SqlByte y);
+        public override bool Equals(object value);
+        public override int GetHashCode();
+        public static SqlBoolean GreaterThan(SqlByte x, SqlByte y);
+        public static SqlBoolean GreaterThanOrEqual(SqlByte x, SqlByte y);
+        public static SqlBoolean LessThan(SqlByte x, SqlByte y);
+        public static SqlBoolean LessThanOrEqual(SqlByte x, SqlByte y);
+        public static SqlByte Mod(SqlByte x, SqlByte y);
+        public static SqlByte Modulus(SqlByte x, SqlByte y);
+        public static SqlByte Multiply(SqlByte x, SqlByte y);
+        public static SqlBoolean NotEquals(SqlByte x, SqlByte y);
+        public static SqlByte OnesComplement(SqlByte x);
+        public static SqlByte operator +(SqlByte x, SqlByte y);
+        public static SqlByte operator &(SqlByte x, SqlByte y);
+        public static SqlByte operator |(SqlByte x, SqlByte y);
+        public static SqlByte operator /(SqlByte x, SqlByte y);
+        public static SqlBoolean operator ==(SqlByte x, SqlByte y);
+        public static SqlByte operator ^(SqlByte x, SqlByte y);
+        public static explicit operator SqlByte (SqlBoolean x);
+        public static explicit operator byte (SqlByte x);
+        public static explicit operator SqlByte (SqlDecimal x);
+        public static explicit operator SqlByte (SqlDouble x);
+        public static explicit operator SqlByte (SqlInt16 x);
+        public static explicit operator SqlByte (SqlInt32 x);
+        public static explicit operator SqlByte (SqlInt64 x);
+        public static explicit operator SqlByte (SqlMoney x);
+        public static explicit operator SqlByte (SqlSingle x);
+        public static explicit operator SqlByte (SqlString x);
+        public static SqlBoolean operator >(SqlByte x, SqlByte y);
+        public static SqlBoolean operator >=(SqlByte x, SqlByte y);
+        public static implicit operator SqlByte (byte x);
+        public static SqlBoolean operator !=(SqlByte x, SqlByte y);
+        public static SqlBoolean operator <(SqlByte x, SqlByte y);
+        public static SqlBoolean operator <=(SqlByte x, SqlByte y);
+        public static SqlByte operator %(SqlByte x, SqlByte y);
+        public static SqlByte operator *(SqlByte x, SqlByte y);
+        public static SqlByte operator ~(SqlByte x);
+        public static SqlByte operator -(SqlByte x, SqlByte y);
+        public static SqlByte Parse(string s);
+        public static SqlByte Subtract(SqlByte x, SqlByte y);
+        public SqlBoolean ToSqlBoolean();
+        public SqlDecimal ToSqlDecimal();
+        public SqlDouble ToSqlDouble();
+        public SqlInt16 ToSqlInt16();
+        public SqlInt32 ToSqlInt32();
+        public SqlInt64 ToSqlInt64();
+        public SqlMoney ToSqlMoney();
+        public SqlSingle ToSqlSingle();
+        public SqlString ToSqlString();
+        public override string ToString();
+        public static SqlByte Xor(SqlByte x, SqlByte y);
+    }
+    public sealed class SqlBytes : INullable {
+        public SqlBytes();
+        public SqlBytes(byte[] buffer);
+        public SqlBytes(SqlBinary value);
+        public SqlBytes(Stream s);
+        public byte[] Buffer { get; }
+        public bool IsNull { get; }
+        public long Length { get; }
+        public long MaxLength { get; }
+        public static SqlBytes Null { get; }
+        public Stream Stream { get; set; }
+        public byte this[long offset] { get; set; }
+        public byte[] Value { get; }
+        public static explicit operator SqlBytes (SqlBinary value);
+        public static explicit operator SqlBinary (SqlBytes value);
+        public long Read(long offset, byte[] buffer, int offsetInBuffer, int count);
+        public void SetLength(long value);
+        public void SetNull();
+        public SqlBinary ToSqlBinary();
+        public void Write(long offset, byte[] buffer, int offsetInBuffer, int count);
+    }
+    public sealed class SqlChars : INullable {
+        public SqlChars();
+        public SqlChars(char[] buffer);
+        public SqlChars(SqlString value);
+        public char[] Buffer { get; }
+        public bool IsNull { get; }
+        public long Length { get; }
+        public long MaxLength { get; }
+        public static SqlChars Null { get; }
+        public char this[long offset] { get; set; }
+        public char[] Value { get; }
+        public static explicit operator SqlString (SqlChars value);
+        public static explicit operator SqlChars (SqlString value);
+        public long Read(long offset, char[] buffer, int offsetInBuffer, int count);
+        public void SetLength(long value);
+        public void SetNull();
+        public SqlString ToSqlString();
+        public void Write(long offset, char[] buffer, int offsetInBuffer, int count);
+    }
+    public enum SqlCompareOptions {
+        BinarySort = 32768,
+        BinarySort2 = 16384,
+        IgnoreCase = 1,
+        IgnoreKanaType = 8,
+        IgnoreNonSpace = 2,
+        IgnoreWidth = 16,
+        None = 0,
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct SqlDateTime : IComparable, INullable {
+        public static readonly SqlDateTime MaxValue;
+        public static readonly SqlDateTime MinValue;
+        public static readonly SqlDateTime Null;
+        public static readonly int SQLTicksPerHour;
+        public static readonly int SQLTicksPerMinute;
+        public static readonly int SQLTicksPerSecond;
+        public SqlDateTime(DateTime value);
+        public SqlDateTime(int dayTicks, int timeTicks);
+        public SqlDateTime(int year, int month, int day);
+        public SqlDateTime(int year, int month, int day, int hour, int minute, int second);
+        public SqlDateTime(int year, int month, int day, int hour, int minute, int second, double millisecond);
+        public SqlDateTime(int year, int month, int day, int hour, int minute, int second, int bilisecond);
+        public int DayTicks { get; }
+        public bool IsNull { get; }
+        public int TimeTicks { get; }
+        public DateTime Value { get; }
+        public static SqlDateTime Add(SqlDateTime x, TimeSpan t);
+        public int CompareTo(SqlDateTime value);
+        public int CompareTo(object value);
+        public static SqlBoolean Equals(SqlDateTime x, SqlDateTime y);
+        public override bool Equals(object value);
+        public override int GetHashCode();
+        public static SqlBoolean GreaterThan(SqlDateTime x, SqlDateTime y);
+        public static SqlBoolean GreaterThanOrEqual(SqlDateTime x, SqlDateTime y);
+        public static SqlBoolean LessThan(SqlDateTime x, SqlDateTime y);
+        public static SqlBoolean LessThanOrEqual(SqlDateTime x, SqlDateTime y);
+        public static SqlBoolean NotEquals(SqlDateTime x, SqlDateTime y);
+        public static SqlDateTime operator +(SqlDateTime x, TimeSpan t);
+        public static SqlBoolean operator ==(SqlDateTime x, SqlDateTime y);
+        public static explicit operator DateTime (SqlDateTime x);
+        public static explicit operator SqlDateTime (SqlString x);
+        public static SqlBoolean operator >(SqlDateTime x, SqlDateTime y);
+        public static SqlBoolean operator >=(SqlDateTime x, SqlDateTime y);
+        public static implicit operator SqlDateTime (DateTime value);
+        public static SqlBoolean operator !=(SqlDateTime x, SqlDateTime y);
+        public static SqlBoolean operator <(SqlDateTime x, SqlDateTime y);
+        public static SqlBoolean operator <=(SqlDateTime x, SqlDateTime y);
+        public static SqlDateTime operator -(SqlDateTime x, TimeSpan t);
+        public static SqlDateTime Parse(string s);
+        public static SqlDateTime Subtract(SqlDateTime x, TimeSpan t);
+        public SqlString ToSqlString();
+        public override string ToString();
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct SqlDecimal : IComparable, INullable {
+        public static readonly byte MaxPrecision;
+        public static readonly byte MaxScale;
+        public static readonly SqlDecimal MaxValue;
+        public static readonly SqlDecimal MinValue;
+        public static readonly SqlDecimal Null;
+        public SqlDecimal(byte bPrecision, byte bScale, bool fPositive, int data1, int data2, int data3, int data4);
+        public SqlDecimal(byte bPrecision, byte bScale, bool fPositive, int[] bits);
+        public SqlDecimal(Decimal value);
+        public SqlDecimal(double dVal);
+        public SqlDecimal(int value);
+        public SqlDecimal(long value);
+        public byte[] BinData { get; }
+        public int[] Data { get; }
+        public bool IsNull { get; }
+        public bool IsPositive { get; }
+        public byte Precision { get; }
+        public byte Scale { get; }
+        public Decimal Value { get; }
+        public static SqlDecimal Abs(SqlDecimal n);
+        public static SqlDecimal Add(SqlDecimal x, SqlDecimal y);
+        public static SqlDecimal AdjustScale(SqlDecimal n, int digits, bool fRound);
+        public static SqlDecimal Ceiling(SqlDecimal n);
+        public int CompareTo(SqlDecimal value);
+        public int CompareTo(object value);
+        public static SqlDecimal ConvertToPrecScale(SqlDecimal n, int precision, int scale);
+        public static SqlDecimal Divide(SqlDecimal x, SqlDecimal y);
+        public static SqlBoolean Equals(SqlDecimal x, SqlDecimal y);
+        public override bool Equals(object value);
+        public static SqlDecimal Floor(SqlDecimal n);
+        public override int GetHashCode();
+        public static SqlBoolean GreaterThan(SqlDecimal x, SqlDecimal y);
+        public static SqlBoolean GreaterThanOrEqual(SqlDecimal x, SqlDecimal y);
+        public static SqlBoolean LessThan(SqlDecimal x, SqlDecimal y);
+        public static SqlBoolean LessThanOrEqual(SqlDecimal x, SqlDecimal y);
+        public static SqlDecimal Multiply(SqlDecimal x, SqlDecimal y);
+        public static SqlBoolean NotEquals(SqlDecimal x, SqlDecimal y);
+        public static SqlDecimal operator +(SqlDecimal x, SqlDecimal y);
+        public static SqlDecimal operator /(SqlDecimal x, SqlDecimal y);
+        public static SqlBoolean operator ==(SqlDecimal x, SqlDecimal y);
+        public static explicit operator SqlDecimal (SqlBoolean x);
+        public static explicit operator Decimal (SqlDecimal x);
+        public static explicit operator SqlDecimal (SqlDouble x);
+        public static explicit operator SqlDecimal (SqlSingle x);
+        public static explicit operator SqlDecimal (SqlString x);
+        public static explicit operator SqlDecimal (double x);
+        public static SqlBoolean operator >(SqlDecimal x, SqlDecimal y);
+        public static SqlBoolean operator >=(SqlDecimal x, SqlDecimal y);
+        public static implicit operator SqlDecimal (SqlByte x);
+        public static implicit operator SqlDecimal (SqlInt16 x);
+        public static implicit operator SqlDecimal (SqlInt32 x);
+        public static implicit operator SqlDecimal (SqlInt64 x);
+        public static implicit operator SqlDecimal (SqlMoney x);
+        public static implicit operator SqlDecimal (Decimal x);
+        public static implicit operator SqlDecimal (long x);
+        public static SqlBoolean operator !=(SqlDecimal x, SqlDecimal y);
+        public static SqlBoolean operator <(SqlDecimal x, SqlDecimal y);
+        public static SqlBoolean operator <=(SqlDecimal x, SqlDecimal y);
+        public static SqlDecimal operator *(SqlDecimal x, SqlDecimal y);
+        public static SqlDecimal operator -(SqlDecimal x, SqlDecimal y);
+        public static SqlDecimal operator -(SqlDecimal x);
+        public static SqlDecimal Parse(string s);
+        public static SqlDecimal Power(SqlDecimal n, double exp);
+        public static SqlDecimal Round(SqlDecimal n, int position);
+        public static SqlInt32 Sign(SqlDecimal n);
+        public static SqlDecimal Subtract(SqlDecimal x, SqlDecimal y);
+        public double ToDouble();
+        public SqlBoolean ToSqlBoolean();
+        public SqlByte ToSqlByte();
+        public SqlDouble ToSqlDouble();
+        public SqlInt16 ToSqlInt16();
+        public SqlInt32 ToSqlInt32();
+        public SqlInt64 ToSqlInt64();
+        public SqlMoney ToSqlMoney();
+        public SqlSingle ToSqlSingle();
+        public SqlString ToSqlString();
+        public override string ToString();
+        public static SqlDecimal Truncate(SqlDecimal n, int position);
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct SqlDouble : IComparable, INullable {
+        public static readonly SqlDouble MaxValue;
+        public static readonly SqlDouble MinValue;
+        public static readonly SqlDouble Null;
+        public static readonly SqlDouble Zero;
+        public SqlDouble(double value);
+        public bool IsNull { get; }
+        public double Value { get; }
+        public static SqlDouble Add(SqlDouble x, SqlDouble y);
+        public int CompareTo(SqlDouble value);
+        public int CompareTo(object value);
+        public static SqlDouble Divide(SqlDouble x, SqlDouble y);
+        public static SqlBoolean Equals(SqlDouble x, SqlDouble y);
+        public override bool Equals(object value);
+        public override int GetHashCode();
+        public static SqlBoolean GreaterThan(SqlDouble x, SqlDouble y);
+        public static SqlBoolean GreaterThanOrEqual(SqlDouble x, SqlDouble y);
+        public static SqlBoolean LessThan(SqlDouble x, SqlDouble y);
+        public static SqlBoolean LessThanOrEqual(SqlDouble x, SqlDouble y);
+        public static SqlDouble Multiply(SqlDouble x, SqlDouble y);
+        public static SqlBoolean NotEquals(SqlDouble x, SqlDouble y);
+        public static SqlDouble operator +(SqlDouble x, SqlDouble y);
+        public static SqlDouble operator /(SqlDouble x, SqlDouble y);
+        public static SqlBoolean operator ==(SqlDouble x, SqlDouble y);
+        public static explicit operator SqlDouble (SqlBoolean x);
+        public static explicit operator double (SqlDouble x);
+        public static explicit operator SqlDouble (SqlString x);
+        public static SqlBoolean operator >(SqlDouble x, SqlDouble y);
+        public static SqlBoolean operator >=(SqlDouble x, SqlDouble y);
+        public static implicit operator SqlDouble (SqlByte x);
+        public static implicit operator SqlDouble (SqlDecimal x);
+        public static implicit operator SqlDouble (SqlInt16 x);
+        public static implicit operator SqlDouble (SqlInt32 x);
+        public static implicit operator SqlDouble (SqlInt64 x);
+        public static implicit operator SqlDouble (SqlMoney x);
+        public static implicit operator SqlDouble (SqlSingle x);
+        public static implicit operator SqlDouble (double x);
+        public static SqlBoolean operator !=(SqlDouble x, SqlDouble y);
+        public static SqlBoolean operator <(SqlDouble x, SqlDouble y);
+        public static SqlBoolean operator <=(SqlDouble x, SqlDouble y);
+        public static SqlDouble operator *(SqlDouble x, SqlDouble y);
+        public static SqlDouble operator -(SqlDouble x, SqlDouble y);
+        public static SqlDouble operator -(SqlDouble x);
+        public static SqlDouble Parse(string s);
+        public static SqlDouble Subtract(SqlDouble x, SqlDouble y);
+        public SqlBoolean ToSqlBoolean();
+        public SqlByte ToSqlByte();
+        public SqlDecimal ToSqlDecimal();
+        public SqlInt16 ToSqlInt16();
+        public SqlInt32 ToSqlInt32();
+        public SqlInt64 ToSqlInt64();
+        public SqlMoney ToSqlMoney();
+        public SqlSingle ToSqlSingle();
+        public SqlString ToSqlString();
+        public override string ToString();
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct SqlGuid : IComparable, INullable {
+        public static readonly SqlGuid Null;
+        public SqlGuid(byte[] value);
+        public SqlGuid(Guid g);
+        public SqlGuid(int a, short b, short c, byte d, byte e, byte f, byte g, byte h, byte i, byte j, byte k);
+        public SqlGuid(string s);
+        public bool IsNull { get; }
+        public Guid Value { get; }
+        public int CompareTo(SqlGuid value);
+        public int CompareTo(object value);
+        public static SqlBoolean Equals(SqlGuid x, SqlGuid y);
+        public override bool Equals(object value);
+        public override int GetHashCode();
+        public static SqlBoolean GreaterThan(SqlGuid x, SqlGuid y);
+        public static SqlBoolean GreaterThanOrEqual(SqlGuid x, SqlGuid y);
+        public static SqlBoolean LessThan(SqlGuid x, SqlGuid y);
+        public static SqlBoolean LessThanOrEqual(SqlGuid x, SqlGuid y);
+        public static SqlBoolean NotEquals(SqlGuid x, SqlGuid y);
+        public static SqlBoolean operator ==(SqlGuid x, SqlGuid y);
+        public static explicit operator SqlGuid (SqlBinary x);
+        public static explicit operator Guid (SqlGuid x);
+        public static explicit operator SqlGuid (SqlString x);
+        public static SqlBoolean operator >(SqlGuid x, SqlGuid y);
+        public static SqlBoolean operator >=(SqlGuid x, SqlGuid y);
+        public static implicit operator SqlGuid (Guid x);
+        public static SqlBoolean operator !=(SqlGuid x, SqlGuid y);
+        public static SqlBoolean operator <(SqlGuid x, SqlGuid y);
+        public static SqlBoolean operator <=(SqlGuid x, SqlGuid y);
+        public static SqlGuid Parse(string s);
+        public byte[] ToByteArray();
+        public SqlBinary ToSqlBinary();
+        public SqlString ToSqlString();
+        public override string ToString();
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct SqlInt16 : IComparable, INullable {
+        public static readonly SqlInt16 MaxValue;
+        public static readonly SqlInt16 MinValue;
+        public static readonly SqlInt16 Null;
+        public static readonly SqlInt16 Zero;
+        public SqlInt16(short value);
+        public bool IsNull { get; }
+        public short Value { get; }
+        public static SqlInt16 Add(SqlInt16 x, SqlInt16 y);
+        public static SqlInt16 BitwiseAnd(SqlInt16 x, SqlInt16 y);
+        public static SqlInt16 BitwiseOr(SqlInt16 x, SqlInt16 y);
+        public int CompareTo(SqlInt16 value);
+        public int CompareTo(object value);
+        public static SqlInt16 Divide(SqlInt16 x, SqlInt16 y);
+        public static SqlBoolean Equals(SqlInt16 x, SqlInt16 y);
+        public override bool Equals(object value);
+        public override int GetHashCode();
+        public static SqlBoolean GreaterThan(SqlInt16 x, SqlInt16 y);
+        public static SqlBoolean GreaterThanOrEqual(SqlInt16 x, SqlInt16 y);
+        public static SqlBoolean LessThan(SqlInt16 x, SqlInt16 y);
+        public static SqlBoolean LessThanOrEqual(SqlInt16 x, SqlInt16 y);
+        public static SqlInt16 Mod(SqlInt16 x, SqlInt16 y);
+        public static SqlInt16 Modulus(SqlInt16 x, SqlInt16 y);
+        public static SqlInt16 Multiply(SqlInt16 x, SqlInt16 y);
+        public static SqlBoolean NotEquals(SqlInt16 x, SqlInt16 y);
+        public static SqlInt16 OnesComplement(SqlInt16 x);
+        public static SqlInt16 operator +(SqlInt16 x, SqlInt16 y);
+        public static SqlInt16 operator &(SqlInt16 x, SqlInt16 y);
+        public static SqlInt16 operator |(SqlInt16 x, SqlInt16 y);
+        public static SqlInt16 operator /(SqlInt16 x, SqlInt16 y);
+        public static SqlBoolean operator ==(SqlInt16 x, SqlInt16 y);
+        public static SqlInt16 operator ^(SqlInt16 x, SqlInt16 y);
+        public static explicit operator SqlInt16 (SqlBoolean x);
+        public static explicit operator SqlInt16 (SqlDecimal x);
+        public static explicit operator SqlInt16 (SqlDouble x);
+        public static explicit operator short (SqlInt16 x);
+        public static explicit operator SqlInt16 (SqlInt32 x);
+        public static explicit operator SqlInt16 (SqlInt64 x);
+        public static explicit operator SqlInt16 (SqlMoney x);
+        public static explicit operator SqlInt16 (SqlSingle x);
+        public static explicit operator SqlInt16 (SqlString x);
+        public static SqlBoolean operator >(SqlInt16 x, SqlInt16 y);
+        public static SqlBoolean operator >=(SqlInt16 x, SqlInt16 y);
+        public static implicit operator SqlInt16 (SqlByte x);
+        public static implicit operator SqlInt16 (short x);
+        public static SqlBoolean operator !=(SqlInt16 x, SqlInt16 y);
+        public static SqlBoolean operator <(SqlInt16 x, SqlInt16 y);
+        public static SqlBoolean operator <=(SqlInt16 x, SqlInt16 y);
+        public static SqlInt16 operator %(SqlInt16 x, SqlInt16 y);
+        public static SqlInt16 operator *(SqlInt16 x, SqlInt16 y);
+        public static SqlInt16 operator ~(SqlInt16 x);
+        public static SqlInt16 operator -(SqlInt16 x, SqlInt16 y);
+        public static SqlInt16 operator -(SqlInt16 x);
+        public static SqlInt16 Parse(string s);
+        public static SqlInt16 Subtract(SqlInt16 x, SqlInt16 y);
+        public SqlBoolean ToSqlBoolean();
+        public SqlByte ToSqlByte();
+        public SqlDecimal ToSqlDecimal();
+        public SqlDouble ToSqlDouble();
+        public SqlInt32 ToSqlInt32();
+        public SqlInt64 ToSqlInt64();
+        public SqlMoney ToSqlMoney();
+        public SqlSingle ToSqlSingle();
+        public SqlString ToSqlString();
+        public override string ToString();
+        public static SqlInt16 Xor(SqlInt16 x, SqlInt16 y);
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct SqlInt32 : IComparable, INullable {
+        public static readonly SqlInt32 MaxValue;
+        public static readonly SqlInt32 MinValue;
+        public static readonly SqlInt32 Null;
+        public static readonly SqlInt32 Zero;
+        public SqlInt32(int value);
+        public bool IsNull { get; }
+        public int Value { get; }
+        public static SqlInt32 Add(SqlInt32 x, SqlInt32 y);
+        public static SqlInt32 BitwiseAnd(SqlInt32 x, SqlInt32 y);
+        public static SqlInt32 BitwiseOr(SqlInt32 x, SqlInt32 y);
+        public int CompareTo(SqlInt32 value);
+        public int CompareTo(object value);
+        public static SqlInt32 Divide(SqlInt32 x, SqlInt32 y);
+        public static SqlBoolean Equals(SqlInt32 x, SqlInt32 y);
+        public override bool Equals(object value);
+        public override int GetHashCode();
+        public static SqlBoolean GreaterThan(SqlInt32 x, SqlInt32 y);
+        public static SqlBoolean GreaterThanOrEqual(SqlInt32 x, SqlInt32 y);
+        public static SqlBoolean LessThan(SqlInt32 x, SqlInt32 y);
+        public static SqlBoolean LessThanOrEqual(SqlInt32 x, SqlInt32 y);
+        public static SqlInt32 Mod(SqlInt32 x, SqlInt32 y);
+        public static SqlInt32 Modulus(SqlInt32 x, SqlInt32 y);
+        public static SqlInt32 Multiply(SqlInt32 x, SqlInt32 y);
+        public static SqlBoolean NotEquals(SqlInt32 x, SqlInt32 y);
+        public static SqlInt32 OnesComplement(SqlInt32 x);
+        public static SqlInt32 operator +(SqlInt32 x, SqlInt32 y);
+        public static SqlInt32 operator &(SqlInt32 x, SqlInt32 y);
+        public static SqlInt32 operator |(SqlInt32 x, SqlInt32 y);
+        public static SqlInt32 operator /(SqlInt32 x, SqlInt32 y);
+        public static SqlBoolean operator ==(SqlInt32 x, SqlInt32 y);
+        public static SqlInt32 operator ^(SqlInt32 x, SqlInt32 y);
+        public static explicit operator SqlInt32 (SqlBoolean x);
+        public static explicit operator SqlInt32 (SqlDecimal x);
+        public static explicit operator SqlInt32 (SqlDouble x);
+        public static explicit operator int (SqlInt32 x);
+        public static explicit operator SqlInt32 (SqlInt64 x);
+        public static explicit operator SqlInt32 (SqlMoney x);
+        public static explicit operator SqlInt32 (SqlSingle x);
+        public static explicit operator SqlInt32 (SqlString x);
+        public static SqlBoolean operator >(SqlInt32 x, SqlInt32 y);
+        public static SqlBoolean operator >=(SqlInt32 x, SqlInt32 y);
+        public static implicit operator SqlInt32 (SqlByte x);
+        public static implicit operator SqlInt32 (SqlInt16 x);
+        public static implicit operator SqlInt32 (int x);
+        public static SqlBoolean operator !=(SqlInt32 x, SqlInt32 y);
+        public static SqlBoolean operator <(SqlInt32 x, SqlInt32 y);
+        public static SqlBoolean operator <=(SqlInt32 x, SqlInt32 y);
+        public static SqlInt32 operator %(SqlInt32 x, SqlInt32 y);
+        public static SqlInt32 operator *(SqlInt32 x, SqlInt32 y);
+        public static SqlInt32 operator ~(SqlInt32 x);
+        public static SqlInt32 operator -(SqlInt32 x, SqlInt32 y);
+        public static SqlInt32 operator -(SqlInt32 x);
+        public static SqlInt32 Parse(string s);
+        public static SqlInt32 Subtract(SqlInt32 x, SqlInt32 y);
+        public SqlBoolean ToSqlBoolean();
+        public SqlByte ToSqlByte();
+        public SqlDecimal ToSqlDecimal();
+        public SqlDouble ToSqlDouble();
+        public SqlInt16 ToSqlInt16();
+        public SqlInt64 ToSqlInt64();
+        public SqlMoney ToSqlMoney();
+        public SqlSingle ToSqlSingle();
+        public SqlString ToSqlString();
+        public override string ToString();
+        public static SqlInt32 Xor(SqlInt32 x, SqlInt32 y);
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct SqlInt64 : IComparable, INullable {
+        public static readonly SqlInt64 MaxValue;
+        public static readonly SqlInt64 MinValue;
+        public static readonly SqlInt64 Null;
+        public static readonly SqlInt64 Zero;
+        public SqlInt64(long value);
+        public bool IsNull { get; }
+        public long Value { get; }
+        public static SqlInt64 Add(SqlInt64 x, SqlInt64 y);
+        public static SqlInt64 BitwiseAnd(SqlInt64 x, SqlInt64 y);
+        public static SqlInt64 BitwiseOr(SqlInt64 x, SqlInt64 y);
+        public int CompareTo(SqlInt64 value);
+        public int CompareTo(object value);
+        public static SqlInt64 Divide(SqlInt64 x, SqlInt64 y);
+        public static SqlBoolean Equals(SqlInt64 x, SqlInt64 y);
+        public override bool Equals(object value);
+        public override int GetHashCode();
+        public static SqlBoolean GreaterThan(SqlInt64 x, SqlInt64 y);
+        public static SqlBoolean GreaterThanOrEqual(SqlInt64 x, SqlInt64 y);
+        public static SqlBoolean LessThan(SqlInt64 x, SqlInt64 y);
+        public static SqlBoolean LessThanOrEqual(SqlInt64 x, SqlInt64 y);
+        public static SqlInt64 Mod(SqlInt64 x, SqlInt64 y);
+        public static SqlInt64 Modulus(SqlInt64 x, SqlInt64 y);
+        public static SqlInt64 Multiply(SqlInt64 x, SqlInt64 y);
+        public static SqlBoolean NotEquals(SqlInt64 x, SqlInt64 y);
+        public static SqlInt64 OnesComplement(SqlInt64 x);
+        public static SqlInt64 operator +(SqlInt64 x, SqlInt64 y);
+        public static SqlInt64 operator &(SqlInt64 x, SqlInt64 y);
+        public static SqlInt64 operator |(SqlInt64 x, SqlInt64 y);
+        public static SqlInt64 operator /(SqlInt64 x, SqlInt64 y);
+        public static SqlBoolean operator ==(SqlInt64 x, SqlInt64 y);
+        public static SqlInt64 operator ^(SqlInt64 x, SqlInt64 y);
+        public static explicit operator SqlInt64 (SqlBoolean x);
+        public static explicit operator SqlInt64 (SqlDecimal x);
+        public static explicit operator SqlInt64 (SqlDouble x);
+        public static explicit operator long (SqlInt64 x);
+        public static explicit operator SqlInt64 (SqlMoney x);
+        public static explicit operator SqlInt64 (SqlSingle x);
+        public static explicit operator SqlInt64 (SqlString x);
+        public static SqlBoolean operator >(SqlInt64 x, SqlInt64 y);
+        public static SqlBoolean operator >=(SqlInt64 x, SqlInt64 y);
+        public static implicit operator SqlInt64 (SqlByte x);
+        public static implicit operator SqlInt64 (SqlInt16 x);
+        public static implicit operator SqlInt64 (SqlInt32 x);
+        public static implicit operator SqlInt64 (long x);
+        public static SqlBoolean operator !=(SqlInt64 x, SqlInt64 y);
+        public static SqlBoolean operator <(SqlInt64 x, SqlInt64 y);
+        public static SqlBoolean operator <=(SqlInt64 x, SqlInt64 y);
+        public static SqlInt64 operator %(SqlInt64 x, SqlInt64 y);
+        public static SqlInt64 operator *(SqlInt64 x, SqlInt64 y);
+        public static SqlInt64 operator ~(SqlInt64 x);
+        public static SqlInt64 operator -(SqlInt64 x, SqlInt64 y);
+        public static SqlInt64 operator -(SqlInt64 x);
+        public static SqlInt64 Parse(string s);
+        public static SqlInt64 Subtract(SqlInt64 x, SqlInt64 y);
+        public SqlBoolean ToSqlBoolean();
+        public SqlByte ToSqlByte();
+        public SqlDecimal ToSqlDecimal();
+        public SqlDouble ToSqlDouble();
+        public SqlInt16 ToSqlInt16();
+        public SqlInt32 ToSqlInt32();
+        public SqlMoney ToSqlMoney();
+        public SqlSingle ToSqlSingle();
+        public SqlString ToSqlString();
+        public override string ToString();
+        public static SqlInt64 Xor(SqlInt64 x, SqlInt64 y);
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct SqlMoney : IComparable, INullable {
+        public static readonly SqlMoney MaxValue;
+        public static readonly SqlMoney MinValue;
+        public static readonly SqlMoney Null;
+        public static readonly SqlMoney Zero;
+        public SqlMoney(Decimal value);
+        public SqlMoney(double value);
+        public SqlMoney(int value);
+        public SqlMoney(long value);
+        public bool IsNull { get; }
+        public Decimal Value { get; }
+        public static SqlMoney Add(SqlMoney x, SqlMoney y);
+        public int CompareTo(SqlMoney value);
+        public int CompareTo(object value);
+        public static SqlMoney Divide(SqlMoney x, SqlMoney y);
+        public static SqlBoolean Equals(SqlMoney x, SqlMoney y);
+        public override bool Equals(object value);
+        public override int GetHashCode();
+        public static SqlBoolean GreaterThan(SqlMoney x, SqlMoney y);
+        public static SqlBoolean GreaterThanOrEqual(SqlMoney x, SqlMoney y);
+        public static SqlBoolean LessThan(SqlMoney x, SqlMoney y);
+        public static SqlBoolean LessThanOrEqual(SqlMoney x, SqlMoney y);
+        public static SqlMoney Multiply(SqlMoney x, SqlMoney y);
+        public static SqlBoolean NotEquals(SqlMoney x, SqlMoney y);
+        public static SqlMoney operator +(SqlMoney x, SqlMoney y);
+        public static SqlMoney operator /(SqlMoney x, SqlMoney y);
+        public static SqlBoolean operator ==(SqlMoney x, SqlMoney y);
+        public static explicit operator SqlMoney (SqlBoolean x);
+        public static explicit operator SqlMoney (SqlDecimal x);
+        public static explicit operator SqlMoney (SqlDouble x);
+        public static explicit operator Decimal (SqlMoney x);
+        public static explicit operator SqlMoney (SqlSingle x);
+        public static explicit operator SqlMoney (SqlString x);
+        public static explicit operator SqlMoney (double x);
+        public static SqlBoolean operator >(SqlMoney x, SqlMoney y);
+        public static SqlBoolean operator >=(SqlMoney x, SqlMoney y);
+        public static implicit operator SqlMoney (SqlByte x);
+        public static implicit operator SqlMoney (SqlInt16 x);
+        public static implicit operator SqlMoney (SqlInt32 x);
+        public static implicit operator SqlMoney (SqlInt64 x);
+        public static implicit operator SqlMoney (Decimal x);
+        public static implicit operator SqlMoney (long x);
+        public static SqlBoolean operator !=(SqlMoney x, SqlMoney y);
+        public static SqlBoolean operator <(SqlMoney x, SqlMoney y);
+        public static SqlBoolean operator <=(SqlMoney x, SqlMoney y);
+        public static SqlMoney operator *(SqlMoney x, SqlMoney y);
+        public static SqlMoney operator -(SqlMoney x, SqlMoney y);
+        public static SqlMoney operator -(SqlMoney x);
+        public static SqlMoney Parse(string s);
+        public static SqlMoney Subtract(SqlMoney x, SqlMoney y);
+        public Decimal ToDecimal();
+        public double ToDouble();
+        public int ToInt32();
+        public long ToInt64();
+        public SqlBoolean ToSqlBoolean();
+        public SqlByte ToSqlByte();
+        public SqlDecimal ToSqlDecimal();
+        public SqlDouble ToSqlDouble();
+        public SqlInt16 ToSqlInt16();
+        public SqlInt32 ToSqlInt32();
+        public SqlInt64 ToSqlInt64();
+        public SqlSingle ToSqlSingle();
+        public SqlString ToSqlString();
+        public override string ToString();
+    }
+    public sealed class SqlNullValueException : SqlTypeException {
+        public SqlNullValueException();
+        public SqlNullValueException(string message);
+        public SqlNullValueException(string message, Exception e);
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct SqlSingle : IComparable, INullable {
+        public static readonly SqlSingle MaxValue;
+        public static readonly SqlSingle MinValue;
+        public static readonly SqlSingle Null;
+        public static readonly SqlSingle Zero;
+        public SqlSingle(double value);
+        public SqlSingle(float value);
+        public bool IsNull { get; }
+        public float Value { get; }
+        public static SqlSingle Add(SqlSingle x, SqlSingle y);
+        public int CompareTo(SqlSingle value);
+        public int CompareTo(object value);
+        public static SqlSingle Divide(SqlSingle x, SqlSingle y);
+        public static SqlBoolean Equals(SqlSingle x, SqlSingle y);
+        public override bool Equals(object value);
+        public override int GetHashCode();
+        public static SqlBoolean GreaterThan(SqlSingle x, SqlSingle y);
+        public static SqlBoolean GreaterThanOrEqual(SqlSingle x, SqlSingle y);
+        public static SqlBoolean LessThan(SqlSingle x, SqlSingle y);
+        public static SqlBoolean LessThanOrEqual(SqlSingle x, SqlSingle y);
+        public static SqlSingle Multiply(SqlSingle x, SqlSingle y);
+        public static SqlBoolean NotEquals(SqlSingle x, SqlSingle y);
+        public static SqlSingle operator +(SqlSingle x, SqlSingle y);
+        public static SqlSingle operator /(SqlSingle x, SqlSingle y);
+        public static SqlBoolean operator ==(SqlSingle x, SqlSingle y);
+        public static explicit operator SqlSingle (SqlBoolean x);
+        public static explicit operator SqlSingle (SqlDouble x);
+        public static explicit operator float (SqlSingle x);
+        public static explicit operator SqlSingle (SqlString x);
+        public static SqlBoolean operator >(SqlSingle x, SqlSingle y);
+        public static SqlBoolean operator >=(SqlSingle x, SqlSingle y);
+        public static implicit operator SqlSingle (SqlByte x);
+        public static implicit operator SqlSingle (SqlDecimal x);
+        public static implicit operator SqlSingle (SqlInt16 x);
+        public static implicit operator SqlSingle (SqlInt32 x);
+        public static implicit operator SqlSingle (SqlInt64 x);
+        public static implicit operator SqlSingle (SqlMoney x);
+        public static implicit operator SqlSingle (float x);
+        public static SqlBoolean operator !=(SqlSingle x, SqlSingle y);
+        public static SqlBoolean operator <(SqlSingle x, SqlSingle y);
+        public static SqlBoolean operator <=(SqlSingle x, SqlSingle y);
+        public static SqlSingle operator *(SqlSingle x, SqlSingle y);
+        public static SqlSingle operator -(SqlSingle x, SqlSingle y);
+        public static SqlSingle operator -(SqlSingle x);
+        public static SqlSingle Parse(string s);
+        public static SqlSingle Subtract(SqlSingle x, SqlSingle y);
+        public SqlBoolean ToSqlBoolean();
+        public SqlByte ToSqlByte();
+        public SqlDecimal ToSqlDecimal();
+        public SqlDouble ToSqlDouble();
+        public SqlInt16 ToSqlInt16();
+        public SqlInt32 ToSqlInt32();
+        public SqlInt64 ToSqlInt64();
+        public SqlMoney ToSqlMoney();
+        public SqlString ToSqlString();
+        public override string ToString();
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct SqlString : IComparable, INullable {
+        public static readonly SqlString Null;
+        public static readonly int BinarySort;
+        public static readonly int BinarySort2;
+        public static readonly int IgnoreCase;
+        public static readonly int IgnoreKanaType;
+        public static readonly int IgnoreNonSpace;
+        public static readonly int IgnoreWidth;
+        public SqlString(int lcid, SqlCompareOptions compareOptions, byte[] data);
+        public SqlString(int lcid, SqlCompareOptions compareOptions, byte[] data, bool fUnicode);
+        public SqlString(int lcid, SqlCompareOptions compareOptions, byte[] data, int index, int count);
+        public SqlString(int lcid, SqlCompareOptions compareOptions, byte[] data, int index, int count, bool fUnicode);
+        public SqlString(string data);
+        public SqlString(string data, int lcid);
+        public SqlString(string data, int lcid, SqlCompareOptions compareOptions);
+        public CompareInfo CompareInfo { get; }
+        public CultureInfo CultureInfo { get; }
+        public bool IsNull { get; }
+        public int LCID { get; }
+        public SqlCompareOptions SqlCompareOptions { get; }
+        public string Value { get; }
+        public static SqlString Add(SqlString x, SqlString y);
+        public SqlString Clone();
+        public static CompareOptions CompareOptionsFromSqlCompareOptions(SqlCompareOptions compareOptions);
+        public int CompareTo(SqlString value);
+        public int CompareTo(object value);
+        public static SqlString Concat(SqlString x, SqlString y);
+        public static SqlBoolean Equals(SqlString x, SqlString y);
+        public override bool Equals(object value);
+        public override int GetHashCode();
+        public byte[] GetNonUnicodeBytes();
+        public byte[] GetUnicodeBytes();
+        public static SqlBoolean GreaterThan(SqlString x, SqlString y);
+        public static SqlBoolean GreaterThanOrEqual(SqlString x, SqlString y);
+        public static SqlBoolean LessThan(SqlString x, SqlString y);
+        public static SqlBoolean LessThanOrEqual(SqlString x, SqlString y);
+        public static SqlBoolean NotEquals(SqlString x, SqlString y);
+        public static SqlString operator +(SqlString x, SqlString y);
+        public static SqlBoolean operator ==(SqlString x, SqlString y);
+        public static explicit operator SqlString (SqlBoolean x);
+        public static explicit operator SqlString (SqlByte x);
+        public static explicit operator SqlString (SqlDateTime x);
+        public static explicit operator SqlString (SqlDecimal x);
+        public static explicit operator SqlString (SqlDouble x);
+        public static explicit operator SqlString (SqlGuid x);
+        public static explicit operator SqlString (SqlInt16 x);
+        public static explicit operator SqlString (SqlInt32 x);
+        public static explicit operator SqlString (SqlInt64 x);
+        public static explicit operator SqlString (SqlMoney x);
+        public static explicit operator SqlString (SqlSingle x);
+        public static explicit operator string (SqlString x);
+        public static SqlBoolean operator >(SqlString x, SqlString y);
+        public static SqlBoolean operator >=(SqlString x, SqlString y);
+        public static implicit operator SqlString (string x);
+        public static SqlBoolean operator !=(SqlString x, SqlString y);
+        public static SqlBoolean operator <(SqlString x, SqlString y);
+        public static SqlBoolean operator <=(SqlString x, SqlString y);
+        public SqlBoolean ToSqlBoolean();
+        public SqlByte ToSqlByte();
+        public SqlDateTime ToSqlDateTime();
+        public SqlDecimal ToSqlDecimal();
+        public SqlDouble ToSqlDouble();
+        public SqlGuid ToSqlGuid();
+        public SqlInt16 ToSqlInt16();
+        public SqlInt32 ToSqlInt32();
+        public SqlInt64 ToSqlInt64();
+        public SqlMoney ToSqlMoney();
+        public SqlSingle ToSqlSingle();
+        public override string ToString();
+    }
+    public sealed class SqlTruncateException : SqlTypeException {
+        public SqlTruncateException();
+        public SqlTruncateException(string message);
+        public SqlTruncateException(string message, Exception e);
+    }
+    public class SqlTypeException : Exception {
+        public SqlTypeException();
+        public SqlTypeException(string message);
+        public SqlTypeException(string message, Exception e);
+    }
+    public sealed class SqlXml : INullable {
+        public SqlXml();
+        public SqlXml(Stream value);
+        public SqlXml(XmlReader value);
+        public bool IsNull { get; }
+        public static SqlXml Null { get; }
+        public string Value { get; }
+        public XmlReader CreateReader();
+    }
+}
```

## System.Diagnostics

```c#
+namespace System.Diagnostics {
+    public class BooleanSwitch : Switch {
+        public BooleanSwitch(string displayName, string description);
+        public BooleanSwitch(string displayName, string description, string defaultSwitchValue);
+        public bool Enabled { get; set; }
+        protected override void OnValueChanged();
+    }
+    public sealed class ConditionalAttribute : Attribute {
+        public ConditionalAttribute(string conditionString);
+        public string ConditionString { get; }
+    }
+    public class DataReceivedEventArgs : EventArgs {
+        public string Data { get; }
+    }
+    public delegate void DataReceivedEventHandler(object sender, DataReceivedEventArgs e);
+    public static class Debug {
+        public static void Assert(bool condition);
+        public static void Assert(bool condition, string message);
+        public static void Assert(bool condition, string message, string detailMessage);
+        public static void Assert(bool condition, string message, string detailMessageFormat, params object[] args);
+        public static void Fail(string message);
+        public static void Fail(string message, string detailMessage);
+        public static void Write(object value);
+        public static void Write(object value, string category);
+        public static void Write(string message);
+        public static void Write(string message, string category);
+        public static void WriteIf(bool condition, object value);
+        public static void WriteIf(bool condition, object value, string category);
+        public static void WriteIf(bool condition, string message);
+        public static void WriteIf(bool condition, string message, string category);
+        public static void WriteLine(object value);
+        public static void WriteLine(object value, string category);
+        public static void WriteLine(string message);
+        public static void WriteLine(string format, params object[] args);
+        public static void WriteLine(string message, string category);
+        public static void WriteLineIf(bool condition, object value);
+        public static void WriteLineIf(bool condition, object value, string category);
+        public static void WriteLineIf(bool condition, string message);
+        public static void WriteLineIf(bool condition, string message, string category);
+    }
+    public sealed class DebuggableAttribute : Attribute {
+        public DebuggableAttribute(DebuggableAttribute.DebuggingModes modes);
+        public DebuggableAttribute(bool isJITTrackingEnabled, bool isJITOptimizerDisabled);
+        public enum DebuggingModes {
+            Default = 1,
+            DisableOptimizations = 256,
+            EnableEditAndContinue = 4,
+            IgnoreSymbolStoreSequencePoints = 2,
+            None = 0,
+        }
+    }
+    public sealed class Debugger {
+        public Debugger();
+        public static bool IsAttached { [MethodImpl(InternalCall)]get; }
+        public static void Break();
+        [MethodImpl(InternalCall)]public static bool IsLogging();
+        public static bool Launch();
+        [MethodImpl(InternalCall)]public static void Log(int level, string category, string message);
+        public static void NotifyOfCrossThreadDependency();
+    }
+    public sealed class DebuggerBrowsableAttribute : Attribute {
+        public DebuggerBrowsableAttribute(DebuggerBrowsableState state);
+        public DebuggerBrowsableState State { get; }
+    }
+    public enum DebuggerBrowsableState {
+        Collapsed = 2,
+        Never = 0,
+        RootHidden = 3,
+    }
+    public sealed class DebuggerDisplayAttribute : Attribute {
+        public DebuggerDisplayAttribute(string value);
+        public string Name { get; set; }
+        public Type Target { get; set; }
+        public string TargetTypeName { get; set; }
+        public string Type { get; set; }
+        public string Value { get; }
+    }
+    public sealed class DebuggerHiddenAttribute : Attribute {
+        public DebuggerHiddenAttribute();
+    }
+    public sealed class DebuggerNonUserCodeAttribute : Attribute {
+        public DebuggerNonUserCodeAttribute();
+    }
+    public sealed class DebuggerStepThroughAttribute : Attribute {
+        public DebuggerStepThroughAttribute();
+    }
+    public sealed class DebuggerTypeProxyAttribute : Attribute {
+        public DebuggerTypeProxyAttribute(string typeName);
+        public DebuggerTypeProxyAttribute(Type type);
+        public string ProxyTypeName { get; }
+        public Type Target { get; set; }
+        public string TargetTypeName { get; set; }
+    }
+    public class DefaultTraceListener : TraceListener {
+        public DefaultTraceListener();
+        public override void Fail(string message);
+        public override void Fail(string message, string detailMessage);
+        public override void Write(string message);
+        public override void WriteLine(string message);
+    }
+    public class DelimitedListTraceListener : TextWriterTraceListener {
+        public DelimitedListTraceListener(Stream stream);
+        public DelimitedListTraceListener(Stream stream, string name);
+        public DelimitedListTraceListener(TextWriter writer);
+        public DelimitedListTraceListener(TextWriter writer, string name);
+        public string Delimiter { get; set; }
+        public override void TraceData(TraceEventCache eventCache, string source, TraceEventType eventType, int id, object data);
+        public override void TraceData(TraceEventCache eventCache, string source, TraceEventType eventType, int id, params object[] data);
+        public override void TraceEvent(TraceEventCache eventCache, string source, TraceEventType eventType, int id, string message);
+        public override void TraceEvent(TraceEventCache eventCache, string source, TraceEventType eventType, int id, string format, params object[] args);
+    }
+    public class DiagnosticListener : DiagnosticSource, IDisposable, IObservable<KeyValuePair<string, object>> {
+        public DiagnosticListener(string name);
+        public static IObservable<DiagnosticListener> AllListeners { get; }
+        public string Name { get; private set; }
+        public virtual void Dispose();
+        public override bool IsEnabled(string name);
+        public IDisposable Subscribe(IObserver<KeyValuePair<string, object>> observer);
+        public virtual IDisposable Subscribe(IObserver<KeyValuePair<string, object>> observer, Predicate<string> isEnabled);
+        public override string ToString();
+        public override void Write(string name, object value);
+    }
+    public abstract class DiagnosticSource {
+        protected DiagnosticSource();
+        public abstract bool IsEnabled(string name);
+        public abstract void Write(string name, object value);
+    }
+    public class EventTypeFilter : TraceFilter {
+        public EventTypeFilter(SourceLevels level);
+        public SourceLevels EventType { get; set; }
+        public override bool ShouldTrace(TraceEventCache cache, string source, TraceEventType eventType, int id, string formatOrMessage, object[] args, object data1, object[] data);
+    }
+    public sealed class FileVersionInfo {
+        public string Comments { get; }
+        public string CompanyName { get; }
+        public int FileBuildPart { get; }
+        public string FileDescription { get; }
+        public int FileMajorPart { get; }
+        public int FileMinorPart { get; }
+        public string FileName { get; }
+        public int FilePrivatePart { get; }
+        public string FileVersion { get; }
+        public string InternalName { get; }
+        public bool IsDebug { get; }
+        public bool IsPatched { get; }
+        public bool IsPreRelease { get; }
+        public bool IsPrivateBuild { get; }
+        public bool IsSpecialBuild { get; }
+        public string Language { get; }
+        public string LegalCopyright { get; }
+        public string LegalTrademarks { get; }
+        public string OriginalFilename { get; }
+        public string PrivateBuild { get; }
+        public int ProductBuildPart { get; }
+        public int ProductMajorPart { get; }
+        public int ProductMinorPart { get; }
+        public string ProductName { get; }
+        public int ProductPrivatePart { get; }
+        public string ProductVersion { get; }
+        public string SpecialBuild { get; }
+        public static FileVersionInfo GetVersionInfo(string fileName);
+        public override string ToString();
+    }
+    public class Process : IDisposable {
+        public Process();
+        public int BasePriority { get; }
+        public bool EnableRaisingEvents { get; set; }
+        public int ExitCode { get; }
+        public DateTime ExitTime { get; }
+        public bool HasExited { get; }
+        public int Id { get; }
+        public string MachineName { get; }
+        public ProcessModule MainModule { get; }
+        public IntPtr MaxWorkingSet { get; set; }
+        public IntPtr MinWorkingSet { get; set; }
+        public ProcessModuleCollection Modules { get; }
+        public long NonpagedSystemMemorySize64 { get; }
+        public long PagedMemorySize64 { get; }
+        public long PagedSystemMemorySize64 { get; }
+        public long PeakPagedMemorySize64 { get; }
+        public long PeakVirtualMemorySize64 { get; }
+        public long PeakWorkingSet64 { get; }
+        public bool PriorityBoostEnabled { get; set; }
+        public ProcessPriorityClass PriorityClass { get; set; }
+        public long PrivateMemorySize64 { get; }
+        public TimeSpan PrivilegedProcessorTime { get; }
+        public string ProcessName { get; }
+        public IntPtr ProcessorAffinity { get; set; }
+        public SafeProcessHandle SafeHandle { get; }
+        public int SessionId { get; }
+        public StreamReader StandardError { get; }
+        public StreamWriter StandardInput { get; }
+        public StreamReader StandardOutput { get; }
+        public ProcessStartInfo StartInfo { get; set; }
+        public DateTime StartTime { get; }
+        public ProcessThreadCollection Threads { get; }
+        public TimeSpan TotalProcessorTime { get; }
+        public TimeSpan UserProcessorTime { get; }
+        public long VirtualMemorySize64 { get; }
+        public long WorkingSet64 { get; }
+        public event DataReceivedEventHandler ErrorDataReceived;
+        public event EventHandler Exited;
+        public event DataReceivedEventHandler OutputDataReceived;
+        public void BeginErrorReadLine();
+        public void BeginOutputReadLine();
+        public void CancelErrorRead();
+        public void CancelOutputRead();
+        public void Dispose();
+        protected virtual void Dispose(bool disposing);
+        public static void EnterDebugMode();
+        public static Process GetCurrentProcess();
+        public static Process GetProcessById(int processId);
+        public static Process GetProcessById(int processId, string machineName);
+        public static Process[] GetProcesses();
+        public static Process[] GetProcesses(string machineName);
+        public static Process[] GetProcessesByName(string processName);
+        public static Process[] GetProcessesByName(string processName, string machineName);
+        public void Kill();
+        public static void LeaveDebugMode();
+        protected void OnExited();
+        public void Refresh();
+        public bool Start();
+        public static Process Start(ProcessStartInfo startInfo);
+        public static Process Start(string fileName);
+        public static Process Start(string fileName, string arguments);
+        public void WaitForExit();
+        public bool WaitForExit(int milliseconds);
+    }
+    public class ProcessModule {
+        public IntPtr BaseAddress { get; }
+        public IntPtr EntryPointAddress { get; }
+        public string FileName { get; }
+        public int ModuleMemorySize { get; }
+        public string ModuleName { get; }
+        public override string ToString();
+    }
+    public class ProcessModuleCollection : ICollection, IEnumerable {
+        protected ProcessModuleCollection();
+        public ProcessModuleCollection(ProcessModule[] processModules);
+        public int Count { get; }
+        bool System.Collections.ICollection.IsSynchronized { get; }
+        object System.Collections.ICollection.SyncRoot { get; }
+        public ProcessModule this[int index] { get; }
+        public bool Contains(ProcessModule module);
+        public void CopyTo(ProcessModule[] array, int index);
+        public IEnumerator GetEnumerator();
+        public int IndexOf(ProcessModule module);
+        void System.Collections.ICollection.CopyTo(Array array, int index);
+    }
+    public enum ProcessPriorityClass {
+        AboveNormal = 32768,
+        BelowNormal = 16384,
+        High = 128,
+        Idle = 64,
+        Normal = 32,
+        RealTime = 256,
+    }
+    public sealed class ProcessStartInfo {
+        public ProcessStartInfo();
+        public ProcessStartInfo(string fileName);
+        public ProcessStartInfo(string fileName, string arguments);
+        public string Arguments { get; set; }
+        public bool CreateNoWindow { get; set; }
+        public string Domain { get; set; }
+        public IDictionary<string, string> Environment { get; }
+        public string FileName { get; set; }
+        public bool LoadUserProfile { get; set; }
+        public string PasswordInClearText { get; set; }
+        public bool RedirectStandardError { get; set; }
+        public bool RedirectStandardInput { get; set; }
+        public bool RedirectStandardOutput { get; set; }
+        public Encoding StandardErrorEncoding { get; set; }
+        public Encoding StandardOutputEncoding { get; set; }
+        public string UserName { get; set; }
+        public bool UseShellExecute { get; set; }
+        public string WorkingDirectory { get; set; }
+    }
+    public class ProcessThread {
+        public int BasePriority { get; }
+        public int CurrentPriority { get; }
+        public int Id { get; }
+        public int IdealProcessor { set; }
+        public bool PriorityBoostEnabled { get; set; }
+        public ThreadPriorityLevel PriorityLevel { get; set; }
+        public TimeSpan PrivilegedProcessorTime { get; }
+        public IntPtr ProcessorAffinity { set; }
+        public IntPtr StartAddress { get; }
+        public DateTime StartTime { get; }
+        public ThreadState ThreadState { get; }
+        public TimeSpan TotalProcessorTime { get; }
+        public TimeSpan UserProcessorTime { get; }
+        public ThreadWaitReason WaitReason { get; }
+        public void ResetIdealProcessor();
+    }
+    public class ProcessThreadCollection : ICollection, IEnumerable {
+        protected ProcessThreadCollection();
+        public ProcessThreadCollection(ProcessThread[] processThreads);
+        public int Count { get; }
+        bool System.Collections.ICollection.IsSynchronized { get; }
+        object System.Collections.ICollection.SyncRoot { get; }
+        public ProcessThread this[int index] { get; }
+        public int Add(ProcessThread thread);
+        public bool Contains(ProcessThread thread);
+        public void CopyTo(ProcessThread[] array, int index);
+        public IEnumerator GetEnumerator();
+        public int IndexOf(ProcessThread thread);
+        public void Insert(int index, ProcessThread thread);
+        public void Remove(ProcessThread thread);
+        void System.Collections.ICollection.CopyTo(Array array, int index);
+    }
+    public class SourceFilter : TraceFilter {
+        public SourceFilter(string source);
+        public string Source { get; set; }
+        public override bool ShouldTrace(TraceEventCache cache, string source, TraceEventType eventType, int id, string formatOrMessage, object[] args, object data1, object[] data);
+    }
+    public enum SourceLevels {
+        All = -1,
+        Critical = 1,
+        Error = 3,
+        Information = 15,
+        Off = 0,
+        Verbose = 31,
+        Warning = 7,
+    }
+    public class SourceSwitch : Switch {
+        public SourceSwitch(string name);
+        public SourceSwitch(string displayName, string defaultSwitchValue);
+        public SourceLevels Level { get; set; }
+        protected override void OnValueChanged();
+        public bool ShouldTrace(TraceEventType eventType);
+    }
+    public class StackFrame {
+        public const int OFFSET_UNKNOWN = -1;
+        public StackFrame();
+        public StackFrame(bool fNeedFileInfo);
+        public StackFrame(int skipFrames);
+        public StackFrame(int skipFrames, bool fNeedFileInfo);
+        public StackFrame(string fileName, int lineNumber);
+        public StackFrame(string fileName, int lineNumber, int colNumber);
+        public virtual int GetFileColumnNumber();
+        public virtual int GetFileLineNumber();
+        public virtual string GetFileName();
+        public virtual int GetILOffset();
+        public virtual MethodBase GetMethod();
+        public virtual int GetNativeOffset();
+        public override string ToString();
+    }
+    public static class StackFrameExtensions {
+        public static IntPtr GetNativeImageBase(this StackFrame stackFrame);
+        public static IntPtr GetNativeIP(this StackFrame stackFrame);
+        public static bool HasILOffset(this StackFrame stackFrame);
+        public static bool HasMethod(this StackFrame stackFrame);
+        public static bool HasNativeImage(this StackFrame stackFrame);
+        public static bool HasSource(this StackFrame stackFrame);
+    }
+    public class StackTrace {
+        public const int METHODS_TO_SKIP = 0;
+        public StackTrace();
+        public StackTrace(bool fNeedFileInfo);
+        public StackTrace(StackFrame frame);
+        public StackTrace(Exception e);
+        public StackTrace(Exception e, bool fNeedFileInfo);
+        public StackTrace(Exception e, int skipFrames);
+        public StackTrace(Exception e, int skipFrames, bool fNeedFileInfo);
+        public StackTrace(int skipFrames);
+        public StackTrace(int skipFrames, bool fNeedFileInfo);
+        public StackTrace(Thread targetThread, bool needFileInfo);
+        public virtual int FrameCount { get; }
+        public virtual StackFrame GetFrame(int index);
+        public virtual StackFrame[] GetFrames();
+        public override string ToString();
+    }
+    public class Stopwatch {
+        public static readonly bool IsHighResolution;
+        public static readonly long Frequency;
+        public Stopwatch();
+        public TimeSpan Elapsed { get; }
+        public long ElapsedMilliseconds { get; }
+        public long ElapsedTicks { get; }
+        public bool IsRunning { get; }
+        public static long GetTimestamp();
+        public void Reset();
+        public void Restart();
+        public void Start();
+        public static Stopwatch StartNew();
+        public void Stop();
+    }
+    public abstract class Switch {
+        protected Switch(string displayName, string description);
+        protected Switch(string displayName, string description, string defaultSwitchValue);
+        public string Description { get; }
+        public string DisplayName { get; }
+        protected int SwitchSetting { get; set; }
+        protected string Value { get; set; }
+        protected virtual void OnSwitchSettingChanged();
+        protected virtual void OnValueChanged();
+    }
+    public class TextWriterTraceListener : TraceListener {
+        public TextWriterTraceListener();
+        public TextWriterTraceListener(Stream stream);
+        public TextWriterTraceListener(Stream stream, string name);
+        public TextWriterTraceListener(TextWriter writer);
+        public TextWriterTraceListener(TextWriter writer, string name);
+        public TextWriter Writer { get; set; }
+        protected override void Dispose(bool disposing);
+        public override void Flush();
+        public override void Write(string message);
+        public override void WriteLine(string message);
+    }
+    public enum ThreadPriorityLevel {
+        AboveNormal = 1,
+        BelowNormal = -1,
+        Highest = 2,
+        Idle = -15,
+        Lowest = -2,
+        Normal = 0,
+        TimeCritical = 15,
+    }
+    public enum ThreadState {
+        Initialized = 0,
+        Ready = 1,
+        Running = 2,
+        Standby = 3,
+        Terminated = 4,
+        Transition = 6,
+        Unknown = 7,
+        Wait = 5,
+    }
+    public enum ThreadWaitReason {
+        EventPairHigh = 7,
+        EventPairLow = 8,
+        ExecutionDelay = 4,
+        Executive = 0,
+        FreePage = 1,
+        LpcReceive = 9,
+        LpcReply = 10,
+        PageIn = 2,
+        PageOut = 12,
+        Suspended = 5,
+        SystemAllocation = 3,
+        Unknown = 13,
+        UserRequest = 6,
+        VirtualMemory = 11,
+    }
+    public sealed class Trace {
+        public static bool AutoFlush { get; set; }
+        public static int IndentLevel { get; set; }
+        public static int IndentSize { get; set; }
+        public static TraceListenerCollection Listeners { get; }
+        public static bool UseGlobalLock { get; set; }
+        public static void Assert(bool condition);
+        public static void Assert(bool condition, string message);
+        public static void Assert(bool condition, string message, string detailMessage);
+        public static void Close();
+        public static void Fail(string message);
+        public static void Fail(string message, string detailMessage);
+        public static void Flush();
+        public static void Indent();
+        public static void Refresh();
+        public static void TraceError(string message);
+        public static void TraceError(string format, params object[] args);
+        public static void TraceInformation(string message);
+        public static void TraceInformation(string format, params object[] args);
+        public static void TraceWarning(string message);
+        public static void TraceWarning(string format, params object[] args);
+        public static void Unindent();
+        public static void Write(object value);
+        public static void Write(object value, string category);
+        public static void Write(string message);
+        public static void Write(string message, string category);
+        public static void WriteIf(bool condition, object value);
+        public static void WriteIf(bool condition, object value, string category);
+        public static void WriteIf(bool condition, string message);
+        public static void WriteIf(bool condition, string message, string category);
+        public static void WriteLine(object value);
+        public static void WriteLine(object value, string category);
+        public static void WriteLine(string message);
+        public static void WriteLine(string message, string category);
+        public static void WriteLineIf(bool condition, object value);
+        public static void WriteLineIf(bool condition, object value, string category);
+        public static void WriteLineIf(bool condition, string message);
+        public static void WriteLineIf(bool condition, string message, string category);
+    }
+    public class TraceEventCache {
+        public TraceEventCache();
+        public DateTime DateTime { get; }
+        public int ProcessId { get; }
+        public string ThreadId { get; }
+        public long Timestamp { get; }
+    }
+    public enum TraceEventType {
+        Critical = 1,
+        Error = 2,
+        Information = 8,
+        Verbose = 16,
+        Warning = 4,
+    }
+    public abstract class TraceFilter {
+        protected TraceFilter();
+        public abstract bool ShouldTrace(TraceEventCache cache, string source, TraceEventType eventType, int id, string formatOrMessage, object[] args, object data1, object[] data);
+    }
+    public enum TraceLevel {
+        Error = 1,
+        Info = 3,
+        Off = 0,
+        Verbose = 4,
+        Warning = 2,
+    }
+    public abstract class TraceListener : IDisposable {
+        protected TraceListener();
+        protected TraceListener(string name);
+        public TraceFilter Filter { get; set; }
+        public int IndentLevel { get; set; }
+        public int IndentSize { get; set; }
+        public virtual bool IsThreadSafe { get; }
+        public virtual string Name { get; set; }
+        protected bool NeedIndent { get; set; }
+        public TraceOptions TraceOutputOptions { get; set; }
+        public void Dispose();
+        protected virtual void Dispose(bool disposing);
+        public virtual void Fail(string message);
+        public virtual void Fail(string message, string detailMessage);
+        public virtual void Flush();
+        public virtual void TraceData(TraceEventCache eventCache, string source, TraceEventType eventType, int id, object data);
+        public virtual void TraceData(TraceEventCache eventCache, string source, TraceEventType eventType, int id, params object[] data);
+        public virtual void TraceEvent(TraceEventCache eventCache, string source, TraceEventType eventType, int id);
+        public virtual void TraceEvent(TraceEventCache eventCache, string source, TraceEventType eventType, int id, string message);
+        public virtual void TraceEvent(TraceEventCache eventCache, string source, TraceEventType eventType, int id, string format, params object[] args);
+        public virtual void Write(object o);
+        public virtual void Write(object o, string category);
+        public abstract void Write(string message);
+        public virtual void Write(string message, string category);
+        protected virtual void WriteIndent();
+        public virtual void WriteLine(object o);
+        public virtual void WriteLine(object o, string category);
+        public abstract void WriteLine(string message);
+        public virtual void WriteLine(string message, string category);
+    }
+    public class TraceListenerCollection : ICollection, IEnumerable, IList {
+        public int Count { get; }
+        bool System.Collections.ICollection.IsSynchronized { get; }
+        object System.Collections.ICollection.SyncRoot { get; }
+        bool System.Collections.IList.IsFixedSize { get; }
+        bool System.Collections.IList.IsReadOnly { get; }
+        object System.Collections.IList.this[int index] { get; set; }
+        public TraceListener this[int i] { get; set; }
+        public TraceListener this[string name] { get; }
+        public int Add(TraceListener listener);
+        public void AddRange(TraceListener[] value);
+        public void AddRange(TraceListenerCollection value);
+        public void Clear();
+        public bool Contains(TraceListener listener);
+        public void CopyTo(TraceListener[] listeners, int index);
+        public IEnumerator GetEnumerator();
+        public int IndexOf(TraceListener listener);
+        public void Insert(int index, TraceListener listener);
+        public void Remove(TraceListener listener);
+        public void Remove(string name);
+        public void RemoveAt(int index);
+        void System.Collections.ICollection.CopyTo(Array array, int index);
+        int System.Collections.IList.Add(object value);
+        bool System.Collections.IList.Contains(object value);
+        int System.Collections.IList.IndexOf(object value);
+        void System.Collections.IList.Insert(int index, object value);
+        void System.Collections.IList.Remove(object value);
+    }
+    public enum TraceOptions {
+        DateTime = 2,
+        None = 0,
+        ProcessId = 8,
+        ThreadId = 16,
+        Timestamp = 4,
+    }
+    public class TraceSource {
+        public TraceSource(string name);
+        public TraceSource(string name, SourceLevels defaultLevel);
+        public TraceListenerCollection Listeners { get; }
+        public string Name { get; }
+        public SourceSwitch Switch { get; set; }
+        public void Close();
+        public void Flush();
+        public void TraceData(TraceEventType eventType, int id, object data);
+        public void TraceData(TraceEventType eventType, int id, params object[] data);
+        public void TraceEvent(TraceEventType eventType, int id);
+        public void TraceEvent(TraceEventType eventType, int id, string message);
+        public void TraceEvent(TraceEventType eventType, int id, string format, params object[] args);
+        public void TraceInformation(string message);
+        public void TraceInformation(string format, params object[] args);
+    }
+    public class TraceSwitch : Switch {
+        public TraceSwitch(string displayName, string description);
+        public TraceSwitch(string displayName, string description, string defaultSwitchValue);
+        public TraceLevel Level { get; set; }
+        public bool TraceError { get; }
+        public bool TraceInfo { get; }
+        public bool TraceVerbose { get; }
+        public bool TraceWarning { get; }
+        protected override void OnSwitchSettingChanged();
+        protected override void OnValueChanged();
+    }
+}
```

## System.Diagnostics.CodeAnalysis

```c#
+namespace System.Diagnostics.CodeAnalysis {
+    public sealed class SuppressMessageAttribute : Attribute {
+        public SuppressMessageAttribute(string category, string checkId);
+        public string Category { get; }
+        public string CheckId { get; }
+        public string Justification { get; set; }
+        public string MessageId { get; set; }
+        public string Scope { get; set; }
+        public string Target { get; set; }
+    }
+}
```

## System.Diagnostics.Contracts

```c#
+namespace System.Diagnostics.Contracts {
+    public static class Contract {
+        public static event EventHandler<ContractFailedEventArgs> ContractFailed;
+        public static void Assert(bool condition);
+        public static void Assert(bool condition, string userMessage);
+        public static void Assume(bool condition);
+        public static void Assume(bool condition, string userMessage);
+        public static void EndContractBlock();
+        public static void Ensures(bool condition);
+        public static void Ensures(bool condition, string userMessage);
+        public static void EnsuresOnThrow<TException>(bool condition) where TException : Exception;
+        public static void EnsuresOnThrow<TException>(bool condition, string userMessage) where TException : Exception;
+        public static bool Exists(int fromInclusive, int toExclusive, Predicate<int> predicate);
+        public static bool Exists<T>(IEnumerable<T> collection, Predicate<T> predicate);
+        public static bool ForAll(int fromInclusive, int toExclusive, Predicate<int> predicate);
+        public static bool ForAll<T>(IEnumerable<T> collection, Predicate<T> predicate);
+        public static void Invariant(bool condition);
+        public static void Invariant(bool condition, string userMessage);
+        public static T OldValue<T>(T value);
+        public static void Requires(bool condition);
+        public static void Requires(bool condition, string userMessage);
+        public static void Requires<TException>(bool condition) where TException : Exception;
+        public static void Requires<TException>(bool condition, string userMessage) where TException : Exception;
+        public static T Result<T>();
+        public static T ValueAtReturn<T>(out T value);
+    }
+    public sealed class ContractAbbreviatorAttribute : Attribute {
+        public ContractAbbreviatorAttribute();
+    }
+    public sealed class ContractArgumentValidatorAttribute : Attribute {
+        public ContractArgumentValidatorAttribute();
+    }
+    public sealed class ContractClassAttribute : Attribute {
+        public ContractClassAttribute(Type typeContainingContracts);
+        public Type TypeContainingContracts { get; }
+    }
+    public sealed class ContractClassForAttribute : Attribute {
+        public ContractClassForAttribute(Type typeContractsAreFor);
+        public Type TypeContractsAreFor { get; }
+    }
+    public sealed class ContractFailedEventArgs : EventArgs {
+        public ContractFailedEventArgs(ContractFailureKind failureKind, string message, string condition, Exception originalException);
+        public string Condition { get; }
+        public ContractFailureKind FailureKind { get; }
+        public bool Handled { get; }
+        public string Message { get; }
+        public Exception OriginalException { get; }
+        public bool Unwind { get; }
+        public void SetHandled();
+        public void SetUnwind();
+    }
+    public enum ContractFailureKind {
+        Assert = 4,
+        Assume = 5,
+        Invariant = 3,
+        Postcondition = 1,
+        PostconditionOnException = 2,
+        Precondition = 0,
+    }
+    public sealed class ContractInvariantMethodAttribute : Attribute {
+        public ContractInvariantMethodAttribute();
+    }
+    public sealed class ContractOptionAttribute : Attribute {
+        public ContractOptionAttribute(string category, string setting, bool enabled);
+        public ContractOptionAttribute(string category, string setting, string value);
+        public string Category { get; }
+        public bool Enabled { get; }
+        public string Setting { get; }
+        public string Value { get; }
+    }
+    public sealed class ContractPublicPropertyNameAttribute : Attribute {
+        public ContractPublicPropertyNameAttribute(string name);
+        public string Name { get; }
+    }
+    public sealed class ContractReferenceAssemblyAttribute : Attribute {
+        public ContractReferenceAssemblyAttribute();
+    }
+    public sealed class ContractRuntimeIgnoredAttribute : Attribute {
+        public ContractRuntimeIgnoredAttribute();
+    }
+    public sealed class ContractVerificationAttribute : Attribute {
+        public ContractVerificationAttribute(bool value);
+        public bool Value { get; }
+    }
+    public sealed class PureAttribute : Attribute {
+        public PureAttribute();
+    }
+}
```

## System.Diagnostics.Contracts.Internal

```c#
+namespace System.Diagnostics.Contracts.Internal {
+    public static class ContractHelper {
+        public static string RaiseContractFailedEvent(ContractFailureKind failureKind, string userMessage, string conditionText, Exception innerException);
+        public static void TriggerFailure(ContractFailureKind kind, string displayMessage, string userMessage, string conditionText, Exception innerException);
+    }
+}
```

## System.Diagnostics.SymbolStore

```c#
+namespace System.Diagnostics.SymbolStore {
+    public interface ISymbolDocumentWriter {
+        void SetCheckSum(Guid algorithmId, byte[] checkSum);
+        void SetSource(byte[] source);
+    }
+}
```

## System.Diagnostics.Tracing

```c#
+namespace System.Diagnostics.Tracing {
+    public enum EventActivityOptions {
+        Detachable = 8,
+        Disable = 2,
+        None = 0,
+        Recursive = 4,
+    }
+    public sealed class EventAttribute : Attribute {
+        public EventAttribute(int eventId);
+        public EventActivityOptions ActivityOptions { get; set; }
+        public EventChannel Channel { get; set; }
+        public int EventId { get; private set; }
+        public EventKeywords Keywords { get; set; }
+        public EventLevel Level { get; set; }
+        public string Message { get; set; }
+        public EventOpcode Opcode { get; set; }
+        public EventTags Tags { get; set; }
+        public EventTask Task { get; set; }
+        public byte Version { get; set; }
+    }
+    public enum EventChannel : byte {
+        Admin = (byte)16,
+        Analytic = (byte)18,
+        Debug = (byte)19,
+        None = (byte)0,
+        Operational = (byte)17,
+    }
+    public enum EventCommand {
+        Disable = -3,
+        Enable = -2,
+        SendManifest = -1,
+        Update = 0,
+    }
+    public class EventCommandEventArgs : EventArgs {
+        public IDictionary<string, string> Arguments { get; internal set; }
+        public EventCommand Command { get; internal set; }
+        public bool DisableEvent(int eventId);
+        public bool EnableEvent(int eventId);
+    }
+    public class EventCounter {
+        public EventCounter(string name, EventSource eventSource);
+        public void WriteMetric(float value);
+    }
+    public class EventDataAttribute : Attribute {
+        public EventDataAttribute();
+        public string Name { get; set; }
+    }
+    public class EventFieldAttribute : Attribute {
+        public EventFieldAttribute();
+        public EventFieldFormat Format { get; set; }
+        public EventFieldTags Tags { get; set; }
+    }
+    public enum EventFieldFormat {
+        Boolean = 3,
+        Default = 0,
+        Hexadecimal = 4,
+        HResult = 15,
+        Json = 12,
+        String = 2,
+        Xml = 11,
+    }
+    public enum EventFieldTags {
+        None = 0,
+    }
+    public class EventIgnoreAttribute : Attribute {
+        public EventIgnoreAttribute();
+    }
+    public enum EventKeywords : long {
+        All = (long)-1,
+        AuditFailure = (long)4503599627370496,
+        AuditSuccess = (long)9007199254740992,
+        CorrelationHint = (long)4503599627370496,
+        EventLogClassic = (long)36028797018963968,
+        MicrosoftTelemetry = (long)562949953421312,
+        None = (long)0,
+        Sqm = (long)2251799813685248,
+        WdiContext = (long)562949953421312,
+        WdiDiagnostic = (long)1125899906842624,
+    }
+    public enum EventLevel {
+        Critical = 1,
+        Error = 2,
+        Informational = 4,
+        LogAlways = 0,
+        Verbose = 5,
+        Warning = 3,
+    }
+    public class EventListener : IDisposable {
+        public EventListener();
+        public void DisableEvents(EventSource eventSource);
+        public virtual void Dispose();
+        public void EnableEvents(EventSource eventSource, EventLevel level);
+        public void EnableEvents(EventSource eventSource, EventLevel level, EventKeywords matchAnyKeyword);
+        public void EnableEvents(EventSource eventSource, EventLevel level, EventKeywords matchAnyKeyword, IDictionary<string, string> arguments);
+        public static int EventSourceIndex(EventSource eventSource);
+        protected internal virtual void OnEventSourceCreated(EventSource eventSource);
+        protected internal virtual void OnEventWritten(EventWrittenEventArgs eventData);
+    }
+    public enum EventManifestOptions {
+        AllCultures = 2,
+        AllowEventSourceOverride = 8,
+        None = 0,
+        OnlyIfNeededForRegistration = 4,
+        Strict = 1,
+    }
+    public enum EventOpcode {
+        DataCollectionStart = 3,
+        DataCollectionStop = 4,
+        Extension = 5,
+        Info = 0,
+        Receive = 240,
+        Reply = 6,
+        Resume = 7,
+        Send = 9,
+        Start = 1,
+        Stop = 2,
+        Suspend = 8,
+    }
+    public class EventSource : IDisposable {
+        protected EventSource();
+        protected EventSource(bool throwOnEventWriteErrors);
+        protected EventSource(EventSourceSettings settings);
+        protected EventSource(EventSourceSettings settings, params string[] traits);
+        public EventSource(string eventSourceName);
+        public EventSource(string eventSourceName, EventSourceSettings config);
+        public EventSource(string eventSourceName, EventSourceSettings config, params string[] traits);
+        public Exception ConstructionException { get; }
+        public static Guid CurrentThreadActivityId { get; }
+        public Guid Guid { get; }
+        public string Name { get; }
+        public EventSourceSettings Settings { get; }
+        public event EventHandler<EventCommandEventArgs> EventCommandExecuted;
+        public void Dispose();
+        protected virtual void Dispose(bool disposing);
+        ~EventSource();
+        public static string GenerateManifest(Type eventSourceType, string assemblyPathToIncludeInManifest);
+        public static string GenerateManifest(Type eventSourceType, string assemblyPathToIncludeInManifest, EventManifestOptions flags);
+        public static Guid GetGuid(Type eventSourceType);
+        public static string GetName(Type eventSourceType);
+        public static IEnumerable<EventSource> GetSources();
+        public string GetTrait(string key);
+        public bool IsEnabled();
+        public bool IsEnabled(EventLevel level, EventKeywords keywords);
+        public bool IsEnabled(EventLevel level, EventKeywords keywords, EventChannel channel);
+        protected virtual void OnEventCommand(EventCommandEventArgs command);
+        public static void SendCommand(EventSource eventSource, EventCommand command, IDictionary<string, string> commandArguments);
+        public static void SetCurrentThreadActivityId(Guid activityId);
+        public static void SetCurrentThreadActivityId(Guid activityId, out Guid oldActivityThatWillContinue);
+        public override string ToString();
+        public void Write(string eventName);
+        public void Write(string eventName, EventSourceOptions options);
+        public void Write<T>(string eventName, ref EventSourceOptions options, ref Guid activityId, ref Guid relatedActivityId, ref T data);
+        public void Write<T>(string eventName, ref EventSourceOptions options, ref T data);
+        public void Write<T>(string eventName, T data);
+        protected void WriteEvent(int eventId);
+        protected void WriteEvent(int eventId, byte[] arg1);
+        protected void WriteEvent(int eventId, int arg1);
+        protected void WriteEvent(int eventId, int arg1, int arg2);
+        protected void WriteEvent(int eventId, int arg1, int arg2, int arg3);
+        protected void WriteEvent(int eventId, int arg1, string arg2);
+        protected void WriteEvent(int eventId, long arg1);
+        protected void WriteEvent(int eventId, long arg1, byte[] arg2);
+        protected void WriteEvent(int eventId, long arg1, long arg2);
+        protected void WriteEvent(int eventId, long arg1, long arg2, long arg3);
+        protected void WriteEvent(int eventId, long arg1, string arg2);
+        protected void WriteEvent(int eventId, params object[] args);
+        protected void WriteEvent(int eventId, string arg1);
+        protected void WriteEvent(int eventId, string arg1, int arg2);
+        protected void WriteEvent(int eventId, string arg1, int arg2, int arg3);
+        protected void WriteEvent(int eventId, string arg1, long arg2);
+        protected void WriteEvent(int eventId, string arg1, string arg2);
+        protected void WriteEvent(int eventId, string arg1, string arg2, string arg3);
+        protected unsafe void WriteEventCore(int eventId, int eventDataCount, EventSource.EventData* data);
+        protected void WriteEventWithRelatedActivityId(int eventId, Guid relatedActivityId, params object[] args);
+        protected unsafe void WriteEventWithRelatedActivityIdCore(int eventId, Guid* relatedActivityId, int eventDataCount, EventSource.EventData* data);
+        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+        protected internal struct EventData {
+            public IntPtr DataPointer { get; set; }
+            public int Size { get; set; }
+        }
+    }
+    public sealed class EventSourceAttribute : Attribute {
+        public EventSourceAttribute();
+        public string Guid { get; set; }
+        public string LocalizationResources { get; set; }
+        public string Name { get; set; }
+    }
+    public class EventSourceException : Exception {
+        public EventSourceException();
+        public EventSourceException(string message);
+        public EventSourceException(string message, Exception innerException);
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct EventSourceOptions {
+        public EventActivityOptions ActivityOptions { get; set; }
+        public EventKeywords Keywords { get; set; }
+        public EventLevel Level { get; set; }
+        public EventOpcode Opcode { get; set; }
+        public EventTags Tags { get; set; }
+    }
+    public enum EventSourceSettings {
+        Default = 0,
+        EtwManifestEventFormat = 4,
+        EtwSelfDescribingEventFormat = 8,
+        ThrowOnEventWriteErrors = 1,
+    }
+    public enum EventTags {
+        None = 0,
+    }
+    public enum EventTask {
+        None = 0,
+    }
+    public class EventWrittenEventArgs : EventArgs {
+        public Guid ActivityId { get; }
+        public EventChannel Channel { get; }
+        public int EventId { get; internal set; }
+        public string EventName { get; internal set; }
+        public EventSource EventSource { get; }
+        public EventKeywords Keywords { get; }
+        public EventLevel Level { get; }
+        public string Message { get; internal set; }
+        public EventOpcode Opcode { get; }
+        public ReadOnlyCollection<object> Payload { get; internal set; }
+        public ReadOnlyCollection<string> PayloadNames { get; internal set; }
+        public Guid RelatedActivityId { get; internal set; }
+        public EventTags Tags { get; }
+        public EventTask Task { get; }
+        public byte Version { get; }
+    }
+    public sealed class NonEventAttribute : Attribute {
+        public NonEventAttribute();
+    }
+}
```

## System.Drawing

```c#
+namespace System.Drawing {
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Size=1)]
+    public struct Point {
+        public static readonly Point Empty;
+        public Point(Size sz);
+        public Point(int dw);
+        public Point(int x, int y);
+        public bool IsEmpty { get; }
+        public int X { get; set; }
+        public int Y { get; set; }
+        public static Point Add(Point pt, Size sz);
+        public static Point Ceiling(PointF value);
+        public override bool Equals(object obj);
+        public override int GetHashCode();
+        public void Offset(Point p);
+        public void Offset(int dx, int dy);
+        public static Point operator +(Point pt, Size sz);
+        public static bool operator ==(Point left, Point right);
+        public static explicit operator Size (Point p);
+        public static implicit operator PointF (Point p);
+        public static bool operator !=(Point left, Point right);
+        public static Point operator -(Point pt, Size sz);
+        public static Point Round(PointF value);
+        public static Point Subtract(Point pt, Size sz);
+        public override string ToString();
+        public static Point Truncate(PointF value);
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Size=1)]
+    public struct PointF {
+        public static readonly PointF Empty;
+        public PointF(float x, float y);
+        public bool IsEmpty { get; }
+        public float X { get; set; }
+        public float Y { get; set; }
+        public static PointF Add(PointF pt, Size sz);
+        public static PointF Add(PointF pt, SizeF sz);
+        public override bool Equals(object obj);
+        public override int GetHashCode();
+        public static PointF operator +(PointF pt, Size sz);
+        public static PointF operator +(PointF pt, SizeF sz);
+        public static bool operator ==(PointF left, PointF right);
+        public static bool operator !=(PointF left, PointF right);
+        public static PointF operator -(PointF pt, Size sz);
+        public static PointF operator -(PointF pt, SizeF sz);
+        public static PointF Subtract(PointF pt, Size sz);
+        public static PointF Subtract(PointF pt, SizeF sz);
+        public override string ToString();
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Size=1)]
+    public struct Rectangle {
+        public static readonly Rectangle Empty;
+        public Rectangle(Point location, Size size);
+        public Rectangle(int x, int y, int width, int height);
+        public int Bottom { get; }
+        public int Height { get; set; }
+        public bool IsEmpty { get; }
+        public int Left { get; }
+        public Point Location { get; set; }
+        public int Right { get; }
+        public Size Size { get; set; }
+        public int Top { get; }
+        public int Width { get; set; }
+        public int X { get; set; }
+        public int Y { get; set; }
+        public static Rectangle Ceiling(RectangleF value);
+        public bool Contains(Point pt);
+        public bool Contains(Rectangle rect);
+        public bool Contains(int x, int y);
+        public override bool Equals(object obj);
+        public static Rectangle FromLTRB(int left, int top, int right, int bottom);
+        public override int GetHashCode();
+        public static Rectangle Inflate(Rectangle rect, int x, int y);
+        public void Inflate(Size size);
+        public void Inflate(int width, int height);
+        public void Intersect(Rectangle rect);
+        public static Rectangle Intersect(Rectangle a, Rectangle b);
+        public bool IntersectsWith(Rectangle rect);
+        public void Offset(Point pos);
+        public void Offset(int x, int y);
+        public static bool operator ==(Rectangle left, Rectangle right);
+        public static bool operator !=(Rectangle left, Rectangle right);
+        public static Rectangle Round(RectangleF value);
+        public override string ToString();
+        public static Rectangle Truncate(RectangleF value);
+        public static Rectangle Union(Rectangle a, Rectangle b);
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Size=1)]
+    public struct RectangleF {
+        public static readonly RectangleF Empty;
+        public RectangleF(PointF location, SizeF size);
+        public RectangleF(float x, float y, float width, float height);
+        public float Bottom { get; }
+        public float Height { get; set; }
+        public bool IsEmpty { get; }
+        public float Left { get; }
+        public PointF Location { get; set; }
+        public float Right { get; }
+        public SizeF Size { get; set; }
+        public float Top { get; }
+        public float Width { get; set; }
+        public float X { get; set; }
+        public float Y { get; set; }
+        public bool Contains(PointF pt);
+        public bool Contains(RectangleF rect);
+        public bool Contains(float x, float y);
+        public override bool Equals(object obj);
+        public static RectangleF FromLTRB(float left, float top, float right, float bottom);
+        public override int GetHashCode();
+        public static RectangleF Inflate(RectangleF rect, float x, float y);
+        public void Inflate(SizeF size);
+        public void Inflate(float x, float y);
+        public void Intersect(RectangleF rect);
+        public static RectangleF Intersect(RectangleF a, RectangleF b);
+        public bool IntersectsWith(RectangleF rect);
+        public void Offset(PointF pos);
+        public void Offset(float x, float y);
+        public static bool operator ==(RectangleF left, RectangleF right);
+        public static implicit operator RectangleF (Rectangle r);
+        public static bool operator !=(RectangleF left, RectangleF right);
+        public override string ToString();
+        public static RectangleF Union(RectangleF a, RectangleF b);
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Size=1)]
+    public struct Size {
+        public static readonly Size Empty;
+        public Size(Point pt);
+        public Size(int width, int height);
+        public int Height { get; set; }
+        public bool IsEmpty { get; }
+        public int Width { get; set; }
+        public static Size Add(Size sz1, Size sz2);
+        public static Size Ceiling(SizeF value);
+        public override bool Equals(object obj);
+        public override int GetHashCode();
+        public static Size operator +(Size sz1, Size sz2);
+        public static bool operator ==(Size sz1, Size sz2);
+        public static explicit operator Point (Size size);
+        public static implicit operator SizeF (Size p);
+        public static bool operator !=(Size sz1, Size sz2);
+        public static Size operator -(Size sz1, Size sz2);
+        public static Size Round(SizeF value);
+        public static Size Subtract(Size sz1, Size sz2);
+        public override string ToString();
+        public static Size Truncate(SizeF value);
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Size=1)]
+    public struct SizeF {
+        public static readonly SizeF Empty;
+        public SizeF(PointF pt);
+        public SizeF(SizeF size);
+        public SizeF(float width, float height);
+        public float Height { get; set; }
+        public bool IsEmpty { get; }
+        public float Width { get; set; }
+        public static SizeF Add(SizeF sz1, SizeF sz2);
+        public override bool Equals(object obj);
+        public override int GetHashCode();
+        public static SizeF operator +(SizeF sz1, SizeF sz2);
+        public static bool operator ==(SizeF sz1, SizeF sz2);
+        public static explicit operator PointF (SizeF size);
+        public static bool operator !=(SizeF sz1, SizeF sz2);
+        public static SizeF operator -(SizeF sz1, SizeF sz2);
+        public static SizeF Subtract(SizeF sz1, SizeF sz2);
+        public PointF ToPointF();
+        public Size ToSize();
+        public override string ToString();
+    }
+}
```

## System.Dynamic

```c#
+namespace System.Dynamic {
+    public abstract class BinaryOperationBinder : DynamicMetaObjectBinder {
+        protected BinaryOperationBinder(ExpressionType operation);
+        public ExpressionType Operation { get; }
+        public sealed override Type ReturnType { get; }
+        public sealed override DynamicMetaObject Bind(DynamicMetaObject target, DynamicMetaObject[] args);
+        public DynamicMetaObject FallbackBinaryOperation(DynamicMetaObject target, DynamicMetaObject arg);
+        public abstract DynamicMetaObject FallbackBinaryOperation(DynamicMetaObject target, DynamicMetaObject arg, DynamicMetaObject errorSuggestion);
+    }
+    public abstract class BindingRestrictions {
+        public static readonly BindingRestrictions Empty;
+        public static BindingRestrictions Combine(IList<DynamicMetaObject> contributingObjects);
+        public static BindingRestrictions GetExpressionRestriction(Expression expression);
+        public static BindingRestrictions GetInstanceRestriction(Expression expression, object instance);
+        public static BindingRestrictions GetTypeRestriction(Expression expression, Type type);
+        public BindingRestrictions Merge(BindingRestrictions restrictions);
+        public Expression ToExpression();
+    }
+    public sealed class CallInfo {
+        public CallInfo(int argCount, IEnumerable<string> argNames);
+        public CallInfo(int argCount, params string[] argNames);
+        public int ArgumentCount { get; }
+        public ReadOnlyCollection<string> ArgumentNames { get; }
+        public override bool Equals(object obj);
+        public override int GetHashCode();
+    }
+    public abstract class ConvertBinder : DynamicMetaObjectBinder {
+        protected ConvertBinder(Type type, bool @explicit);
+        public bool Explicit { get; }
+        public sealed override Type ReturnType { get; }
+        public Type Type { get; }
+        public sealed override DynamicMetaObject Bind(DynamicMetaObject target, DynamicMetaObject[] args);
+        public DynamicMetaObject FallbackConvert(DynamicMetaObject target);
+        public abstract DynamicMetaObject FallbackConvert(DynamicMetaObject target, DynamicMetaObject errorSuggestion);
+    }
+    public abstract class CreateInstanceBinder : DynamicMetaObjectBinder {
+        protected CreateInstanceBinder(CallInfo callInfo);
+        public CallInfo CallInfo { get; }
+        public sealed override Type ReturnType { get; }
+        public sealed override DynamicMetaObject Bind(DynamicMetaObject target, DynamicMetaObject[] args);
+        public DynamicMetaObject FallbackCreateInstance(DynamicMetaObject target, DynamicMetaObject[] args);
+        public abstract DynamicMetaObject FallbackCreateInstance(DynamicMetaObject target, DynamicMetaObject[] args, DynamicMetaObject errorSuggestion);
+    }
+    public abstract class DeleteIndexBinder : DynamicMetaObjectBinder {
+        protected DeleteIndexBinder(CallInfo callInfo);
+        public CallInfo CallInfo { get; }
+        public sealed override Type ReturnType { get; }
+        public sealed override DynamicMetaObject Bind(DynamicMetaObject target, DynamicMetaObject[] args);
+        public DynamicMetaObject FallbackDeleteIndex(DynamicMetaObject target, DynamicMetaObject[] indexes);
+        public abstract DynamicMetaObject FallbackDeleteIndex(DynamicMetaObject target, DynamicMetaObject[] indexes, DynamicMetaObject errorSuggestion);
+    }
+    public abstract class DeleteMemberBinder : DynamicMetaObjectBinder {
+        protected DeleteMemberBinder(string name, bool ignoreCase);
+        public bool IgnoreCase { get; }
+        public string Name { get; }
+        public sealed override Type ReturnType { get; }
+        public sealed override DynamicMetaObject Bind(DynamicMetaObject target, DynamicMetaObject[] args);
+        public DynamicMetaObject FallbackDeleteMember(DynamicMetaObject target);
+        public abstract DynamicMetaObject FallbackDeleteMember(DynamicMetaObject target, DynamicMetaObject errorSuggestion);
+    }
+    public class DynamicMetaObject {
+        public static readonly DynamicMetaObject[] EmptyMetaObjects;
+        public DynamicMetaObject(Expression expression, BindingRestrictions restrictions);
+        public DynamicMetaObject(Expression expression, BindingRestrictions restrictions, object value);
+        public Expression Expression { get; }
+        public bool HasValue { get; }
+        public Type LimitType { get; }
+        public BindingRestrictions Restrictions { get; }
+        public Type RuntimeType { get; }
+        public object Value { get; }
+        public virtual DynamicMetaObject BindBinaryOperation(BinaryOperationBinder binder, DynamicMetaObject arg);
+        public virtual DynamicMetaObject BindConvert(ConvertBinder binder);
+        public virtual DynamicMetaObject BindCreateInstance(CreateInstanceBinder binder, DynamicMetaObject[] args);
+        public virtual DynamicMetaObject BindDeleteIndex(DeleteIndexBinder binder, DynamicMetaObject[] indexes);
+        public virtual DynamicMetaObject BindDeleteMember(DeleteMemberBinder binder);
+        public virtual DynamicMetaObject BindGetIndex(GetIndexBinder binder, DynamicMetaObject[] indexes);
+        public virtual DynamicMetaObject BindGetMember(GetMemberBinder binder);
+        public virtual DynamicMetaObject BindInvoke(InvokeBinder binder, DynamicMetaObject[] args);
+        public virtual DynamicMetaObject BindInvokeMember(InvokeMemberBinder binder, DynamicMetaObject[] args);
+        public virtual DynamicMetaObject BindSetIndex(SetIndexBinder binder, DynamicMetaObject[] indexes, DynamicMetaObject value);
+        public virtual DynamicMetaObject BindSetMember(SetMemberBinder binder, DynamicMetaObject value);
+        public virtual DynamicMetaObject BindUnaryOperation(UnaryOperationBinder binder);
+        public static DynamicMetaObject Create(object value, Expression expression);
+        public virtual IEnumerable<string> GetDynamicMemberNames();
+    }
+    public abstract class DynamicMetaObjectBinder : CallSiteBinder {
+        protected DynamicMetaObjectBinder();
+        public virtual Type ReturnType { get; }
+        public abstract DynamicMetaObject Bind(DynamicMetaObject target, DynamicMetaObject[] args);
+        public sealed override Expression Bind(object[] args, ReadOnlyCollection<ParameterExpression> parameters, LabelTarget returnLabel);
+        public DynamicMetaObject Defer(DynamicMetaObject target, params DynamicMetaObject[] args);
+        public DynamicMetaObject Defer(params DynamicMetaObject[] args);
+        public Expression GetUpdateExpression(Type type);
+    }
+    public class DynamicObject : IDynamicMetaObjectProvider {
+        protected DynamicObject();
+        public virtual IEnumerable<string> GetDynamicMemberNames();
+        public virtual DynamicMetaObject GetMetaObject(Expression parameter);
+        public virtual bool TryBinaryOperation(BinaryOperationBinder binder, object arg, out object result);
+        public virtual bool TryConvert(ConvertBinder binder, out object result);
+        public virtual bool TryCreateInstance(CreateInstanceBinder binder, object[] args, out object result);
+        public virtual bool TryDeleteIndex(DeleteIndexBinder binder, object[] indexes);
+        public virtual bool TryDeleteMember(DeleteMemberBinder binder);
+        public virtual bool TryGetIndex(GetIndexBinder binder, object[] indexes, out object result);
+        public virtual bool TryGetMember(GetMemberBinder binder, out object result);
+        public virtual bool TryInvoke(InvokeBinder binder, object[] args, out object result);
+        public virtual bool TryInvokeMember(InvokeMemberBinder binder, object[] args, out object result);
+        public virtual bool TrySetIndex(SetIndexBinder binder, object[] indexes, object value);
+        public virtual bool TrySetMember(SetMemberBinder binder, object value);
+        public virtual bool TryUnaryOperation(UnaryOperationBinder binder, out object result);
+    }
+    public sealed class ExpandoObject : ICollection<KeyValuePair<string, object>>, IDictionary<string, object>, IDynamicMetaObjectProvider, IEnumerable, IEnumerable<KeyValuePair<string, object>>, INotifyPropertyChanged {
+        public ExpandoObject();
+        int System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.Count { get; }
+        bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.IsReadOnly { get; }
+        object System.Collections.Generic.IDictionary<System.String,System.Object>.this[string key] { get; set; }
+        ICollection<string> System.Collections.Generic.IDictionary<System.String,System.Object>.Keys { get; }
+        ICollection<object> System.Collections.Generic.IDictionary<System.String,System.Object>.Values { get; }
+        event PropertyChangedEventHandler System.ComponentModel.INotifyPropertyChanged.PropertyChanged;
+        void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.Add(KeyValuePair<string, object> item);
+        void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.Clear();
+        bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.Contains(KeyValuePair<string, object> item);
+        void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.CopyTo(KeyValuePair<string, object>[] array, int arrayIndex);
+        bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.Remove(KeyValuePair<string, object> item);
+        void System.Collections.Generic.IDictionary<System.String,System.Object>.Add(string key, object value);
+        bool System.Collections.Generic.IDictionary<System.String,System.Object>.ContainsKey(string key);
+        bool System.Collections.Generic.IDictionary<System.String,System.Object>.Remove(string key);
+        bool System.Collections.Generic.IDictionary<System.String,System.Object>.TryGetValue(string key, out object value);
+        IEnumerator<KeyValuePair<string, object>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.GetEnumerator();
+        IEnumerator System.Collections.IEnumerable.GetEnumerator();
+        DynamicMetaObject System.Dynamic.IDynamicMetaObjectProvider.GetMetaObject(Expression parameter);
+    }
+    public abstract class GetIndexBinder : DynamicMetaObjectBinder {
+        protected GetIndexBinder(CallInfo callInfo);
+        public CallInfo CallInfo { get; }
+        public sealed override Type ReturnType { get; }
+        public sealed override DynamicMetaObject Bind(DynamicMetaObject target, DynamicMetaObject[] args);
+        public DynamicMetaObject FallbackGetIndex(DynamicMetaObject target, DynamicMetaObject[] indexes);
+        public abstract DynamicMetaObject FallbackGetIndex(DynamicMetaObject target, DynamicMetaObject[] indexes, DynamicMetaObject errorSuggestion);
+    }
+    public abstract class GetMemberBinder : DynamicMetaObjectBinder {
+        protected GetMemberBinder(string name, bool ignoreCase);
+        public bool IgnoreCase { get; }
+        public string Name { get; }
+        public sealed override Type ReturnType { get; }
+        public sealed override DynamicMetaObject Bind(DynamicMetaObject target, DynamicMetaObject[] args);
+        public DynamicMetaObject FallbackGetMember(DynamicMetaObject target);
+        public abstract DynamicMetaObject FallbackGetMember(DynamicMetaObject target, DynamicMetaObject errorSuggestion);
+    }
+    public interface IDynamicMetaObjectProvider {
+        DynamicMetaObject GetMetaObject(Expression parameter);
+    }
+    public interface IInvokeOnGetBinder {
+        bool InvokeOnGet { get; }
+    }
+    public abstract class InvokeBinder : DynamicMetaObjectBinder {
+        protected InvokeBinder(CallInfo callInfo);
+        public CallInfo CallInfo { get; }
+        public sealed override Type ReturnType { get; }
+        public sealed override DynamicMetaObject Bind(DynamicMetaObject target, DynamicMetaObject[] args);
+        public DynamicMetaObject FallbackInvoke(DynamicMetaObject target, DynamicMetaObject[] args);
+        public abstract DynamicMetaObject FallbackInvoke(DynamicMetaObject target, DynamicMetaObject[] args, DynamicMetaObject errorSuggestion);
+    }
+    public abstract class InvokeMemberBinder : DynamicMetaObjectBinder {
+        protected InvokeMemberBinder(string name, bool ignoreCase, CallInfo callInfo);
+        public CallInfo CallInfo { get; }
+        public bool IgnoreCase { get; }
+        public string Name { get; }
+        public sealed override Type ReturnType { get; }
+        public sealed override DynamicMetaObject Bind(DynamicMetaObject target, DynamicMetaObject[] args);
+        public abstract DynamicMetaObject FallbackInvoke(DynamicMetaObject target, DynamicMetaObject[] args, DynamicMetaObject errorSuggestion);
+        public DynamicMetaObject FallbackInvokeMember(DynamicMetaObject target, DynamicMetaObject[] args);
+        public abstract DynamicMetaObject FallbackInvokeMember(DynamicMetaObject target, DynamicMetaObject[] args, DynamicMetaObject errorSuggestion);
+    }
+    public abstract class SetIndexBinder : DynamicMetaObjectBinder {
+        protected SetIndexBinder(CallInfo callInfo);
+        public CallInfo CallInfo { get; }
+        public sealed override Type ReturnType { get; }
+        public sealed override DynamicMetaObject Bind(DynamicMetaObject target, DynamicMetaObject[] args);
+        public DynamicMetaObject FallbackSetIndex(DynamicMetaObject target, DynamicMetaObject[] indexes, DynamicMetaObject value);
+        public abstract DynamicMetaObject FallbackSetIndex(DynamicMetaObject target, DynamicMetaObject[] indexes, DynamicMetaObject value, DynamicMetaObject errorSuggestion);
+    }
+    public abstract class SetMemberBinder : DynamicMetaObjectBinder {
+        protected SetMemberBinder(string name, bool ignoreCase);
+        public bool IgnoreCase { get; }
+        public string Name { get; }
+        public sealed override Type ReturnType { get; }
+        public sealed override DynamicMetaObject Bind(DynamicMetaObject target, DynamicMetaObject[] args);
+        public DynamicMetaObject FallbackSetMember(DynamicMetaObject target, DynamicMetaObject value);
+        public abstract DynamicMetaObject FallbackSetMember(DynamicMetaObject target, DynamicMetaObject value, DynamicMetaObject errorSuggestion);
+    }
+    public abstract class UnaryOperationBinder : DynamicMetaObjectBinder {
+        protected UnaryOperationBinder(ExpressionType operation);
+        public ExpressionType Operation { get; }
+        public sealed override Type ReturnType { get; }
+        public sealed override DynamicMetaObject Bind(DynamicMetaObject target, DynamicMetaObject[] args);
+        public DynamicMetaObject FallbackUnaryOperation(DynamicMetaObject target);
+        public abstract DynamicMetaObject FallbackUnaryOperation(DynamicMetaObject target, DynamicMetaObject errorSuggestion);
+    }
+}
```

## System.Globalization

```c#
+namespace System.Globalization {
+    public abstract class Calendar {
+        public const int CurrentEra = 0;
+        protected Calendar();
+        public virtual CalendarAlgorithmType AlgorithmType { get; }
+        protected virtual int DaysInYearBeforeMinSupportedYear { get; }
+        public abstract int[] Eras { get; }
+        public bool IsReadOnly { get; }
+        public virtual DateTime MaxSupportedDateTime { get; }
+        public virtual DateTime MinSupportedDateTime { get; }
+        public virtual int TwoDigitYearMax { get; set; }
+        public virtual DateTime AddDays(DateTime time, int days);
+        public virtual DateTime AddHours(DateTime time, int hours);
+        public virtual DateTime AddMilliseconds(DateTime time, double milliseconds);
+        public virtual DateTime AddMinutes(DateTime time, int minutes);
+        public abstract DateTime AddMonths(DateTime time, int months);
+        public virtual DateTime AddSeconds(DateTime time, int seconds);
+        public virtual DateTime AddWeeks(DateTime time, int weeks);
+        public abstract DateTime AddYears(DateTime time, int years);
+        public abstract int GetDayOfMonth(DateTime time);
+        public abstract DayOfWeek GetDayOfWeek(DateTime time);
+        public abstract int GetDayOfYear(DateTime time);
+        public virtual int GetDaysInMonth(int year, int month);
+        public abstract int GetDaysInMonth(int year, int month, int era);
+        public virtual int GetDaysInYear(int year);
+        public abstract int GetDaysInYear(int year, int era);
+        public abstract int GetEra(DateTime time);
+        public virtual int GetHour(DateTime time);
+        public virtual int GetLeapMonth(int year, int era);
+        public virtual double GetMilliseconds(DateTime time);
+        public virtual int GetMinute(DateTime time);
+        public abstract int GetMonth(DateTime time);
+        public virtual int GetMonthsInYear(int year);
+        public abstract int GetMonthsInYear(int year, int era);
+        public virtual int GetSecond(DateTime time);
+        public virtual int GetWeekOfYear(DateTime time, CalendarWeekRule rule, DayOfWeek firstDayOfWeek);
+        public abstract int GetYear(DateTime time);
+        public virtual bool IsLeapDay(int year, int month, int day);
+        public abstract bool IsLeapDay(int year, int month, int day, int era);
+        public virtual bool IsLeapMonth(int year, int month);
+        public abstract bool IsLeapMonth(int year, int month, int era);
+        public virtual bool IsLeapYear(int year);
+        public abstract bool IsLeapYear(int year, int era);
+        public virtual DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond);
+        public abstract DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
+        public virtual int ToFourDigitYear(int year);
+    }
+    public enum CalendarAlgorithmType {
+        LunarCalendar = 2,
+        LunisolarCalendar = 3,
+        SolarCalendar = 1,
+        Unknown = 0,
+    }
+    public enum CalendarWeekRule {
+        FirstDay = 0,
+        FirstFourDayWeek = 2,
+        FirstFullWeek = 1,
+    }
+    public static class CharUnicodeInfo {
+        public static double GetNumericValue(char ch);
+        public static double GetNumericValue(string s, int index);
+        public static UnicodeCategory GetUnicodeCategory(char ch);
+        public static UnicodeCategory GetUnicodeCategory(string s, int index);
+    }
+    public class ChineseLunisolarCalendar : EastAsianLunisolarCalendar {
+        public const int ChineseEra = 1;
+        public ChineseLunisolarCalendar();
+        protected override int DaysInYearBeforeMinSupportedYear { get; }
+        public override int[] Eras { get; }
+        public override DateTime MaxSupportedDateTime { get; }
+        public override DateTime MinSupportedDateTime { get; }
+        public override int GetEra(DateTime time);
+    }
+    public class CompareInfo {
+        public virtual string Name { get; }
+        public virtual int Compare(string string1, int offset1, int length1, string string2, int offset2, int length2);
+        public virtual int Compare(string string1, int offset1, int length1, string string2, int offset2, int length2, CompareOptions options);
+        public virtual int Compare(string string1, int offset1, string string2, int offset2);
+        public virtual int Compare(string string1, int offset1, string string2, int offset2, CompareOptions options);
+        public virtual int Compare(string string1, string string2);
+        public virtual int Compare(string string1, string string2, CompareOptions options);
+        public override bool Equals(object value);
+        public static CompareInfo GetCompareInfo(string name);
+        public override int GetHashCode();
+        public virtual int GetHashCode(string source, CompareOptions options);
+        public virtual int IndexOf(string source, char value);
+        public virtual int IndexOf(string source, char value, CompareOptions options);
+        public virtual int IndexOf(string source, char value, int startIndex, CompareOptions options);
+        public virtual int IndexOf(string source, char value, int startIndex, int count);
+        public virtual int IndexOf(string source, char value, int startIndex, int count, CompareOptions options);
+        public virtual int IndexOf(string source, string value);
+        public virtual int IndexOf(string source, string value, CompareOptions options);
+        public virtual int IndexOf(string source, string value, int startIndex, CompareOptions options);
+        public virtual int IndexOf(string source, string value, int startIndex, int count);
+        public virtual int IndexOf(string source, string value, int startIndex, int count, CompareOptions options);
+        public virtual bool IsPrefix(string source, string prefix);
+        public virtual bool IsPrefix(string source, string prefix, CompareOptions options);
+        public virtual bool IsSuffix(string source, string suffix);
+        public virtual bool IsSuffix(string source, string suffix, CompareOptions options);
+        public virtual int LastIndexOf(string source, char value);
+        public virtual int LastIndexOf(string source, char value, CompareOptions options);
+        public virtual int LastIndexOf(string source, char value, int startIndex, CompareOptions options);
+        public virtual int LastIndexOf(string source, char value, int startIndex, int count);
+        public virtual int LastIndexOf(string source, char value, int startIndex, int count, CompareOptions options);
+        public virtual int LastIndexOf(string source, string value);
+        public virtual int LastIndexOf(string source, string value, CompareOptions options);
+        public virtual int LastIndexOf(string source, string value, int startIndex, CompareOptions options);
+        public virtual int LastIndexOf(string source, string value, int startIndex, int count);
+        public virtual int LastIndexOf(string source, string value, int startIndex, int count, CompareOptions options);
+        public override string ToString();
+    }
+    public enum CompareOptions {
+        IgnoreCase = 1,
+        IgnoreKanaType = 8,
+        IgnoreNonSpace = 2,
+        IgnoreSymbols = 4,
+        IgnoreWidth = 16,
+        None = 0,
+        Ordinal = 1073741824,
+        OrdinalIgnoreCase = 268435456,
+        StringSort = 536870912,
+    }
+    public class CultureInfo : IFormatProvider {
+        public CultureInfo(string name);
+        public virtual Calendar Calendar { get; }
+        public virtual CompareInfo CompareInfo { get; }
+        public static CultureInfo CurrentCulture { get; set; }
+        public static CultureInfo CurrentUICulture { get; set; }
+        public virtual DateTimeFormatInfo DateTimeFormat { get; set; }
+        public static CultureInfo DefaultThreadCurrentCulture { get; set; }
+        public static CultureInfo DefaultThreadCurrentUICulture { get; set; }
+        public virtual string DisplayName { get; }
+        public virtual string EnglishName { get; }
+        public static CultureInfo InvariantCulture { get; }
+        public virtual bool IsNeutralCulture { get; }
+        public bool IsReadOnly { get; }
+        public virtual string Name { get; }
+        public virtual string NativeName { get; }
+        public virtual NumberFormatInfo NumberFormat { get; set; }
+        public virtual Calendar[] OptionalCalendars { get; }
+        public virtual CultureInfo Parent { get; }
+        public virtual TextInfo TextInfo { get; }
+        public virtual string TwoLetterISOLanguageName { get; }
+        public virtual object Clone();
+        public override bool Equals(object value);
+        public virtual object GetFormat(Type formatType);
+        public override int GetHashCode();
+        public static CultureInfo ReadOnly(CultureInfo ci);
+        public override string ToString();
+    }
+    public class CultureNotFoundException : ArgumentException {
+        public CultureNotFoundException();
+        public CultureNotFoundException(string message);
+        public CultureNotFoundException(string message, Exception innerException);
+        public CultureNotFoundException(string paramName, string message);
+        public CultureNotFoundException(string message, string invalidCultureName, Exception innerException);
+        public CultureNotFoundException(string paramName, string invalidCultureName, string message);
+        public virtual string InvalidCultureName { get; }
+        public override string Message { get; }
+    }
+    public sealed class DateTimeFormatInfo : IFormatProvider {
+        public DateTimeFormatInfo();
+        public string[] AbbreviatedDayNames { get; set; }
+        public string[] AbbreviatedMonthGenitiveNames { get; set; }
+        public string[] AbbreviatedMonthNames { get; set; }
+        public string AMDesignator { get; set; }
+        public Calendar Calendar { get; set; }
+        public CalendarWeekRule CalendarWeekRule { get; set; }
+        public static DateTimeFormatInfo CurrentInfo { get; }
+        public string[] DayNames { get; set; }
+        public DayOfWeek FirstDayOfWeek { get; set; }
+        public string FullDateTimePattern { get; set; }
+        public static DateTimeFormatInfo InvariantInfo { get; }
+        public bool IsReadOnly { get; }
+        public string LongDatePattern { get; set; }
+        public string LongTimePattern { get; set; }
+        public string MonthDayPattern { get; set; }
+        public string[] MonthGenitiveNames { get; set; }
+        public string[] MonthNames { get; set; }
+        public string PMDesignator { get; set; }
+        public string RFC1123Pattern { get; }
+        public string ShortDatePattern { get; set; }
+        public string[] ShortestDayNames { get; set; }
+        public string ShortTimePattern { get; set; }
+        public string SortableDateTimePattern { get; }
+        public string UniversalSortableDateTimePattern { get; }
+        public string YearMonthPattern { get; set; }
+        public object Clone();
+        public string GetAbbreviatedDayName(DayOfWeek dayofweek);
+        public string GetAbbreviatedEraName(int era);
+        public string GetAbbreviatedMonthName(int month);
+        public string GetDayName(DayOfWeek dayofweek);
+        public int GetEra(string eraName);
+        public string GetEraName(int era);
+        public object GetFormat(Type formatType);
+        public static DateTimeFormatInfo GetInstance(IFormatProvider provider);
+        public string GetMonthName(int month);
+        public static DateTimeFormatInfo ReadOnly(DateTimeFormatInfo dtfi);
+    }
+    public enum DateTimeStyles {
+        AdjustToUniversal = 16,
+        AllowInnerWhite = 4,
+        AllowLeadingWhite = 1,
+        AllowTrailingWhite = 2,
+        AllowWhiteSpaces = 7,
+        AssumeLocal = 32,
+        AssumeUniversal = 64,
+        NoCurrentDateDefault = 8,
+        None = 0,
+        RoundtripKind = 128,
+    }
+    public abstract class EastAsianLunisolarCalendar : Calendar {
+        public override CalendarAlgorithmType AlgorithmType { get; }
+        public override int TwoDigitYearMax { get; set; }
+        public override DateTime AddMonths(DateTime time, int months);
+        public override DateTime AddYears(DateTime time, int years);
+        public int GetCelestialStem(int sexagenaryYear);
+        public override int GetDayOfMonth(DateTime time);
+        public override DayOfWeek GetDayOfWeek(DateTime time);
+        public override int GetDayOfYear(DateTime time);
+        public override int GetDaysInMonth(int year, int month, int era);
+        public override int GetDaysInYear(int year, int era);
+        public override int GetLeapMonth(int year, int era);
+        public override int GetMonth(DateTime time);
+        public override int GetMonthsInYear(int year, int era);
+        public virtual int GetSexagenaryYear(DateTime time);
+        public int GetTerrestrialBranch(int sexagenaryYear);
+        public override int GetYear(DateTime time);
+        public override bool IsLeapDay(int year, int month, int day, int era);
+        public override bool IsLeapMonth(int year, int month, int era);
+        public override bool IsLeapYear(int year, int era);
+        public override DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
+        public override int ToFourDigitYear(int year);
+    }
+    public static class GlobalizationExtensions {
+        public static StringComparer GetStringComparer(this CompareInfo compareInfo, CompareOptions options);
+    }
+    public class GregorianCalendar : Calendar {
+        public const int ADEra = 1;
+        public GregorianCalendar();
+        public GregorianCalendar(GregorianCalendarTypes type);
+        public override CalendarAlgorithmType AlgorithmType { get; }
+        public virtual GregorianCalendarTypes CalendarType { get; set; }
+        public override int[] Eras { get; }
+        public override DateTime MaxSupportedDateTime { get; }
+        public override DateTime MinSupportedDateTime { get; }
+        public override int TwoDigitYearMax { get; set; }
+        public override DateTime AddMonths(DateTime time, int months);
+        public override DateTime AddYears(DateTime time, int years);
+        public override int GetDayOfMonth(DateTime time);
+        public override DayOfWeek GetDayOfWeek(DateTime time);
+        public override int GetDayOfYear(DateTime time);
+        public override int GetDaysInMonth(int year, int month, int era);
+        public override int GetDaysInYear(int year, int era);
+        public override int GetEra(DateTime time);
+        public override int GetLeapMonth(int year, int era);
+        public override int GetMonth(DateTime time);
+        public override int GetMonthsInYear(int year, int era);
+        public override int GetYear(DateTime time);
+        public override bool IsLeapDay(int year, int month, int day, int era);
+        public override bool IsLeapMonth(int year, int month, int era);
+        public override bool IsLeapYear(int year, int era);
+        public override DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
+        public override int ToFourDigitYear(int year);
+    }
+    public enum GregorianCalendarTypes {
+        Arabic = 10,
+        Localized = 1,
+        MiddleEastFrench = 9,
+        TransliteratedEnglish = 11,
+        TransliteratedFrench = 12,
+        USEnglish = 2,
+    }
+    public class HebrewCalendar : Calendar {
+        public HebrewCalendar();
+        public override CalendarAlgorithmType AlgorithmType { get; }
+        public override int[] Eras { get; }
+        public override DateTime MaxSupportedDateTime { get; }
+        public override DateTime MinSupportedDateTime { get; }
+        public override int TwoDigitYearMax { get; set; }
+        public override DateTime AddMonths(DateTime time, int months);
+        public override DateTime AddYears(DateTime time, int years);
+        public override int GetDayOfMonth(DateTime time);
+        public override DayOfWeek GetDayOfWeek(DateTime time);
+        public override int GetDayOfYear(DateTime time);
+        public override int GetDaysInMonth(int year, int month, int era);
+        public override int GetDaysInYear(int year, int era);
+        public override int GetEra(DateTime time);
+        public override int GetLeapMonth(int year, int era);
+        public override int GetMonth(DateTime time);
+        public override int GetMonthsInYear(int year, int era);
+        public override int GetYear(DateTime time);
+        public override bool IsLeapDay(int year, int month, int day, int era);
+        public override bool IsLeapMonth(int year, int month, int era);
+        public override bool IsLeapYear(int year, int era);
+        public override DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
+        public override int ToFourDigitYear(int year);
+    }
+    public class HijriCalendar : Calendar {
+        public HijriCalendar();
+        public override CalendarAlgorithmType AlgorithmType { get; }
+        protected override int DaysInYearBeforeMinSupportedYear { get; }
+        public override int[] Eras { get; }
+        public int HijriAdjustment { get; set; }
+        public override DateTime MaxSupportedDateTime { get; }
+        public override DateTime MinSupportedDateTime { get; }
+        public override int TwoDigitYearMax { get; set; }
+        public override DateTime AddMonths(DateTime time, int months);
+        public override DateTime AddYears(DateTime time, int years);
+        public override int GetDayOfMonth(DateTime time);
+        public override DayOfWeek GetDayOfWeek(DateTime time);
+        public override int GetDayOfYear(DateTime time);
+        public override int GetDaysInMonth(int year, int month, int era);
+        public override int GetDaysInYear(int year, int era);
+        public override int GetEra(DateTime time);
+        public override int GetLeapMonth(int year, int era);
+        public override int GetMonth(DateTime time);
+        public override int GetMonthsInYear(int year, int era);
+        public override int GetYear(DateTime time);
+        public override bool IsLeapDay(int year, int month, int day, int era);
+        public override bool IsLeapMonth(int year, int month, int era);
+        public override bool IsLeapYear(int year, int era);
+        public override DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
+        public override int ToFourDigitYear(int year);
+    }
+    public sealed class IdnMapping {
+        public IdnMapping();
+        public bool AllowUnassigned { get; set; }
+        public bool UseStd3AsciiRules { get; set; }
+        public override bool Equals(object obj);
+        public string GetAscii(string unicode);
+        public string GetAscii(string unicode, int index);
+        public string GetAscii(string unicode, int index, int count);
+        public override int GetHashCode();
+        public string GetUnicode(string ascii);
+        public string GetUnicode(string ascii, int index);
+        public string GetUnicode(string ascii, int index, int count);
+    }
+    public class JapaneseCalendar : Calendar {
+        public JapaneseCalendar();
+        public override CalendarAlgorithmType AlgorithmType { get; }
+        public override int[] Eras { get; }
+        public override DateTime MaxSupportedDateTime { get; }
+        public override DateTime MinSupportedDateTime { get; }
+        public override int TwoDigitYearMax { get; set; }
+        public override DateTime AddMonths(DateTime time, int months);
+        public override DateTime AddYears(DateTime time, int years);
+        public override int GetDayOfMonth(DateTime time);
+        public override DayOfWeek GetDayOfWeek(DateTime time);
+        public override int GetDayOfYear(DateTime time);
+        public override int GetDaysInMonth(int year, int month, int era);
+        public override int GetDaysInYear(int year, int era);
+        public override int GetEra(DateTime time);
+        public override int GetLeapMonth(int year, int era);
+        public override int GetMonth(DateTime time);
+        public override int GetMonthsInYear(int year, int era);
+        public override int GetWeekOfYear(DateTime time, CalendarWeekRule rule, DayOfWeek firstDayOfWeek);
+        public override int GetYear(DateTime time);
+        public override bool IsLeapDay(int year, int month, int day, int era);
+        public override bool IsLeapMonth(int year, int month, int era);
+        public override bool IsLeapYear(int year, int era);
+        public override DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
+        public override int ToFourDigitYear(int year);
+    }
+    public class JapaneseLunisolarCalendar : EastAsianLunisolarCalendar {
+        public const int JapaneseEra = 1;
+        public JapaneseLunisolarCalendar();
+        protected override int DaysInYearBeforeMinSupportedYear { get; }
+        public override int[] Eras { get; }
+        public override DateTime MaxSupportedDateTime { get; }
+        public override DateTime MinSupportedDateTime { get; }
+        public override int GetEra(DateTime time);
+    }
+    public class JulianCalendar : Calendar {
+        public static readonly int JulianEra;
+        public JulianCalendar();
+        public override CalendarAlgorithmType AlgorithmType { get; }
+        public override int[] Eras { get; }
+        public override DateTime MaxSupportedDateTime { get; }
+        public override DateTime MinSupportedDateTime { get; }
+        public override int TwoDigitYearMax { get; set; }
+        public override DateTime AddMonths(DateTime time, int months);
+        public override DateTime AddYears(DateTime time, int years);
+        public override int GetDayOfMonth(DateTime time);
+        public override DayOfWeek GetDayOfWeek(DateTime time);
+        public override int GetDayOfYear(DateTime time);
+        public override int GetDaysInMonth(int year, int month, int era);
+        public override int GetDaysInYear(int year, int era);
+        public override int GetEra(DateTime time);
+        public override int GetLeapMonth(int year, int era);
+        public override int GetMonth(DateTime time);
+        public override int GetMonthsInYear(int year, int era);
+        public override int GetYear(DateTime time);
+        public override bool IsLeapDay(int year, int month, int day, int era);
+        public override bool IsLeapMonth(int year, int month, int era);
+        public override bool IsLeapYear(int year, int era);
+        public override DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
+        public override int ToFourDigitYear(int year);
+    }
+    public class KoreanCalendar : Calendar {
+        public const int KoreanEra = 1;
+        public KoreanCalendar();
+        public override CalendarAlgorithmType AlgorithmType { get; }
+        public override int[] Eras { get; }
+        public override DateTime MaxSupportedDateTime { get; }
+        public override DateTime MinSupportedDateTime { get; }
+        public override int TwoDigitYearMax { get; set; }
+        public override DateTime AddMonths(DateTime time, int months);
+        public override DateTime AddYears(DateTime time, int years);
+        public override int GetDayOfMonth(DateTime time);
+        public override DayOfWeek GetDayOfWeek(DateTime time);
+        public override int GetDayOfYear(DateTime time);
+        public override int GetDaysInMonth(int year, int month, int era);
+        public override int GetDaysInYear(int year, int era);
+        public override int GetEra(DateTime time);
+        public override int GetLeapMonth(int year, int era);
+        public override int GetMonth(DateTime time);
+        public override int GetMonthsInYear(int year, int era);
+        public override int GetWeekOfYear(DateTime time, CalendarWeekRule rule, DayOfWeek firstDayOfWeek);
+        public override int GetYear(DateTime time);
+        public override bool IsLeapDay(int year, int month, int day, int era);
+        public override bool IsLeapMonth(int year, int month, int era);
+        public override bool IsLeapYear(int year, int era);
+        public override DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
+        public override int ToFourDigitYear(int year);
+    }
+    public class KoreanLunisolarCalendar : EastAsianLunisolarCalendar {
+        public const int GregorianEra = 1;
+        public KoreanLunisolarCalendar();
+        protected override int DaysInYearBeforeMinSupportedYear { get; }
+        public override int[] Eras { get; }
+        public override DateTime MaxSupportedDateTime { get; }
+        public override DateTime MinSupportedDateTime { get; }
+        public override int GetEra(DateTime time);
+    }
+    public sealed class NumberFormatInfo : IFormatProvider {
+        public NumberFormatInfo();
+        public int CurrencyDecimalDigits { get; set; }
+        public string CurrencyDecimalSeparator { get; set; }
+        public string CurrencyGroupSeparator { get; set; }
+        public int[] CurrencyGroupSizes { get; set; }
+        public int CurrencyNegativePattern { get; set; }
+        public int CurrencyPositivePattern { get; set; }
+        public string CurrencySymbol { get; set; }
+        public static NumberFormatInfo CurrentInfo { get; }
+        public static NumberFormatInfo InvariantInfo { get; }
+        public bool IsReadOnly { get; }
+        public string NaNSymbol { get; set; }
+        public string NegativeInfinitySymbol { get; set; }
+        public string NegativeSign { get; set; }
+        public int NumberDecimalDigits { get; set; }
+        public string NumberDecimalSeparator { get; set; }
+        public string NumberGroupSeparator { get; set; }
+        public int[] NumberGroupSizes { get; set; }
+        public int NumberNegativePattern { get; set; }
+        public int PercentDecimalDigits { get; set; }
+        public string PercentDecimalSeparator { get; set; }
+        public string PercentGroupSeparator { get; set; }
+        public int[] PercentGroupSizes { get; set; }
+        public int PercentNegativePattern { get; set; }
+        public int PercentPositivePattern { get; set; }
+        public string PercentSymbol { get; set; }
+        public string PerMilleSymbol { get; set; }
+        public string PositiveInfinitySymbol { get; set; }
+        public string PositiveSign { get; set; }
+        public object Clone();
+        public object GetFormat(Type formatType);
+        public static NumberFormatInfo GetInstance(IFormatProvider formatProvider);
+        public static NumberFormatInfo ReadOnly(NumberFormatInfo nfi);
+    }
+    public enum NumberStyles {
+        AllowCurrencySymbol = 256,
+        AllowDecimalPoint = 32,
+        AllowExponent = 128,
+        AllowHexSpecifier = 512,
+        AllowLeadingSign = 4,
+        AllowLeadingWhite = 1,
+        AllowParentheses = 16,
+        AllowThousands = 64,
+        AllowTrailingSign = 8,
+        AllowTrailingWhite = 2,
+        Any = 511,
+        Currency = 383,
+        Float = 167,
+        HexNumber = 515,
+        Integer = 7,
+        None = 0,
+        Number = 111,
+    }
+    public class PersianCalendar : Calendar {
+        public static readonly int PersianEra;
+        public PersianCalendar();
+        public override CalendarAlgorithmType AlgorithmType { get; }
+        public override int[] Eras { get; }
+        public override DateTime MaxSupportedDateTime { get; }
+        public override DateTime MinSupportedDateTime { get; }
+        public override int TwoDigitYearMax { get; set; }
+        public override DateTime AddMonths(DateTime time, int months);
+        public override DateTime AddYears(DateTime time, int years);
+        public override int GetDayOfMonth(DateTime time);
+        public override DayOfWeek GetDayOfWeek(DateTime time);
+        public override int GetDayOfYear(DateTime time);
+        public override int GetDaysInMonth(int year, int month, int era);
+        public override int GetDaysInYear(int year, int era);
+        public override int GetEra(DateTime time);
+        public override int GetLeapMonth(int year, int era);
+        public override int GetMonth(DateTime time);
+        public override int GetMonthsInYear(int year, int era);
+        public override int GetYear(DateTime time);
+        public override bool IsLeapDay(int year, int month, int day, int era);
+        public override bool IsLeapMonth(int year, int month, int era);
+        public override bool IsLeapYear(int year, int era);
+        public override DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
+        public override int ToFourDigitYear(int year);
+    }
+    public class RegionInfo {
+        public RegionInfo(string name);
+        public virtual string CurrencySymbol { get; }
+        public static RegionInfo CurrentRegion { get; }
+        public virtual string DisplayName { get; }
+        public virtual string EnglishName { get; }
+        public virtual bool IsMetric { get; }
+        public virtual string ISOCurrencySymbol { get; }
+        public virtual string Name { get; }
+        public virtual string NativeName { get; }
+        public virtual string TwoLetterISORegionName { get; }
+        public override bool Equals(object value);
+        public override int GetHashCode();
+        public override string ToString();
+    }
+    public class StringInfo {
+        public StringInfo();
+        public StringInfo(string value);
+        public int LengthInTextElements { get; }
+        public string String { get; set; }
+        public override bool Equals(object value);
+        public override int GetHashCode();
+        public static string GetNextTextElement(string str);
+        public static string GetNextTextElement(string str, int index);
+        public static TextElementEnumerator GetTextElementEnumerator(string str);
+        public static TextElementEnumerator GetTextElementEnumerator(string str, int index);
+        public static int[] ParseCombiningCharacters(string str);
+    }
+    public class TaiwanCalendar : Calendar {
+        public TaiwanCalendar();
+        public override CalendarAlgorithmType AlgorithmType { get; }
+        public override int[] Eras { get; }
+        public override DateTime MaxSupportedDateTime { get; }
+        public override DateTime MinSupportedDateTime { get; }
+        public override int TwoDigitYearMax { get; set; }
+        public override DateTime AddMonths(DateTime time, int months);
+        public override DateTime AddYears(DateTime time, int years);
+        public override int GetDayOfMonth(DateTime time);
+        public override DayOfWeek GetDayOfWeek(DateTime time);
+        public override int GetDayOfYear(DateTime time);
+        public override int GetDaysInMonth(int year, int month, int era);
+        public override int GetDaysInYear(int year, int era);
+        public override int GetEra(DateTime time);
+        public override int GetLeapMonth(int year, int era);
+        public override int GetMonth(DateTime time);
+        public override int GetMonthsInYear(int year, int era);
+        public override int GetWeekOfYear(DateTime time, CalendarWeekRule rule, DayOfWeek firstDayOfWeek);
+        public override int GetYear(DateTime time);
+        public override bool IsLeapDay(int year, int month, int day, int era);
+        public override bool IsLeapMonth(int year, int month, int era);
+        public override bool IsLeapYear(int year, int era);
+        public override DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
+        public override int ToFourDigitYear(int year);
+    }
+    public class TaiwanLunisolarCalendar : EastAsianLunisolarCalendar {
+        public TaiwanLunisolarCalendar();
+        protected override int DaysInYearBeforeMinSupportedYear { get; }
+        public override int[] Eras { get; }
+        public override DateTime MaxSupportedDateTime { get; }
+        public override DateTime MinSupportedDateTime { get; }
+        public override int GetEra(DateTime time);
+    }
+    public class TextElementEnumerator : IEnumerator {
+        public object Current { get; }
+        public int ElementIndex { get; }
+        public string GetTextElement();
+        public bool MoveNext();
+        public void Reset();
+    }
+    public class TextInfo {
+        public string CultureName { get; }
+        public bool IsReadOnly { get; }
+        public bool IsRightToLeft { get; }
+        public virtual string ListSeparator { get; set; }
+        public override bool Equals(object obj);
+        public override int GetHashCode();
+        public virtual char ToLower(char c);
+        public virtual string ToLower(string str);
+        public override string ToString();
+        public virtual char ToUpper(char c);
+        public virtual string ToUpper(string str);
+    }
+    public class ThaiBuddhistCalendar : Calendar {
+        public const int ThaiBuddhistEra = 1;
+        public ThaiBuddhistCalendar();
+        public override CalendarAlgorithmType AlgorithmType { get; }
+        public override int[] Eras { get; }
+        public override DateTime MaxSupportedDateTime { get; }
+        public override DateTime MinSupportedDateTime { get; }
+        public override int TwoDigitYearMax { get; set; }
+        public override DateTime AddMonths(DateTime time, int months);
+        public override DateTime AddYears(DateTime time, int years);
+        public override int GetDayOfMonth(DateTime time);
+        public override DayOfWeek GetDayOfWeek(DateTime time);
+        public override int GetDayOfYear(DateTime time);
+        public override int GetDaysInMonth(int year, int month, int era);
+        public override int GetDaysInYear(int year, int era);
+        public override int GetEra(DateTime time);
+        public override int GetLeapMonth(int year, int era);
+        public override int GetMonth(DateTime time);
+        public override int GetMonthsInYear(int year, int era);
+        public override int GetWeekOfYear(DateTime time, CalendarWeekRule rule, DayOfWeek firstDayOfWeek);
+        public override int GetYear(DateTime time);
+        public override bool IsLeapDay(int year, int month, int day, int era);
+        public override bool IsLeapMonth(int year, int month, int era);
+        public override bool IsLeapYear(int year, int era);
+        public override DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
+        public override int ToFourDigitYear(int year);
+    }
+    public enum TimeSpanStyles {
+        AssumeNegative = 1,
+        None = 0,
+    }
+    public class UmAlQuraCalendar : Calendar {
+        public UmAlQuraCalendar();
+        public override CalendarAlgorithmType AlgorithmType { get; }
+        protected override int DaysInYearBeforeMinSupportedYear { get; }
+        public override int[] Eras { get; }
+        public override DateTime MaxSupportedDateTime { get; }
+        public override DateTime MinSupportedDateTime { get; }
+        public override int TwoDigitYearMax { get; set; }
+        public override DateTime AddMonths(DateTime time, int months);
+        public override DateTime AddYears(DateTime time, int years);
+        public override int GetDayOfMonth(DateTime time);
+        public override DayOfWeek GetDayOfWeek(DateTime time);
+        public override int GetDayOfYear(DateTime time);
+        public override int GetDaysInMonth(int year, int month, int era);
+        public override int GetDaysInYear(int year, int era);
+        public override int GetEra(DateTime time);
+        public override int GetLeapMonth(int year, int era);
+        public override int GetMonth(DateTime time);
+        public override int GetMonthsInYear(int year, int era);
+        public override int GetYear(DateTime time);
+        public override bool IsLeapDay(int year, int month, int day, int era);
+        public override bool IsLeapMonth(int year, int month, int era);
+        public override bool IsLeapYear(int year, int era);
+        public override DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
+        public override int ToFourDigitYear(int year);
+    }
+    public enum UnicodeCategory {
+        ClosePunctuation = 21,
+        ConnectorPunctuation = 18,
+        Control = 14,
+        CurrencySymbol = 26,
+        DashPunctuation = 19,
+        DecimalDigitNumber = 8,
+        EnclosingMark = 7,
+        FinalQuotePunctuation = 23,
+        Format = 15,
+        InitialQuotePunctuation = 22,
+        LetterNumber = 9,
+        LineSeparator = 12,
+        LowercaseLetter = 1,
+        MathSymbol = 25,
+        ModifierLetter = 3,
+        ModifierSymbol = 27,
+        NonSpacingMark = 5,
+        OpenPunctuation = 20,
+        OtherLetter = 4,
+        OtherNotAssigned = 29,
+        OtherNumber = 10,
+        OtherPunctuation = 24,
+        OtherSymbol = 28,
+        ParagraphSeparator = 13,
+        PrivateUse = 17,
+        SpaceSeparator = 11,
+        SpacingCombiningMark = 6,
+        Surrogate = 16,
+        TitlecaseLetter = 2,
+        UppercaseLetter = 0,
+    }
+}
```

## System.IdentityModel

```c#
+namespace System.IdentityModel {
+    public class SecurityMessageSerializationException : Exception {
+        public SecurityMessageSerializationException();
+        public SecurityMessageSerializationException(string message);
+        public SecurityMessageSerializationException(string message, Exception innerException);
+    }
+}
```

## System.IdentityModel.Claims

```c#
+namespace System.IdentityModel.Claims {
+    public class Claim {
+        public Claim(string claimType, object resource, string right);
+        public string ClaimType { get; }
+        public static IEqualityComparer<Claim> DefaultComparer { get; }
+        public object Resource { get; }
+        public string Right { get; }
+        public static Claim System { get; }
+        public static Claim CreateDnsClaim(string dns);
+        public static Claim CreateHashClaim(byte[] hash);
+        public static Claim CreateNameClaim(string name);
+        public static Claim CreateSpnClaim(string spn);
+        public static Claim CreateThumbprintClaim(byte[] thumbprint);
+        public static Claim CreateUpnClaim(string upn);
+        public static Claim CreateUriClaim(Uri uri);
+        public static Claim CreateWindowsSidClaim(SecurityIdentifier sid);
+        public static Claim CreateX500DistinguishedNameClaim(X500DistinguishedName x500DistinguishedName);
+        public override bool Equals(object obj);
+        public override int GetHashCode();
+        public override string ToString();
+    }
+    public abstract class ClaimSet : IEnumerable, IEnumerable<Claim> {
+        protected ClaimSet();
+        public abstract int Count { get; }
+        public abstract ClaimSet Issuer { get; }
+        public static ClaimSet System { get; }
+        public abstract Claim this[int index] { get; }
+        public static ClaimSet Windows { get; }
+        public virtual bool ContainsClaim(Claim claim);
+        public virtual bool ContainsClaim(Claim claim, IEqualityComparer<Claim> comparer);
+        public abstract IEnumerable<Claim> FindClaims(string claimType, string right);
+        public abstract IEnumerator<Claim> GetEnumerator();
+        IEnumerator System.Collections.IEnumerable.GetEnumerator();
+    }
+    public static class ClaimTypes {
+        public static string Anonymous { get; }
+        public static string Authentication { get; }
+        public static string AuthorizationDecision { get; }
+        public static string Country { get; }
+        public static string DateOfBirth { get; }
+        public static string DenyOnlySid { get; }
+        public static string Dns { get; }
+        public static string Email { get; }
+        public static string Gender { get; }
+        public static string GivenName { get; }
+        public static string Hash { get; }
+        public static string HomePhone { get; }
+        public static string Locality { get; }
+        public static string MobilePhone { get; }
+        public static string Name { get; }
+        public static string NameIdentifier { get; }
+        public static string OtherPhone { get; }
+        public static string PostalCode { get; }
+        public static string PPID { get; }
+        public static string Rsa { get; }
+        public static string Sid { get; }
+        public static string Spn { get; }
+        public static string StateOrProvince { get; }
+        public static string StreetAddress { get; }
+        public static string Surname { get; }
+        public static string System { get; }
+        public static string Thumbprint { get; }
+        public static string Upn { get; }
+        public static string Uri { get; }
+        public static string Webpage { get; }
+        public static string X500DistinguishedName { get; }
+    }
+    public class DefaultClaimSet : ClaimSet {
+        public DefaultClaimSet(IList<Claim> claims);
+        public DefaultClaimSet(params Claim[] claims);
+        public DefaultClaimSet(ClaimSet issuer, IList<Claim> claims);
+        public DefaultClaimSet(ClaimSet issuer, params Claim[] claims);
+        public override int Count { get; }
+        public override ClaimSet Issuer { get; }
+        public override Claim this[int index] { get; }
+        public override bool ContainsClaim(Claim claim);
+        public override IEnumerable<Claim> FindClaims(string claimType, string right);
+        public override IEnumerator<Claim> GetEnumerator();
+        protected void Initialize(ClaimSet issuer, IList<Claim> claims);
+        public override string ToString();
+    }
+    public static class Rights {
+        public static string Identity { get; }
+        public static string PossessProperty { get; }
+    }
+    public class WindowsClaimSet : ClaimSet, IDisposable, IIdentityInfo {
+        public WindowsClaimSet(WindowsIdentity windowsIdentity);
+        public WindowsClaimSet(WindowsIdentity windowsIdentity, bool includeWindowsGroups);
+        public WindowsClaimSet(WindowsIdentity windowsIdentity, bool includeWindowsGroups, DateTime expirationTime);
+        public WindowsClaimSet(WindowsIdentity windowsIdentity, DateTime expirationTime);
+        public WindowsClaimSet(WindowsIdentity windowsIdentity, string authenticationType, bool includeWindowsGroups, DateTime expirationTime);
+        public override int Count { get; }
+        public DateTime ExpirationTime { get; }
+        public override ClaimSet Issuer { get; }
+        public override Claim this[int index] { get; }
+        public WindowsIdentity WindowsIdentity { get; }
+        public void Dispose();
+        public override IEnumerable<Claim> FindClaims(string claimType, string right);
+        public override IEnumerator<Claim> GetEnumerator();
+        public override string ToString();
+        public static bool TryCreateWindowsSidClaim(WindowsIdentity windowsIdentity, out Claim claim);
+    }
+    public class X509CertificateClaimSet : ClaimSet, IDisposable, IIdentityInfo {
+        public X509CertificateClaimSet(X509Certificate2 certificate);
+        public override int Count { get; }
+        public DateTime ExpirationTime { get; }
+        public override ClaimSet Issuer { get; }
+        public override Claim this[int index] { get; }
+        public X509Certificate2 X509Certificate { get; }
+        public void Dispose();
+        public override IEnumerable<Claim> FindClaims(string claimType, string right);
+        public override IEnumerator<Claim> GetEnumerator();
+        public override string ToString();
+    }
+}
```

## System.IdentityModel.Policy

```c#
+namespace System.IdentityModel.Policy {
+    public abstract class AuthorizationContext : IAuthorizationComponent {
+        protected AuthorizationContext();
+        public abstract ReadOnlyCollection<ClaimSet> ClaimSets { get; }
+        public abstract DateTime ExpirationTime { get; }
+        public abstract string Id { get; }
+        public abstract IDictionary<string, object> Properties { get; }
+        public static AuthorizationContext CreateDefaultAuthorizationContext(IList<IAuthorizationPolicy> authorizationPolicies);
+    }
+    public abstract class EvaluationContext {
+        protected EvaluationContext();
+        public abstract ReadOnlyCollection<ClaimSet> ClaimSets { get; }
+        public abstract int Generation { get; }
+        public abstract IDictionary<string, object> Properties { get; }
+        public abstract void AddClaimSet(IAuthorizationPolicy policy, ClaimSet claimSet);
+        public abstract void RecordExpirationTime(DateTime expirationTime);
+    }
+    public interface IAuthorizationComponent {
+        string Id { get; }
+    }
+    public interface IAuthorizationPolicy : IAuthorizationComponent {
+        ClaimSet Issuer { get; }
+        bool Evaluate(EvaluationContext evaluationContext, ref object state);
+    }
+}
```

## System.IdentityModel.Selectors

```c#
+namespace System.IdentityModel.Selectors {
+    public class KerberosSecurityTokenProvider : SecurityTokenProvider {
+        public KerberosSecurityTokenProvider(string servicePrincipalName);
+        public KerberosSecurityTokenProvider(string servicePrincipalName, TokenImpersonationLevel tokenImpersonationLevel);
+        public KerberosSecurityTokenProvider(string servicePrincipalName, TokenImpersonationLevel tokenImpersonationLevel, NetworkCredential networkCredential);
+        public NetworkCredential NetworkCredential { get; }
+        public string ServicePrincipalName { get; }
+        public TokenImpersonationLevel TokenImpersonationLevel { get; }
+        protected override Task<SecurityToken> GetTokenCoreAsync(CancellationToken cancellationToken);
+    }
+    public abstract class SecurityTokenAuthenticator {
+        protected SecurityTokenAuthenticator();
+        public bool CanValidateToken(SecurityToken token);
+        protected abstract bool CanValidateTokenCore(SecurityToken token);
+        public ReadOnlyCollection<IAuthorizationPolicy> ValidateToken(SecurityToken token);
+        protected abstract ReadOnlyCollection<IAuthorizationPolicy> ValidateTokenCore(SecurityToken token);
+    }
+    public abstract class SecurityTokenManager {
+        protected SecurityTokenManager();
+        public abstract SecurityTokenAuthenticator CreateSecurityTokenAuthenticator(SecurityTokenRequirement tokenRequirement, out SecurityTokenResolver outOfBandTokenResolver);
+        public abstract SecurityTokenProvider CreateSecurityTokenProvider(SecurityTokenRequirement tokenRequirement);
+        public abstract SecurityTokenSerializer CreateSecurityTokenSerializer(SecurityTokenVersion version);
+    }
+    public abstract class SecurityTokenProvider {
+        protected SecurityTokenProvider();
+        public virtual bool SupportsTokenCancellation { get; }
+        public virtual bool SupportsTokenRenewal { get; }
+        public Task CancelTokenAsync(CancellationToken cancellationToken, SecurityToken securityToken);
+        protected virtual Task CancelTokenCoreAsync(CancellationToken cancellationToken, SecurityToken token);
+        public Task<SecurityToken> GetTokenAsync(CancellationToken cancellationToken);
+        protected abstract Task<SecurityToken> GetTokenCoreAsync(CancellationToken cancellationToken);
+        public Task<SecurityToken> RenewTokenAsync(CancellationToken cancellationToken, SecurityToken tokenToBeRenewed);
+        protected virtual Task<SecurityToken> RenewTokenCoreAsync(CancellationToken cancellationToken, SecurityToken tokenToBeRenewed);
+    }
+    public class SecurityTokenRequirement {
+        public SecurityTokenRequirement();
+        public static string IsOptionalTokenProperty { get; }
+        public int KeySize { get; set; }
+        public static string KeySizeProperty { get; }
+        public SecurityKeyType KeyType { get; set; }
+        public static string KeyTypeProperty { get; }
+        public SecurityKeyUsage KeyUsage { get; set; }
+        public static string KeyUsageProperty { get; }
+        public static string PeerAuthenticationMode { get; }
+        public IDictionary<string, object> Properties { get; }
+        public bool RequireCryptographicToken { get; set; }
+        public static string RequireCryptographicTokenProperty { get; }
+        public string TokenType { get; set; }
+        public static string TokenTypeProperty { get; }
+        public TValue GetProperty<TValue>(string propertyName);
+        public bool TryGetProperty<TValue>(string propertyName, out TValue result);
+    }
+    public abstract class SecurityTokenResolver {
+        protected SecurityTokenResolver();
+    }
+    public abstract class SecurityTokenSerializer {
+        protected SecurityTokenSerializer();
+        public bool CanReadKeyIdentifier(XmlReader reader);
+        public bool CanReadKeyIdentifierClause(XmlReader reader);
+        protected abstract bool CanReadKeyIdentifierClauseCore(XmlReader reader);
+        protected abstract bool CanReadKeyIdentifierCore(XmlReader reader);
+        public bool CanReadToken(XmlReader reader);
+        protected abstract bool CanReadTokenCore(XmlReader reader);
+        public bool CanWriteKeyIdentifier(SecurityKeyIdentifier keyIdentifier);
+        public bool CanWriteKeyIdentifierClause(SecurityKeyIdentifierClause keyIdentifierClause);
+        protected abstract bool CanWriteKeyIdentifierClauseCore(SecurityKeyIdentifierClause keyIdentifierClause);
+        protected abstract bool CanWriteKeyIdentifierCore(SecurityKeyIdentifier keyIdentifier);
+        public bool CanWriteToken(SecurityToken token);
+        protected abstract bool CanWriteTokenCore(SecurityToken token);
+        public SecurityKeyIdentifier ReadKeyIdentifier(XmlReader reader);
+        public SecurityKeyIdentifierClause ReadKeyIdentifierClause(XmlReader reader);
+        protected abstract SecurityKeyIdentifierClause ReadKeyIdentifierClauseCore(XmlReader reader);
+        protected abstract SecurityKeyIdentifier ReadKeyIdentifierCore(XmlReader reader);
+        public SecurityToken ReadToken(XmlReader reader, SecurityTokenResolver tokenResolver);
+        protected abstract SecurityToken ReadTokenCore(XmlReader reader, SecurityTokenResolver tokenResolver);
+        public void WriteKeyIdentifier(XmlWriter writer, SecurityKeyIdentifier keyIdentifier);
+        public void WriteKeyIdentifierClause(XmlWriter writer, SecurityKeyIdentifierClause keyIdentifierClause);
+        protected abstract void WriteKeyIdentifierClauseCore(XmlWriter writer, SecurityKeyIdentifierClause keyIdentifierClause);
+        protected abstract void WriteKeyIdentifierCore(XmlWriter writer, SecurityKeyIdentifier keyIdentifier);
+        public void WriteToken(XmlWriter writer, SecurityToken token);
+        protected abstract void WriteTokenCore(XmlWriter writer, SecurityToken token);
+    }
+    public abstract class SecurityTokenVersion {
+        protected SecurityTokenVersion();
+        public abstract ReadOnlyCollection<string> GetSecuritySpecifications();
+    }
+    public class UserNameSecurityTokenProvider : SecurityTokenProvider {
+        public UserNameSecurityTokenProvider(string userName, string password);
+        protected override Task<SecurityToken> GetTokenCoreAsync(CancellationToken cancellationToken);
+    }
+    public class WindowsSecurityTokenAuthenticator : SecurityTokenAuthenticator {
+        public WindowsSecurityTokenAuthenticator();
+        public WindowsSecurityTokenAuthenticator(bool includeWindowsGroups);
+        protected override bool CanValidateTokenCore(SecurityToken token);
+        protected override ReadOnlyCollection<IAuthorizationPolicy> ValidateTokenCore(SecurityToken token);
+    }
+    public abstract class X509CertificateValidator {
+        protected X509CertificateValidator();
+        public static X509CertificateValidator ChainTrust { get; }
+        public static X509CertificateValidator None { get; }
+        public static X509CertificateValidator CreateChainTrustValidator(bool useMachineContext, X509ChainPolicy chainPolicy);
+        public abstract void Validate(X509Certificate2 certificate);
+    }
+    public class X509SecurityTokenAuthenticator : SecurityTokenAuthenticator {
+        public X509SecurityTokenAuthenticator();
+        public X509SecurityTokenAuthenticator(X509CertificateValidator validator);
+        public X509SecurityTokenAuthenticator(X509CertificateValidator validator, bool mapToWindows);
+        public X509SecurityTokenAuthenticator(X509CertificateValidator validator, bool mapToWindows, bool includeWindowsGroups);
+        protected override bool CanValidateTokenCore(SecurityToken token);
+        protected override ReadOnlyCollection<IAuthorizationPolicy> ValidateTokenCore(SecurityToken token);
+    }
+    public class X509SecurityTokenProvider : SecurityTokenProvider, IDisposable {
+        public X509SecurityTokenProvider(X509Certificate2 certificate);
+        public void Dispose();
+        protected override Task<SecurityToken> GetTokenCoreAsync(CancellationToken cancellationToken);
+    }
+}
```

## System.IdentityModel.Tokens

```c#
+namespace System.IdentityModel.Tokens {
+    public abstract class BinaryKeyIdentifierClause : SecurityKeyIdentifierClause {
+        protected BinaryKeyIdentifierClause(string clauseType, byte[] identificationData, bool cloneBuffer);
+        protected BinaryKeyIdentifierClause(string clauseType, byte[] identificationData, bool cloneBuffer, byte[] derivationNonce, int derivationLength);
+        public byte[] GetBuffer();
+        protected byte[] GetRawBuffer();
+        public bool Matches(byte[] data);
+        public bool Matches(byte[] data, int offset);
+        public override bool Matches(SecurityKeyIdentifierClause keyIdentifierClause);
+    }
+    public sealed class EncryptedKeyIdentifierClause : BinaryKeyIdentifierClause {
+        public EncryptedKeyIdentifierClause(byte[] encryptedKey, string encryptionMethod);
+        public EncryptedKeyIdentifierClause(byte[] encryptedKey, string encryptionMethod, SecurityKeyIdentifier encryptingKeyIdentifier);
+        public EncryptedKeyIdentifierClause(byte[] encryptedKey, string encryptionMethod, SecurityKeyIdentifier encryptingKeyIdentifier, string carriedKeyName);
+        public EncryptedKeyIdentifierClause(byte[] encryptedKey, string encryptionMethod, SecurityKeyIdentifier encryptingKeyIdentifier, string carriedKeyName, byte[] derivationNonce, int derivationLength);
+        public string CarriedKeyName { get; }
+        public SecurityKeyIdentifier EncryptingKeyIdentifier { get; }
+        public string EncryptionMethod { get; }
+        public byte[] GetEncryptedKey();
+        public bool Matches(byte[] encryptedKey, string encryptionMethod, string carriedKeyName);
+        public override bool Matches(SecurityKeyIdentifierClause keyIdentifierClause);
+        public override string ToString();
+    }
+    public class KerberosRequestorSecurityToken : SecurityToken {
+        public override string Id { get; }
+        public override ReadOnlyCollection<SecurityKey> SecurityKeys { get; }
+        public string ServicePrincipalName { get; }
+        public override DateTime ValidFrom { get; }
+        public override DateTime ValidTo { get; }
+    }
+    public class LocalIdKeyIdentifierClause : SecurityKeyIdentifierClause {
+        public LocalIdKeyIdentifierClause(string localId);
+        public LocalIdKeyIdentifierClause(string localId, byte[] derivationNonce, int derivationLength, Type ownerType);
+        public LocalIdKeyIdentifierClause(string localId, Type ownerType);
+        public string LocalId { get; }
+        public Type OwnerType { get; }
+        public override bool Matches(SecurityKeyIdentifierClause keyIdentifierClause);
+        public bool Matches(string localId, Type ownerType);
+        public override string ToString();
+    }
+    public class SamlSerializer {
+        public SamlSerializer();
+    }
+    public static class SecurityAlgorithms {
+        public const string Aes128Encryption = "http://www.w3.org/2001/04/xmlenc#aes128-cbc";
+        public const string Aes128KeyWrap = "http://www.w3.org/2001/04/xmlenc#kw-aes128";
+        public const string Aes192Encryption = "http://www.w3.org/2001/04/xmlenc#aes192-cbc";
+        public const string Aes192KeyWrap = "http://www.w3.org/2001/04/xmlenc#kw-aes192";
+        public const string Aes256Encryption = "http://www.w3.org/2001/04/xmlenc#aes256-cbc";
+        public const string Aes256KeyWrap = "http://www.w3.org/2001/04/xmlenc#kw-aes256";
+        public const string DesEncryption = "http://www.w3.org/2001/04/xmlenc#des-cbc";
+        public const string DsaSha1Signature = "http://www.w3.org/2000/09/xmldsig#dsa-sha1";
+        public const string ExclusiveC14n = "http://www.w3.org/2001/10/xml-exc-c14n#";
+        public const string ExclusiveC14nWithComments = "http://www.w3.org/2001/10/xml-exc-c14n#WithComments";
+        public const string HmacSha1Signature = "http://www.w3.org/2000/09/xmldsig#hmac-sha1";
+        public const string HmacSha256Signature = "http://www.w3.org/2001/04/xmldsig-more#hmac-sha256";
+        public const string Psha1KeyDerivation = "http://schemas.xmlsoap.org/ws/2005/02/sc/dk/p_sha1";
+        public const string Psha1KeyDerivationDec2005 = "http://docs.oasis-open.org/ws-sx/ws-secureconversation/200512/dk/p_sha1";
+        public const string Ripemd160Digest = "http://www.w3.org/2001/04/xmlenc#ripemd160";
+        public const string RsaOaepKeyWrap = "http://www.w3.org/2001/04/xmlenc#rsa-oaep-mgf1p";
+        public const string RsaSha1Signature = "http://www.w3.org/2000/09/xmldsig#rsa-sha1";
+        public const string RsaSha256Signature = "http://www.w3.org/2001/04/xmldsig-more#rsa-sha256";
+        public const string RsaV15KeyWrap = "http://www.w3.org/2001/04/xmlenc#rsa-1_5";
+        public const string Sha1Digest = "http://www.w3.org/2000/09/xmldsig#sha1";
+        public const string Sha256Digest = "http://www.w3.org/2001/04/xmlenc#sha256";
+        public const string Sha512Digest = "http://www.w3.org/2001/04/xmlenc#sha512";
+        public const string StrTransform = "http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-soap-message-security-1.0#STR-Transform";
+        public const string TlsSspiKeyWrap = "http://schemas.xmlsoap.org/2005/02/trust/tlsnego#TLS_Wrap";
+        public const string TripleDesEncryption = "http://www.w3.org/2001/04/xmlenc#tripledes-cbc";
+        public const string TripleDesKeyWrap = "http://www.w3.org/2001/04/xmlenc#kw-tripledes";
+        public const string WindowsSspiKeyWrap = "http://schemas.xmlsoap.org/2005/02/trust/spnego#GSS_Wrap";
+    }
+    public abstract class SecurityKey {
+        protected SecurityKey();
+        public abstract int KeySize { get; }
+        public abstract byte[] DecryptKey(string algorithm, byte[] keyData);
+        public abstract byte[] EncryptKey(string algorithm, byte[] keyData);
+        public abstract bool IsAsymmetricAlgorithm(string algorithm);
+        public abstract bool IsSupportedAlgorithm(string algorithm);
+        public abstract bool IsSymmetricAlgorithm(string algorithm);
+    }
+    public class SecurityKeyIdentifier : IEnumerable, IEnumerable<SecurityKeyIdentifierClause> {
+        public SecurityKeyIdentifier();
+        public SecurityKeyIdentifier(params SecurityKeyIdentifierClause[] clauses);
+        public bool CanCreateKey { get; }
+        public int Count { get; }
+        public bool IsReadOnly { get; }
+        public SecurityKeyIdentifierClause this[int index] { get; }
+        public void Add(SecurityKeyIdentifierClause clause);
+        public SecurityKey CreateKey();
+        public TClause Find<TClause>() where TClause : SecurityKeyIdentifierClause;
+        public IEnumerator<SecurityKeyIdentifierClause> GetEnumerator();
+        public void MakeReadOnly();
+        IEnumerator System.Collections.IEnumerable.GetEnumerator();
+        public override string ToString();
+        public bool TryFind<TClause>(out TClause clause) where TClause : SecurityKeyIdentifierClause;
+    }
+    public abstract class SecurityKeyIdentifierClause {
+        protected SecurityKeyIdentifierClause(string clauseType);
+        protected SecurityKeyIdentifierClause(string clauseType, byte[] nonce, int length);
+        public virtual bool CanCreateKey { get; }
+        public string ClauseType { get; }
+        public int DerivationLength { get; }
+        public string Id { get; set; }
+        public virtual SecurityKey CreateKey();
+        public byte[] GetDerivationNonce();
+        public virtual bool Matches(SecurityKeyIdentifierClause keyIdentifierClause);
+    }
+    public enum SecurityKeyType {
+        AsymmetricKey = 1,
+        BearerKey = 2,
+        SymmetricKey = 0,
+    }
+    public enum SecurityKeyUsage {
+        Exchange = 0,
+        Signature = 1,
+    }
+    public abstract class SecurityToken {
+        protected SecurityToken();
+        public abstract string Id { get; }
+        public abstract ReadOnlyCollection<SecurityKey> SecurityKeys { get; }
+        public abstract DateTime ValidFrom { get; }
+        public abstract DateTime ValidTo { get; }
+    }
+    public class SecurityTokenException : Exception {
+        public SecurityTokenException();
+        public SecurityTokenException(string message);
+        public SecurityTokenException(string message, Exception innerException);
+    }
+    public static class SecurityTokenTypes {
+        public static string Kerberos { get; }
+        public static string Rsa { get; }
+        public static string Saml { get; }
+        public static string UserName { get; }
+        public static string X509Certificate { get; }
+    }
+    public class SecurityTokenValidationException : SecurityTokenException {
+        public SecurityTokenValidationException();
+        public SecurityTokenValidationException(string message);
+        public SecurityTokenValidationException(string message, Exception innerException);
+    }
+    public class UserNameSecurityToken : SecurityToken {
+        public UserNameSecurityToken(string userName, string password);
+        public UserNameSecurityToken(string userName, string password, string id);
+        public override string Id { get; }
+        public string Password { get; }
+        public override ReadOnlyCollection<SecurityKey> SecurityKeys { get; }
+        public string UserName { get; }
+        public override DateTime ValidFrom { get; }
+        public override DateTime ValidTo { get; }
+    }
+    public class WindowsSecurityToken : SecurityToken, IDisposable {
+        protected WindowsSecurityToken();
+        public WindowsSecurityToken(WindowsIdentity windowsIdentity);
+        public WindowsSecurityToken(WindowsIdentity windowsIdentity, string id);
+        public WindowsSecurityToken(WindowsIdentity windowsIdentity, string id, string authenticationType);
+        public string AuthenticationType { get; }
+        public override string Id { get; }
+        public override ReadOnlyCollection<SecurityKey> SecurityKeys { get; }
+        public override DateTime ValidFrom { get; }
+        public override DateTime ValidTo { get; }
+        public virtual WindowsIdentity WindowsIdentity { get; }
+        public virtual void Dispose();
+        protected void Initialize(string id, DateTime effectiveTime, DateTime expirationTime, WindowsIdentity windowsIdentity, bool clone);
+        protected void Initialize(string id, string authenticationType, DateTime effectiveTime, DateTime expirationTime, WindowsIdentity windowsIdentity, bool clone);
+        protected void ThrowIfDisposed();
+    }
+    public class X509SecurityToken : SecurityToken, IDisposable {
+        public X509SecurityToken(X509Certificate2 certificate);
+        public X509SecurityToken(X509Certificate2 certificate, string id);
+        public X509Certificate2 Certificate { get; }
+        public override string Id { get; }
+        public override ReadOnlyCollection<SecurityKey> SecurityKeys { get; }
+        public override DateTime ValidFrom { get; }
+        public override DateTime ValidTo { get; }
+        public virtual void Dispose();
+        protected void ThrowIfDisposed();
+    }
+}
```

## System.IO

```c#
+namespace System.IO {
+    public class BinaryReader : IDisposable {
+        public BinaryReader(Stream input);
+        public BinaryReader(Stream input, Encoding encoding);
+        public BinaryReader(Stream input, Encoding encoding, bool leaveOpen);
+        public virtual Stream BaseStream { get; }
+        public virtual void Close();
+        public void Dispose();
+        protected virtual void Dispose(bool disposing);
+        protected virtual void FillBuffer(int numBytes);
+        public virtual int PeekChar();
+        public virtual int Read();
+        public virtual int Read(byte[] buffer, int index, int count);
+        public virtual int Read(char[] buffer, int index, int count);
+        protected internal int Read7BitEncodedInt();
+        public virtual bool ReadBoolean();
+        public virtual byte ReadByte();
+        public virtual byte[] ReadBytes(int count);
+        public virtual char ReadChar();
+        public virtual char[] ReadChars(int count);
+        public virtual decimal ReadDecimal();
+        public virtual double ReadDouble();
+        public virtual short ReadInt16();
+        public virtual int ReadInt32();
+        public virtual long ReadInt64();
+        public virtual sbyte ReadSByte();
+        public virtual float ReadSingle();
+        public virtual string ReadString();
+        public virtual ushort ReadUInt16();
+        public virtual uint ReadUInt32();
+        public virtual ulong ReadUInt64();
+    }
+    public class BinaryWriter : IDisposable {
+        public static readonly BinaryWriter Null;
+        protected Stream OutStream;
+        protected BinaryWriter();
+        public BinaryWriter(Stream output);
+        public BinaryWriter(Stream output, Encoding encoding);
+        public BinaryWriter(Stream output, Encoding encoding, bool leaveOpen);
+        public virtual Stream BaseStream { get; }
+        public virtual void Close();
+        public void Dispose();
+        protected virtual void Dispose(bool disposing);
+        public virtual void Flush();
+        public virtual long Seek(int offset, SeekOrigin origin);
+        public virtual void Write(bool value);
+        public virtual void Write(byte value);
+        public virtual void Write(byte[] buffer);
+        public virtual void Write(byte[] buffer, int index, int count);
+        public virtual void Write(char ch);
+        public virtual void Write(char[] chars);
+        public virtual void Write(char[] chars, int index, int count);
+        public virtual void Write(decimal value);
+        public virtual void Write(double value);
+        public virtual void Write(short value);
+        public virtual void Write(int value);
+        public virtual void Write(long value);
+        public virtual void Write(sbyte value);
+        public virtual void Write(float value);
+        public virtual void Write(string value);
+        public virtual void Write(ushort value);
+        public virtual void Write(uint value);
+        public virtual void Write(ulong value);
+        protected void Write7BitEncodedInt(int value);
+    }
+    public sealed class BufferedStream : Stream {
+        public BufferedStream(Stream stream);
+        public BufferedStream(Stream stream, int bufferSize);
+        public override bool CanRead { get; }
+        public override bool CanSeek { get; }
+        public override bool CanWrite { get; }
+        public override long Length { get; }
+        public override long Position { get; set; }
+        protected override void Dispose(bool disposing);
+        public override void Flush();
+        public override Task FlushAsync(CancellationToken cancellationToken);
+        public override int Read(byte[] array, int offset, int count);
+        public override Task<int> ReadAsync(byte[] buffer, int offset, int count, CancellationToken cancellationToken);
+        public override int ReadByte();
+        public override long Seek(long offset, SeekOrigin origin);
+        public override void SetLength(long value);
+        public override void Write(byte[] array, int offset, int count);
+        public override Task WriteAsync(byte[] buffer, int offset, int count, CancellationToken cancellationToken);
+        public override void WriteByte(byte value);
+    }
+    public static class Directory {
+        public static DirectoryInfo CreateDirectory(string path);
+        public static void Delete(string path);
+        public static void Delete(string path, bool recursive);
+        public static IEnumerable<string> EnumerateDirectories(string path);
+        public static IEnumerable<string> EnumerateDirectories(string path, string searchPattern);
+        public static IEnumerable<string> EnumerateDirectories(string path, string searchPattern, SearchOption searchOption);
+        public static IEnumerable<string> EnumerateFiles(string path);
+        public static IEnumerable<string> EnumerateFiles(string path, string searchPattern);
+        public static IEnumerable<string> EnumerateFiles(string path, string searchPattern, SearchOption searchOption);
+        public static IEnumerable<string> EnumerateFileSystemEntries(string path);
+        public static IEnumerable<string> EnumerateFileSystemEntries(string path, string searchPattern);
+        public static IEnumerable<string> EnumerateFileSystemEntries(string path, string searchPattern, SearchOption searchOption);
+        public static bool Exists(string path);
+        public static DateTime GetCreationTime(string path);
+        public static DateTime GetCreationTimeUtc(string path);
+        public static string GetCurrentDirectory();
+        public static string[] GetDirectories(string path);
+        public static string[] GetDirectories(string path, string searchPattern);
+        public static string[] GetDirectories(string path, string searchPattern, SearchOption searchOption);
+        public static string GetDirectoryRoot(string path);
+        public static string[] GetFiles(string path);
+        public static string[] GetFiles(string path, string searchPattern);
+        public static string[] GetFiles(string path, string searchPattern, SearchOption searchOption);
+        public static string[] GetFileSystemEntries(string path);
+        public static string[] GetFileSystemEntries(string path, string searchPattern);
+        public static string[] GetFileSystemEntries(string path, string searchPattern, SearchOption searchOption);
+        public static DateTime GetLastAccessTime(string path);
+        public static DateTime GetLastAccessTimeUtc(string path);
+        public static DateTime GetLastWriteTime(string path);
+        public static DateTime GetLastWriteTimeUtc(string path);
+        public static DirectoryInfo GetParent(string path);
+        public static void Move(string sourceDirName, string destDirName);
+        public static void SetCreationTime(string path, DateTime creationTime);
+        public static void SetCreationTimeUtc(string path, DateTime creationTimeUtc);
+        public static void SetCurrentDirectory(string path);
+        public static void SetLastAccessTime(string path, DateTime lastAccessTime);
+        public static void SetLastAccessTimeUtc(string path, DateTime lastAccessTimeUtc);
+        public static void SetLastWriteTime(string path, DateTime lastWriteTime);
+        public static void SetLastWriteTimeUtc(string path, DateTime lastWriteTimeUtc);
+    }
+    public sealed class DirectoryInfo : FileSystemInfo {
+        public DirectoryInfo(string path);
+        public override bool Exists { get; }
+        public override string Name { get; }
+        public DirectoryInfo Parent { get; }
+        public DirectoryInfo Root { get; }
+        public void Create();
+        public DirectoryInfo CreateSubdirectory(string path);
+        public override void Delete();
+        public void Delete(bool recursive);
+        public IEnumerable<DirectoryInfo> EnumerateDirectories();
+        public IEnumerable<DirectoryInfo> EnumerateDirectories(string searchPattern);
+        public IEnumerable<DirectoryInfo> EnumerateDirectories(string searchPattern, SearchOption searchOption);
+        public IEnumerable<FileInfo> EnumerateFiles();
+        public IEnumerable<FileInfo> EnumerateFiles(string searchPattern);
+        public IEnumerable<FileInfo> EnumerateFiles(string searchPattern, SearchOption searchOption);
+        public IEnumerable<FileSystemInfo> EnumerateFileSystemInfos();
+        public IEnumerable<FileSystemInfo> EnumerateFileSystemInfos(string searchPattern);
+        public IEnumerable<FileSystemInfo> EnumerateFileSystemInfos(string searchPattern, SearchOption searchOption);
+        public DirectoryInfo[] GetDirectories();
+        public DirectoryInfo[] GetDirectories(string searchPattern);
+        public DirectoryInfo[] GetDirectories(string searchPattern, SearchOption searchOption);
+        public FileInfo[] GetFiles();
+        public FileInfo[] GetFiles(string searchPattern);
+        public FileInfo[] GetFiles(string searchPattern, SearchOption searchOption);
+        public FileSystemInfo[] GetFileSystemInfos();
+        public FileSystemInfo[] GetFileSystemInfos(string searchPattern);
+        public FileSystemInfo[] GetFileSystemInfos(string searchPattern, SearchOption searchOption);
+        public void MoveTo(string destDirName);
+        public override string ToString();
+    }
+    public class DirectoryNotFoundException : IOException {
+        public DirectoryNotFoundException();
+        public DirectoryNotFoundException(string message);
+        public DirectoryNotFoundException(string message, Exception innerException);
+    }
+    public sealed class DriveInfo {
+        public DriveInfo(string driveName);
+        public long AvailableFreeSpace { get; }
+        public string DriveFormat { get; }
+        public DriveType DriveType { get; }
+        public bool IsReady { get; }
+        public string Name { get; }
+        public DirectoryInfo RootDirectory { get; }
+        public long TotalFreeSpace { get; }
+        public long TotalSize { get; }
+        public string VolumeLabel { get; set; }
+        public static DriveInfo[] GetDrives();
+        public override string ToString();
+    }
+    public class DriveNotFoundException : IOException {
+        public DriveNotFoundException();
+        public DriveNotFoundException(string message);
+        public DriveNotFoundException(string message, Exception innerException);
+    }
+    public enum DriveType {
+        CDRom = 5,
+        Fixed = 3,
+        Network = 4,
+        NoRootDirectory = 1,
+        Ram = 6,
+        Removable = 2,
+        Unknown = 0,
+    }
+    public class EndOfStreamException : IOException {
+        public EndOfStreamException();
+        public EndOfStreamException(string message);
+        public EndOfStreamException(string message, Exception innerException);
+    }
+    public class ErrorEventArgs : EventArgs {
+        public ErrorEventArgs(Exception exception);
+        public virtual Exception GetException();
+    }
+    public delegate void ErrorEventHandler(object sender, ErrorEventArgs e);
+    public static class File {
+        public static void AppendAllLines(string path, IEnumerable<string> contents);
+        public static void AppendAllLines(string path, IEnumerable<string> contents, Encoding encoding);
+        public static void AppendAllText(string path, string contents);
+        public static void AppendAllText(string path, string contents, Encoding encoding);
+        public static StreamWriter AppendText(string path);
+        public static void Copy(string sourceFileName, string destFileName);
+        public static void Copy(string sourceFileName, string destFileName, bool overwrite);
+        public static FileStream Create(string path);
+        public static FileStream Create(string path, int bufferSize);
+        public static FileStream Create(string path, int bufferSize, FileOptions options);
+        public static StreamWriter CreateText(string path);
+        public static void Delete(string path);
+        public static bool Exists(string path);
+        public static FileAttributes GetAttributes(string path);
+        public static DateTime GetCreationTime(string path);
+        public static DateTime GetCreationTimeUtc(string path);
+        public static DateTime GetLastAccessTime(string path);
+        public static DateTime GetLastAccessTimeUtc(string path);
+        public static DateTime GetLastWriteTime(string path);
+        public static DateTime GetLastWriteTimeUtc(string path);
+        public static void Move(string sourceFileName, string destFileName);
+        public static FileStream Open(string path, FileMode mode);
+        public static FileStream Open(string path, FileMode mode, FileAccess access);
+        public static FileStream Open(string path, FileMode mode, FileAccess access, FileShare share);
+        public static FileStream OpenRead(string path);
+        public static StreamReader OpenText(string path);
+        public static FileStream OpenWrite(string path);
+        public static byte[] ReadAllBytes(string path);
+        public static string[] ReadAllLines(string path);
+        public static string[] ReadAllLines(string path, Encoding encoding);
+        public static string ReadAllText(string path);
+        public static string ReadAllText(string path, Encoding encoding);
+        public static IEnumerable<string> ReadLines(string path);
+        public static IEnumerable<string> ReadLines(string path, Encoding encoding);
+        public static void SetAttributes(string path, FileAttributes fileAttributes);
+        public static void SetCreationTime(string path, DateTime creationTime);
+        public static void SetCreationTimeUtc(string path, DateTime creationTimeUtc);
+        public static void SetLastAccessTime(string path, DateTime lastAccessTime);
+        public static void SetLastAccessTimeUtc(string path, DateTime lastAccessTimeUtc);
+        public static void SetLastWriteTime(string path, DateTime lastWriteTime);
+        public static void SetLastWriteTimeUtc(string path, DateTime lastWriteTimeUtc);
+        public static void WriteAllBytes(string path, byte[] bytes);
+        public static void WriteAllLines(string path, IEnumerable<string> contents);
+        public static void WriteAllLines(string path, IEnumerable<string> contents, Encoding encoding);
+        public static void WriteAllText(string path, string contents);
+        public static void WriteAllText(string path, string contents, Encoding encoding);
+    }
+    public enum FileAccess {
+        Read = 1,
+        ReadWrite = 3,
+        Write = 2,
+    }
+    public enum FileAttributes {
+        Archive = 32,
+        Compressed = 2048,
+        Device = 64,
+        Directory = 16,
+        Encrypted = 16384,
+        Hidden = 2,
+        IntegrityStream = 32768,
+        Normal = 128,
+        NoScrubData = 131072,
+        NotContentIndexed = 8192,
+        Offline = 4096,
+        ReadOnly = 1,
+        ReparsePoint = 1024,
+        SparseFile = 512,
+        System = 4,
+        Temporary = 256,
+    }
+    public class FileFormatException : FormatException {
+        public FileFormatException();
+        public FileFormatException(string message);
+        public FileFormatException(string message, Exception innerException);
+        public FileFormatException(Uri sourceUri);
+        public FileFormatException(Uri sourceUri, Exception innerException);
+        public FileFormatException(Uri sourceUri, string message);
+        public FileFormatException(Uri sourceUri, string message, Exception innerException);
+        public Uri SourceUri { get; }
+    }
+    public sealed class FileInfo : FileSystemInfo {
+        public FileInfo(string fileName);
+        public DirectoryInfo Directory { get; }
+        public string DirectoryName { get; }
+        public override bool Exists { get; }
+        public bool IsReadOnly { get; set; }
+        public long Length { get; }
+        public override string Name { get; }
+        public StreamWriter AppendText();
+        public FileInfo CopyTo(string destFileName);
+        public FileInfo CopyTo(string destFileName, bool overwrite);
+        public FileStream Create();
+        public StreamWriter CreateText();
+        public override void Delete();
+        public void MoveTo(string destFileName);
+        public FileStream Open(FileMode mode);
+        public FileStream Open(FileMode mode, FileAccess access);
+        public FileStream Open(FileMode mode, FileAccess access, FileShare share);
+        public FileStream OpenRead();
+        public StreamReader OpenText();
+        public FileStream OpenWrite();
+        public override string ToString();
+    }
+    public class FileLoadException : IOException {
+        public FileLoadException();
+        public FileLoadException(string message);
+        public FileLoadException(string message, Exception inner);
+        public FileLoadException(string message, string fileName);
+        public FileLoadException(string message, string fileName, Exception inner);
+        public string FileName { get; }
+        public override string Message { get; }
+        public override string ToString();
+    }
+    public enum FileMode {
+        Append = 6,
+        Create = 2,
+        CreateNew = 1,
+        Open = 3,
+        OpenOrCreate = 4,
+        Truncate = 5,
+    }
+    public class FileNotFoundException : IOException {
+        public FileNotFoundException();
+        public FileNotFoundException(string message);
+        public FileNotFoundException(string message, Exception innerException);
+        public FileNotFoundException(string message, string fileName);
+        public FileNotFoundException(string message, string fileName, Exception innerException);
+        public string FileName { get; }
+        public override string Message { get; }
+        public override string ToString();
+    }
+    public enum FileOptions {
+        Asynchronous = 1073741824,
+        DeleteOnClose = 67108864,
+        Encrypted = 16384,
+        None = 0,
+        RandomAccess = 268435456,
+        SequentialScan = 134217728,
+        WriteThrough = -2147483648,
+    }
+    public enum FileShare {
+        Delete = 4,
+        Inheritable = 16,
+        None = 0,
+        Read = 1,
+        ReadWrite = 3,
+        Write = 2,
+    }
+    public class FileStream : Stream {
+        public FileStream(SafeFileHandle handle, FileAccess access);
+        public FileStream(SafeFileHandle handle, FileAccess access, int bufferSize);
+        public FileStream(SafeFileHandle handle, FileAccess access, int bufferSize, bool isAsync);
+        public FileStream(string path, FileMode mode);
+        public FileStream(string path, FileMode mode, FileAccess access);
+        public FileStream(string path, FileMode mode, FileAccess access, FileShare share);
+        public FileStream(string path, FileMode mode, FileAccess access, FileShare share, int bufferSize);
+        public FileStream(string path, FileMode mode, FileAccess access, FileShare share, int bufferSize, bool useAsync);
+        public FileStream(string path, FileMode mode, FileAccess access, FileShare share, int bufferSize, FileOptions options);
+        public override bool CanRead { get; }
+        public override bool CanSeek { get; }
+        public override bool CanWrite { get; }
+        public virtual bool IsAsync { get; }
+        public override long Length { get; }
+        public string Name { get; }
+        public override long Position { get; set; }
+        public virtual SafeFileHandle SafeFileHandle { get; }
+        protected override void Dispose(bool disposing);
+        ~FileStream();
+        public override void Flush();
+        public virtual void Flush(bool flushToDisk);
+        public override Task FlushAsync(CancellationToken cancellationToken);
+        public override int Read(byte[] array, int offset, int count);
+        public override Task<int> ReadAsync(byte[] buffer, int offset, int count, CancellationToken cancellationToken);
+        public override int ReadByte();
+        public override long Seek(long offset, SeekOrigin origin);
+        public override void SetLength(long value);
+        public override void Write(byte[] array, int offset, int count);
+        public override Task WriteAsync(byte[] buffer, int offset, int count, CancellationToken cancellationToken);
+        public override void WriteByte(byte value);
+    }
+    public static class FileSystemAclExtensions {
+        public static DirectorySecurity GetAccessControl(this DirectoryInfo directoryInfo);
+        public static DirectorySecurity GetAccessControl(this DirectoryInfo directoryInfo, AccessControlSections includeSections);
+        public static FileSecurity GetAccessControl(this FileInfo fileInfo);
+        public static FileSecurity GetAccessControl(this FileInfo fileInfo, AccessControlSections includeSections);
+        public static FileSecurity GetAccessControl(this FileStream fileStream);
+        public static void SetAccessControl(this DirectoryInfo directoryInfo, DirectorySecurity directorySecurity);
+        public static void SetAccessControl(this FileInfo fileInfo, FileSecurity fileSecurity);
+        public static void SetAccessControl(this FileStream fileStream, FileSecurity fileSecurity);
+    }
+    public class FileSystemEventArgs : EventArgs {
+        public FileSystemEventArgs(WatcherChangeTypes changeType, string directory, string name);
+        public WatcherChangeTypes ChangeType { get; }
+        public string FullPath { get; }
+        public string Name { get; }
+    }
+    public delegate void FileSystemEventHandler(object sender, FileSystemEventArgs e);
+    public abstract class FileSystemInfo {
+        protected string FullPath;
+        protected string OriginalPath;
+        protected FileSystemInfo();
+        public FileAttributes Attributes { get; set; }
+        public DateTime CreationTime { get; set; }
+        public DateTime CreationTimeUtc { get; set; }
+        public abstract bool Exists { get; }
+        public string Extension { get; }
+        public virtual string FullName { get; }
+        public DateTime LastAccessTime { get; set; }
+        public DateTime LastAccessTimeUtc { get; set; }
+        public DateTime LastWriteTime { get; set; }
+        public DateTime LastWriteTimeUtc { get; set; }
+        public abstract string Name { get; }
+        public abstract void Delete();
+        public void Refresh();
+    }
+    public class FileSystemWatcher : IDisposable {
+        public FileSystemWatcher();
+        public FileSystemWatcher(string path);
+        public FileSystemWatcher(string path, string filter);
+        public bool EnableRaisingEvents { get; set; }
+        public string Filter { get; set; }
+        public bool IncludeSubdirectories { get; set; }
+        public int InternalBufferSize { get; set; }
+        public NotifyFilters NotifyFilter { get; set; }
+        public string Path { get; set; }
+        public event FileSystemEventHandler Changed;
+        public event FileSystemEventHandler Created;
+        public event FileSystemEventHandler Deleted;
+        public event ErrorEventHandler Error;
+        public event RenamedEventHandler Renamed;
+        public void Dispose();
+        protected virtual void Dispose(bool disposing);
+        protected void OnChanged(FileSystemEventArgs e);
+        protected void OnCreated(FileSystemEventArgs e);
+        protected void OnDeleted(FileSystemEventArgs e);
+        protected void OnError(ErrorEventArgs e);
+        protected void OnRenamed(RenamedEventArgs e);
+        public WaitForChangedResult WaitForChanged(WatcherChangeTypes changeType);
+        public WaitForChangedResult WaitForChanged(WatcherChangeTypes changeType, int timeout);
+    }
+    public enum HandleInheritability {
+        Inheritable = 1,
+        None = 0,
+    }
+    public sealed class InvalidDataException : Exception {
+        public InvalidDataException();
+        public InvalidDataException(string message);
+        public InvalidDataException(string message, Exception innerException);
+    }
+    public class IOException : Exception {
+        public IOException();
+        public IOException(string message);
+        public IOException(string message, Exception innerException);
+        public IOException(string message, int hresult);
+    }
+    public class MemoryStream : Stream {
+        public MemoryStream();
+        public MemoryStream(byte[] buffer);
+        public MemoryStream(byte[] buffer, bool writable);
+        public MemoryStream(byte[] buffer, int index, int count);
+        public MemoryStream(byte[] buffer, int index, int count, bool writable);
+        public MemoryStream(byte[] buffer, int index, int count, bool writable, bool publiclyVisible);
+        public MemoryStream(int capacity);
+        public override bool CanRead { get; }
+        public override bool CanSeek { get; }
+        public override bool CanWrite { get; }
+        public virtual int Capacity { get; set; }
+        public override long Length { get; }
+        public override long Position { get; set; }
+        public override Task CopyToAsync(Stream destination, int bufferSize, CancellationToken cancellationToken);
+        protected override void Dispose(bool disposing);
+        public override void Flush();
+        public override Task FlushAsync(CancellationToken cancellationToken);
+        public virtual byte[] GetBuffer();
+        public override int Read(byte[] buffer, int offset, int count);
+        public override Task<int> ReadAsync(byte[] buffer, int offset, int count, CancellationToken cancellationToken);
+        public override int ReadByte();
+        public override long Seek(long offset, SeekOrigin loc);
+        public override void SetLength(long value);
+        public virtual byte[] ToArray();
+        public virtual bool TryGetBuffer(out ArraySegment<byte> buffer);
+        public override void Write(byte[] buffer, int offset, int count);
+        public override Task WriteAsync(byte[] buffer, int offset, int count, CancellationToken cancellationToken);
+        public override void WriteByte(byte value);
+        public virtual void WriteTo(Stream stream);
+    }
+    public enum NotifyFilters {
+        Attributes = 4,
+        CreationTime = 64,
+        DirectoryName = 2,
+        FileName = 1,
+        LastAccess = 32,
+        LastWrite = 16,
+        Security = 256,
+        Size = 8,
+    }
+    public static class Path {
+        public static readonly char AltDirectorySeparatorChar;
+        public static readonly char DirectorySeparatorChar;
+        public static readonly char PathSeparator;
+        public static readonly char VolumeSeparatorChar;
+        public static string ChangeExtension(string path, string extension);
+        public static string Combine(string path1, string path2);
+        public static string Combine(string path1, string path2, string path3);
+        public static string Combine(params string[] paths);
+        public static string GetDirectoryName(string path);
+        public static string GetExtension(string path);
+        public static string GetFileName(string path);
+        public static string GetFileNameWithoutExtension(string path);
+        public static string GetFullPath(string path);
+        public static char[] GetInvalidFileNameChars();
+        public static char[] GetInvalidPathChars();
+        public static string GetPathRoot(string path);
+        public static string GetRandomFileName();
+        public static string GetTempFileName();
+        public static string GetTempPath();
+        public static bool HasExtension(string path);
+        public static bool IsPathRooted(string path);
+    }
+    public class PathTooLongException : IOException {
+        public PathTooLongException();
+        public PathTooLongException(string message);
+        public PathTooLongException(string message, Exception innerException);
+    }
+    public class RenamedEventArgs : FileSystemEventArgs {
+        public RenamedEventArgs(WatcherChangeTypes changeType, string directory, string name, string oldName);
+        public string OldFullPath { get; }
+        public string OldName { get; }
+    }
+    public delegate void RenamedEventHandler(object sender, RenamedEventArgs e);
+    public enum SearchOption {
+        AllDirectories = 1,
+        TopDirectoryOnly = 0,
+    }
+    public enum SeekOrigin {
+        Begin = 0,
+        Current = 1,
+        End = 2,
+    }
+    public abstract class Stream : IDisposable {
+        public static readonly Stream Null;
+        protected Stream();
+        public abstract bool CanRead { get; }
+        public abstract bool CanSeek { get; }
+        public virtual bool CanTimeout { get; }
+        public abstract bool CanWrite { get; }
+        public abstract long Length { get; }
+        public abstract long Position { get; set; }
+        public virtual int ReadTimeout { get; set; }
+        public virtual int WriteTimeout { get; set; }
+        public virtual IAsyncResult BeginRead(byte[] buffer, int offset, int count, AsyncCallback callback, object state);
+        public virtual IAsyncResult BeginWrite(byte[] buffer, int offset, int count, AsyncCallback callback, object state);
+        public virtual void Close();
+        public void CopyTo(Stream destination);
+        public void CopyTo(Stream destination, int bufferSize);
+        public Task CopyToAsync(Stream destination);
+        public Task CopyToAsync(Stream destination, int bufferSize);
+        public virtual Task CopyToAsync(Stream destination, int bufferSize, CancellationToken cancellationToken);
+        public void Dispose();
+        protected virtual void Dispose(bool disposing);
+        public virtual int EndRead(IAsyncResult asyncResult);
+        public virtual void EndWrite(IAsyncResult asyncResult);
+        public abstract void Flush();
+        public Task FlushAsync();
+        public virtual Task FlushAsync(CancellationToken cancellationToken);
+        public abstract int Read(byte[] buffer, int offset, int count);
+        public Task<int> ReadAsync(byte[] buffer, int offset, int count);
+        public virtual Task<int> ReadAsync(byte[] buffer, int offset, int count, CancellationToken cancellationToken);
+        public virtual int ReadByte();
+        public abstract long Seek(long offset, SeekOrigin origin);
+        public abstract void SetLength(long value);
+        public abstract void Write(byte[] buffer, int offset, int count);
+        public Task WriteAsync(byte[] buffer, int offset, int count);
+        public virtual Task WriteAsync(byte[] buffer, int offset, int count, CancellationToken cancellationToken);
+        public virtual void WriteByte(byte value);
+    }
+    public class StreamReader : TextReader {
+        public static readonly new StreamReader Null;
+        public StreamReader(Stream stream);
+        public StreamReader(Stream stream, bool detectEncodingFromByteOrderMarks);
+        public StreamReader(Stream stream, Encoding encoding);
+        public StreamReader(Stream stream, Encoding encoding, bool detectEncodingFromByteOrderMarks);
+        public StreamReader(Stream stream, Encoding encoding, bool detectEncodingFromByteOrderMarks, int bufferSize);
+        public StreamReader(Stream stream, Encoding encoding, bool detectEncodingFromByteOrderMarks, int bufferSize, bool leaveOpen);
+        public StreamReader(string path);
+        public StreamReader(string path, bool detectEncodingFromByteOrderMarks);
+        public StreamReader(string path, Encoding encoding);
+        public StreamReader(string path, Encoding encoding, bool detectEncodingFromByteOrderMarks);
+        public StreamReader(string path, Encoding encoding, bool detectEncodingFromByteOrderMarks, int bufferSize);
+        public virtual Stream BaseStream { get; }
+        public virtual Encoding CurrentEncoding { get; }
+        public bool EndOfStream { get; }
+        public override void Close();
+        public void DiscardBufferedData();
+        protected override void Dispose(bool disposing);
+        public override int Peek();
+        public override int Read();
+        public override int Read(char[] buffer, int index, int count);
+        public override Task<int> ReadAsync(char[] buffer, int index, int count);
+        public override int ReadBlock(char[] buffer, int index, int count);
+        public override Task<int> ReadBlockAsync(char[] buffer, int index, int count);
+        public override string ReadLine();
+        public override Task<string> ReadLineAsync();
+        public override string ReadToEnd();
+        public override Task<string> ReadToEndAsync();
+    }
+    public class StreamWriter : TextWriter {
+        public static readonly new StreamWriter Null;
+        public StreamWriter(Stream stream);
+        public StreamWriter(Stream stream, Encoding encoding);
+        public StreamWriter(Stream stream, Encoding encoding, int bufferSize);
+        public StreamWriter(Stream stream, Encoding encoding, int bufferSize, bool leaveOpen);
+        public StreamWriter(string path);
+        public StreamWriter(string path, bool append);
+        public StreamWriter(string path, bool append, Encoding encoding);
+        public StreamWriter(string path, bool append, Encoding encoding, int bufferSize);
+        public virtual bool AutoFlush { get; set; }
+        public virtual Stream BaseStream { get; }
+        public override Encoding Encoding { get; }
+        public override void Close();
+        protected override void Dispose(bool disposing);
+        public override void Flush();
+        public override Task FlushAsync();
+        public override void Write(char value);
+        public override void Write(char[] buffer);
+        public override void Write(char[] buffer, int index, int count);
+        public override void Write(string value);
+        public override Task WriteAsync(char value);
+        public override Task WriteAsync(char[] buffer, int index, int count);
+        public override Task WriteAsync(string value);
+        public override Task WriteLineAsync();
+        public override Task WriteLineAsync(char value);
+        public override Task WriteLineAsync(char[] buffer, int index, int count);
+        public override Task WriteLineAsync(string value);
+    }
+    public class StringReader : TextReader {
+        public StringReader(string s);
+        public override void Close();
+        protected override void Dispose(bool disposing);
+        public override int Peek();
+        public override int Read();
+        public override int Read(char[] buffer, int index, int count);
+        public override Task<int> ReadAsync(char[] buffer, int index, int count);
+        public override Task<int> ReadBlockAsync(char[] buffer, int index, int count);
+        public override string ReadLine();
+        public override Task<string> ReadLineAsync();
+        public override string ReadToEnd();
+        public override Task<string> ReadToEndAsync();
+    }
+    public class StringWriter : TextWriter {
+        public StringWriter();
+        public StringWriter(IFormatProvider formatProvider);
+        public StringWriter(StringBuilder sb);
+        public StringWriter(StringBuilder sb, IFormatProvider formatProvider);
+        public override Encoding Encoding { get; }
+        public override void Close();
+        protected override void Dispose(bool disposing);
+        public override Task FlushAsync();
+        public virtual StringBuilder GetStringBuilder();
+        public override string ToString();
+        public override void Write(char value);
+        public override void Write(char[] buffer, int index, int count);
+        public override void Write(string value);
+        public override Task WriteAsync(char value);
+        public override Task WriteAsync(char[] buffer, int index, int count);
+        public override Task WriteAsync(string value);
+        public override Task WriteLineAsync(char value);
+        public override Task WriteLineAsync(char[] buffer, int index, int count);
+        public override Task WriteLineAsync(string value);
+    }
+    public abstract class TextReader : IDisposable {
+        public static readonly TextReader Null;
+        protected TextReader();
+        public virtual void Close();
+        public void Dispose();
+        protected virtual void Dispose(bool disposing);
+        public virtual int Peek();
+        public virtual int Read();
+        public virtual int Read(char[] buffer, int index, int count);
+        public virtual Task<int> ReadAsync(char[] buffer, int index, int count);
+        public virtual int ReadBlock(char[] buffer, int index, int count);
+        public virtual Task<int> ReadBlockAsync(char[] buffer, int index, int count);
+        public virtual string ReadLine();
+        public virtual Task<string> ReadLineAsync();
+        public virtual string ReadToEnd();
+        public virtual Task<string> ReadToEndAsync();
+    }
+    public abstract class TextWriter : IDisposable {
+        protected char[] CoreNewLine;
+        public static readonly TextWriter Null;
+        protected TextWriter();
+        protected TextWriter(IFormatProvider formatProvider);
+        public abstract Encoding Encoding { get; }
+        public virtual IFormatProvider FormatProvider { get; }
+        public virtual string NewLine { get; set; }
+        public virtual void Close();
+        public void Dispose();
+        protected virtual void Dispose(bool disposing);
+        public virtual void Flush();
+        public virtual Task FlushAsync();
+        public virtual void Write(bool value);
+        public virtual void Write(char value);
+        public virtual void Write(char[] buffer);
+        public virtual void Write(char[] buffer, int index, int count);
+        public virtual void Write(decimal value);
+        public virtual void Write(double value);
+        public virtual void Write(int value);
+        public virtual void Write(long value);
+        public virtual void Write(object value);
+        public virtual void Write(float value);
+        public virtual void Write(string value);
+        public virtual void Write(string format, object arg0);
+        public virtual void Write(string format, object arg0, object arg1);
+        public virtual void Write(string format, object arg0, object arg1, object arg2);
+        public virtual void Write(string format, params object[] arg);
+        public virtual void Write(uint value);
+        public virtual void Write(ulong value);
+        public virtual Task WriteAsync(char value);
+        public Task WriteAsync(char[] buffer);
+        public virtual Task WriteAsync(char[] buffer, int index, int count);
+        public virtual Task WriteAsync(string value);
+        public virtual void WriteLine();
+        public virtual void WriteLine(bool value);
+        public virtual void WriteLine(char value);
+        public virtual void WriteLine(char[] buffer);
+        public virtual void WriteLine(char[] buffer, int index, int count);
+        public virtual void WriteLine(decimal value);
+        public virtual void WriteLine(double value);
+        public virtual void WriteLine(int value);
+        public virtual void WriteLine(long value);
+        public virtual void WriteLine(object value);
+        public virtual void WriteLine(float value);
+        public virtual void WriteLine(string value);
+        public virtual void WriteLine(string format, object arg0);
+        public virtual void WriteLine(string format, object arg0, object arg1);
+        public virtual void WriteLine(string format, object arg0, object arg1, object arg2);
+        public virtual void WriteLine(string format, params object[] arg);
+        public virtual void WriteLine(uint value);
+        public virtual void WriteLine(ulong value);
+        public virtual Task WriteLineAsync();
+        public virtual Task WriteLineAsync(char value);
+        public Task WriteLineAsync(char[] buffer);
+        public virtual Task WriteLineAsync(char[] buffer, int index, int count);
+        public virtual Task WriteLineAsync(string value);
+    }
+    public class UnmanagedMemoryAccessor : IDisposable {
+        protected UnmanagedMemoryAccessor();
+        public UnmanagedMemoryAccessor(SafeBuffer buffer, long offset, long capacity);
+        public UnmanagedMemoryAccessor(SafeBuffer buffer, long offset, long capacity, FileAccess access);
+        public bool CanRead { get; }
+        public bool CanWrite { get; }
+        public long Capacity { get; }
+        protected bool IsOpen { get; }
+        public void Dispose();
+        protected virtual void Dispose(bool disposing);
+        protected void Initialize(SafeBuffer buffer, long offset, long capacity, FileAccess access);
+        public bool ReadBoolean(long position);
+        public byte ReadByte(long position);
+        public char ReadChar(long position);
+        public decimal ReadDecimal(long position);
+        public double ReadDouble(long position);
+        public short ReadInt16(long position);
+        public int ReadInt32(long position);
+        public long ReadInt64(long position);
+        public sbyte ReadSByte(long position);
+        public float ReadSingle(long position);
+        public ushort ReadUInt16(long position);
+        public uint ReadUInt32(long position);
+        public ulong ReadUInt64(long position);
+        public void Write(long position, bool value);
+        public void Write(long position, byte value);
+        public void Write(long position, char value);
+        public void Write(long position, decimal value);
+        public void Write(long position, double value);
+        public void Write(long position, short value);
+        public void Write(long position, int value);
+        public void Write(long position, long value);
+        public void Write(long position, sbyte value);
+        public void Write(long position, float value);
+        public void Write(long position, ushort value);
+        public void Write(long position, uint value);
+        public void Write(long position, ulong value);
+    }
+    public class UnmanagedMemoryStream : Stream {
+        protected UnmanagedMemoryStream();
+        public unsafe UnmanagedMemoryStream(byte* pointer, long length);
+        public unsafe UnmanagedMemoryStream(byte* pointer, long length, long capacity, FileAccess access);
+        public UnmanagedMemoryStream(SafeBuffer buffer, long offset, long length);
+        public UnmanagedMemoryStream(SafeBuffer buffer, long offset, long length, FileAccess access);
+        public override bool CanRead { get; }
+        public override bool CanSeek { get; }
+        public override bool CanWrite { get; }
+        public long Capacity { get; }
+        public override long Length { get; }
+        public override long Position { get; set; }
+        public unsafe byte* PositionPointer { get; set; }
+        protected override void Dispose(bool disposing);
+        public override void Flush();
+        public override Task FlushAsync(CancellationToken cancellationToken);
+        protected unsafe void Initialize(byte* pointer, long length, long capacity, FileAccess access);
+        protected void Initialize(SafeBuffer buffer, long offset, long length, FileAccess access);
+        public override int Read(byte[] buffer, int offset, int count);
+        public override Task<int> ReadAsync(byte[] buffer, int offset, int count, CancellationToken cancellationToken);
+        public override int ReadByte();
+        public override long Seek(long offset, SeekOrigin loc);
+        public override void SetLength(long value);
+        public override void Write(byte[] buffer, int offset, int count);
+        public override Task WriteAsync(byte[] buffer, int offset, int count, CancellationToken cancellationToken);
+        public override void WriteByte(byte value);
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Size=1)]
+    public struct WaitForChangedResult {
+        public WatcherChangeTypes ChangeType { get; set; }
+        public string Name { get; set; }
+        public string OldName { get; set; }
+        public bool TimedOut { get; set; }
+    }
+    public enum WatcherChangeTypes {
+        All = 15,
+        Changed = 4,
+        Created = 1,
+        Deleted = 2,
+        Renamed = 8,
+    }
+}
```

## System.IO.Compression

```c#
+namespace System.IO.Compression {
+    public enum CompressionLevel {
+        Fastest = 1,
+        NoCompression = 2,
+        Optimal = 0,
+    }
+    public enum CompressionMode {
+        Compress = 1,
+        Decompress = 0,
+    }
+    public class DeflateStream : Stream {
+        public DeflateStream(Stream stream, CompressionLevel compressionLevel);
+        public DeflateStream(Stream stream, CompressionLevel compressionLevel, bool leaveOpen);
+        public DeflateStream(Stream stream, CompressionMode mode);
+        public DeflateStream(Stream stream, CompressionMode mode, bool leaveOpen);
+        public Stream BaseStream { get; }
+        public override bool CanRead { get; }
+        public override bool CanSeek { get; }
+        public override bool CanWrite { get; }
+        public override long Length { get; }
+        public override long Position { get; set; }
+        protected override void Dispose(bool disposing);
+        public override void Flush();
+        public override int Read(byte[] array, int offset, int count);
+        public override Task<int> ReadAsync(byte[] array, int offset, int count, CancellationToken cancellationToken);
+        public override long Seek(long offset, SeekOrigin origin);
+        public override void SetLength(long value);
+        public override void Write(byte[] array, int offset, int count);
+        public override Task WriteAsync(byte[] array, int offset, int count, CancellationToken cancellationToken);
+    }
+    public class GZipStream : Stream {
+        public GZipStream(Stream stream, CompressionLevel compressionLevel);
+        public GZipStream(Stream stream, CompressionLevel compressionLevel, bool leaveOpen);
+        public GZipStream(Stream stream, CompressionMode mode);
+        public GZipStream(Stream stream, CompressionMode mode, bool leaveOpen);
+        public Stream BaseStream { get; }
+        public override bool CanRead { get; }
+        public override bool CanSeek { get; }
+        public override bool CanWrite { get; }
+        public override long Length { get; }
+        public override long Position { get; set; }
+        protected override void Dispose(bool disposing);
+        public override void Flush();
+        public override int Read(byte[] array, int offset, int count);
+        public override Task<int> ReadAsync(byte[] array, int offset, int count, CancellationToken cancellationToken);
+        public override long Seek(long offset, SeekOrigin origin);
+        public override void SetLength(long value);
+        public override void Write(byte[] array, int offset, int count);
+        public override Task WriteAsync(byte[] array, int offset, int count, CancellationToken cancellationToken);
+    }
+    public class ZipArchive : IDisposable {
+        public ZipArchive(Stream stream);
+        public ZipArchive(Stream stream, ZipArchiveMode mode);
+        public ZipArchive(Stream stream, ZipArchiveMode mode, bool leaveOpen);
+        public ZipArchive(Stream stream, ZipArchiveMode mode, bool leaveOpen, Encoding entryNameEncoding);
+        public ReadOnlyCollection<ZipArchiveEntry> Entries { get; }
+        public ZipArchiveMode Mode { get; }
+        public ZipArchiveEntry CreateEntry(string entryName);
+        public ZipArchiveEntry CreateEntry(string entryName, CompressionLevel compressionLevel);
+        public void Dispose();
+        protected virtual void Dispose(bool disposing);
+        public ZipArchiveEntry GetEntry(string entryName);
+    }
+    public class ZipArchiveEntry {
+        public ZipArchive Archive { get; }
+        public long CompressedLength { get; }
+        public string FullName { get; }
+        public DateTimeOffset LastWriteTime { get; set; }
+        public long Length { get; }
+        public string Name { get; }
+        public void Delete();
+        public Stream Open();
+        public override string ToString();
+    }
+    public enum ZipArchiveMode {
+        Create = 1,
+        Read = 0,
+        Update = 2,
+    }
+    public static class ZipFile {
+        public static void CreateFromDirectory(string sourceDirectoryName, string destinationArchiveFileName);
+        public static void CreateFromDirectory(string sourceDirectoryName, string destinationArchiveFileName, CompressionLevel compressionLevel, bool includeBaseDirectory);
+        public static void CreateFromDirectory(string sourceDirectoryName, string destinationArchiveFileName, CompressionLevel compressionLevel, bool includeBaseDirectory, Encoding entryNameEncoding);
+        public static void ExtractToDirectory(string sourceArchiveFileName, string destinationDirectoryName);
+        public static void ExtractToDirectory(string sourceArchiveFileName, string destinationDirectoryName, Encoding entryNameEncoding);
+        public static ZipArchive Open(string archiveFileName, ZipArchiveMode mode);
+        public static ZipArchive Open(string archiveFileName, ZipArchiveMode mode, Encoding entryNameEncoding);
+        public static ZipArchive OpenRead(string archiveFileName);
+    }
+    public static class ZipFileExtensions {
+        public static ZipArchiveEntry CreateEntryFromFile(this ZipArchive destination, string sourceFileName, string entryName);
+        public static ZipArchiveEntry CreateEntryFromFile(this ZipArchive destination, string sourceFileName, string entryName, CompressionLevel compressionLevel);
+        public static void ExtractToDirectory(this ZipArchive source, string destinationDirectoryName);
+        public static void ExtractToFile(this ZipArchiveEntry source, string destinationFileName);
+        public static void ExtractToFile(this ZipArchiveEntry source, string destinationFileName, bool overwrite);
+    }
+}
```

## System.IO.MemoryMappedFiles

```c#
+namespace System.IO.MemoryMappedFiles {
+    public class MemoryMappedFile : IDisposable {
+        public SafeMemoryMappedFileHandle SafeMemoryMappedFileHandle { get; }
+        public static MemoryMappedFile CreateFromFile(FileStream fileStream, string mapName, long capacity, MemoryMappedFileAccess access, HandleInheritability inheritability, bool leaveOpen);
+        public static MemoryMappedFile CreateFromFile(string path);
+        public static MemoryMappedFile CreateFromFile(string path, FileMode mode);
+        public static MemoryMappedFile CreateFromFile(string path, FileMode mode, string mapName);
+        public static MemoryMappedFile CreateFromFile(string path, FileMode mode, string mapName, long capacity);
+        public static MemoryMappedFile CreateFromFile(string path, FileMode mode, string mapName, long capacity, MemoryMappedFileAccess access);
+        public static MemoryMappedFile CreateNew(string mapName, long capacity);
+        public static MemoryMappedFile CreateNew(string mapName, long capacity, MemoryMappedFileAccess access);
+        public static MemoryMappedFile CreateNew(string mapName, long capacity, MemoryMappedFileAccess access, MemoryMappedFileOptions options, HandleInheritability inheritability);
+        public static MemoryMappedFile CreateOrOpen(string mapName, long capacity);
+        public static MemoryMappedFile CreateOrOpen(string mapName, long capacity, MemoryMappedFileAccess access);
+        public static MemoryMappedFile CreateOrOpen(string mapName, long capacity, MemoryMappedFileAccess access, MemoryMappedFileOptions options, HandleInheritability inheritability);
+        public MemoryMappedViewAccessor CreateViewAccessor();
+        public MemoryMappedViewAccessor CreateViewAccessor(long offset, long size);
+        public MemoryMappedViewAccessor CreateViewAccessor(long offset, long size, MemoryMappedFileAccess access);
+        public MemoryMappedViewStream CreateViewStream();
+        public MemoryMappedViewStream CreateViewStream(long offset, long size);
+        public MemoryMappedViewStream CreateViewStream(long offset, long size, MemoryMappedFileAccess access);
+        public void Dispose();
+        protected virtual void Dispose(bool disposing);
+        public static MemoryMappedFile OpenExisting(string mapName);
+        public static MemoryMappedFile OpenExisting(string mapName, MemoryMappedFileRights desiredAccessRights);
+        public static MemoryMappedFile OpenExisting(string mapName, MemoryMappedFileRights desiredAccessRights, HandleInheritability inheritability);
+    }
+    public enum MemoryMappedFileAccess {
+        CopyOnWrite = 3,
+        Read = 1,
+        ReadExecute = 4,
+        ReadWrite = 0,
+        ReadWriteExecute = 5,
+        Write = 2,
+    }
+    public enum MemoryMappedFileOptions {
+        DelayAllocatePages = 67108864,
+        None = 0,
+    }
+    public enum MemoryMappedFileRights {
+        AccessSystemSecurity = 16777216,
+        ChangePermissions = 262144,
+        CopyOnWrite = 1,
+        Delete = 65536,
+        Execute = 8,
+        FullControl = 983055,
+        Read = 4,
+        ReadExecute = 12,
+        ReadPermissions = 131072,
+        ReadWrite = 6,
+        ReadWriteExecute = 14,
+        TakeOwnership = 524288,
+        Write = 2,
+    }
+    public sealed class MemoryMappedViewAccessor : UnmanagedMemoryAccessor {
+        public long PointerOffset { get; }
+        public SafeMemoryMappedViewHandle SafeMemoryMappedViewHandle { get; }
+        protected override void Dispose(bool disposing);
+        public void Flush();
+    }
+    public sealed class MemoryMappedViewStream : UnmanagedMemoryStream {
+        public long PointerOffset { get; }
+        public SafeMemoryMappedViewHandle SafeMemoryMappedViewHandle { get; }
+        protected override void Dispose(bool disposing);
+        public override void Flush();
+        public override void SetLength(long value);
+    }
+}
```

## System.IO.Packaging

```c#
+namespace System.IO.Packaging {
+    public enum CompressionOption {
+        Fast = 2,
+        Maximum = 1,
+        Normal = 0,
+        NotCompressed = -1,
+        SuperFast = 3,
+    }
+    public enum EncryptionOption {
+        None = 0,
+        RightsManagement = 1,
+    }
+    public abstract class Package : IDisposable {
+        protected Package(FileAccess openFileAccess);
+        public FileAccess FileOpenAccess { get; }
+        public PackageProperties PackageProperties { get; }
+        public void Close();
+        public PackagePart CreatePart(Uri partUri, string contentType);
+        public PackagePart CreatePart(Uri partUri, string contentType, CompressionOption compressionOption);
+        protected abstract PackagePart CreatePartCore(Uri partUri, string contentType, CompressionOption compressionOption);
+        public PackageRelationship CreateRelationship(Uri targetUri, TargetMode targetMode, string relationshipType);
+        public PackageRelationship CreateRelationship(Uri targetUri, TargetMode targetMode, string relationshipType, string id);
+        public void DeletePart(Uri partUri);
+        protected abstract void DeletePartCore(Uri partUri);
+        public void DeleteRelationship(string id);
+        protected virtual void Dispose(bool disposing);
+        public void Flush();
+        protected abstract void FlushCore();
+        public PackagePart GetPart(Uri partUri);
+        protected abstract PackagePart GetPartCore(Uri partUri);
+        public PackagePartCollection GetParts();
+        protected abstract PackagePart[] GetPartsCore();
+        public PackageRelationship GetRelationship(string id);
+        public PackageRelationshipCollection GetRelationships();
+        public PackageRelationshipCollection GetRelationshipsByType(string relationshipType);
+        public static Package Open(Stream stream);
+        public static Package Open(Stream stream, FileMode packageMode);
+        public static Package Open(Stream stream, FileMode packageMode, FileAccess packageAccess);
+        public static Package Open(string path);
+        public static Package Open(string path, FileMode packageMode);
+        public static Package Open(string path, FileMode packageMode, FileAccess packageAccess);
+        public static Package Open(string path, FileMode packageMode, FileAccess packageAccess, FileShare packageShare);
+        public virtual bool PartExists(Uri partUri);
+        public bool RelationshipExists(string id);
+        void System.IDisposable.Dispose();
+    }
+    public abstract class PackagePart {
+        protected PackagePart(Package package, Uri partUri);
+        protected PackagePart(Package package, Uri partUri, string contentType);
+        protected PackagePart(Package package, Uri partUri, string contentType, CompressionOption compressionOption);
+        public CompressionOption CompressionOption { get; }
+        public string ContentType { get; }
+        public Package Package { get; }
+        public Uri Uri { get; }
+        public PackageRelationship CreateRelationship(Uri targetUri, TargetMode targetMode, string relationshipType);
+        public PackageRelationship CreateRelationship(Uri targetUri, TargetMode targetMode, string relationshipType, string id);
+        public void DeleteRelationship(string id);
+        protected virtual string GetContentTypeCore();
+        public PackageRelationship GetRelationship(string id);
+        public PackageRelationshipCollection GetRelationships();
+        public PackageRelationshipCollection GetRelationshipsByType(string relationshipType);
+        public Stream GetStream();
+        public Stream GetStream(FileMode mode);
+        public Stream GetStream(FileMode mode, FileAccess access);
+        protected abstract Stream GetStreamCore(FileMode mode, FileAccess access);
+        public bool RelationshipExists(string id);
+    }
+    public class PackagePartCollection : IEnumerable, IEnumerable<PackagePart> {
+        public IEnumerator<PackagePart> GetEnumerator();
+        IEnumerator<PackagePart> System.Collections.Generic.IEnumerable<System.IO.Packaging.PackagePart>.GetEnumerator();
+        IEnumerator System.Collections.IEnumerable.GetEnumerator();
+    }
+    public abstract class PackageProperties : IDisposable {
+        protected PackageProperties();
+        public abstract string Category { get; set; }
+        public abstract string ContentStatus { get; set; }
+        public abstract string ContentType { get; set; }
+        public abstract Nullable<DateTime> Created { get; set; }
+        public abstract string Creator { get; set; }
+        public abstract string Description { get; set; }
+        public abstract string Identifier { get; set; }
+        public abstract string Keywords { get; set; }
+        public abstract string Language { get; set; }
+        public abstract string LastModifiedBy { get; set; }
+        public abstract Nullable<DateTime> LastPrinted { get; set; }
+        public abstract Nullable<DateTime> Modified { get; set; }
+        public abstract string Revision { get; set; }
+        public abstract string Subject { get; set; }
+        public abstract string Title { get; set; }
+        public abstract string Version { get; set; }
+        public void Dispose();
+        protected virtual void Dispose(bool disposing);
+    }
+    public class PackageRelationship {
+        public string Id { get; }
+        public Package Package { get; }
+        public string RelationshipType { get; }
+        public Uri SourceUri { get; }
+        public TargetMode TargetMode { get; }
+        public Uri TargetUri { get; }
+    }
+    public class PackageRelationshipCollection : IEnumerable, IEnumerable<PackageRelationship> {
+        public IEnumerator<PackageRelationship> GetEnumerator();
+        IEnumerator System.Collections.IEnumerable.GetEnumerator();
+    }
+    public sealed class PackageRelationshipSelector {
+        public PackageRelationshipSelector(Uri sourceUri, PackageRelationshipSelectorType selectorType, string selectionCriteria);
+        public string SelectionCriteria { get; }
+        public PackageRelationshipSelectorType SelectorType { get; }
+        public Uri SourceUri { get; }
+        public List<PackageRelationship> Select(Package package);
+    }
+    public enum PackageRelationshipSelectorType {
+        Id = 0,
+        Type = 1,
+    }
+    public static class PackUriHelper {
+        public static readonly string UriSchemePack;
+        public static int ComparePartUri(Uri firstPartUri, Uri secondPartUri);
+        public static Uri CreatePartUri(Uri partUri);
+        public static Uri GetNormalizedPartUri(Uri partUri);
+        public static Uri GetRelationshipPartUri(Uri partUri);
+        public static Uri GetRelativeUri(Uri sourcePartUri, Uri targetPartUri);
+        public static Uri GetSourcePartUriFromRelationshipPartUri(Uri relationshipPartUri);
+        public static bool IsRelationshipPartUri(Uri partUri);
+        public static Uri ResolvePartUri(Uri sourcePartUri, Uri targetUri);
+    }
+    public enum TargetMode {
+        External = 1,
+        Internal = 0,
+    }
+    public sealed class ZipPackage : Package {
+        protected override PackagePart CreatePartCore(Uri partUri, string contentType, CompressionOption compressionOption);
+        protected override void DeletePartCore(Uri partUri);
+        protected override void Dispose(bool disposing);
+        protected override void FlushCore();
+        protected override PackagePart GetPartCore(Uri partUri);
+        protected override PackagePart[] GetPartsCore();
+    }
+    public sealed class ZipPackagePart : PackagePart {
+        protected override Stream GetStreamCore(FileMode streamFileMode, FileAccess streamFileAccess);
+    }
+}
```

## System.IO.Pipes

```c#
+namespace System.IO.Pipes {
+    public sealed class AnonymousPipeClientStream : PipeStream {
+        public AnonymousPipeClientStream(PipeDirection direction, SafePipeHandle safePipeHandle);
+        public AnonymousPipeClientStream(PipeDirection direction, string pipeHandleAsString);
+        public AnonymousPipeClientStream(string pipeHandleAsString);
+        public override PipeTransmissionMode ReadMode { set; }
+        public override PipeTransmissionMode TransmissionMode { get; }
+        ~AnonymousPipeClientStream();
+    }
+    public sealed class AnonymousPipeServerStream : PipeStream {
+        public AnonymousPipeServerStream();
+        public AnonymousPipeServerStream(PipeDirection direction);
+        public AnonymousPipeServerStream(PipeDirection direction, SafePipeHandle serverSafePipeHandle, SafePipeHandle clientSafePipeHandle);
+        public AnonymousPipeServerStream(PipeDirection direction, HandleInheritability inheritability);
+        public AnonymousPipeServerStream(PipeDirection direction, HandleInheritability inheritability, int bufferSize);
+        public SafePipeHandle ClientSafePipeHandle { get; }
+        public override PipeTransmissionMode ReadMode { set; }
+        public override PipeTransmissionMode TransmissionMode { get; }
+        protected override void Dispose(bool disposing);
+        public void DisposeLocalCopyOfClientHandle();
+        ~AnonymousPipeServerStream();
+        public string GetClientHandleAsString();
+    }
+    public sealed class NamedPipeClientStream : PipeStream {
+        public NamedPipeClientStream(PipeDirection direction, bool isAsync, bool isConnected, SafePipeHandle safePipeHandle);
+        public NamedPipeClientStream(string pipeName);
+        public NamedPipeClientStream(string serverName, string pipeName);
+        public NamedPipeClientStream(string serverName, string pipeName, PipeDirection direction);
+        public NamedPipeClientStream(string serverName, string pipeName, PipeDirection direction, PipeOptions options);
+        public NamedPipeClientStream(string serverName, string pipeName, PipeDirection direction, PipeOptions options, TokenImpersonationLevel impersonationLevel);
+        public int NumberOfServerInstances { get; }
+        public void Connect();
+        public void Connect(int timeout);
+        public Task ConnectAsync();
+        public Task ConnectAsync(int timeout);
+        public Task ConnectAsync(int timeout, CancellationToken cancellationToken);
+        public Task ConnectAsync(CancellationToken cancellationToken);
+        ~NamedPipeClientStream();
+    }
+    public sealed class NamedPipeServerStream : PipeStream {
+        public NamedPipeServerStream(PipeDirection direction, bool isAsync, bool isConnected, SafePipeHandle safePipeHandle);
+        public NamedPipeServerStream(string pipeName);
+        public NamedPipeServerStream(string pipeName, PipeDirection direction);
+        public NamedPipeServerStream(string pipeName, PipeDirection direction, int maxNumberOfServerInstances);
+        public NamedPipeServerStream(string pipeName, PipeDirection direction, int maxNumberOfServerInstances, PipeTransmissionMode transmissionMode);
+        public NamedPipeServerStream(string pipeName, PipeDirection direction, int maxNumberOfServerInstances, PipeTransmissionMode transmissionMode, PipeOptions options);
+        public NamedPipeServerStream(string pipeName, PipeDirection direction, int maxNumberOfServerInstances, PipeTransmissionMode transmissionMode, PipeOptions options, int inBufferSize, int outBufferSize);
+        public void Disconnect();
+        ~NamedPipeServerStream();
+        public string GetImpersonationUserName();
+        public void WaitForConnection();
+        public Task WaitForConnectionAsync();
+        public Task WaitForConnectionAsync(CancellationToken cancellationToken);
+    }
+    public enum PipeDirection {
+        In = 1,
+        InOut = 3,
+        Out = 2,
+    }
+    public enum PipeOptions {
+        Asynchronous = 1073741824,
+        None = 0,
+        WriteThrough = -2147483648,
+    }
+    public abstract class PipeStream : Stream {
+        protected PipeStream(PipeDirection direction, int bufferSize);
+        protected PipeStream(PipeDirection direction, PipeTransmissionMode transmissionMode, int outBufferSize);
+        public override bool CanRead { get; }
+        public override bool CanSeek { get; }
+        public override bool CanWrite { get; }
+        public virtual int InBufferSize { get; }
+        public bool IsAsync { get; }
+        public bool IsConnected { get; protected set; }
+        public bool IsMessageComplete { get; }
+        public override long Length { get; }
+        public virtual int OutBufferSize { get; }
+        public override long Position { get; set; }
+        public virtual PipeTransmissionMode ReadMode { get; set; }
+        public SafePipeHandle SafePipeHandle { get; }
+        public virtual PipeTransmissionMode TransmissionMode { get; }
+        protected override void Dispose(bool disposing);
+        public override void Flush();
+        public override int Read(byte[] buffer, int offset, int count);
+        public override Task<int> ReadAsync(byte[] buffer, int offset, int count, CancellationToken cancellationToken);
+        public override int ReadByte();
+        public override long Seek(long offset, SeekOrigin origin);
+        public override void SetLength(long value);
+        public void WaitForPipeDrain();
+        public override void Write(byte[] buffer, int offset, int count);
+        public override Task WriteAsync(byte[] buffer, int offset, int count, CancellationToken cancellationToken);
+        public override void WriteByte(byte value);
+    }
+    public enum PipeTransmissionMode {
+        Byte = 0,
+        Message = 1,
+    }
+}
```

## System.Linq

```c#
+namespace System.Linq {
+    public static class Enumerable {
+        public static TResult Aggregate<TSource, TAccumulate, TResult>(this IEnumerable<TSource> source, TAccumulate seed, Func<TAccumulate, TSource, TAccumulate> func, Func<TAccumulate, TResult> resultSelector);
+        public static TAccumulate Aggregate<TSource, TAccumulate>(this IEnumerable<TSource> source, TAccumulate seed, Func<TAccumulate, TSource, TAccumulate> func);
+        public static TSource Aggregate<TSource>(this IEnumerable<TSource> source, Func<TSource, TSource, TSource> func);
+        public static bool All<TSource>(this IEnumerable<TSource> source, Func<TSource, bool> predicate);
+        public static bool Any<TSource>(this IEnumerable<TSource> source);
+        public static bool Any<TSource>(this IEnumerable<TSource> source, Func<TSource, bool> predicate);
+        public static IEnumerable<TSource> Append<TSource>(this IEnumerable<TSource> source, TSource element);
+        public static IEnumerable<TSource> AsEnumerable<TSource>(this IEnumerable<TSource> source);
+        public static Decimal Average(this IEnumerable<Decimal> source);
+        public static double Average(this IEnumerable<double> source);
+        public static double Average(this IEnumerable<int> source);
+        public static double Average(this IEnumerable<long> source);
+        public static Nullable<Decimal> Average(this IEnumerable<Nullable<Decimal>> source);
+        public static Nullable<double> Average(this IEnumerable<Nullable<double>> source);
+        public static Nullable<double> Average(this IEnumerable<Nullable<int>> source);
+        public static Nullable<double> Average(this IEnumerable<Nullable<long>> source);
+        public static Nullable<float> Average(this IEnumerable<Nullable<float>> source);
+        public static float Average(this IEnumerable<float> source);
+        public static Decimal Average<TSource>(this IEnumerable<TSource> source, Func<TSource, Decimal> selector);
+        public static double Average<TSource>(this IEnumerable<TSource> source, Func<TSource, double> selector);
+        public static double Average<TSource>(this IEnumerable<TSource> source, Func<TSource, int> selector);
+        public static double Average<TSource>(this IEnumerable<TSource> source, Func<TSource, long> selector);
+        public static Nullable<Decimal> Average<TSource>(this IEnumerable<TSource> source, Func<TSource, Nullable<Decimal>> selector);
+        public static Nullable<double> Average<TSource>(this IEnumerable<TSource> source, Func<TSource, Nullable<double>> selector);
+        public static Nullable<double> Average<TSource>(this IEnumerable<TSource> source, Func<TSource, Nullable<int>> selector);
+        public static Nullable<double> Average<TSource>(this IEnumerable<TSource> source, Func<TSource, Nullable<long>> selector);
+        public static Nullable<float> Average<TSource>(this IEnumerable<TSource> source, Func<TSource, Nullable<float>> selector);
+        public static float Average<TSource>(this IEnumerable<TSource> source, Func<TSource, float> selector);
+        public static IEnumerable<TResult> Cast<TResult>(this IEnumerable source);
+        public static IEnumerable<TSource> Concat<TSource>(this IEnumerable<TSource> first, IEnumerable<TSource> second);
+        public static bool Contains<TSource>(this IEnumerable<TSource> source, TSource value);
+        public static bool Contains<TSource>(this IEnumerable<TSource> source, TSource value, IEqualityComparer<TSource> comparer);
+        public static int Count<TSource>(this IEnumerable<TSource> source);
+        public static int Count<TSource>(this IEnumerable<TSource> source, Func<TSource, bool> predicate);
+        public static IEnumerable<TSource> DefaultIfEmpty<TSource>(this IEnumerable<TSource> source);
+        public static IEnumerable<TSource> DefaultIfEmpty<TSource>(this IEnumerable<TSource> source, TSource defaultValue);
+        public static IEnumerable<TSource> Distinct<TSource>(this IEnumerable<TSource> source);
+        public static IEnumerable<TSource> Distinct<TSource>(this IEnumerable<TSource> source, IEqualityComparer<TSource> comparer);
+        public static TSource ElementAt<TSource>(this IEnumerable<TSource> source, int index);
+        public static TSource ElementAtOrDefault<TSource>(this IEnumerable<TSource> source, int index);
+        public static IEnumerable<TResult> Empty<TResult>();
+        public static IEnumerable<TSource> Except<TSource>(this IEnumerable<TSource> first, IEnumerable<TSource> second);
+        public static IEnumerable<TSource> Except<TSource>(this IEnumerable<TSource> first, IEnumerable<TSource> second, IEqualityComparer<TSource> comparer);
+        public static TSource First<TSource>(this IEnumerable<TSource> source);
+        public static TSource First<TSource>(this IEnumerable<TSource> source, Func<TSource, bool> predicate);
+        public static TSource FirstOrDefault<TSource>(this IEnumerable<TSource> source);
+        public static TSource FirstOrDefault<TSource>(this IEnumerable<TSource> source, Func<TSource, bool> predicate);
+        public static IEnumerable<TResult> GroupBy<TSource, TKey, TElement, TResult>(this IEnumerable<TSource> source, Func<TSource, TKey> keySelector, Func<TSource, TElement> elementSelector, Func<TKey, IEnumerable<TElement>, TResult> resultSelector);
+        public static IEnumerable<TResult> GroupBy<TSource, TKey, TElement, TResult>(this IEnumerable<TSource> source, Func<TSource, TKey> keySelector, Func<TSource, TElement> elementSelector, Func<TKey, IEnumerable<TElement>, TResult> resultSelector, IEqualityComparer<TKey> comparer);
+        public static IEnumerable<IGrouping<TKey, TElement>> GroupBy<TSource, TKey, TElement>(this IEnumerable<TSource> source, Func<TSource, TKey> keySelector, Func<TSource, TElement> elementSelector);
+        public static IEnumerable<IGrouping<TKey, TElement>> GroupBy<TSource, TKey, TElement>(this IEnumerable<TSource> source, Func<TSource, TKey> keySelector, Func<TSource, TElement> elementSelector, IEqualityComparer<TKey> comparer);
+        public static IEnumerable<TResult> GroupBy<TSource, TKey, TResult>(this IEnumerable<TSource> source, Func<TSource, TKey> keySelector, Func<TKey, IEnumerable<TSource>, TResult> resultSelector);
+        public static IEnumerable<TResult> GroupBy<TSource, TKey, TResult>(this IEnumerable<TSource> source, Func<TSource, TKey> keySelector, Func<TKey, IEnumerable<TSource>, TResult> resultSelector, IEqualityComparer<TKey> comparer);
+        public static IEnumerable<IGrouping<TKey, TSource>> GroupBy<TSource, TKey>(this IEnumerable<TSource> source, Func<TSource, TKey> keySelector);
+        public static IEnumerable<IGrouping<TKey, TSource>> GroupBy<TSource, TKey>(this IEnumerable<TSource> source, Func<TSource, TKey> keySelector, IEqualityComparer<TKey> comparer);
+        public static IEnumerable<TResult> GroupJoin<TOuter, TInner, TKey, TResult>(this IEnumerable<TOuter> outer, IEnumerable<TInner> inner, Func<TOuter, TKey> outerKeySelector, Func<TInner, TKey> innerKeySelector, Func<TOuter, IEnumerable<TInner>, TResult> resultSelector);
+        public static IEnumerable<TResult> GroupJoin<TOuter, TInner, TKey, TResult>(this IEnumerable<TOuter> outer, IEnumerable<TInner> inner, Func<TOuter, TKey> outerKeySelector, Func<TInner, TKey> innerKeySelector, Func<TOuter, IEnumerable<TInner>, TResult> resultSelector, IEqualityComparer<TKey> comparer);
+        public static IEnumerable<TSource> Intersect<TSource>(this IEnumerable<TSource> first, IEnumerable<TSource> second);
+        public static IEnumerable<TSource> Intersect<TSource>(this IEnumerable<TSource> first, IEnumerable<TSource> second, IEqualityComparer<TSource> comparer);
+        public static IEnumerable<TResult> Join<TOuter, TInner, TKey, TResult>(this IEnumerable<TOuter> outer, IEnumerable<TInner> inner, Func<TOuter, TKey> outerKeySelector, Func<TInner, TKey> innerKeySelector, Func<TOuter, TInner, TResult> resultSelector);
+        public static IEnumerable<TResult> Join<TOuter, TInner, TKey, TResult>(this IEnumerable<TOuter> outer, IEnumerable<TInner> inner, Func<TOuter, TKey> outerKeySelector, Func<TInner, TKey> innerKeySelector, Func<TOuter, TInner, TResult> resultSelector, IEqualityComparer<TKey> comparer);
+        public static TSource Last<TSource>(this IEnumerable<TSource> source);
+        public static TSource Last<TSource>(this IEnumerable<TSource> source, Func<TSource, bool> predicate);
+        public static TSource LastOrDefault<TSource>(this IEnumerable<TSource> source);
+        public static TSource LastOrDefault<TSource>(this IEnumerable<TSource> source, Func<TSource, bool> predicate);
+        public static long LongCount<TSource>(this IEnumerable<TSource> source);
+        public static long LongCount<TSource>(this IEnumerable<TSource> source, Func<TSource, bool> predicate);
+        public static Decimal Max(this IEnumerable<Decimal> source);
+        public static double Max(this IEnumerable<double> source);
+        public static int Max(this IEnumerable<int> source);
+        public static long Max(this IEnumerable<long> source);
+        public static Nullable<Decimal> Max(this IEnumerable<Nullable<Decimal>> source);
+        public static Nullable<double> Max(this IEnumerable<Nullable<double>> source);
+        public static Nullable<int> Max(this IEnumerable<Nullable<int>> source);
+        public static Nullable<long> Max(this IEnumerable<Nullable<long>> source);
+        public static Nullable<float> Max(this IEnumerable<Nullable<float>> source);
+        public static float Max(this IEnumerable<float> source);
+        public static TResult Max<TSource, TResult>(this IEnumerable<TSource> source, Func<TSource, TResult> selector);
+        public static TSource Max<TSource>(this IEnumerable<TSource> source);
+        public static Decimal Max<TSource>(this IEnumerable<TSource> source, Func<TSource, Decimal> selector);
+        public static double Max<TSource>(this IEnumerable<TSource> source, Func<TSource, double> selector);
+        public static int Max<TSource>(this IEnumerable<TSource> source, Func<TSource, int> selector);
+        public static long Max<TSource>(this IEnumerable<TSource> source, Func<TSource, long> selector);
+        public static Nullable<Decimal> Max<TSource>(this IEnumerable<TSource> source, Func<TSource, Nullable<Decimal>> selector);
+        public static Nullable<double> Max<TSource>(this IEnumerable<TSource> source, Func<TSource, Nullable<double>> selector);
+        public static Nullable<int> Max<TSource>(this IEnumerable<TSource> source, Func<TSource, Nullable<int>> selector);
+        public static Nullable<long> Max<TSource>(this IEnumerable<TSource> source, Func<TSource, Nullable<long>> selector);
+        public static Nullable<float> Max<TSource>(this IEnumerable<TSource> source, Func<TSource, Nullable<float>> selector);
+        public static float Max<TSource>(this IEnumerable<TSource> source, Func<TSource, float> selector);
+        public static Decimal Min(this IEnumerable<Decimal> source);
+        public static double Min(this IEnumerable<double> source);
+        public static int Min(this IEnumerable<int> source);
+        public static long Min(this IEnumerable<long> source);
+        public static Nullable<Decimal> Min(this IEnumerable<Nullable<Decimal>> source);
+        public static Nullable<double> Min(this IEnumerable<Nullable<double>> source);
+        public static Nullable<int> Min(this IEnumerable<Nullable<int>> source);
+        public static Nullable<long> Min(this IEnumerable<Nullable<long>> source);
+        public static Nullable<float> Min(this IEnumerable<Nullable<float>> source);
+        public static float Min(this IEnumerable<float> source);
+        public static TResult Min<TSource, TResult>(this IEnumerable<TSource> source, Func<TSource, TResult> selector);
+        public static TSource Min<TSource>(this IEnumerable<TSource> source);
+        public static Decimal Min<TSource>(this IEnumerable<TSource> source, Func<TSource, Decimal> selector);
+        public static double Min<TSource>(this IEnumerable<TSource> source, Func<TSource, double> selector);
+        public static int Min<TSource>(this IEnumerable<TSource> source, Func<TSource, int> selector);
+        public static long Min<TSource>(this IEnumerable<TSource> source, Func<TSource, long> selector);
+        public static Nullable<Decimal> Min<TSource>(this IEnumerable<TSource> source, Func<TSource, Nullable<Decimal>> selector);
+        public static Nullable<double> Min<TSource>(this IEnumerable<TSource> source, Func<TSource, Nullable<double>> selector);
+        public static Nullable<int> Min<TSource>(this IEnumerable<TSource> source, Func<TSource, Nullable<int>> selector);
+        public static Nullable<long> Min<TSource>(this IEnumerable<TSource> source, Func<TSource, Nullable<long>> selector);
+        public static Nullable<float> Min<TSource>(this IEnumerable<TSource> source, Func<TSource, Nullable<float>> selector);
+        public static float Min<TSource>(this IEnumerable<TSource> source, Func<TSource, float> selector);
+        public static IEnumerable<TResult> OfType<TResult>(this IEnumerable source);
+        public static IOrderedEnumerable<TSource> OrderBy<TSource, TKey>(this IEnumerable<TSource> source, Func<TSource, TKey> keySelector);
+        public static IOrderedEnumerable<TSource> OrderBy<TSource, TKey>(this IEnumerable<TSource> source, Func<TSource, TKey> keySelector, IComparer<TKey> comparer);
+        public static IOrderedEnumerable<TSource> OrderByDescending<TSource, TKey>(this IEnumerable<TSource> source, Func<TSource, TKey> keySelector);
+        public static IOrderedEnumerable<TSource> OrderByDescending<TSource, TKey>(this IEnumerable<TSource> source, Func<TSource, TKey> keySelector, IComparer<TKey> comparer);
+        public static IEnumerable<TSource> Prepend<TSource>(this IEnumerable<TSource> source, TSource element);
+        public static IEnumerable<int> Range(int start, int count);
+        public static IEnumerable<TResult> Repeat<TResult>(TResult element, int count);
+        public static IEnumerable<TSource> Reverse<TSource>(this IEnumerable<TSource> source);
+        public static IEnumerable<TResult> Select<TSource, TResult>(this IEnumerable<TSource> source, Func<TSource, int, TResult> selector);
+        public static IEnumerable<TResult> Select<TSource, TResult>(this IEnumerable<TSource> source, Func<TSource, TResult> selector);
+        public static IEnumerable<TResult> SelectMany<TSource, TCollection, TResult>(this IEnumerable<TSource> source, Func<TSource, IEnumerable<TCollection>> collectionSelector, Func<TSource, TCollection, TResult> resultSelector);
+        public static IEnumerable<TResult> SelectMany<TSource, TCollection, TResult>(this IEnumerable<TSource> source, Func<TSource, int, IEnumerable<TCollection>> collectionSelector, Func<TSource, TCollection, TResult> resultSelector);
+        public static IEnumerable<TResult> SelectMany<TSource, TResult>(this IEnumerable<TSource> source, Func<TSource, IEnumerable<TResult>> selector);
+        public static IEnumerable<TResult> SelectMany<TSource, TResult>(this IEnumerable<TSource> source, Func<TSource, int, IEnumerable<TResult>> selector);
+        public static bool SequenceEqual<TSource>(this IEnumerable<TSource> first, IEnumerable<TSource> second);
+        public static bool SequenceEqual<TSource>(this IEnumerable<TSource> first, IEnumerable<TSource> second, IEqualityComparer<TSource> comparer);
+        public static TSource Single<TSource>(this IEnumerable<TSource> source);
+        public static TSource Single<TSource>(this IEnumerable<TSource> source, Func<TSource, bool> predicate);
+        public static TSource SingleOrDefault<TSource>(this IEnumerable<TSource> source);
+        public static TSource SingleOrDefault<TSource>(this IEnumerable<TSource> source, Func<TSource, bool> predicate);
+        public static IEnumerable<TSource> Skip<TSource>(this IEnumerable<TSource> source, int count);
+        public static IEnumerable<TSource> SkipWhile<TSource>(this IEnumerable<TSource> source, Func<TSource, bool> predicate);
+        public static IEnumerable<TSource> SkipWhile<TSource>(this IEnumerable<TSource> source, Func<TSource, int, bool> predicate);
+        public static Decimal Sum(this IEnumerable<Decimal> source);
+        public static double Sum(this IEnumerable<double> source);
+        public static int Sum(this IEnumerable<int> source);
+        public static long Sum(this IEnumerable<long> source);
+        public static Nullable<Decimal> Sum(this IEnumerable<Nullable<Decimal>> source);
+        public static Nullable<double> Sum(this IEnumerable<Nullable<double>> source);
+        public static Nullable<int> Sum(this IEnumerable<Nullable<int>> source);
+        public static Nullable<long> Sum(this IEnumerable<Nullable<long>> source);
+        public static Nullable<float> Sum(this IEnumerable<Nullable<float>> source);
+        public static float Sum(this IEnumerable<float> source);
+        public static Decimal Sum<TSource>(this IEnumerable<TSource> source, Func<TSource, Decimal> selector);
+        public static double Sum<TSource>(this IEnumerable<TSource> source, Func<TSource, double> selector);
+        public static int Sum<TSource>(this IEnumerable<TSource> source, Func<TSource, int> selector);
+        public static long Sum<TSource>(this IEnumerable<TSource> source, Func<TSource, long> selector);
+        public static Nullable<Decimal> Sum<TSource>(this IEnumerable<TSource> source, Func<TSource, Nullable<Decimal>> selector);
+        public static Nullable<double> Sum<TSource>(this IEnumerable<TSource> source, Func<TSource, Nullable<double>> selector);
+        public static Nullable<int> Sum<TSource>(this IEnumerable<TSource> source, Func<TSource, Nullable<int>> selector);
+        public static Nullable<long> Sum<TSource>(this IEnumerable<TSource> source, Func<TSource, Nullable<long>> selector);
+        public static Nullable<float> Sum<TSource>(this IEnumerable<TSource> source, Func<TSource, Nullable<float>> selector);
+        public static float Sum<TSource>(this IEnumerable<TSource> source, Func<TSource, float> selector);
+        public static IEnumerable<TSource> Take<TSource>(this IEnumerable<TSource> source, int count);
+        public static IEnumerable<TSource> TakeWhile<TSource>(this IEnumerable<TSource> source, Func<TSource, bool> predicate);
+        public static IEnumerable<TSource> TakeWhile<TSource>(this IEnumerable<TSource> source, Func<TSource, int, bool> predicate);
+        public static IOrderedEnumerable<TSource> ThenBy<TSource, TKey>(this IOrderedEnumerable<TSource> source, Func<TSource, TKey> keySelector);
+        public static IOrderedEnumerable<TSource> ThenBy<TSource, TKey>(this IOrderedEnumerable<TSource> source, Func<TSource, TKey> keySelector, IComparer<TKey> comparer);
+        public static IOrderedEnumerable<TSource> ThenByDescending<TSource, TKey>(this IOrderedEnumerable<TSource> source, Func<TSource, TKey> keySelector);
+        public static IOrderedEnumerable<TSource> ThenByDescending<TSource, TKey>(this IOrderedEnumerable<TSource> source, Func<TSource, TKey> keySelector, IComparer<TKey> comparer);
+        public static TSource[] ToArray<TSource>(this IEnumerable<TSource> source);
+        public static Dictionary<TKey, TElement> ToDictionary<TSource, TKey, TElement>(this IEnumerable<TSource> source, Func<TSource, TKey> keySelector, Func<TSource, TElement> elementSelector);
+        public static Dictionary<TKey, TElement> ToDictionary<TSource, TKey, TElement>(this IEnumerable<TSource> source, Func<TSource, TKey> keySelector, Func<TSource, TElement> elementSelector, IEqualityComparer<TKey> comparer);
+        public static Dictionary<TKey, TSource> ToDictionary<TSource, TKey>(this IEnumerable<TSource> source, Func<TSource, TKey> keySelector);
+        public static Dictionary<TKey, TSource> ToDictionary<TSource, TKey>(this IEnumerable<TSource> source, Func<TSource, TKey> keySelector, IEqualityComparer<TKey> comparer);
+        public static List<TSource> ToList<TSource>(this IEnumerable<TSource> source);
+        public static ILookup<TKey, TElement> ToLookup<TSource, TKey, TElement>(this IEnumerable<TSource> source, Func<TSource, TKey> keySelector, Func<TSource, TElement> elementSelector);
+        public static ILookup<TKey, TElement> ToLookup<TSource, TKey, TElement>(this IEnumerable<TSource> source, Func<TSource, TKey> keySelector, Func<TSource, TElement> elementSelector, IEqualityComparer<TKey> comparer);
+        public static ILookup<TKey, TSource> ToLookup<TSource, TKey>(this IEnumerable<TSource> source, Func<TSource, TKey> keySelector);
+        public static ILookup<TKey, TSource> ToLookup<TSource, TKey>(this IEnumerable<TSource> source, Func<TSource, TKey> keySelector, IEqualityComparer<TKey> comparer);
+        public static IEnumerable<TSource> Union<TSource>(this IEnumerable<TSource> first, IEnumerable<TSource> second);
+        public static IEnumerable<TSource> Union<TSource>(this IEnumerable<TSource> first, IEnumerable<TSource> second, IEqualityComparer<TSource> comparer);
+        public static IEnumerable<TSource> Where<TSource>(this IEnumerable<TSource> source, Func<TSource, bool> predicate);
+        public static IEnumerable<TSource> Where<TSource>(this IEnumerable<TSource> source, Func<TSource, int, bool> predicate);
+        public static IEnumerable<TResult> Zip<TFirst, TSecond, TResult>(this IEnumerable<TFirst> first, IEnumerable<TSecond> second, Func<TFirst, TSecond, TResult> resultSelector);
+    }
+    public abstract class EnumerableExecutor {
+        protected EnumerableExecutor();
+    }
+    public class EnumerableExecutor<T> : EnumerableExecutor {
+        public EnumerableExecutor(Expression expression);
+    }
+    public abstract class EnumerableQuery {
+        protected EnumerableQuery();
+    }
+    public class EnumerableQuery<T> : EnumerableQuery, IEnumerable, IEnumerable<T>, IOrderedQueryable, IOrderedQueryable<T>, IQueryable, IQueryable<T>, IQueryProvider {
+        public EnumerableQuery(IEnumerable<T> enumerable);
+        public EnumerableQuery(Expression expression);
+        Type System.Linq.IQueryable.ElementType { get; }
+        Expression System.Linq.IQueryable.Expression { get; }
+        IQueryProvider System.Linq.IQueryable.Provider { get; }
+        IEnumerator<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
+        IEnumerator System.Collections.IEnumerable.GetEnumerator();
+        IQueryable System.Linq.IQueryProvider.CreateQuery(Expression expression);
+        IQueryable<S> System.Linq.IQueryProvider.CreateQuery<S>(Expression expression);
+        object System.Linq.IQueryProvider.Execute(Expression expression);
+        S System.Linq.IQueryProvider.Execute<S>(Expression expression);
+        public override string ToString();
+    }
+    public interface IGrouping<out TKey, out TElement> : IEnumerable, IEnumerable<TElement> {
+        TKey Key { get; }
+    }
+    public interface ILookup<TKey, TElement> : IEnumerable, IEnumerable<IGrouping<TKey, TElement>> {
+        int Count { get; }
+        IEnumerable<TElement> this[TKey key] { get; }
+        bool Contains(TKey key);
+    }
+    public static class ImmutableArrayExtensions {
+        public static T Aggregate<T>(this ImmutableArray<T> immutableArray, Func<T, T, T> func);
+        public static TAccumulate Aggregate<TAccumulate, T>(this ImmutableArray<T> immutableArray, TAccumulate seed, Func<TAccumulate, T, TAccumulate> func);
+        public static TResult Aggregate<TAccumulate, TResult, T>(this ImmutableArray<T> immutableArray, TAccumulate seed, Func<TAccumulate, T, TAccumulate> func, Func<TAccumulate, TResult> resultSelector);
+        public static bool All<T>(this ImmutableArray<T> immutableArray, Func<T, bool> predicate);
+        public static bool Any<T>(this ImmutableArray<T>.Builder builder);
+        public static bool Any<T>(this ImmutableArray<T> immutableArray);
+        public static bool Any<T>(this ImmutableArray<T> immutableArray, Func<T, bool> predicate);
+        public static T ElementAt<T>(this ImmutableArray<T> immutableArray, int index);
+        public static T ElementAtOrDefault<T>(this ImmutableArray<T> immutableArray, int index);
+        public static T First<T>(this ImmutableArray<T>.Builder builder);
+        public static T First<T>(this ImmutableArray<T> immutableArray);
+        public static T First<T>(this ImmutableArray<T> immutableArray, Func<T, bool> predicate);
+        public static T FirstOrDefault<T>(this ImmutableArray<T>.Builder builder);
+        public static T FirstOrDefault<T>(this ImmutableArray<T> immutableArray);
+        public static T FirstOrDefault<T>(this ImmutableArray<T> immutableArray, Func<T, bool> predicate);
+        public static T Last<T>(this ImmutableArray<T>.Builder builder);
+        public static T Last<T>(this ImmutableArray<T> immutableArray);
+        public static T Last<T>(this ImmutableArray<T> immutableArray, Func<T, bool> predicate);
+        public static T LastOrDefault<T>(this ImmutableArray<T>.Builder builder);
+        public static T LastOrDefault<T>(this ImmutableArray<T> immutableArray);
+        public static T LastOrDefault<T>(this ImmutableArray<T> immutableArray, Func<T, bool> predicate);
+        public static IEnumerable<TResult> Select<T, TResult>(this ImmutableArray<T> immutableArray, Func<T, TResult> selector);
+        public static IEnumerable<TResult> SelectMany<TSource, TCollection, TResult>(this ImmutableArray<TSource> immutableArray, Func<TSource, IEnumerable<TCollection>> collectionSelector, Func<TSource, TCollection, TResult> resultSelector);
+        public static bool SequenceEqual<TDerived, TBase>(this ImmutableArray<TBase> immutableArray, IEnumerable<TDerived> items, IEqualityComparer<TBase> comparer=null) where TDerived : TBase;
+        public static bool SequenceEqual<TDerived, TBase>(this ImmutableArray<TBase> immutableArray, ImmutableArray<TDerived> items, IEqualityComparer<TBase> comparer=null) where TDerived : TBase;
+        public static bool SequenceEqual<TDerived, TBase>(this ImmutableArray<TBase> immutableArray, ImmutableArray<TDerived> items, Func<TBase, TBase, bool> predicate) where TDerived : TBase;
+        public static T Single<T>(this ImmutableArray<T> immutableArray);
+        public static T Single<T>(this ImmutableArray<T> immutableArray, Func<T, bool> predicate);
+        public static T SingleOrDefault<T>(this ImmutableArray<T> immutableArray);
+        public static T SingleOrDefault<T>(this ImmutableArray<T> immutableArray, Func<T, bool> predicate);
+        public static T[] ToArray<T>(this ImmutableArray<T> immutableArray);
+        public static Dictionary<TKey, T> ToDictionary<TKey, T>(this ImmutableArray<T> immutableArray, Func<T, TKey> keySelector);
+        public static Dictionary<TKey, T> ToDictionary<TKey, T>(this ImmutableArray<T> immutableArray, Func<T, TKey> keySelector, IEqualityComparer<TKey> comparer);
+        public static Dictionary<TKey, TElement> ToDictionary<TKey, TElement, T>(this ImmutableArray<T> immutableArray, Func<T, TKey> keySelector, Func<T, TElement> elementSelector);
+        public static Dictionary<TKey, TElement> ToDictionary<TKey, TElement, T>(this ImmutableArray<T> immutableArray, Func<T, TKey> keySelector, Func<T, TElement> elementSelector, IEqualityComparer<TKey> comparer);
+        public static IEnumerable<T> Where<T>(this ImmutableArray<T> immutableArray, Func<T, bool> predicate);
+    }
+    public interface IOrderedEnumerable<TElement> : IEnumerable, IEnumerable<TElement> {
+        IOrderedEnumerable<TElement> CreateOrderedEnumerable<TKey>(Func<TElement, TKey> keySelector, IComparer<TKey> comparer, bool descending);
+    }
+    public interface IOrderedQueryable : IEnumerable, IQueryable
+    public interface IOrderedQueryable<out T> : IEnumerable, IEnumerable<T>, IOrderedQueryable, IQueryable, IQueryable<T>
+    public interface IQueryable : IEnumerable {
+        Type ElementType { get; }
+        Expression Expression { get; }
+        IQueryProvider Provider { get; }
+    }
+    public interface IQueryable<out T> : IEnumerable, IEnumerable<T>, IQueryable
+    public interface IQueryProvider {
+        IQueryable CreateQuery(Expression expression);
+        IQueryable<TElement> CreateQuery<TElement>(Expression expression);
+        object Execute(Expression expression);
+        TResult Execute<TResult>(Expression expression);
+    }
+    public class Lookup<TKey, TElement> : IEnumerable, IEnumerable<IGrouping<TKey, TElement>>, ILookup<TKey, TElement> {
+        public int Count { get; }
+        public IEnumerable<TElement> this[TKey key] { get; }
+        public IEnumerable<TResult> ApplyResultSelector<TResult>(Func<TKey, IEnumerable<TElement>, TResult> resultSelector);
+        public bool Contains(TKey key);
+        public IEnumerator<IGrouping<TKey, TElement>> GetEnumerator();
+        IEnumerator System.Collections.IEnumerable.GetEnumerator();
+    }
+    public class OrderedParallelQuery<TSource> : ParallelQuery<TSource> {
+        public override IEnumerator<TSource> GetEnumerator();
+    }
+    public static class ParallelEnumerable {
+        public static TResult Aggregate<TSource, TAccumulate, TResult>(this ParallelQuery<TSource> source, Func<TAccumulate> seedFactory, Func<TAccumulate, TSource, TAccumulate> updateAccumulatorFunc, Func<TAccumulate, TAccumulate, TAccumulate> combineAccumulatorsFunc, Func<TAccumulate, TResult> resultSelector);
+        public static TResult Aggregate<TSource, TAccumulate, TResult>(this ParallelQuery<TSource> source, TAccumulate seed, Func<TAccumulate, TSource, TAccumulate> updateAccumulatorFunc, Func<TAccumulate, TAccumulate, TAccumulate> combineAccumulatorsFunc, Func<TAccumulate, TResult> resultSelector);
+        public static TResult Aggregate<TSource, TAccumulate, TResult>(this ParallelQuery<TSource> source, TAccumulate seed, Func<TAccumulate, TSource, TAccumulate> func, Func<TAccumulate, TResult> resultSelector);
+        public static TAccumulate Aggregate<TSource, TAccumulate>(this ParallelQuery<TSource> source, TAccumulate seed, Func<TAccumulate, TSource, TAccumulate> func);
+        public static TSource Aggregate<TSource>(this ParallelQuery<TSource> source, Func<TSource, TSource, TSource> func);
+        public static bool All<TSource>(this ParallelQuery<TSource> source, Func<TSource, bool> predicate);
+        public static bool Any<TSource>(this ParallelQuery<TSource> source);
+        public static bool Any<TSource>(this ParallelQuery<TSource> source, Func<TSource, bool> predicate);
+        public static IEnumerable<TSource> AsEnumerable<TSource>(this ParallelQuery<TSource> source);
+        public static ParallelQuery AsOrdered(this ParallelQuery source);
+        public static ParallelQuery<TSource> AsOrdered<TSource>(this ParallelQuery<TSource> source);
+        public static ParallelQuery AsParallel(this IEnumerable source);
+        public static ParallelQuery<TSource> AsParallel<TSource>(this Partitioner<TSource> source);
+        public static ParallelQuery<TSource> AsParallel<TSource>(this IEnumerable<TSource> source);
+        public static IEnumerable<TSource> AsSequential<TSource>(this ParallelQuery<TSource> source);
+        public static ParallelQuery<TSource> AsUnordered<TSource>(this ParallelQuery<TSource> source);
+        public static Decimal Average(this ParallelQuery<Decimal> source);
+        public static double Average(this ParallelQuery<double> source);
+        public static double Average(this ParallelQuery<int> source);
+        public static double Average(this ParallelQuery<long> source);
+        public static Nullable<Decimal> Average(this ParallelQuery<Nullable<Decimal>> source);
+        public static Nullable<double> Average(this ParallelQuery<Nullable<double>> source);
+        public static Nullable<double> Average(this ParallelQuery<Nullable<int>> source);
+        public static Nullable<double> Average(this ParallelQuery<Nullable<long>> source);
+        public static Nullable<float> Average(this ParallelQuery<Nullable<float>> source);
+        public static float Average(this ParallelQuery<float> source);
+        public static Decimal Average<TSource>(this ParallelQuery<TSource> source, Func<TSource, Decimal> selector);
+        public static double Average<TSource>(this ParallelQuery<TSource> source, Func<TSource, double> selector);
+        public static double Average<TSource>(this ParallelQuery<TSource> source, Func<TSource, int> selector);
+        public static double Average<TSource>(this ParallelQuery<TSource> source, Func<TSource, long> selector);
+        public static Nullable<Decimal> Average<TSource>(this ParallelQuery<TSource> source, Func<TSource, Nullable<Decimal>> selector);
+        public static Nullable<double> Average<TSource>(this ParallelQuery<TSource> source, Func<TSource, Nullable<double>> selector);
+        public static Nullable<double> Average<TSource>(this ParallelQuery<TSource> source, Func<TSource, Nullable<int>> selector);
+        public static Nullable<double> Average<TSource>(this ParallelQuery<TSource> source, Func<TSource, Nullable<long>> selector);
+        public static Nullable<float> Average<TSource>(this ParallelQuery<TSource> source, Func<TSource, Nullable<float>> selector);
+        public static float Average<TSource>(this ParallelQuery<TSource> source, Func<TSource, float> selector);
+        public static ParallelQuery<TResult> Cast<TResult>(this ParallelQuery source);
+        public static ParallelQuery<TSource> Concat<TSource>(this ParallelQuery<TSource> first, IEnumerable<TSource> second);
+        public static ParallelQuery<TSource> Concat<TSource>(this ParallelQuery<TSource> first, ParallelQuery<TSource> second);
+        public static bool Contains<TSource>(this ParallelQuery<TSource> source, TSource value);
+        public static bool Contains<TSource>(this ParallelQuery<TSource> source, TSource value, IEqualityComparer<TSource> comparer);
+        public static int Count<TSource>(this ParallelQuery<TSource> source);
+        public static int Count<TSource>(this ParallelQuery<TSource> source, Func<TSource, bool> predicate);
+        public static ParallelQuery<TSource> DefaultIfEmpty<TSource>(this ParallelQuery<TSource> source);
+        public static ParallelQuery<TSource> DefaultIfEmpty<TSource>(this ParallelQuery<TSource> source, TSource defaultValue);
+        public static ParallelQuery<TSource> Distinct<TSource>(this ParallelQuery<TSource> source);
+        public static ParallelQuery<TSource> Distinct<TSource>(this ParallelQuery<TSource> source, IEqualityComparer<TSource> comparer);
+        public static TSource ElementAt<TSource>(this ParallelQuery<TSource> source, int index);
+        public static TSource ElementAtOrDefault<TSource>(this ParallelQuery<TSource> source, int index);
+        public static ParallelQuery<TResult> Empty<TResult>();
+        public static ParallelQuery<TSource> Except<TSource>(this ParallelQuery<TSource> first, IEnumerable<TSource> second);
+        public static ParallelQuery<TSource> Except<TSource>(this ParallelQuery<TSource> first, IEnumerable<TSource> second, IEqualityComparer<TSource> comparer);
+        public static ParallelQuery<TSource> Except<TSource>(this ParallelQuery<TSource> first, ParallelQuery<TSource> second);
+        public static ParallelQuery<TSource> Except<TSource>(this ParallelQuery<TSource> first, ParallelQuery<TSource> second, IEqualityComparer<TSource> comparer);
+        public static TSource First<TSource>(this ParallelQuery<TSource> source);
+        public static TSource First<TSource>(this ParallelQuery<TSource> source, Func<TSource, bool> predicate);
+        public static TSource FirstOrDefault<TSource>(this ParallelQuery<TSource> source);
+        public static TSource FirstOrDefault<TSource>(this ParallelQuery<TSource> source, Func<TSource, bool> predicate);
+        public static void ForAll<TSource>(this ParallelQuery<TSource> source, Action<TSource> action);
+        public static ParallelQuery<TResult> GroupBy<TSource, TKey, TElement, TResult>(this ParallelQuery<TSource> source, Func<TSource, TKey> keySelector, Func<TSource, TElement> elementSelector, Func<TKey, IEnumerable<TElement>, TResult> resultSelector);
+        public static ParallelQuery<TResult> GroupBy<TSource, TKey, TElement, TResult>(this ParallelQuery<TSource> source, Func<TSource, TKey> keySelector, Func<TSource, TElement> elementSelector, Func<TKey, IEnumerable<TElement>, TResult> resultSelector, IEqualityComparer<TKey> comparer);
+        public static ParallelQuery<IGrouping<TKey, TElement>> GroupBy<TSource, TKey, TElement>(this ParallelQuery<TSource> source, Func<TSource, TKey> keySelector, Func<TSource, TElement> elementSelector);
+        public static ParallelQuery<IGrouping<TKey, TElement>> GroupBy<TSource, TKey, TElement>(this ParallelQuery<TSource> source, Func<TSource, TKey> keySelector, Func<TSource, TElement> elementSelector, IEqualityComparer<TKey> comparer);
+        public static ParallelQuery<TResult> GroupBy<TSource, TKey, TResult>(this ParallelQuery<TSource> source, Func<TSource, TKey> keySelector, Func<TKey, IEnumerable<TSource>, TResult> resultSelector);
+        public static ParallelQuery<TResult> GroupBy<TSource, TKey, TResult>(this ParallelQuery<TSource> source, Func<TSource, TKey> keySelector, Func<TKey, IEnumerable<TSource>, TResult> resultSelector, IEqualityComparer<TKey> comparer);
+        public static ParallelQuery<IGrouping<TKey, TSource>> GroupBy<TSource, TKey>(this ParallelQuery<TSource> source, Func<TSource, TKey> keySelector);
+        public static ParallelQuery<IGrouping<TKey, TSource>> GroupBy<TSource, TKey>(this ParallelQuery<TSource> source, Func<TSource, TKey> keySelector, IEqualityComparer<TKey> comparer);
+        public static ParallelQuery<TResult> GroupJoin<TOuter, TInner, TKey, TResult>(this ParallelQuery<TOuter> outer, IEnumerable<TInner> inner, Func<TOuter, TKey> outerKeySelector, Func<TInner, TKey> innerKeySelector, Func<TOuter, IEnumerable<TInner>, TResult> resultSelector);
+        public static ParallelQuery<TResult> GroupJoin<TOuter, TInner, TKey, TResult>(this ParallelQuery<TOuter> outer, IEnumerable<TInner> inner, Func<TOuter, TKey> outerKeySelector, Func<TInner, TKey> innerKeySelector, Func<TOuter, IEnumerable<TInner>, TResult> resultSelector, IEqualityComparer<TKey> comparer);
+        public static ParallelQuery<TResult> GroupJoin<TOuter, TInner, TKey, TResult>(this ParallelQuery<TOuter> outer, ParallelQuery<TInner> inner, Func<TOuter, TKey> outerKeySelector, Func<TInner, TKey> innerKeySelector, Func<TOuter, IEnumerable<TInner>, TResult> resultSelector);
+        public static ParallelQuery<TResult> GroupJoin<TOuter, TInner, TKey, TResult>(this ParallelQuery<TOuter> outer, ParallelQuery<TInner> inner, Func<TOuter, TKey> outerKeySelector, Func<TInner, TKey> innerKeySelector, Func<TOuter, IEnumerable<TInner>, TResult> resultSelector, IEqualityComparer<TKey> comparer);
+        public static ParallelQuery<TSource> Intersect<TSource>(this ParallelQuery<TSource> first, IEnumerable<TSource> second);
+        public static ParallelQuery<TSource> Intersect<TSource>(this ParallelQuery<TSource> first, IEnumerable<TSource> second, IEqualityComparer<TSource> comparer);
+        public static ParallelQuery<TSource> Intersect<TSource>(this ParallelQuery<TSource> first, ParallelQuery<TSource> second);
+        public static ParallelQuery<TSource> Intersect<TSource>(this ParallelQuery<TSource> first, ParallelQuery<TSource> second, IEqualityComparer<TSource> comparer);
+        public static ParallelQuery<TResult> Join<TOuter, TInner, TKey, TResult>(this ParallelQuery<TOuter> outer, IEnumerable<TInner> inner, Func<TOuter, TKey> outerKeySelector, Func<TInner, TKey> innerKeySelector, Func<TOuter, TInner, TResult> resultSelector);
+        public static ParallelQuery<TResult> Join<TOuter, TInner, TKey, TResult>(this ParallelQuery<TOuter> outer, IEnumerable<TInner> inner, Func<TOuter, TKey> outerKeySelector, Func<TInner, TKey> innerKeySelector, Func<TOuter, TInner, TResult> resultSelector, IEqualityComparer<TKey> comparer);
+        public static ParallelQuery<TResult> Join<TOuter, TInner, TKey, TResult>(this ParallelQuery<TOuter> outer, ParallelQuery<TInner> inner, Func<TOuter, TKey> outerKeySelector, Func<TInner, TKey> innerKeySelector, Func<TOuter, TInner, TResult> resultSelector);
+        public static ParallelQuery<TResult> Join<TOuter, TInner, TKey, TResult>(this ParallelQuery<TOuter> outer, ParallelQuery<TInner> inner, Func<TOuter, TKey> outerKeySelector, Func<TInner, TKey> innerKeySelector, Func<TOuter, TInner, TResult> resultSelector, IEqualityComparer<TKey> comparer);
+        public static TSource Last<TSource>(this ParallelQuery<TSource> source);
+        public static TSource Last<TSource>(this ParallelQuery<TSource> source, Func<TSource, bool> predicate);
+        public static TSource LastOrDefault<TSource>(this ParallelQuery<TSource> source);
+        public static TSource LastOrDefault<TSource>(this ParallelQuery<TSource> source, Func<TSource, bool> predicate);
+        public static long LongCount<TSource>(this ParallelQuery<TSource> source);
+        public static long LongCount<TSource>(this ParallelQuery<TSource> source, Func<TSource, bool> predicate);
+        public static Decimal Max(this ParallelQuery<Decimal> source);
+        public static double Max(this ParallelQuery<double> source);
+        public static int Max(this ParallelQuery<int> source);
+        public static long Max(this ParallelQuery<long> source);
+        public static Nullable<Decimal> Max(this ParallelQuery<Nullable<Decimal>> source);
+        public static Nullable<double> Max(this ParallelQuery<Nullable<double>> source);
+        public static Nullable<int> Max(this ParallelQuery<Nullable<int>> source);
+        public static Nullable<long> Max(this ParallelQuery<Nullable<long>> source);
+        public static Nullable<float> Max(this ParallelQuery<Nullable<float>> source);
+        public static float Max(this ParallelQuery<float> source);
+        public static TResult Max<TSource, TResult>(this ParallelQuery<TSource> source, Func<TSource, TResult> selector);
+        public static TSource Max<TSource>(this ParallelQuery<TSource> source);
+        public static Decimal Max<TSource>(this ParallelQuery<TSource> source, Func<TSource, Decimal> selector);
+        public static double Max<TSource>(this ParallelQuery<TSource> source, Func<TSource, double> selector);
+        public static int Max<TSource>(this ParallelQuery<TSource> source, Func<TSource, int> selector);
+        public static long Max<TSource>(this ParallelQuery<TSource> source, Func<TSource, long> selector);
+        public static Nullable<Decimal> Max<TSource>(this ParallelQuery<TSource> source, Func<TSource, Nullable<Decimal>> selector);
+        public static Nullable<double> Max<TSource>(this ParallelQuery<TSource> source, Func<TSource, Nullable<double>> selector);
+        public static Nullable<int> Max<TSource>(this ParallelQuery<TSource> source, Func<TSource, Nullable<int>> selector);
+        public static Nullable<long> Max<TSource>(this ParallelQuery<TSource> source, Func<TSource, Nullable<long>> selector);
+        public static Nullable<float> Max<TSource>(this ParallelQuery<TSource> source, Func<TSource, Nullable<float>> selector);
+        public static float Max<TSource>(this ParallelQuery<TSource> source, Func<TSource, float> selector);
+        public static Decimal Min(this ParallelQuery<Decimal> source);
+        public static double Min(this ParallelQuery<double> source);
+        public static int Min(this ParallelQuery<int> source);
+        public static long Min(this ParallelQuery<long> source);
+        public static Nullable<Decimal> Min(this ParallelQuery<Nullable<Decimal>> source);
+        public static Nullable<double> Min(this ParallelQuery<Nullable<double>> source);
+        public static Nullable<int> Min(this ParallelQuery<Nullable<int>> source);
+        public static Nullable<long> Min(this ParallelQuery<Nullable<long>> source);
+        public static Nullable<float> Min(this ParallelQuery<Nullable<float>> source);
+        public static float Min(this ParallelQuery<float> source);
+        public static TResult Min<TSource, TResult>(this ParallelQuery<TSource> source, Func<TSource, TResult> selector);
+        public static TSource Min<TSource>(this ParallelQuery<TSource> source);
+        public static Decimal Min<TSource>(this ParallelQuery<TSource> source, Func<TSource, Decimal> selector);
+        public static double Min<TSource>(this ParallelQuery<TSource> source, Func<TSource, double> selector);
+        public static int Min<TSource>(this ParallelQuery<TSource> source, Func<TSource, int> selector);
+        public static long Min<TSource>(this ParallelQuery<TSource> source, Func<TSource, long> selector);
+        public static Nullable<Decimal> Min<TSource>(this ParallelQuery<TSource> source, Func<TSource, Nullable<Decimal>> selector);
+        public static Nullable<double> Min<TSource>(this ParallelQuery<TSource> source, Func<TSource, Nullable<double>> selector);
+        public static Nullable<int> Min<TSource>(this ParallelQuery<TSource> source, Func<TSource, Nullable<int>> selector);
+        public static Nullable<long> Min<TSource>(this ParallelQuery<TSource> source, Func<TSource, Nullable<long>> selector);
+        public static Nullable<float> Min<TSource>(this ParallelQuery<TSource> source, Func<TSource, Nullable<float>> selector);
+        public static float Min<TSource>(this ParallelQuery<TSource> source, Func<TSource, float> selector);
+        public static ParallelQuery<TResult> OfType<TResult>(this ParallelQuery source);
+        public static OrderedParallelQuery<TSource> OrderBy<TSource, TKey>(this ParallelQuery<TSource> source, Func<TSource, TKey> keySelector);
+        public static OrderedParallelQuery<TSource> OrderBy<TSource, TKey>(this ParallelQuery<TSource> source, Func<TSource, TKey> keySelector, IComparer<TKey> comparer);
+        public static OrderedParallelQuery<TSource> OrderByDescending<TSource, TKey>(this ParallelQuery<TSource> source, Func<TSource, TKey> keySelector);
+        public static OrderedParallelQuery<TSource> OrderByDescending<TSource, TKey>(this ParallelQuery<TSource> source, Func<TSource, TKey> keySelector, IComparer<TKey> comparer);
+        public static ParallelQuery<int> Range(int start, int count);
+        public static ParallelQuery<TResult> Repeat<TResult>(TResult element, int count);
+        public static ParallelQuery<TSource> Reverse<TSource>(this ParallelQuery<TSource> source);
+        public static ParallelQuery<TResult> Select<TSource, TResult>(this ParallelQuery<TSource> source, Func<TSource, int, TResult> selector);
+        public static ParallelQuery<TResult> Select<TSource, TResult>(this ParallelQuery<TSource> source, Func<TSource, TResult> selector);
+        public static ParallelQuery<TResult> SelectMany<TSource, TCollection, TResult>(this ParallelQuery<TSource> source, Func<TSource, IEnumerable<TCollection>> collectionSelector, Func<TSource, TCollection, TResult> resultSelector);
+        public static ParallelQuery<TResult> SelectMany<TSource, TCollection, TResult>(this ParallelQuery<TSource> source, Func<TSource, int, IEnumerable<TCollection>> collectionSelector, Func<TSource, TCollection, TResult> resultSelector);
+        public static ParallelQuery<TResult> SelectMany<TSource, TResult>(this ParallelQuery<TSource> source, Func<TSource, IEnumerable<TResult>> selector);
+        public static ParallelQuery<TResult> SelectMany<TSource, TResult>(this ParallelQuery<TSource> source, Func<TSource, int, IEnumerable<TResult>> selector);
+        public static bool SequenceEqual<TSource>(this ParallelQuery<TSource> first, IEnumerable<TSource> second);
+        public static bool SequenceEqual<TSource>(this ParallelQuery<TSource> first, IEnumerable<TSource> second, IEqualityComparer<TSource> comparer);
+        public static bool SequenceEqual<TSource>(this ParallelQuery<TSource> first, ParallelQuery<TSource> second);
+        public static bool SequenceEqual<TSource>(this ParallelQuery<TSource> first, ParallelQuery<TSource> second, IEqualityComparer<TSource> comparer);
+        public static TSource Single<TSource>(this ParallelQuery<TSource> source);
+        public static TSource Single<TSource>(this ParallelQuery<TSource> source, Func<TSource, bool> predicate);
+        public static TSource SingleOrDefault<TSource>(this ParallelQuery<TSource> source);
+        public static TSource SingleOrDefault<TSource>(this ParallelQuery<TSource> source, Func<TSource, bool> predicate);
+        public static ParallelQuery<TSource> Skip<TSource>(this ParallelQuery<TSource> source, int count);
+        public static ParallelQuery<TSource> SkipWhile<TSource>(this ParallelQuery<TSource> source, Func<TSource, bool> predicate);
+        public static ParallelQuery<TSource> SkipWhile<TSource>(this ParallelQuery<TSource> source, Func<TSource, int, bool> predicate);
+        public static Decimal Sum(this ParallelQuery<Decimal> source);
+        public static double Sum(this ParallelQuery<double> source);
+        public static int Sum(this ParallelQuery<int> source);
+        public static long Sum(this ParallelQuery<long> source);
+        public static Nullable<Decimal> Sum(this ParallelQuery<Nullable<Decimal>> source);
+        public static Nullable<double> Sum(this ParallelQuery<Nullable<double>> source);
+        public static Nullable<int> Sum(this ParallelQuery<Nullable<int>> source);
+        public static Nullable<long> Sum(this ParallelQuery<Nullable<long>> source);
+        public static Nullable<float> Sum(this ParallelQuery<Nullable<float>> source);
+        public static float Sum(this ParallelQuery<float> source);
+        public static Decimal Sum<TSource>(this ParallelQuery<TSource> source, Func<TSource, Decimal> selector);
+        public static double Sum<TSource>(this ParallelQuery<TSource> source, Func<TSource, double> selector);
+        public static int Sum<TSource>(this ParallelQuery<TSource> source, Func<TSource, int> selector);
+        public static long Sum<TSource>(this ParallelQuery<TSource> source, Func<TSource, long> selector);
+        public static Nullable<Decimal> Sum<TSource>(this ParallelQuery<TSource> source, Func<TSource, Nullable<Decimal>> selector);
+        public static Nullable<double> Sum<TSource>(this ParallelQuery<TSource> source, Func<TSource, Nullable<double>> selector);
+        public static Nullable<int> Sum<TSource>(this ParallelQuery<TSource> source, Func<TSource, Nullable<int>> selector);
+        public static Nullable<long> Sum<TSource>(this ParallelQuery<TSource> source, Func<TSource, Nullable<long>> selector);
+        public static Nullable<float> Sum<TSource>(this ParallelQuery<TSource> source, Func<TSource, Nullable<float>> selector);
+        public static float Sum<TSource>(this ParallelQuery<TSource> source, Func<TSource, float> selector);
+        public static ParallelQuery<TSource> Take<TSource>(this ParallelQuery<TSource> source, int count);
+        public static ParallelQuery<TSource> TakeWhile<TSource>(this ParallelQuery<TSource> source, Func<TSource, bool> predicate);
+        public static ParallelQuery<TSource> TakeWhile<TSource>(this ParallelQuery<TSource> source, Func<TSource, int, bool> predicate);
+        public static OrderedParallelQuery<TSource> ThenBy<TSource, TKey>(this OrderedParallelQuery<TSource> source, Func<TSource, TKey> keySelector);
+        public static OrderedParallelQuery<TSource> ThenBy<TSource, TKey>(this OrderedParallelQuery<TSource> source, Func<TSource, TKey> keySelector, IComparer<TKey> comparer);
+        public static OrderedParallelQuery<TSource> ThenByDescending<TSource, TKey>(this OrderedParallelQuery<TSource> source, Func<TSource, TKey> keySelector);
+        public static OrderedParallelQuery<TSource> ThenByDescending<TSource, TKey>(this OrderedParallelQuery<TSource> source, Func<TSource, TKey> keySelector, IComparer<TKey> comparer);
+        public static TSource[] ToArray<TSource>(this ParallelQuery<TSource> source);
+        public static Dictionary<TKey, TElement> ToDictionary<TSource, TKey, TElement>(this ParallelQuery<TSource> source, Func<TSource, TKey> keySelector, Func<TSource, TElement> elementSelector);
+        public static Dictionary<TKey, TElement> ToDictionary<TSource, TKey, TElement>(this ParallelQuery<TSource> source, Func<TSource, TKey> keySelector, Func<TSource, TElement> elementSelector, IEqualityComparer<TKey> comparer);
+        public static Dictionary<TKey, TSource> ToDictionary<TSource, TKey>(this ParallelQuery<TSource> source, Func<TSource, TKey> keySelector);
+        public static Dictionary<TKey, TSource> ToDictionary<TSource, TKey>(this ParallelQuery<TSource> source, Func<TSource, TKey> keySelector, IEqualityComparer<TKey> comparer);
+        public static List<TSource> ToList<TSource>(this ParallelQuery<TSource> source);
+        public static ILookup<TKey, TElement> ToLookup<TSource, TKey, TElement>(this ParallelQuery<TSource> source, Func<TSource, TKey> keySelector, Func<TSource, TElement> elementSelector);
+        public static ILookup<TKey, TElement> ToLookup<TSource, TKey, TElement>(this ParallelQuery<TSource> source, Func<TSource, TKey> keySelector, Func<TSource, TElement> elementSelector, IEqualityComparer<TKey> comparer);
+        public static ILookup<TKey, TSource> ToLookup<TSource, TKey>(this ParallelQuery<TSource> source, Func<TSource, TKey> keySelector);
+        public static ILookup<TKey, TSource> ToLookup<TSource, TKey>(this ParallelQuery<TSource> source, Func<TSource, TKey> keySelector, IEqualityComparer<TKey> comparer);
+        public static ParallelQuery<TSource> Union<TSource>(this ParallelQuery<TSource> first, IEnumerable<TSource> second);
+        public static ParallelQuery<TSource> Union<TSource>(this ParallelQuery<TSource> first, IEnumerable<TSource> second, IEqualityComparer<TSource> comparer);
+        public static ParallelQuery<TSource> Union<TSource>(this ParallelQuery<TSource> first, ParallelQuery<TSource> second);
+        public static ParallelQuery<TSource> Union<TSource>(this ParallelQuery<TSource> first, ParallelQuery<TSource> second, IEqualityComparer<TSource> comparer);
+        public static ParallelQuery<TSource> Where<TSource>(this ParallelQuery<TSource> source, Func<TSource, bool> predicate);
+        public static ParallelQuery<TSource> Where<TSource>(this ParallelQuery<TSource> source, Func<TSource, int, bool> predicate);
+        public static ParallelQuery<TSource> WithCancellation<TSource>(this ParallelQuery<TSource> source, CancellationToken cancellationToken);
+        public static ParallelQuery<TSource> WithDegreeOfParallelism<TSource>(this ParallelQuery<TSource> source, int degreeOfParallelism);
+        public static ParallelQuery<TSource> WithExecutionMode<TSource>(this ParallelQuery<TSource> source, ParallelExecutionMode executionMode);
+        public static ParallelQuery<TSource> WithMergeOptions<TSource>(this ParallelQuery<TSource> source, ParallelMergeOptions mergeOptions);
+        public static ParallelQuery<TResult> Zip<TFirst, TSecond, TResult>(this ParallelQuery<TFirst> first, IEnumerable<TSecond> second, Func<TFirst, TSecond, TResult> resultSelector);
+        public static ParallelQuery<TResult> Zip<TFirst, TSecond, TResult>(this ParallelQuery<TFirst> first, ParallelQuery<TSecond> second, Func<TFirst, TSecond, TResult> resultSelector);
+    }
+    public enum ParallelExecutionMode {
+        Default = 0,
+        ForceParallelism = 1,
+    }
+    public enum ParallelMergeOptions {
+        AutoBuffered = 2,
+        Default = 0,
+        FullyBuffered = 3,
+        NotBuffered = 1,
+    }
+    public class ParallelQuery : IEnumerable {
+        IEnumerator System.Collections.IEnumerable.GetEnumerator();
+    }
+    public class ParallelQuery<TSource> : ParallelQuery, IEnumerable, IEnumerable<TSource> {
+        public virtual IEnumerator<TSource> GetEnumerator();
+    }
+    public static class Queryable {
+        public static TResult Aggregate<TSource, TAccumulate, TResult>(this IQueryable<TSource> source, TAccumulate seed, Expression<Func<TAccumulate, TSource, TAccumulate>> func, Expression<Func<TAccumulate, TResult>> selector);
+        public static TAccumulate Aggregate<TSource, TAccumulate>(this IQueryable<TSource> source, TAccumulate seed, Expression<Func<TAccumulate, TSource, TAccumulate>> func);
+        public static TSource Aggregate<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, TSource, TSource>> func);
+        public static bool All<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, bool>> predicate);
+        public static bool Any<TSource>(this IQueryable<TSource> source);
+        public static bool Any<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, bool>> predicate);
+        public static IQueryable AsQueryable(this IEnumerable source);
+        public static IQueryable<TElement> AsQueryable<TElement>(this IEnumerable<TElement> source);
+        public static Decimal Average(this IQueryable<Decimal> source);
+        public static double Average(this IQueryable<double> source);
+        public static double Average(this IQueryable<int> source);
+        public static double Average(this IQueryable<long> source);
+        public static Nullable<Decimal> Average(this IQueryable<Nullable<Decimal>> source);
+        public static Nullable<double> Average(this IQueryable<Nullable<double>> source);
+        public static Nullable<double> Average(this IQueryable<Nullable<int>> source);
+        public static Nullable<double> Average(this IQueryable<Nullable<long>> source);
+        public static Nullable<float> Average(this IQueryable<Nullable<float>> source);
+        public static float Average(this IQueryable<float> source);
+        public static Decimal Average<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, Decimal>> selector);
+        public static double Average<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, double>> selector);
+        public static double Average<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, int>> selector);
+        public static double Average<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, long>> selector);
+        public static Nullable<Decimal> Average<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, Nullable<Decimal>>> selector);
+        public static Nullable<double> Average<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, Nullable<double>>> selector);
+        public static Nullable<double> Average<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, Nullable<int>>> selector);
+        public static Nullable<double> Average<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, Nullable<long>>> selector);
+        public static Nullable<float> Average<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, Nullable<float>>> selector);
+        public static float Average<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, float>> selector);
+        public static IQueryable<TResult> Cast<TResult>(this IQueryable source);
+        public static IQueryable<TSource> Concat<TSource>(this IQueryable<TSource> source1, IEnumerable<TSource> source2);
+        public static bool Contains<TSource>(this IQueryable<TSource> source, TSource item);
+        public static bool Contains<TSource>(this IQueryable<TSource> source, TSource item, IEqualityComparer<TSource> comparer);
+        public static int Count<TSource>(this IQueryable<TSource> source);
+        public static int Count<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, bool>> predicate);
+        public static IQueryable<TSource> DefaultIfEmpty<TSource>(this IQueryable<TSource> source);
+        public static IQueryable<TSource> DefaultIfEmpty<TSource>(this IQueryable<TSource> source, TSource defaultValue);
+        public static IQueryable<TSource> Distinct<TSource>(this IQueryable<TSource> source);
+        public static IQueryable<TSource> Distinct<TSource>(this IQueryable<TSource> source, IEqualityComparer<TSource> comparer);
+        public static TSource ElementAt<TSource>(this IQueryable<TSource> source, int index);
+        public static TSource ElementAtOrDefault<TSource>(this IQueryable<TSource> source, int index);
+        public static IQueryable<TSource> Except<TSource>(this IQueryable<TSource> source1, IEnumerable<TSource> source2);
+        public static IQueryable<TSource> Except<TSource>(this IQueryable<TSource> source1, IEnumerable<TSource> source2, IEqualityComparer<TSource> comparer);
+        public static TSource First<TSource>(this IQueryable<TSource> source);
+        public static TSource First<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, bool>> predicate);
+        public static TSource FirstOrDefault<TSource>(this IQueryable<TSource> source);
+        public static TSource FirstOrDefault<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, bool>> predicate);
+        public static IQueryable<TResult> GroupBy<TSource, TKey, TElement, TResult>(this IQueryable<TSource> source, Expression<Func<TSource, TKey>> keySelector, Expression<Func<TSource, TElement>> elementSelector, Expression<Func<TKey, IEnumerable<TElement>, TResult>> resultSelector);
+        public static IQueryable<TResult> GroupBy<TSource, TKey, TElement, TResult>(this IQueryable<TSource> source, Expression<Func<TSource, TKey>> keySelector, Expression<Func<TSource, TElement>> elementSelector, Expression<Func<TKey, IEnumerable<TElement>, TResult>> resultSelector, IEqualityComparer<TKey> comparer);
+        public static IQueryable<IGrouping<TKey, TElement>> GroupBy<TSource, TKey, TElement>(this IQueryable<TSource> source, Expression<Func<TSource, TKey>> keySelector, Expression<Func<TSource, TElement>> elementSelector);
+        public static IQueryable<IGrouping<TKey, TElement>> GroupBy<TSource, TKey, TElement>(this IQueryable<TSource> source, Expression<Func<TSource, TKey>> keySelector, Expression<Func<TSource, TElement>> elementSelector, IEqualityComparer<TKey> comparer);
+        public static IQueryable<TResult> GroupBy<TSource, TKey, TResult>(this IQueryable<TSource> source, Expression<Func<TSource, TKey>> keySelector, Expression<Func<TKey, IEnumerable<TSource>, TResult>> resultSelector);
+        public static IQueryable<TResult> GroupBy<TSource, TKey, TResult>(this IQueryable<TSource> source, Expression<Func<TSource, TKey>> keySelector, Expression<Func<TKey, IEnumerable<TSource>, TResult>> resultSelector, IEqualityComparer<TKey> comparer);
+        public static IQueryable<IGrouping<TKey, TSource>> GroupBy<TSource, TKey>(this IQueryable<TSource> source, Expression<Func<TSource, TKey>> keySelector);
+        public static IQueryable<IGrouping<TKey, TSource>> GroupBy<TSource, TKey>(this IQueryable<TSource> source, Expression<Func<TSource, TKey>> keySelector, IEqualityComparer<TKey> comparer);
+        public static IQueryable<TResult> GroupJoin<TOuter, TInner, TKey, TResult>(this IQueryable<TOuter> outer, IEnumerable<TInner> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<TInner, TKey>> innerKeySelector, Expression<Func<TOuter, IEnumerable<TInner>, TResult>> resultSelector);
+        public static IQueryable<TResult> GroupJoin<TOuter, TInner, TKey, TResult>(this IQueryable<TOuter> outer, IEnumerable<TInner> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<TInner, TKey>> innerKeySelector, Expression<Func<TOuter, IEnumerable<TInner>, TResult>> resultSelector, IEqualityComparer<TKey> comparer);
+        public static IQueryable<TSource> Intersect<TSource>(this IQueryable<TSource> source1, IEnumerable<TSource> source2);
+        public static IQueryable<TSource> Intersect<TSource>(this IQueryable<TSource> source1, IEnumerable<TSource> source2, IEqualityComparer<TSource> comparer);
+        public static IQueryable<TResult> Join<TOuter, TInner, TKey, TResult>(this IQueryable<TOuter> outer, IEnumerable<TInner> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<TInner, TKey>> innerKeySelector, Expression<Func<TOuter, TInner, TResult>> resultSelector);
+        public static IQueryable<TResult> Join<TOuter, TInner, TKey, TResult>(this IQueryable<TOuter> outer, IEnumerable<TInner> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<TInner, TKey>> innerKeySelector, Expression<Func<TOuter, TInner, TResult>> resultSelector, IEqualityComparer<TKey> comparer);
+        public static TSource Last<TSource>(this IQueryable<TSource> source);
+        public static TSource Last<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, bool>> predicate);
+        public static TSource LastOrDefault<TSource>(this IQueryable<TSource> source);
+        public static TSource LastOrDefault<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, bool>> predicate);
+        public static long LongCount<TSource>(this IQueryable<TSource> source);
+        public static long LongCount<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, bool>> predicate);
+        public static TResult Max<TSource, TResult>(this IQueryable<TSource> source, Expression<Func<TSource, TResult>> selector);
+        public static TSource Max<TSource>(this IQueryable<TSource> source);
+        public static TResult Min<TSource, TResult>(this IQueryable<TSource> source, Expression<Func<TSource, TResult>> selector);
+        public static TSource Min<TSource>(this IQueryable<TSource> source);
+        public static IQueryable<TResult> OfType<TResult>(this IQueryable source);
+        public static IOrderedQueryable<TSource> OrderBy<TSource, TKey>(this IQueryable<TSource> source, Expression<Func<TSource, TKey>> keySelector);
+        public static IOrderedQueryable<TSource> OrderBy<TSource, TKey>(this IQueryable<TSource> source, Expression<Func<TSource, TKey>> keySelector, IComparer<TKey> comparer);
+        public static IOrderedQueryable<TSource> OrderByDescending<TSource, TKey>(this IQueryable<TSource> source, Expression<Func<TSource, TKey>> keySelector);
+        public static IOrderedQueryable<TSource> OrderByDescending<TSource, TKey>(this IQueryable<TSource> source, Expression<Func<TSource, TKey>> keySelector, IComparer<TKey> comparer);
+        public static IQueryable<TSource> Reverse<TSource>(this IQueryable<TSource> source);
+        public static IQueryable<TResult> Select<TSource, TResult>(this IQueryable<TSource> source, Expression<Func<TSource, int, TResult>> selector);
+        public static IQueryable<TResult> Select<TSource, TResult>(this IQueryable<TSource> source, Expression<Func<TSource, TResult>> selector);
+        public static IQueryable<TResult> SelectMany<TSource, TCollection, TResult>(this IQueryable<TSource> source, Expression<Func<TSource, IEnumerable<TCollection>>> collectionSelector, Expression<Func<TSource, TCollection, TResult>> resultSelector);
+        public static IQueryable<TResult> SelectMany<TSource, TCollection, TResult>(this IQueryable<TSource> source, Expression<Func<TSource, int, IEnumerable<TCollection>>> collectionSelector, Expression<Func<TSource, TCollection, TResult>> resultSelector);
+        public static IQueryable<TResult> SelectMany<TSource, TResult>(this IQueryable<TSource> source, Expression<Func<TSource, IEnumerable<TResult>>> selector);
+        public static IQueryable<TResult> SelectMany<TSource, TResult>(this IQueryable<TSource> source, Expression<Func<TSource, int, IEnumerable<TResult>>> selector);
+        public static bool SequenceEqual<TSource>(this IQueryable<TSource> source1, IEnumerable<TSource> source2);
+        public static bool SequenceEqual<TSource>(this IQueryable<TSource> source1, IEnumerable<TSource> source2, IEqualityComparer<TSource> comparer);
+        public static TSource Single<TSource>(this IQueryable<TSource> source);
+        public static TSource Single<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, bool>> predicate);
+        public static TSource SingleOrDefault<TSource>(this IQueryable<TSource> source);
+        public static TSource SingleOrDefault<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, bool>> predicate);
+        public static IQueryable<TSource> Skip<TSource>(this IQueryable<TSource> source, int count);
+        public static IQueryable<TSource> SkipWhile<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, bool>> predicate);
+        public static IQueryable<TSource> SkipWhile<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, int, bool>> predicate);
+        public static Decimal Sum(this IQueryable<Decimal> source);
+        public static double Sum(this IQueryable<double> source);
+        public static int Sum(this IQueryable<int> source);
+        public static long Sum(this IQueryable<long> source);
+        public static Nullable<Decimal> Sum(this IQueryable<Nullable<Decimal>> source);
+        public static Nullable<double> Sum(this IQueryable<Nullable<double>> source);
+        public static Nullable<int> Sum(this IQueryable<Nullable<int>> source);
+        public static Nullable<long> Sum(this IQueryable<Nullable<long>> source);
+        public static Nullable<float> Sum(this IQueryable<Nullable<float>> source);
+        public static float Sum(this IQueryable<float> source);
+        public static Decimal Sum<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, Decimal>> selector);
+        public static double Sum<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, double>> selector);
+        public static int Sum<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, int>> selector);
+        public static long Sum<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, long>> selector);
+        public static Nullable<Decimal> Sum<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, Nullable<Decimal>>> selector);
+        public static Nullable<double> Sum<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, Nullable<double>>> selector);
+        public static Nullable<int> Sum<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, Nullable<int>>> selector);
+        public static Nullable<long> Sum<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, Nullable<long>>> selector);
+        public static Nullable<float> Sum<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, Nullable<float>>> selector);
+        public static float Sum<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, float>> selector);
+        public static IQueryable<TSource> Take<TSource>(this IQueryable<TSource> source, int count);
+        public static IQueryable<TSource> TakeWhile<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, bool>> predicate);
+        public static IQueryable<TSource> TakeWhile<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, int, bool>> predicate);
+        public static IOrderedQueryable<TSource> ThenBy<TSource, TKey>(this IOrderedQueryable<TSource> source, Expression<Func<TSource, TKey>> keySelector);
+        public static IOrderedQueryable<TSource> ThenBy<TSource, TKey>(this IOrderedQueryable<TSource> source, Expression<Func<TSource, TKey>> keySelector, IComparer<TKey> comparer);
+        public static IOrderedQueryable<TSource> ThenByDescending<TSource, TKey>(this IOrderedQueryable<TSource> source, Expression<Func<TSource, TKey>> keySelector);
+        public static IOrderedQueryable<TSource> ThenByDescending<TSource, TKey>(this IOrderedQueryable<TSource> source, Expression<Func<TSource, TKey>> keySelector, IComparer<TKey> comparer);
+        public static IQueryable<TSource> Union<TSource>(this IQueryable<TSource> source1, IEnumerable<TSource> source2);
+        public static IQueryable<TSource> Union<TSource>(this IQueryable<TSource> source1, IEnumerable<TSource> source2, IEqualityComparer<TSource> comparer);
+        public static IQueryable<TSource> Where<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, bool>> predicate);
+        public static IQueryable<TSource> Where<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, int, bool>> predicate);
+        public static IQueryable<TResult> Zip<TFirst, TSecond, TResult>(this IQueryable<TFirst> source1, IEnumerable<TSecond> source2, Expression<Func<TFirst, TSecond, TResult>> resultSelector);
+    }
+}
```

## System.Linq.Expressions

```c#
+namespace System.Linq.Expressions {
+    public class BinaryExpression : Expression {
+        public override bool CanReduce { get; }
+        public LambdaExpression Conversion { get; }
+        public bool IsLifted { get; }
+        public bool IsLiftedToNull { get; }
+        public Expression Left { get; }
+        public MethodInfo Method { get; }
+        public Expression Right { get; }
+        protected internal override Expression Accept(ExpressionVisitor visitor);
+        public override Expression Reduce();
+        public BinaryExpression Update(Expression left, LambdaExpression conversion, Expression right);
+    }
+    public class BlockExpression : Expression {
+        public ReadOnlyCollection<Expression> Expressions { get; }
+        public sealed override ExpressionType NodeType { get; }
+        public Expression Result { get; }
+        public override Type Type { get; }
+        public ReadOnlyCollection<ParameterExpression> Variables { get; }
+        protected internal override Expression Accept(ExpressionVisitor visitor);
+        public BlockExpression Update(IEnumerable<ParameterExpression> variables, IEnumerable<Expression> expressions);
+    }
+    public sealed class CatchBlock {
+        public Expression Body { get; }
+        public Expression Filter { get; }
+        public Type Test { get; }
+        public ParameterExpression Variable { get; }
+        public override string ToString();
+        public CatchBlock Update(ParameterExpression variable, Expression filter, Expression body);
+    }
+    public class ConditionalExpression : Expression {
+        public Expression IfFalse { get; }
+        public Expression IfTrue { get; }
+        public sealed override ExpressionType NodeType { get; }
+        public Expression Test { get; }
+        public override Type Type { get; }
+        protected internal override Expression Accept(ExpressionVisitor visitor);
+        public ConditionalExpression Update(Expression test, Expression ifTrue, Expression ifFalse);
+    }
+    public class ConstantExpression : Expression {
+        public sealed override ExpressionType NodeType { get; }
+        public override Type Type { get; }
+        public object Value { get; }
+        protected internal override Expression Accept(ExpressionVisitor visitor);
+    }
+    public class DebugInfoExpression : Expression {
+        public SymbolDocumentInfo Document { get; }
+        public virtual int EndColumn { get; }
+        public virtual int EndLine { get; }
+        public virtual bool IsClear { get; }
+        public sealed override ExpressionType NodeType { get; }
+        public virtual int StartColumn { get; }
+        public virtual int StartLine { get; }
+        public sealed override Type Type { get; }
+        protected internal override Expression Accept(ExpressionVisitor visitor);
+    }
+    public sealed class DefaultExpression : Expression {
+        public sealed override ExpressionType NodeType { get; }
+        public sealed override Type Type { get; }
+        protected internal override Expression Accept(ExpressionVisitor visitor);
+    }
+    public class DynamicExpression : Expression, IArgumentProvider, IDynamicExpression {
+        public ReadOnlyCollection<Expression> Arguments { get; }
+        public CallSiteBinder Binder { get; }
+        public Type DelegateType { get; }
+        public sealed override ExpressionType NodeType { get; }
+        int System.Linq.Expressions.IArgumentProvider.ArgumentCount { get; }
+        public override Type Type { get; }
+        protected override Expression Accept(ExpressionVisitor visitor);
+        public static DynamicExpression Dynamic(CallSiteBinder binder, Type returnType, IEnumerable<Expression> arguments);
+        public static DynamicExpression Dynamic(CallSiteBinder binder, Type returnType, Expression arg0);
+        public static DynamicExpression Dynamic(CallSiteBinder binder, Type returnType, Expression arg0, Expression arg1);
+        public static DynamicExpression Dynamic(CallSiteBinder binder, Type returnType, Expression arg0, Expression arg1, Expression arg2);
+        public static DynamicExpression Dynamic(CallSiteBinder binder, Type returnType, Expression arg0, Expression arg1, Expression arg2, Expression arg3);
+        public static DynamicExpression Dynamic(CallSiteBinder binder, Type returnType, params Expression[] arguments);
+        public static DynamicExpression MakeDynamic(Type delegateType, CallSiteBinder binder, IEnumerable<Expression> arguments);
+        public static DynamicExpression MakeDynamic(Type delegateType, CallSiteBinder binder, Expression arg0);
+        public static DynamicExpression MakeDynamic(Type delegateType, CallSiteBinder binder, Expression arg0, Expression arg1);
+        public static DynamicExpression MakeDynamic(Type delegateType, CallSiteBinder binder, Expression arg0, Expression arg1, Expression arg2);
+        public static DynamicExpression MakeDynamic(Type delegateType, CallSiteBinder binder, Expression arg0, Expression arg1, Expression arg2, Expression arg3);
+        public static DynamicExpression MakeDynamic(Type delegateType, CallSiteBinder binder, params Expression[] arguments);
+        Expression System.Linq.Expressions.IArgumentProvider.GetArgument(int index);
+        object System.Linq.Expressions.IDynamicExpression.CreateCallSite();
+        Expression System.Linq.Expressions.IDynamicExpression.Rewrite(Expression[] args);
+        public DynamicExpression Update(IEnumerable<Expression> arguments);
+    }
+    public abstract class DynamicExpressionVisitor : ExpressionVisitor {
+        protected DynamicExpressionVisitor();
+        protected virtual Expression VisitDynamic(DynamicExpression node);
+    }
+    public sealed class ElementInit : IArgumentProvider {
+        public MethodInfo AddMethod { get; }
+        public ReadOnlyCollection<Expression> Arguments { get; }
+        int System.Linq.Expressions.IArgumentProvider.ArgumentCount { get; }
+        Expression System.Linq.Expressions.IArgumentProvider.GetArgument(int index);
+        public override string ToString();
+        public ElementInit Update(IEnumerable<Expression> arguments);
+    }
+    public abstract class Expression {
+        protected Expression();
+        public virtual bool CanReduce { get; }
+        public virtual ExpressionType NodeType { get; }
+        public virtual Type Type { get; }
+        protected internal virtual Expression Accept(ExpressionVisitor visitor);
+        public static BinaryExpression Add(Expression left, Expression right);
+        public static BinaryExpression Add(Expression left, Expression right, MethodInfo method);
+        public static BinaryExpression AddAssign(Expression left, Expression right);
+        public static BinaryExpression AddAssign(Expression left, Expression right, MethodInfo method);
+        public static BinaryExpression AddAssign(Expression left, Expression right, MethodInfo method, LambdaExpression conversion);
+        public static BinaryExpression AddAssignChecked(Expression left, Expression right);
+        public static BinaryExpression AddAssignChecked(Expression left, Expression right, MethodInfo method);
+        public static BinaryExpression AddAssignChecked(Expression left, Expression right, MethodInfo method, LambdaExpression conversion);
+        public static BinaryExpression AddChecked(Expression left, Expression right);
+        public static BinaryExpression AddChecked(Expression left, Expression right, MethodInfo method);
+        public static BinaryExpression And(Expression left, Expression right);
+        public static BinaryExpression And(Expression left, Expression right, MethodInfo method);
+        public static BinaryExpression AndAlso(Expression left, Expression right);
+        public static BinaryExpression AndAlso(Expression left, Expression right, MethodInfo method);
+        public static BinaryExpression AndAssign(Expression left, Expression right);
+        public static BinaryExpression AndAssign(Expression left, Expression right, MethodInfo method);
+        public static BinaryExpression AndAssign(Expression left, Expression right, MethodInfo method, LambdaExpression conversion);
+        public static IndexExpression ArrayAccess(Expression array, IEnumerable<Expression> indexes);
+        public static IndexExpression ArrayAccess(Expression array, params Expression[] indexes);
+        public static MethodCallExpression ArrayIndex(Expression array, IEnumerable<Expression> indexes);
+        public static BinaryExpression ArrayIndex(Expression array, Expression index);
+        public static MethodCallExpression ArrayIndex(Expression array, params Expression[] indexes);
+        public static UnaryExpression ArrayLength(Expression array);
+        public static BinaryExpression Assign(Expression left, Expression right);
+        public static MemberAssignment Bind(MemberInfo member, Expression expression);
+        public static MemberAssignment Bind(MethodInfo propertyAccessor, Expression expression);
+        public static BlockExpression Block(IEnumerable<Expression> expressions);
+        public static BlockExpression Block(IEnumerable<ParameterExpression> variables, IEnumerable<Expression> expressions);
+        public static BlockExpression Block(IEnumerable<ParameterExpression> variables, params Expression[] expressions);
+        public static BlockExpression Block(Expression arg0, Expression arg1);
+        public static BlockExpression Block(Expression arg0, Expression arg1, Expression arg2);
+        public static BlockExpression Block(Expression arg0, Expression arg1, Expression arg2, Expression arg3);
+        public static BlockExpression Block(Expression arg0, Expression arg1, Expression arg2, Expression arg3, Expression arg4);
+        public static BlockExpression Block(params Expression[] expressions);
+        public static BlockExpression Block(Type type, IEnumerable<Expression> expressions);
+        public static BlockExpression Block(Type type, IEnumerable<ParameterExpression> variables, IEnumerable<Expression> expressions);
+        public static BlockExpression Block(Type type, IEnumerable<ParameterExpression> variables, params Expression[] expressions);
+        public static BlockExpression Block(Type type, params Expression[] expressions);
+        public static GotoExpression Break(LabelTarget target);
+        public static GotoExpression Break(LabelTarget target, Expression value);
+        public static GotoExpression Break(LabelTarget target, Expression value, Type type);
+        public static GotoExpression Break(LabelTarget target, Type type);
+        public static MethodCallExpression Call(Expression instance, MethodInfo method);
+        public static MethodCallExpression Call(Expression instance, MethodInfo method, IEnumerable<Expression> arguments);
+        public static MethodCallExpression Call(Expression instance, MethodInfo method, Expression arg0, Expression arg1);
+        public static MethodCallExpression Call(Expression instance, MethodInfo method, Expression arg0, Expression arg1, Expression arg2);
+        public static MethodCallExpression Call(Expression instance, MethodInfo method, params Expression[] arguments);
+        public static MethodCallExpression Call(Expression instance, string methodName, Type[] typeArguments, params Expression[] arguments);
+        public static MethodCallExpression Call(MethodInfo method, IEnumerable<Expression> arguments);
+        public static MethodCallExpression Call(MethodInfo method, Expression arg0);
+        public static MethodCallExpression Call(MethodInfo method, Expression arg0, Expression arg1);
+        public static MethodCallExpression Call(MethodInfo method, Expression arg0, Expression arg1, Expression arg2);
+        public static MethodCallExpression Call(MethodInfo method, Expression arg0, Expression arg1, Expression arg2, Expression arg3);
+        public static MethodCallExpression Call(MethodInfo method, Expression arg0, Expression arg1, Expression arg2, Expression arg3, Expression arg4);
+        public static MethodCallExpression Call(MethodInfo method, params Expression[] arguments);
+        public static MethodCallExpression Call(Type type, string methodName, Type[] typeArguments, params Expression[] arguments);
+        public static CatchBlock Catch(ParameterExpression variable, Expression body);
+        public static CatchBlock Catch(ParameterExpression variable, Expression body, Expression filter);
+        public static CatchBlock Catch(Type type, Expression body);
+        public static CatchBlock Catch(Type type, Expression body, Expression filter);
+        public static DebugInfoExpression ClearDebugInfo(SymbolDocumentInfo document);
+        public static BinaryExpression Coalesce(Expression left, Expression right);
+        public static BinaryExpression Coalesce(Expression left, Expression right, LambdaExpression conversion);
+        public static ConditionalExpression Condition(Expression test, Expression ifTrue, Expression ifFalse);
+        public static ConditionalExpression Condition(Expression test, Expression ifTrue, Expression ifFalse, Type type);
+        public static ConstantExpression Constant(object value);
+        public static ConstantExpression Constant(object value, Type type);
+        public static GotoExpression Continue(LabelTarget target);
+        public static GotoExpression Continue(LabelTarget target, Type type);
+        public static UnaryExpression Convert(Expression expression, Type type);
+        public static UnaryExpression Convert(Expression expression, Type type, MethodInfo method);
+        public static UnaryExpression ConvertChecked(Expression expression, Type type);
+        public static UnaryExpression ConvertChecked(Expression expression, Type type, MethodInfo method);
+        public static DebugInfoExpression DebugInfo(SymbolDocumentInfo document, int startLine, int startColumn, int endLine, int endColumn);
+        public static UnaryExpression Decrement(Expression expression);
+        public static UnaryExpression Decrement(Expression expression, MethodInfo method);
+        public static DefaultExpression Default(Type type);
+        public static BinaryExpression Divide(Expression left, Expression right);
+        public static BinaryExpression Divide(Expression left, Expression right, MethodInfo method);
+        public static BinaryExpression DivideAssign(Expression left, Expression right);
+        public static BinaryExpression DivideAssign(Expression left, Expression right, MethodInfo method);
+        public static BinaryExpression DivideAssign(Expression left, Expression right, MethodInfo method, LambdaExpression conversion);
+        public static ElementInit ElementInit(MethodInfo addMethod, IEnumerable<Expression> arguments);
+        public static ElementInit ElementInit(MethodInfo addMethod, params Expression[] arguments);
+        public static DefaultExpression Empty();
+        public static BinaryExpression Equal(Expression left, Expression right);
+        public static BinaryExpression Equal(Expression left, Expression right, bool liftToNull, MethodInfo method);
+        public static BinaryExpression ExclusiveOr(Expression left, Expression right);
+        public static BinaryExpression ExclusiveOr(Expression left, Expression right, MethodInfo method);
+        public static BinaryExpression ExclusiveOrAssign(Expression left, Expression right);
+        public static BinaryExpression ExclusiveOrAssign(Expression left, Expression right, MethodInfo method);
+        public static BinaryExpression ExclusiveOrAssign(Expression left, Expression right, MethodInfo method, LambdaExpression conversion);
+        public static MemberExpression Field(Expression expression, FieldInfo field);
+        public static MemberExpression Field(Expression expression, string fieldName);
+        public static MemberExpression Field(Expression expression, Type type, string fieldName);
+        public static Type GetActionType(params Type[] typeArgs);
+        public static Type GetDelegateType(params Type[] typeArgs);
+        public static Type GetFuncType(params Type[] typeArgs);
+        public static GotoExpression Goto(LabelTarget target);
+        public static GotoExpression Goto(LabelTarget target, Expression value);
+        public static GotoExpression Goto(LabelTarget target, Expression value, Type type);
+        public static GotoExpression Goto(LabelTarget target, Type type);
+        public static BinaryExpression GreaterThan(Expression left, Expression right);
+        public static BinaryExpression GreaterThan(Expression left, Expression right, bool liftToNull, MethodInfo method);
+        public static BinaryExpression GreaterThanOrEqual(Expression left, Expression right);
+        public static BinaryExpression GreaterThanOrEqual(Expression left, Expression right, bool liftToNull, MethodInfo method);
+        public static ConditionalExpression IfThen(Expression test, Expression ifTrue);
+        public static ConditionalExpression IfThenElse(Expression test, Expression ifTrue, Expression ifFalse);
+        public static UnaryExpression Increment(Expression expression);
+        public static UnaryExpression Increment(Expression expression, MethodInfo method);
+        public static InvocationExpression Invoke(Expression expression, IEnumerable<Expression> arguments);
+        public static InvocationExpression Invoke(Expression expression, params Expression[] arguments);
+        public static UnaryExpression IsFalse(Expression expression);
+        public static UnaryExpression IsFalse(Expression expression, MethodInfo method);
+        public static UnaryExpression IsTrue(Expression expression);
+        public static UnaryExpression IsTrue(Expression expression, MethodInfo method);
+        public static LabelTarget Label();
+        public static LabelExpression Label(LabelTarget target);
+        public static LabelExpression Label(LabelTarget target, Expression defaultValue);
+        public static LabelTarget Label(string name);
+        public static LabelTarget Label(Type type);
+        public static LabelTarget Label(Type type, string name);
+        public static LambdaExpression Lambda(Expression body, bool tailCall, IEnumerable<ParameterExpression> parameters);
+        public static LambdaExpression Lambda(Expression body, bool tailCall, params ParameterExpression[] parameters);
+        public static LambdaExpression Lambda(Expression body, IEnumerable<ParameterExpression> parameters);
+        public static LambdaExpression Lambda(Expression body, params ParameterExpression[] parameters);
+        public static LambdaExpression Lambda(Expression body, string name, bool tailCall, IEnumerable<ParameterExpression> parameters);
+        public static LambdaExpression Lambda(Expression body, string name, IEnumerable<ParameterExpression> parameters);
+        public static LambdaExpression Lambda(Type delegateType, Expression body, bool tailCall, IEnumerable<ParameterExpression> parameters);
+        public static LambdaExpression Lambda(Type delegateType, Expression body, bool tailCall, params ParameterExpression[] parameters);
+        public static LambdaExpression Lambda(Type delegateType, Expression body, IEnumerable<ParameterExpression> parameters);
+        public static LambdaExpression Lambda(Type delegateType, Expression body, params ParameterExpression[] parameters);
+        public static LambdaExpression Lambda(Type delegateType, Expression body, string name, bool tailCall, IEnumerable<ParameterExpression> parameters);
+        public static LambdaExpression Lambda(Type delegateType, Expression body, string name, IEnumerable<ParameterExpression> parameters);
+        public static Expression<TDelegate> Lambda<TDelegate>(Expression body, bool tailCall, IEnumerable<ParameterExpression> parameters);
+        public static Expression<TDelegate> Lambda<TDelegate>(Expression body, bool tailCall, params ParameterExpression[] parameters);
+        public static Expression<TDelegate> Lambda<TDelegate>(Expression body, IEnumerable<ParameterExpression> parameters);
+        public static Expression<TDelegate> Lambda<TDelegate>(Expression body, params ParameterExpression[] parameters);
+        public static Expression<TDelegate> Lambda<TDelegate>(Expression body, string name, bool tailCall, IEnumerable<ParameterExpression> parameters);
+        public static Expression<TDelegate> Lambda<TDelegate>(Expression body, string name, IEnumerable<ParameterExpression> parameters);
+        public static BinaryExpression LeftShift(Expression left, Expression right);
+        public static BinaryExpression LeftShift(Expression left, Expression right, MethodInfo method);
+        public static BinaryExpression LeftShiftAssign(Expression left, Expression right);
+        public static BinaryExpression LeftShiftAssign(Expression left, Expression right, MethodInfo method);
+        public static BinaryExpression LeftShiftAssign(Expression left, Expression right, MethodInfo method, LambdaExpression conversion);
+        public static BinaryExpression LessThan(Expression left, Expression right);
+        public static BinaryExpression LessThan(Expression left, Expression right, bool liftToNull, MethodInfo method);
+        public static BinaryExpression LessThanOrEqual(Expression left, Expression right);
+        public static BinaryExpression LessThanOrEqual(Expression left, Expression right, bool liftToNull, MethodInfo method);
+        public static MemberListBinding ListBind(MemberInfo member, IEnumerable<ElementInit> initializers);
+        public static MemberListBinding ListBind(MemberInfo member, params ElementInit[] initializers);
+        public static MemberListBinding ListBind(MethodInfo propertyAccessor, IEnumerable<ElementInit> initializers);
+        public static MemberListBinding ListBind(MethodInfo propertyAccessor, params ElementInit[] initializers);
+        public static ListInitExpression ListInit(NewExpression newExpression, IEnumerable<ElementInit> initializers);
+        public static ListInitExpression ListInit(NewExpression newExpression, IEnumerable<Expression> initializers);
+        public static ListInitExpression ListInit(NewExpression newExpression, params ElementInit[] initializers);
+        public static ListInitExpression ListInit(NewExpression newExpression, params Expression[] initializers);
+        public static ListInitExpression ListInit(NewExpression newExpression, MethodInfo addMethod, IEnumerable<Expression> initializers);
+        public static ListInitExpression ListInit(NewExpression newExpression, MethodInfo addMethod, params Expression[] initializers);
+        public static LoopExpression Loop(Expression body);
+        public static LoopExpression Loop(Expression body, LabelTarget @break);
+        public static LoopExpression Loop(Expression body, LabelTarget @break, LabelTarget @continue);
+        public static BinaryExpression MakeBinary(ExpressionType binaryType, Expression left, Expression right);
+        public static BinaryExpression MakeBinary(ExpressionType binaryType, Expression left, Expression right, bool liftToNull, MethodInfo method);
+        public static BinaryExpression MakeBinary(ExpressionType binaryType, Expression left, Expression right, bool liftToNull, MethodInfo method, LambdaExpression conversion);
+        public static CatchBlock MakeCatchBlock(Type type, ParameterExpression variable, Expression body, Expression filter);
+        public static GotoExpression MakeGoto(GotoExpressionKind kind, LabelTarget target, Expression value, Type type);
+        public static IndexExpression MakeIndex(Expression instance, PropertyInfo indexer, IEnumerable<Expression> arguments);
+        public static MemberExpression MakeMemberAccess(Expression expression, MemberInfo member);
+        public static TryExpression MakeTry(Type type, Expression body, Expression @finally, Expression fault, IEnumerable<CatchBlock> handlers);
+        public static UnaryExpression MakeUnary(ExpressionType unaryType, Expression operand, Type type);
+        public static UnaryExpression MakeUnary(ExpressionType unaryType, Expression operand, Type type, MethodInfo method);
+        public static MemberMemberBinding MemberBind(MemberInfo member, IEnumerable<MemberBinding> bindings);
+        public static MemberMemberBinding MemberBind(MemberInfo member, params MemberBinding[] bindings);
+        public static MemberMemberBinding MemberBind(MethodInfo propertyAccessor, IEnumerable<MemberBinding> bindings);
+        public static MemberMemberBinding MemberBind(MethodInfo propertyAccessor, params MemberBinding[] bindings);
+        public static MemberInitExpression MemberInit(NewExpression newExpression, IEnumerable<MemberBinding> bindings);
+        public static MemberInitExpression MemberInit(NewExpression newExpression, params MemberBinding[] bindings);
+        public static BinaryExpression Modulo(Expression left, Expression right);
+        public static BinaryExpression Modulo(Expression left, Expression right, MethodInfo method);
+        public static BinaryExpression ModuloAssign(Expression left, Expression right);
+        public static BinaryExpression ModuloAssign(Expression left, Expression right, MethodInfo method);
+        public static BinaryExpression ModuloAssign(Expression left, Expression right, MethodInfo method, LambdaExpression conversion);
+        public static BinaryExpression Multiply(Expression left, Expression right);
+        public static BinaryExpression Multiply(Expression left, Expression right, MethodInfo method);
+        public static BinaryExpression MultiplyAssign(Expression left, Expression right);
+        public static BinaryExpression MultiplyAssign(Expression left, Expression right, MethodInfo method);
+        public static BinaryExpression MultiplyAssign(Expression left, Expression right, MethodInfo method, LambdaExpression conversion);
+        public static BinaryExpression MultiplyAssignChecked(Expression left, Expression right);
+        public static BinaryExpression MultiplyAssignChecked(Expression left, Expression right, MethodInfo method);
+        public static BinaryExpression MultiplyAssignChecked(Expression left, Expression right, MethodInfo method, LambdaExpression conversion);
+        public static BinaryExpression MultiplyChecked(Expression left, Expression right);
+        public static BinaryExpression MultiplyChecked(Expression left, Expression right, MethodInfo method);
+        public static UnaryExpression Negate(Expression expression);
+        public static UnaryExpression Negate(Expression expression, MethodInfo method);
+        public static UnaryExpression NegateChecked(Expression expression);
+        public static UnaryExpression NegateChecked(Expression expression, MethodInfo method);
+        public static NewExpression New(ConstructorInfo constructor);
+        public static NewExpression New(ConstructorInfo constructor, IEnumerable<Expression> arguments);
+        public static NewExpression New(ConstructorInfo constructor, IEnumerable<Expression> arguments, IEnumerable<MemberInfo> members);
+        public static NewExpression New(ConstructorInfo constructor, IEnumerable<Expression> arguments, params MemberInfo[] members);
+        public static NewExpression New(ConstructorInfo constructor, params Expression[] arguments);
+        public static NewExpression New(Type type);
+        public static NewArrayExpression NewArrayBounds(Type type, IEnumerable<Expression> bounds);
+        public static NewArrayExpression NewArrayBounds(Type type, params Expression[] bounds);
+        public static NewArrayExpression NewArrayInit(Type type, IEnumerable<Expression> initializers);
+        public static NewArrayExpression NewArrayInit(Type type, params Expression[] initializers);
+        public static UnaryExpression Not(Expression expression);
+        public static UnaryExpression Not(Expression expression, MethodInfo method);
+        public static BinaryExpression NotEqual(Expression left, Expression right);
+        public static BinaryExpression NotEqual(Expression left, Expression right, bool liftToNull, MethodInfo method);
+        public static UnaryExpression OnesComplement(Expression expression);
+        public static UnaryExpression OnesComplement(Expression expression, MethodInfo method);
+        public static BinaryExpression Or(Expression left, Expression right);
+        public static BinaryExpression Or(Expression left, Expression right, MethodInfo method);
+        public static BinaryExpression OrAssign(Expression left, Expression right);
+        public static BinaryExpression OrAssign(Expression left, Expression right, MethodInfo method);
+        public static BinaryExpression OrAssign(Expression left, Expression right, MethodInfo method, LambdaExpression conversion);
+        public static BinaryExpression OrElse(Expression left, Expression right);
+        public static BinaryExpression OrElse(Expression left, Expression right, MethodInfo method);
+        public static ParameterExpression Parameter(Type type);
+        public static ParameterExpression Parameter(Type type, string name);
+        public static UnaryExpression PostDecrementAssign(Expression expression);
+        public static UnaryExpression PostDecrementAssign(Expression expression, MethodInfo method);
+        public static UnaryExpression PostIncrementAssign(Expression expression);
+        public static UnaryExpression PostIncrementAssign(Expression expression, MethodInfo method);
+        public static BinaryExpression Power(Expression left, Expression right);
+        public static BinaryExpression Power(Expression left, Expression right, MethodInfo method);
+        public static BinaryExpression PowerAssign(Expression left, Expression right);
+        public static BinaryExpression PowerAssign(Expression left, Expression right, MethodInfo method);
+        public static BinaryExpression PowerAssign(Expression left, Expression right, MethodInfo method, LambdaExpression conversion);
+        public static UnaryExpression PreDecrementAssign(Expression expression);
+        public static UnaryExpression PreDecrementAssign(Expression expression, MethodInfo method);
+        public static UnaryExpression PreIncrementAssign(Expression expression);
+        public static UnaryExpression PreIncrementAssign(Expression expression, MethodInfo method);
+        public static MemberExpression Property(Expression expression, MethodInfo propertyAccessor);
+        public static MemberExpression Property(Expression expression, PropertyInfo property);
+        public static IndexExpression Property(Expression instance, PropertyInfo indexer, IEnumerable<Expression> arguments);
+        public static IndexExpression Property(Expression instance, PropertyInfo indexer, params Expression[] arguments);
+        public static MemberExpression Property(Expression expression, string propertyName);
+        public static IndexExpression Property(Expression instance, string propertyName, params Expression[] arguments);
+        public static MemberExpression Property(Expression expression, Type type, string propertyName);
+        public static MemberExpression PropertyOrField(Expression expression, string propertyOrFieldName);
+        public static UnaryExpression Quote(Expression expression);
+        public virtual Expression Reduce();
+        public Expression ReduceAndCheck();
+        public Expression ReduceExtensions();
+        public static BinaryExpression ReferenceEqual(Expression left, Expression right);
+        public static BinaryExpression ReferenceNotEqual(Expression left, Expression right);
+        public static UnaryExpression Rethrow();
+        public static UnaryExpression Rethrow(Type type);
+        public static GotoExpression Return(LabelTarget target);
+        public static GotoExpression Return(LabelTarget target, Expression value);
+        public static GotoExpression Return(LabelTarget target, Expression value, Type type);
+        public static GotoExpression Return(LabelTarget target, Type type);
+        public static BinaryExpression RightShift(Expression left, Expression right);
+        public static BinaryExpression RightShift(Expression left, Expression right, MethodInfo method);
+        public static BinaryExpression RightShiftAssign(Expression left, Expression right);
+        public static BinaryExpression RightShiftAssign(Expression left, Expression right, MethodInfo method);
+        public static BinaryExpression RightShiftAssign(Expression left, Expression right, MethodInfo method, LambdaExpression conversion);
+        public static RuntimeVariablesExpression RuntimeVariables(IEnumerable<ParameterExpression> variables);
+        public static RuntimeVariablesExpression RuntimeVariables(params ParameterExpression[] variables);
+        public static BinaryExpression Subtract(Expression left, Expression right);
+        public static BinaryExpression Subtract(Expression left, Expression right, MethodInfo method);
+        public static BinaryExpression SubtractAssign(Expression left, Expression right);
+        public static BinaryExpression SubtractAssign(Expression left, Expression right, MethodInfo method);
+        public static BinaryExpression SubtractAssign(Expression left, Expression right, MethodInfo method, LambdaExpression conversion);
+        public static BinaryExpression SubtractAssignChecked(Expression left, Expression right);
+        public static BinaryExpression SubtractAssignChecked(Expression left, Expression right, MethodInfo method);
+        public static BinaryExpression SubtractAssignChecked(Expression left, Expression right, MethodInfo method, LambdaExpression conversion);
+        public static BinaryExpression SubtractChecked(Expression left, Expression right);
+        public static BinaryExpression SubtractChecked(Expression left, Expression right, MethodInfo method);
+        public static SwitchExpression Switch(Expression switchValue, Expression defaultBody, params SwitchCase[] cases);
+        public static SwitchExpression Switch(Expression switchValue, Expression defaultBody, MethodInfo comparison, IEnumerable<SwitchCase> cases);
+        public static SwitchExpression Switch(Expression switchValue, Expression defaultBody, MethodInfo comparison, params SwitchCase[] cases);
+        public static SwitchExpression Switch(Expression switchValue, params SwitchCase[] cases);
+        public static SwitchExpression Switch(Type type, Expression switchValue, Expression defaultBody, MethodInfo comparison, IEnumerable<SwitchCase> cases);
+        public static SwitchExpression Switch(Type type, Expression switchValue, Expression defaultBody, MethodInfo comparison, params SwitchCase[] cases);
+        public static SwitchCase SwitchCase(Expression body, IEnumerable<Expression> testValues);
+        public static SwitchCase SwitchCase(Expression body, params Expression[] testValues);
+        public static SymbolDocumentInfo SymbolDocument(string fileName);
+        public static SymbolDocumentInfo SymbolDocument(string fileName, Guid language);
+        public static SymbolDocumentInfo SymbolDocument(string fileName, Guid language, Guid languageVendor);
+        public static SymbolDocumentInfo SymbolDocument(string fileName, Guid language, Guid languageVendor, Guid documentType);
+        public static UnaryExpression Throw(Expression value);
+        public static UnaryExpression Throw(Expression value, Type type);
+        public override string ToString();
+        public static TryExpression TryCatch(Expression body, params CatchBlock[] handlers);
+        public static TryExpression TryCatchFinally(Expression body, Expression @finally, params CatchBlock[] handlers);
+        public static TryExpression TryFault(Expression body, Expression fault);
+        public static TryExpression TryFinally(Expression body, Expression @finally);
+        public static bool TryGetActionType(Type[] typeArgs, out Type actionType);
+        public static bool TryGetFuncType(Type[] typeArgs, out Type funcType);
+        public static UnaryExpression TypeAs(Expression expression, Type type);
+        public static TypeBinaryExpression TypeEqual(Expression expression, Type type);
+        public static TypeBinaryExpression TypeIs(Expression expression, Type type);
+        public static UnaryExpression UnaryPlus(Expression expression);
+        public static UnaryExpression UnaryPlus(Expression expression, MethodInfo method);
+        public static UnaryExpression Unbox(Expression expression, Type type);
+        public static ParameterExpression Variable(Type type);
+        public static ParameterExpression Variable(Type type, string name);
+        protected internal virtual Expression VisitChildren(ExpressionVisitor visitor);
+    }
+    public sealed class Expression<TDelegate> : LambdaExpression {
+        protected internal override Expression Accept(ExpressionVisitor visitor);
+        public new TDelegate Compile();
+        public new TDelegate Compile(bool preferInterpretation);
+        public Expression<TDelegate> Update(Expression body, IEnumerable<ParameterExpression> parameters);
+    }
+    public enum ExpressionType {
+        Add = 0,
+        AddAssign = 63,
+        AddAssignChecked = 74,
+        AddChecked = 1,
+        And = 2,
+        AndAlso = 3,
+        AndAssign = 64,
+        ArrayIndex = 5,
+        ArrayLength = 4,
+        Assign = 46,
+        Block = 47,
+        Call = 6,
+        Coalesce = 7,
+        Conditional = 8,
+        Constant = 9,
+        Convert = 10,
+        ConvertChecked = 11,
+        DebugInfo = 48,
+        Decrement = 49,
+        Default = 51,
+        Divide = 12,
+        DivideAssign = 65,
+        Dynamic = 50,
+        Equal = 13,
+        ExclusiveOr = 14,
+        ExclusiveOrAssign = 66,
+        Extension = 52,
+        Goto = 53,
+        GreaterThan = 15,
+        GreaterThanOrEqual = 16,
+        Increment = 54,
+        Index = 55,
+        Invoke = 17,
+        IsFalse = 84,
+        IsTrue = 83,
+        Label = 56,
+        Lambda = 18,
+        LeftShift = 19,
+        LeftShiftAssign = 67,
+        LessThan = 20,
+        LessThanOrEqual = 21,
+        ListInit = 22,
+        Loop = 58,
+        MemberAccess = 23,
+        MemberInit = 24,
+        Modulo = 25,
+        ModuloAssign = 68,
+        Multiply = 26,
+        MultiplyAssign = 69,
+        MultiplyAssignChecked = 75,
+        MultiplyChecked = 27,
+        Negate = 28,
+        NegateChecked = 30,
+        New = 31,
+        NewArrayBounds = 33,
+        NewArrayInit = 32,
+        Not = 34,
+        NotEqual = 35,
+        OnesComplement = 82,
+        Or = 36,
+        OrAssign = 70,
+        OrElse = 37,
+        Parameter = 38,
+        PostDecrementAssign = 80,
+        PostIncrementAssign = 79,
+        Power = 39,
+        PowerAssign = 71,
+        PreDecrementAssign = 78,
+        PreIncrementAssign = 77,
+        Quote = 40,
+        RightShift = 41,
+        RightShiftAssign = 72,
+        RuntimeVariables = 57,
+        Subtract = 42,
+        SubtractAssign = 73,
+        SubtractAssignChecked = 76,
+        SubtractChecked = 43,
+        Switch = 59,
+        Throw = 60,
+        Try = 61,
+        TypeAs = 44,
+        TypeEqual = 81,
+        TypeIs = 45,
+        UnaryPlus = 29,
+        Unbox = 62,
+    }
+    public abstract class ExpressionVisitor {
+        protected ExpressionVisitor();
+        public ReadOnlyCollection<Expression> Visit(ReadOnlyCollection<Expression> nodes);
+        public virtual Expression Visit(Expression node);
+        public static ReadOnlyCollection<T> Visit<T>(ReadOnlyCollection<T> nodes, Func<T, T> elementVisitor);
+        public ReadOnlyCollection<T> VisitAndConvert<T>(ReadOnlyCollection<T> nodes, string callerName) where T : Expression;
+        public T VisitAndConvert<T>(T node, string callerName) where T : Expression;
+        protected internal virtual Expression VisitBinary(BinaryExpression node);
+        protected internal virtual Expression VisitBlock(BlockExpression node);
+        protected virtual CatchBlock VisitCatchBlock(CatchBlock node);
+        protected internal virtual Expression VisitConditional(ConditionalExpression node);
+        protected internal virtual Expression VisitConstant(ConstantExpression node);
+        protected internal virtual Expression VisitDebugInfo(DebugInfoExpression node);
+        protected internal virtual Expression VisitDefault(DefaultExpression node);
+        protected virtual ElementInit VisitElementInit(ElementInit node);
+        protected internal virtual Expression VisitExtension(Expression node);
+        protected internal virtual Expression VisitGoto(GotoExpression node);
+        protected internal virtual Expression VisitIndex(IndexExpression node);
+        protected internal virtual Expression VisitInvocation(InvocationExpression node);
+        protected internal virtual Expression VisitLabel(LabelExpression node);
+        protected virtual LabelTarget VisitLabelTarget(LabelTarget node);
+        protected internal virtual Expression VisitLambda<T>(Expression<T> node);
+        protected internal virtual Expression VisitListInit(ListInitExpression node);
+        protected internal virtual Expression VisitLoop(LoopExpression node);
+        protected internal virtual Expression VisitMember(MemberExpression node);
+        protected virtual MemberAssignment VisitMemberAssignment(MemberAssignment node);
+        protected virtual MemberBinding VisitMemberBinding(MemberBinding node);
+        protected internal virtual Expression VisitMemberInit(MemberInitExpression node);
+        protected virtual MemberListBinding VisitMemberListBinding(MemberListBinding node);
+        protected virtual MemberMemberBinding VisitMemberMemberBinding(MemberMemberBinding node);
+        protected internal virtual Expression VisitMethodCall(MethodCallExpression node);
+        protected internal virtual Expression VisitNew(NewExpression node);
+        protected internal virtual Expression VisitNewArray(NewArrayExpression node);
+        protected internal virtual Expression VisitParameter(ParameterExpression node);
+        protected internal virtual Expression VisitRuntimeVariables(RuntimeVariablesExpression node);
+        protected internal virtual Expression VisitSwitch(SwitchExpression node);
+        protected virtual SwitchCase VisitSwitchCase(SwitchCase node);
+        protected internal virtual Expression VisitTry(TryExpression node);
+        protected internal virtual Expression VisitTypeBinary(TypeBinaryExpression node);
+        protected internal virtual Expression VisitUnary(UnaryExpression node);
+    }
+    public sealed class GotoExpression : Expression {
+        public GotoExpressionKind Kind { get; }
+        public sealed override ExpressionType NodeType { get; }
+        public LabelTarget Target { get; }
+        public sealed override Type Type { get; }
+        public Expression Value { get; }
+        protected internal override Expression Accept(ExpressionVisitor visitor);
+        public GotoExpression Update(LabelTarget target, Expression value);
+    }
+    public enum GotoExpressionKind {
+        Break = 2,
+        Continue = 3,
+        Goto = 0,
+        Return = 1,
+    }
+    public interface IArgumentProvider {
+        int ArgumentCount { get; }
+        Expression GetArgument(int index);
+    }
+    public interface IDynamicExpression : IArgumentProvider {
+        Type DelegateType { get; }
+        object CreateCallSite();
+        Expression Rewrite(Expression[] args);
+    }
+    public sealed class IndexExpression : Expression, IArgumentProvider {
+        public ReadOnlyCollection<Expression> Arguments { get; }
+        public PropertyInfo Indexer { get; }
+        public sealed override ExpressionType NodeType { get; }
+        public Expression Object { get; }
+        int System.Linq.Expressions.IArgumentProvider.ArgumentCount { get; }
+        public sealed override Type Type { get; }
+        protected internal override Expression Accept(ExpressionVisitor visitor);
+        Expression System.Linq.Expressions.IArgumentProvider.GetArgument(int index);
+        public IndexExpression Update(Expression @object, IEnumerable<Expression> arguments);
+    }
+    public sealed class InvocationExpression : Expression, IArgumentProvider {
+        public ReadOnlyCollection<Expression> Arguments { get; }
+        public Expression Expression { get; }
+        public sealed override ExpressionType NodeType { get; }
+        int System.Linq.Expressions.IArgumentProvider.ArgumentCount { get; }
+        public sealed override Type Type { get; }
+        protected internal override Expression Accept(ExpressionVisitor visitor);
+        Expression System.Linq.Expressions.IArgumentProvider.GetArgument(int index);
+        public InvocationExpression Update(Expression expression, IEnumerable<Expression> arguments);
+    }
+    public sealed class LabelExpression : Expression {
+        public Expression DefaultValue { get; }
+        public sealed override ExpressionType NodeType { get; }
+        public LabelTarget Target { get; }
+        public sealed override Type Type { get; }
+        protected internal override Expression Accept(ExpressionVisitor visitor);
+        public LabelExpression Update(LabelTarget target, Expression defaultValue);
+    }
+    public sealed class LabelTarget {
+        public string Name { get; }
+        public Type Type { get; }
+        public override string ToString();
+    }
+    public abstract class LambdaExpression : Expression {
+        public Expression Body { get; }
+        public string Name { get; }
+        public sealed override ExpressionType NodeType { get; }
+        public ReadOnlyCollection<ParameterExpression> Parameters { get; }
+        public Type ReturnType { get; }
+        public bool TailCall { get; }
+        public sealed override Type Type { get; }
+        public Delegate Compile();
+        public Delegate Compile(bool preferInterpretation);
+    }
+    public sealed class ListInitExpression : Expression {
+        public override bool CanReduce { get; }
+        public ReadOnlyCollection<ElementInit> Initializers { get; }
+        public NewExpression NewExpression { get; }
+        public sealed override ExpressionType NodeType { get; }
+        public sealed override Type Type { get; }
+        protected internal override Expression Accept(ExpressionVisitor visitor);
+        public override Expression Reduce();
+        public ListInitExpression Update(NewExpression newExpression, IEnumerable<ElementInit> initializers);
+    }
+    public sealed class LoopExpression : Expression {
+        public Expression Body { get; }
+        public LabelTarget BreakLabel { get; }
+        public LabelTarget ContinueLabel { get; }
+        public sealed override ExpressionType NodeType { get; }
+        public sealed override Type Type { get; }
+        protected internal override Expression Accept(ExpressionVisitor visitor);
+        public LoopExpression Update(LabelTarget breakLabel, LabelTarget continueLabel, Expression body);
+    }
+    public sealed class MemberAssignment : MemberBinding {
+        public Expression Expression { get; }
+        public MemberAssignment Update(Expression expression);
+    }
+    public abstract class MemberBinding {
+        public MemberBindingType BindingType { get; }
+        public MemberInfo Member { get; }
+        public override string ToString();
+    }
+    public enum MemberBindingType {
+        Assignment = 0,
+        ListBinding = 2,
+        MemberBinding = 1,
+    }
+    public class MemberExpression : Expression {
+        public Expression Expression { get; }
+        public MemberInfo Member { get; }
+        public sealed override ExpressionType NodeType { get; }
+        protected internal override Expression Accept(ExpressionVisitor visitor);
+        public MemberExpression Update(Expression expression);
+    }
+    public sealed class MemberInitExpression : Expression {
+        public ReadOnlyCollection<MemberBinding> Bindings { get; }
+        public override bool CanReduce { get; }
+        public NewExpression NewExpression { get; }
+        public sealed override ExpressionType NodeType { get; }
+        public sealed override Type Type { get; }
+        protected internal override Expression Accept(ExpressionVisitor visitor);
+        public override Expression Reduce();
+        public MemberInitExpression Update(NewExpression newExpression, IEnumerable<MemberBinding> bindings);
+    }
+    public sealed class MemberListBinding : MemberBinding {
+        public ReadOnlyCollection<ElementInit> Initializers { get; }
+        public MemberListBinding Update(IEnumerable<ElementInit> initializers);
+    }
+    public sealed class MemberMemberBinding : MemberBinding {
+        public ReadOnlyCollection<MemberBinding> Bindings { get; }
+        public MemberMemberBinding Update(IEnumerable<MemberBinding> bindings);
+    }
+    public class MethodCallExpression : Expression, IArgumentProvider {
+        public ReadOnlyCollection<Expression> Arguments { get; }
+        public MethodInfo Method { get; }
+        public sealed override ExpressionType NodeType { get; }
+        public Expression Object { get; }
+        int System.Linq.Expressions.IArgumentProvider.ArgumentCount { get; }
+        public sealed override Type Type { get; }
+        protected internal override Expression Accept(ExpressionVisitor visitor);
+        Expression System.Linq.Expressions.IArgumentProvider.GetArgument(int index);
+        public MethodCallExpression Update(Expression @object, IEnumerable<Expression> arguments);
+    }
+    public class NewArrayExpression : Expression {
+        public ReadOnlyCollection<Expression> Expressions { get; }
+        public sealed override Type Type { get; }
+        protected internal override Expression Accept(ExpressionVisitor visitor);
+        public NewArrayExpression Update(IEnumerable<Expression> expressions);
+    }
+    public class NewExpression : Expression, IArgumentProvider {
+        public ReadOnlyCollection<Expression> Arguments { get; }
+        public ConstructorInfo Constructor { get; }
+        public ReadOnlyCollection<MemberInfo> Members { get; }
+        public sealed override ExpressionType NodeType { get; }
+        int System.Linq.Expressions.IArgumentProvider.ArgumentCount { get; }
+        public override Type Type { get; }
+        protected internal override Expression Accept(ExpressionVisitor visitor);
+        Expression System.Linq.Expressions.IArgumentProvider.GetArgument(int index);
+        public NewExpression Update(IEnumerable<Expression> arguments);
+    }
+    public class ParameterExpression : Expression {
+        public bool IsByRef { get; }
+        public string Name { get; }
+        public sealed override ExpressionType NodeType { get; }
+        public override Type Type { get; }
+        protected internal override Expression Accept(ExpressionVisitor visitor);
+    }
+    public sealed class RuntimeVariablesExpression : Expression {
+        public sealed override ExpressionType NodeType { get; }
+        public sealed override Type Type { get; }
+        public ReadOnlyCollection<ParameterExpression> Variables { get; }
+        protected internal override Expression Accept(ExpressionVisitor visitor);
+        public RuntimeVariablesExpression Update(IEnumerable<ParameterExpression> variables);
+    }
+    public sealed class SwitchCase {
+        public Expression Body { get; }
+        public ReadOnlyCollection<Expression> TestValues { get; }
+        public override string ToString();
+        public SwitchCase Update(IEnumerable<Expression> testValues, Expression body);
+    }
+    public sealed class SwitchExpression : Expression {
+        public ReadOnlyCollection<SwitchCase> Cases { get; }
+        public MethodInfo Comparison { get; }
+        public Expression DefaultBody { get; }
+        public sealed override ExpressionType NodeType { get; }
+        public Expression SwitchValue { get; }
+        public sealed override Type Type { get; }
+        protected internal override Expression Accept(ExpressionVisitor visitor);
+        public SwitchExpression Update(Expression switchValue, IEnumerable<SwitchCase> cases, Expression defaultBody);
+    }
+    public class SymbolDocumentInfo {
+        public virtual Guid DocumentType { get; }
+        public string FileName { get; }
+        public virtual Guid Language { get; }
+        public virtual Guid LanguageVendor { get; }
+    }
+    public sealed class TryExpression : Expression {
+        public Expression Body { get; }
+        public Expression Fault { get; }
+        public Expression Finally { get; }
+        public ReadOnlyCollection<CatchBlock> Handlers { get; }
+        public sealed override ExpressionType NodeType { get; }
+        public sealed override Type Type { get; }
+        protected internal override Expression Accept(ExpressionVisitor visitor);
+        public TryExpression Update(Expression body, IEnumerable<CatchBlock> handlers, Expression @finally, Expression fault);
+    }
+    public sealed class TypeBinaryExpression : Expression {
+        public Expression Expression { get; }
+        public sealed override ExpressionType NodeType { get; }
+        public sealed override Type Type { get; }
+        public Type TypeOperand { get; }
+        protected internal override Expression Accept(ExpressionVisitor visitor);
+        public TypeBinaryExpression Update(Expression expression);
+    }
+    public sealed class UnaryExpression : Expression {
+        public override bool CanReduce { get; }
+        public bool IsLifted { get; }
+        public bool IsLiftedToNull { get; }
+        public MethodInfo Method { get; }
+        public sealed override ExpressionType NodeType { get; }
+        public Expression Operand { get; }
+        public sealed override Type Type { get; }
+        protected internal override Expression Accept(ExpressionVisitor visitor);
+        public override Expression Reduce();
+        public UnaryExpression Update(Expression operand);
+    }
+}
```

## System.Net

```c#
+namespace System.Net {
+    public enum AuthenticationSchemes {
+        Anonymous = 32768,
+        Basic = 8,
+        Digest = 1,
+        IntegratedWindowsAuthentication = 6,
+        Negotiate = 2,
+        None = 0,
+        Ntlm = 4,
+    }
+    public sealed class Cookie {
+        public Cookie();
+        public Cookie(string name, string value);
+        public Cookie(string name, string value, string path);
+        public Cookie(string name, string value, string path, string domain);
+        public string Comment { get; set; }
+        public Uri CommentUri { get; set; }
+        public bool Discard { get; set; }
+        public string Domain { get; set; }
+        public bool Expired { get; set; }
+        public DateTime Expires { get; set; }
+        public bool HttpOnly { get; set; }
+        public string Name { get; set; }
+        public string Path { get; set; }
+        public string Port { get; set; }
+        public bool Secure { get; set; }
+        public DateTime TimeStamp { get; }
+        public string Value { get; set; }
+        public int Version { get; set; }
+        public override bool Equals(object comparand);
+        public override int GetHashCode();
+        public override string ToString();
+    }
+    public class CookieCollection : ICollection, IEnumerable {
+        public CookieCollection();
+        public int Count { get; }
+        bool System.Collections.ICollection.IsSynchronized { get; }
+        object System.Collections.ICollection.SyncRoot { get; }
+        public Cookie this[string name] { get; }
+        public void Add(Cookie cookie);
+        public void Add(CookieCollection cookies);
+        public IEnumerator GetEnumerator();
+        void System.Collections.ICollection.CopyTo(Array array, int index);
+    }
+    public class CookieContainer {
+        public const int DefaultCookieLengthLimit = 4096;
+        public const int DefaultCookieLimit = 300;
+        public const int DefaultPerDomainCookieLimit = 20;
+        public CookieContainer();
+        public int Capacity { get; set; }
+        public int Count { get; }
+        public int MaxCookieSize { get; set; }
+        public int PerDomainCapacity { get; set; }
+        public void Add(Uri uri, Cookie cookie);
+        public void Add(Uri uri, CookieCollection cookies);
+        public string GetCookieHeader(Uri uri);
+        public CookieCollection GetCookies(Uri uri);
+        public void SetCookies(Uri uri, string cookieHeader);
+    }
+    public class CookieException : FormatException {
+        public CookieException();
+    }
+    public class CredentialCache : ICredentials, ICredentialsByHost, IEnumerable {
+        public CredentialCache();
+        public static ICredentials DefaultCredentials { get; }
+        public static NetworkCredential DefaultNetworkCredentials { get; }
+        public void Add(string host, int port, string authenticationType, NetworkCredential credential);
+        public void Add(Uri uriPrefix, string authType, NetworkCredential cred);
+        public NetworkCredential GetCredential(string host, int port, string authenticationType);
+        public NetworkCredential GetCredential(Uri uriPrefix, string authType);
+        public IEnumerator GetEnumerator();
+        public void Remove(string host, int port, string authenticationType);
+        public void Remove(Uri uriPrefix, string authType);
+    }
+    public enum DecompressionMethods {
+        Deflate = 2,
+        GZip = 1,
+        None = 0,
+    }
+    public static class Dns {
+        public static Task<IPAddress[]> GetHostAddressesAsync(string hostNameOrAddress);
+        public static Task<IPHostEntry> GetHostEntryAsync(IPAddress address);
+        public static Task<IPHostEntry> GetHostEntryAsync(string hostNameOrAddress);
+        public static string GetHostName();
+    }
+    public class DnsEndPoint : EndPoint {
+        public DnsEndPoint(string host, int port);
+        public DnsEndPoint(string host, int port, AddressFamily addressFamily);
+        public override AddressFamily AddressFamily { get; }
+        public string Host { get; }
+        public int Port { get; }
+        public override bool Equals(object comparand);
+        public override int GetHashCode();
+        public override string ToString();
+    }
+    public abstract class EndPoint {
+        protected EndPoint();
+        public virtual AddressFamily AddressFamily { get; }
+        public virtual EndPoint Create(SocketAddress socketAddress);
+        public virtual SocketAddress Serialize();
+    }
+    public enum HttpRequestHeader {
+        Accept = 20,
+        AcceptCharset = 21,
+        AcceptEncoding = 22,
+        AcceptLanguage = 23,
+        Allow = 10,
+        Authorization = 24,
+        CacheControl = 0,
+        Connection = 1,
+        ContentEncoding = 13,
+        ContentLanguage = 14,
+        ContentLength = 11,
+        ContentLocation = 15,
+        ContentMd5 = 16,
+        ContentRange = 17,
+        ContentType = 12,
+        Cookie = 25,
+        Date = 2,
+        Expect = 26,
+        Expires = 18,
+        From = 27,
+        Host = 28,
+        IfMatch = 29,
+        IfModifiedSince = 30,
+        IfNoneMatch = 31,
+        IfRange = 32,
+        IfUnmodifiedSince = 33,
+        KeepAlive = 3,
+        LastModified = 19,
+        MaxForwards = 34,
+        Pragma = 4,
+        ProxyAuthorization = 35,
+        Range = 37,
+        Referer = 36,
+        Te = 38,
+        Trailer = 5,
+        TransferEncoding = 6,
+        Translate = 39,
+        Upgrade = 7,
+        UserAgent = 40,
+        Via = 8,
+        Warning = 9,
+    }
+    public enum HttpResponseHeader {
+        AcceptRanges = 20,
+        Age = 21,
+        Allow = 10,
+        CacheControl = 0,
+        Connection = 1,
+        ContentEncoding = 13,
+        ContentLanguage = 14,
+        ContentLength = 11,
+        ContentLocation = 15,
+        ContentMd5 = 16,
+        ContentRange = 17,
+        ContentType = 12,
+        Date = 2,
+        ETag = 22,
+        Expires = 18,
+        KeepAlive = 3,
+        LastModified = 19,
+        Location = 23,
+        Pragma = 4,
+        ProxyAuthenticate = 24,
+        RetryAfter = 25,
+        Server = 26,
+        SetCookie = 27,
+        Trailer = 5,
+        TransferEncoding = 6,
+        Upgrade = 7,
+        Vary = 28,
+        Via = 8,
+        Warning = 9,
+        WwwAuthenticate = 29,
+    }
+    public enum HttpStatusCode {
+        Accepted = 202,
+        Ambiguous = 300,
+        BadGateway = 502,
+        BadRequest = 400,
+        Conflict = 409,
+        Continue = 100,
+        Created = 201,
+        ExpectationFailed = 417,
+        Forbidden = 403,
+        Found = 302,
+        GatewayTimeout = 504,
+        Gone = 410,
+        HttpVersionNotSupported = 505,
+        InternalServerError = 500,
+        LengthRequired = 411,
+        MethodNotAllowed = 405,
+        Moved = 301,
+        MovedPermanently = 301,
+        MultipleChoices = 300,
+        NoContent = 204,
+        NonAuthoritativeInformation = 203,
+        NotAcceptable = 406,
+        NotFound = 404,
+        NotImplemented = 501,
+        NotModified = 304,
+        OK = 200,
+        PartialContent = 206,
+        PaymentRequired = 402,
+        PreconditionFailed = 412,
+        ProxyAuthenticationRequired = 407,
+        Redirect = 302,
+        RedirectKeepVerb = 307,
+        RedirectMethod = 303,
+        RequestedRangeNotSatisfiable = 416,
+        RequestEntityTooLarge = 413,
+        RequestTimeout = 408,
+        RequestUriTooLong = 414,
+        ResetContent = 205,
+        SeeOther = 303,
+        ServiceUnavailable = 503,
+        SwitchingProtocols = 101,
+        TemporaryRedirect = 307,
+        Unauthorized = 401,
+        UnsupportedMediaType = 415,
+        Unused = 306,
+        UpgradeRequired = 426,
+        UseProxy = 305,
+    }
+    public class HttpWebRequest : WebRequest {
+        public string Accept { get; set; }
+        public virtual bool AllowReadStreamBuffering { get; set; }
+        public override string ContentType { get; set; }
+        public int ContinueTimeout { get; set; }
+        public virtual CookieContainer CookieContainer { get; set; }
+        public override ICredentials Credentials { get; set; }
+        public virtual bool HaveResponse { get; }
+        public override WebHeaderCollection Headers { get; set; }
+        public override string Method { get; set; }
+        public override Uri RequestUri { get; }
+        public virtual bool SupportsCookieContainer { get; }
+        public override bool UseDefaultCredentials { get; set; }
+        public override void Abort();
+        public override IAsyncResult BeginGetRequestStream(AsyncCallback callback, object state);
+        public override IAsyncResult BeginGetResponse(AsyncCallback callback, object state);
+        public override Stream EndGetRequestStream(IAsyncResult asyncResult);
+        public override WebResponse EndGetResponse(IAsyncResult asyncResult);
+    }
+    public class HttpWebResponse : WebResponse {
+        public override long ContentLength { get; }
+        public override string ContentType { get; }
+        public virtual CookieCollection Cookies { get; }
+        public override WebHeaderCollection Headers { get; }
+        public virtual string Method { get; }
+        public override Uri ResponseUri { get; }
+        public virtual HttpStatusCode StatusCode { get; }
+        public virtual string StatusDescription { get; }
+        public override bool SupportsHeaders { get; }
+        protected override void Dispose(bool disposing);
+        public override Stream GetResponseStream();
+    }
+    public interface ICredentials {
+        NetworkCredential GetCredential(Uri uri, string authType);
+    }
+    public interface ICredentialsByHost {
+        NetworkCredential GetCredential(string host, int port, string authenticationType);
+    }
+    public class IPAddress {
+        public static readonly IPAddress Any;
+        public static readonly IPAddress Broadcast;
+        public static readonly IPAddress IPv6Any;
+        public static readonly IPAddress IPv6Loopback;
+        public static readonly IPAddress IPv6None;
+        public static readonly IPAddress Loopback;
+        public static readonly IPAddress None;
+        public IPAddress(byte[] address);
+        public IPAddress(byte[] address, long scopeid);
+        public IPAddress(long newAddress);
+        public AddressFamily AddressFamily { get; }
+        public bool IsIPv4MappedToIPv6 { get; }
+        public bool IsIPv6LinkLocal { get; }
+        public bool IsIPv6Multicast { get; }
+        public bool IsIPv6SiteLocal { get; }
+        public bool IsIPv6Teredo { get; }
+        public long ScopeId { get; set; }
+        public override bool Equals(object comparand);
+        public byte[] GetAddressBytes();
+        public override int GetHashCode();
+        public static short HostToNetworkOrder(short host);
+        public static int HostToNetworkOrder(int host);
+        public static long HostToNetworkOrder(long host);
+        public static bool IsLoopback(IPAddress address);
+        public IPAddress MapToIPv4();
+        public IPAddress MapToIPv6();
+        public static short NetworkToHostOrder(short network);
+        public static int NetworkToHostOrder(int network);
+        public static long NetworkToHostOrder(long network);
+        public static IPAddress Parse(string ipString);
+        public override string ToString();
+        public static bool TryParse(string ipString, out IPAddress address);
+    }
+    public class IPEndPoint : EndPoint {
+        public const int MaxPort = 65535;
+        public const int MinPort = 0;
+        public IPEndPoint(long address, int port);
+        public IPEndPoint(IPAddress address, int port);
+        public IPAddress Address { get; set; }
+        public override AddressFamily AddressFamily { get; }
+        public int Port { get; set; }
+        public override EndPoint Create(SocketAddress socketAddress);
+        public override bool Equals(object comparand);
+        public override int GetHashCode();
+        public override SocketAddress Serialize();
+        public override string ToString();
+    }
+    public class IPHostEntry {
+        public IPHostEntry();
+        public IPAddress[] AddressList { get; set; }
+        public string[] Aliases { get; set; }
+        public string HostName { get; set; }
+    }
+    public interface IWebProxy {
+        ICredentials Credentials { get; set; }
+        Uri GetProxy(Uri destination);
+        bool IsBypassed(Uri host);
+    }
+    public interface IWebRequestCreate {
+        WebRequest Create(Uri uri);
+    }
+    public class NetworkCredential : ICredentials, ICredentialsByHost {
+        public NetworkCredential();
+        public NetworkCredential(string userName, string password);
+        public NetworkCredential(string userName, string password, string domain);
+        public string Domain { get; set; }
+        public string Password { get; set; }
+        public string UserName { get; set; }
+        public NetworkCredential GetCredential(string host, int port, string authenticationType);
+        public NetworkCredential GetCredential(Uri uri, string authType);
+    }
+    public class ProtocolViolationException : InvalidOperationException {
+        public ProtocolViolationException();
+        public ProtocolViolationException(string message);
+    }
+    public class SocketAddress {
+        public SocketAddress(AddressFamily family);
+        public SocketAddress(AddressFamily family, int size);
+        public AddressFamily Family { get; }
+        public int Size { get; }
+        public byte this[int offset] { get; set; }
+        public override bool Equals(object comparand);
+        public override int GetHashCode();
+        public override string ToString();
+    }
+    public abstract class TransportContext {
+        protected TransportContext();
+        public abstract ChannelBinding GetChannelBinding(ChannelBindingKind kind);
+    }
+    public class WebException : InvalidOperationException {
+        public WebException();
+        public WebException(string message);
+        public WebException(string message, Exception innerException);
+        public WebException(string message, Exception innerException, WebExceptionStatus status, WebResponse response);
+        public WebException(string message, WebExceptionStatus status);
+        public WebResponse Response { get; }
+        public WebExceptionStatus Status { get; }
+    }
+    public enum WebExceptionStatus {
+        CacheEntryNotFound = 18,
+        ConnectFailure = 2,
+        ConnectionClosed = 8,
+        KeepAliveFailure = 12,
+        MessageLengthLimitExceeded = 17,
+        NameResolutionFailure = 1,
+        Pending = 13,
+        PipelineFailure = 5,
+        ProtocolError = 7,
+        ProxyNameResolutionFailure = 15,
+        ReceiveFailure = 3,
+        RequestCanceled = 6,
+        RequestProhibitedByCachePolicy = 19,
+        RequestProhibitedByProxy = 20,
+        SecureChannelFailure = 10,
+        SendFailure = 4,
+        ServerProtocolViolation = 11,
+        Success = 0,
+        Timeout = 14,
+        TrustFailure = 9,
+        UnknownError = 16,
+    }
+    public sealed class WebHeaderCollection : IEnumerable {
+        public WebHeaderCollection();
+        public string[] AllKeys { get; }
+        public int Count { get; }
+        public string this[HttpRequestHeader header] { get; set; }
+        public string this[HttpResponseHeader header] { get; set; }
+        public string this[string name] { get; set; }
+        public void Remove(string name);
+        IEnumerator System.Collections.IEnumerable.GetEnumerator();
+        public override string ToString();
+    }
+    public abstract class WebRequest {
+        protected WebRequest();
+        public abstract string ContentType { get; set; }
+        public virtual ICredentials Credentials { get; set; }
+        public static IWebProxy DefaultWebProxy { get; set; }
+        public abstract WebHeaderCollection Headers { get; set; }
+        public abstract string Method { get; set; }
+        public virtual IWebProxy Proxy { get; set; }
+        public abstract Uri RequestUri { get; }
+        public virtual bool UseDefaultCredentials { get; set; }
+        public abstract void Abort();
+        public abstract IAsyncResult BeginGetRequestStream(AsyncCallback callback, object state);
+        public abstract IAsyncResult BeginGetResponse(AsyncCallback callback, object state);
+        public static WebRequest Create(string requestUriString);
+        public static WebRequest Create(Uri requestUri);
+        public static HttpWebRequest CreateHttp(string requestUriString);
+        public static HttpWebRequest CreateHttp(Uri requestUri);
+        public abstract Stream EndGetRequestStream(IAsyncResult asyncResult);
+        public abstract WebResponse EndGetResponse(IAsyncResult asyncResult);
+        public virtual Task<Stream> GetRequestStreamAsync();
+        public virtual Task<WebResponse> GetResponseAsync();
+        public static bool RegisterPrefix(string prefix, IWebRequestCreate creator);
+    }
+    public abstract class WebResponse : IDisposable {
+        protected WebResponse();
+        public abstract long ContentLength { get; }
+        public abstract string ContentType { get; }
+        public virtual WebHeaderCollection Headers { get; }
+        public abstract Uri ResponseUri { get; }
+        public virtual bool SupportsHeaders { get; }
+        public void Dispose();
+        protected virtual void Dispose(bool disposing);
+        public abstract Stream GetResponseStream();
+    }
+    public static class WebUtility {
+        public static string HtmlDecode(string value);
+        public static string HtmlEncode(string value);
+        public static string UrlDecode(string encodedValue);
+        public static byte[] UrlDecodeToBytes(byte[] encodedValue, int offset, int count);
+        public static string UrlEncode(string value);
+        public static byte[] UrlEncodeToBytes(byte[] value, int offset, int count);
+    }
+}
```

## System.Net.Http

```c#
+namespace System.Net.Http {
+    public class ByteArrayContent : HttpContent {
+        public ByteArrayContent(byte[] content);
+        public ByteArrayContent(byte[] content, int offset, int count);
+        protected override Task<Stream> CreateContentReadStreamAsync();
+        protected override Task SerializeToStreamAsync(Stream stream, TransportContext context);
+        protected internal override bool TryComputeLength(out long length);
+    }
+    public enum ClientCertificateOption {
+        Automatic = 1,
+        Manual = 0,
+    }
+    public enum CookieUsePolicy {
+        IgnoreCookies = 0,
+        UseInternalCookieStoreOnly = 1,
+        UseSpecifiedCookieContainer = 2,
+    }
+    public abstract class DelegatingHandler : HttpMessageHandler {
+        protected DelegatingHandler();
+        protected DelegatingHandler(HttpMessageHandler innerHandler);
+        public HttpMessageHandler InnerHandler { get; set; }
+        protected override void Dispose(bool disposing);
+        protected internal override Task<HttpResponseMessage> SendAsync(HttpRequestMessage request, CancellationToken cancellationToken);
+    }
+    public class FormUrlEncodedContent : ByteArrayContent {
+        public FormUrlEncodedContent(IEnumerable<KeyValuePair<string, string>> nameValueCollection);
+    }
+    public class HttpClient : HttpMessageInvoker {
+        public HttpClient();
+        public HttpClient(HttpMessageHandler handler);
+        public HttpClient(HttpMessageHandler handler, bool disposeHandler);
+        public Uri BaseAddress { get; set; }
+        public HttpRequestHeaders DefaultRequestHeaders { get; }
+        public long MaxResponseContentBufferSize { get; set; }
+        public TimeSpan Timeout { get; set; }
+        public void CancelPendingRequests();
+        public Task<HttpResponseMessage> DeleteAsync(string requestUri);
+        public Task<HttpResponseMessage> DeleteAsync(string requestUri, CancellationToken cancellationToken);
+        public Task<HttpResponseMessage> DeleteAsync(Uri requestUri);
+        public Task<HttpResponseMessage> DeleteAsync(Uri requestUri, CancellationToken cancellationToken);
+        protected override void Dispose(bool disposing);
+        public Task<HttpResponseMessage> GetAsync(string requestUri);
+        public Task<HttpResponseMessage> GetAsync(string requestUri, HttpCompletionOption completionOption);
+        public Task<HttpResponseMessage> GetAsync(string requestUri, HttpCompletionOption completionOption, CancellationToken cancellationToken);
+        public Task<HttpResponseMessage> GetAsync(string requestUri, CancellationToken cancellationToken);
+        public Task<HttpResponseMessage> GetAsync(Uri requestUri);
+        public Task<HttpResponseMessage> GetAsync(Uri requestUri, HttpCompletionOption completionOption);
+        public Task<HttpResponseMessage> GetAsync(Uri requestUri, HttpCompletionOption completionOption, CancellationToken cancellationToken);
+        public Task<HttpResponseMessage> GetAsync(Uri requestUri, CancellationToken cancellationToken);
+        public Task<byte[]> GetByteArrayAsync(string requestUri);
+        public Task<byte[]> GetByteArrayAsync(Uri requestUri);
+        public Task<Stream> GetStreamAsync(string requestUri);
+        public Task<Stream> GetStreamAsync(Uri requestUri);
+        public Task<string> GetStringAsync(string requestUri);
+        public Task<string> GetStringAsync(Uri requestUri);
+        public Task<HttpResponseMessage> PostAsync(string requestUri, HttpContent content);
+        public Task<HttpResponseMessage> PostAsync(string requestUri, HttpContent content, CancellationToken cancellationToken);
+        public Task<HttpResponseMessage> PostAsync(Uri requestUri, HttpContent content);
+        public Task<HttpResponseMessage> PostAsync(Uri requestUri, HttpContent content, CancellationToken cancellationToken);
+        public Task<HttpResponseMessage> PutAsync(string requestUri, HttpContent content);
+        public Task<HttpResponseMessage> PutAsync(string requestUri, HttpContent content, CancellationToken cancellationToken);
+        public Task<HttpResponseMessage> PutAsync(Uri requestUri, HttpContent content);
+        public Task<HttpResponseMessage> PutAsync(Uri requestUri, HttpContent content, CancellationToken cancellationToken);
+        public Task<HttpResponseMessage> SendAsync(HttpRequestMessage request);
+        public Task<HttpResponseMessage> SendAsync(HttpRequestMessage request, HttpCompletionOption completionOption);
+        public Task<HttpResponseMessage> SendAsync(HttpRequestMessage request, HttpCompletionOption completionOption, CancellationToken cancellationToken);
+        public override Task<HttpResponseMessage> SendAsync(HttpRequestMessage request, CancellationToken cancellationToken);
+    }
+    public class HttpClientHandler : HttpMessageHandler {
+        public HttpClientHandler();
+        public bool AllowAutoRedirect { get; set; }
+        public DecompressionMethods AutomaticDecompression { get; set; }
+        public bool CheckCertificateRevocationList { get; set; }
+        public ClientCertificateOption ClientCertificateOptions { get; set; }
+        public X509CertificateCollection ClientCertificates { get; }
+        public CookieContainer CookieContainer { get; set; }
+        public ICredentials Credentials { get; set; }
+        public ICredentials DefaultProxyCredentials { get; set; }
+        public int MaxAutomaticRedirections { get; set; }
+        public int MaxConnectionsPerServer { get; set; }
+        public long MaxRequestContentBufferSize { get; set; }
+        public int MaxResponseHeadersLength { get; set; }
+        public bool PreAuthenticate { get; set; }
+        public IDictionary<string, object> Properties { get; }
+        public IWebProxy Proxy { get; set; }
+        public Func<HttpRequestMessage, X509Certificate2, X509Chain, SslPolicyErrors, bool> ServerCertificateCustomValidationCallback { get; set; }
+        public SslProtocols SslProtocols { get; set; }
+        public virtual bool SupportsAutomaticDecompression { get; }
+        public virtual bool SupportsProxy { get; }
+        public virtual bool SupportsRedirectConfiguration { get; }
+        public bool UseCookies { get; set; }
+        public bool UseDefaultCredentials { get; set; }
+        public bool UseProxy { get; set; }
+        protected override void Dispose(bool disposing);
+        protected internal override Task<HttpResponseMessage> SendAsync(HttpRequestMessage request, CancellationToken cancellationToken);
+    }
+    public enum HttpCompletionOption {
+        ResponseContentRead = 0,
+        ResponseHeadersRead = 1,
+    }
+    public abstract class HttpContent : IDisposable {
+        protected HttpContent();
+        public HttpContentHeaders Headers { get; }
+        public Task CopyToAsync(Stream stream);
+        public Task CopyToAsync(Stream stream, TransportContext context);
+        protected virtual Task<Stream> CreateContentReadStreamAsync();
+        public void Dispose();
+        protected virtual void Dispose(bool disposing);
+        public Task LoadIntoBufferAsync();
+        public Task LoadIntoBufferAsync(long maxBufferSize);
+        public Task<byte[]> ReadAsByteArrayAsync();
+        public Task<Stream> ReadAsStreamAsync();
+        public Task<string> ReadAsStringAsync();
+        protected abstract Task SerializeToStreamAsync(Stream stream, TransportContext context);
+        protected internal abstract bool TryComputeLength(out long length);
+    }
+    public abstract class HttpMessageHandler : IDisposable {
+        protected HttpMessageHandler();
+        public void Dispose();
+        protected virtual void Dispose(bool disposing);
+        protected internal abstract Task<HttpResponseMessage> SendAsync(HttpRequestMessage request, CancellationToken cancellationToken);
+    }
+    public class HttpMessageInvoker : IDisposable {
+        public HttpMessageInvoker(HttpMessageHandler handler);
+        public HttpMessageInvoker(HttpMessageHandler handler, bool disposeHandler);
+        public void Dispose();
+        protected virtual void Dispose(bool disposing);
+        public virtual Task<HttpResponseMessage> SendAsync(HttpRequestMessage request, CancellationToken cancellationToken);
+    }
+    public class HttpMethod : IEquatable<HttpMethod> {
+        public HttpMethod(string method);
+        public static HttpMethod Delete { get; }
+        public static HttpMethod Get { get; }
+        public static HttpMethod Head { get; }
+        public string Method { get; }
+        public static HttpMethod Options { get; }
+        public static HttpMethod Post { get; }
+        public static HttpMethod Put { get; }
+        public static HttpMethod Trace { get; }
+        public bool Equals(HttpMethod other);
+        public override bool Equals(object obj);
+        public override int GetHashCode();
+        public static bool operator ==(HttpMethod left, HttpMethod right);
+        public static bool operator !=(HttpMethod left, HttpMethod right);
+        public override string ToString();
+    }
+    public class HttpRequestException : Exception {
+        public HttpRequestException();
+        public HttpRequestException(string message);
+        public HttpRequestException(string message, Exception inner);
+    }
+    public class HttpRequestMessage : IDisposable {
+        public HttpRequestMessage();
+        public HttpRequestMessage(HttpMethod method, string requestUri);
+        public HttpRequestMessage(HttpMethod method, Uri requestUri);
+        public HttpContent Content { get; set; }
+        public HttpRequestHeaders Headers { get; }
+        public HttpMethod Method { get; set; }
+        public IDictionary<string, object> Properties { get; }
+        public Uri RequestUri { get; set; }
+        public Version Version { get; set; }
+        public void Dispose();
+        protected virtual void Dispose(bool disposing);
+        public override string ToString();
+    }
+    public class HttpResponseMessage : IDisposable {
+        public HttpResponseMessage();
+        public HttpResponseMessage(HttpStatusCode statusCode);
+        public HttpContent Content { get; set; }
+        public HttpResponseHeaders Headers { get; }
+        public bool IsSuccessStatusCode { get; }
+        public string ReasonPhrase { get; set; }
+        public HttpRequestMessage RequestMessage { get; set; }
+        public HttpStatusCode StatusCode { get; set; }
+        public Version Version { get; set; }
+        public void Dispose();
+        protected virtual void Dispose(bool disposing);
+        public HttpResponseMessage EnsureSuccessStatusCode();
+        public override string ToString();
+    }
+    public abstract class MessageProcessingHandler : DelegatingHandler {
+        protected MessageProcessingHandler();
+        protected MessageProcessingHandler(HttpMessageHandler innerHandler);
+        protected abstract HttpRequestMessage ProcessRequest(HttpRequestMessage request, CancellationToken cancellationToken);
+        protected abstract HttpResponseMessage ProcessResponse(HttpResponseMessage response, CancellationToken cancellationToken);
+        protected internal sealed override Task<HttpResponseMessage> SendAsync(HttpRequestMessage request, CancellationToken cancellationToken);
+    }
+    public class MultipartContent : HttpContent, IEnumerable, IEnumerable<HttpContent> {
+        public MultipartContent();
+        public MultipartContent(string subtype);
+        public MultipartContent(string subtype, string boundary);
+        public virtual void Add(HttpContent content);
+        protected override void Dispose(bool disposing);
+        public IEnumerator<HttpContent> GetEnumerator();
+        protected override Task SerializeToStreamAsync(Stream stream, TransportContext context);
+        IEnumerator System.Collections.IEnumerable.GetEnumerator();
+        protected internal override bool TryComputeLength(out long length);
+    }
+    public class MultipartFormDataContent : MultipartContent {
+        public MultipartFormDataContent();
+        public MultipartFormDataContent(string boundary);
+        public override void Add(HttpContent content);
+        public void Add(HttpContent content, string name);
+        public void Add(HttpContent content, string name, string fileName);
+    }
+    public class StreamContent : HttpContent {
+        public StreamContent(Stream content);
+        public StreamContent(Stream content, int bufferSize);
+        protected override Task<Stream> CreateContentReadStreamAsync();
+        protected override void Dispose(bool disposing);
+        protected override Task SerializeToStreamAsync(Stream stream, TransportContext context);
+        protected internal override bool TryComputeLength(out long length);
+    }
+    public class StringContent : ByteArrayContent {
+        public StringContent(string content);
+        public StringContent(string content, Encoding encoding);
+        public StringContent(string content, Encoding encoding, string mediaType);
+    }
+    public enum WindowsProxyUsePolicy {
+        DoNotUseProxy = 0,
+        UseCustomProxy = 3,
+        UseWinHttpProxy = 1,
+        UseWinInetProxy = 2,
+    }
+    public class WinHttpHandler : HttpMessageHandler {
+        public WinHttpHandler();
+        public DecompressionMethods AutomaticDecompression { get; set; }
+        public bool AutomaticRedirection { get; set; }
+        public bool CheckCertificateRevocationList { get; set; }
+        public ClientCertificateOption ClientCertificateOption { get; set; }
+        public X509Certificate2Collection ClientCertificates { get; }
+        public CookieContainer CookieContainer { get; set; }
+        public CookieUsePolicy CookieUsePolicy { get; set; }
+        public ICredentials DefaultProxyCredentials { get; set; }
+        public int MaxAutomaticRedirections { get; set; }
+        public int MaxConnectionsPerServer { get; set; }
+        public int MaxResponseDrainSize { get; set; }
+        public int MaxResponseHeadersLength { get; set; }
+        public bool PreAuthenticate { get; set; }
+        public IDictionary<string, object> Properties { get; }
+        public IWebProxy Proxy { get; set; }
+        public TimeSpan ReceiveDataTimeout { get; set; }
+        public TimeSpan ReceiveHeadersTimeout { get; set; }
+        public TimeSpan SendTimeout { get; set; }
+        public Func<HttpRequestMessage, X509Certificate2, X509Chain, SslPolicyErrors, bool> ServerCertificateValidationCallback { get; set; }
+        public ICredentials ServerCredentials { get; set; }
+        public SslProtocols SslProtocols { get; set; }
+        public WindowsProxyUsePolicy WindowsProxyUsePolicy { get; set; }
+        protected override void Dispose(bool disposing);
+        protected override Task<HttpResponseMessage> SendAsync(HttpRequestMessage request, CancellationToken cancellationToken);
+    }
+}
```

## System.Net.Http.Headers

```c#
+namespace System.Net.Http.Headers {
+    public class AuthenticationHeaderValue {
+        public AuthenticationHeaderValue(string scheme);
+        public AuthenticationHeaderValue(string scheme, string parameter);
+        public string Parameter { get; }
+        public string Scheme { get; }
+        public override bool Equals(object obj);
+        public override int GetHashCode();
+        public static AuthenticationHeaderValue Parse(string input);
+        public override string ToString();
+        public static bool TryParse(string input, out AuthenticationHeaderValue parsedValue);
+    }
+    public class CacheControlHeaderValue {
+        public CacheControlHeaderValue();
+        public ICollection<NameValueHeaderValue> Extensions { get; }
+        public Nullable<TimeSpan> MaxAge { get; set; }
+        public bool MaxStale { get; set; }
+        public Nullable<TimeSpan> MaxStaleLimit { get; set; }
+        public Nullable<TimeSpan> MinFresh { get; set; }
+        public bool MustRevalidate { get; set; }
+        public bool NoCache { get; set; }
+        public ICollection<string> NoCacheHeaders { get; }
+        public bool NoStore { get; set; }
+        public bool NoTransform { get; set; }
+        public bool OnlyIfCached { get; set; }
+        public bool Private { get; set; }
+        public ICollection<string> PrivateHeaders { get; }
+        public bool ProxyRevalidate { get; set; }
+        public bool Public { get; set; }
+        public Nullable<TimeSpan> SharedMaxAge { get; set; }
+        public override bool Equals(object obj);
+        public override int GetHashCode();
+        public static CacheControlHeaderValue Parse(string input);
+        public override string ToString();
+        public static bool TryParse(string input, out CacheControlHeaderValue parsedValue);
+    }
+    public class ContentDispositionHeaderValue {
+        protected ContentDispositionHeaderValue(ContentDispositionHeaderValue source);
+        public ContentDispositionHeaderValue(string dispositionType);
+        public Nullable<DateTimeOffset> CreationDate { get; set; }
+        public string DispositionType { get; set; }
+        public string FileName { get; set; }
+        public string FileNameStar { get; set; }
+        public Nullable<DateTimeOffset> ModificationDate { get; set; }
+        public string Name { get; set; }
+        public ICollection<NameValueHeaderValue> Parameters { get; }
+        public Nullable<DateTimeOffset> ReadDate { get; set; }
+        public Nullable<long> Size { get; set; }
+        public override bool Equals(object obj);
+        public override int GetHashCode();
+        public static ContentDispositionHeaderValue Parse(string input);
+        public override string ToString();
+        public static bool TryParse(string input, out ContentDispositionHeaderValue parsedValue);
+    }
+    public class ContentRangeHeaderValue {
+        public ContentRangeHeaderValue(long length);
+        public ContentRangeHeaderValue(long from, long to);
+        public ContentRangeHeaderValue(long from, long to, long length);
+        public Nullable<long> From { get; }
+        public bool HasLength { get; }
+        public bool HasRange { get; }
+        public Nullable<long> Length { get; }
+        public Nullable<long> To { get; }
+        public string Unit { get; set; }
+        public override bool Equals(object obj);
+        public override int GetHashCode();
+        public static ContentRangeHeaderValue Parse(string input);
+        public override string ToString();
+        public static bool TryParse(string input, out ContentRangeHeaderValue parsedValue);
+    }
+    public class EntityTagHeaderValue {
+        public EntityTagHeaderValue(string tag);
+        public EntityTagHeaderValue(string tag, bool isWeak);
+        public static EntityTagHeaderValue Any { get; }
+        public bool IsWeak { get; }
+        public string Tag { get; }
+        public override bool Equals(object obj);
+        public override int GetHashCode();
+        public static EntityTagHeaderValue Parse(string input);
+        public override string ToString();
+        public static bool TryParse(string input, out EntityTagHeaderValue parsedValue);
+    }
+    public sealed class HttpContentHeaders : HttpHeaders {
+        public ICollection<string> Allow { get; }
+        public ContentDispositionHeaderValue ContentDisposition { get; set; }
+        public ICollection<string> ContentEncoding { get; }
+        public ICollection<string> ContentLanguage { get; }
+        public Nullable<long> ContentLength { get; set; }
+        public Uri ContentLocation { get; set; }
+        public byte[] ContentMD5 { get; set; }
+        public ContentRangeHeaderValue ContentRange { get; set; }
+        public MediaTypeHeaderValue ContentType { get; set; }
+        public Nullable<DateTimeOffset> Expires { get; set; }
+        public Nullable<DateTimeOffset> LastModified { get; set; }
+    }
+    public abstract class HttpHeaders : IEnumerable, IEnumerable<KeyValuePair<string, IEnumerable<string>>> {
+        protected HttpHeaders();
+        public void Add(string name, IEnumerable<string> values);
+        public void Add(string name, string value);
+        public void Clear();
+        public bool Contains(string name);
+        public IEnumerator<KeyValuePair<string, IEnumerable<string>>> GetEnumerator();
+        public IEnumerable<string> GetValues(string name);
+        public bool Remove(string name);
+        IEnumerator System.Collections.IEnumerable.GetEnumerator();
+        public override string ToString();
+        public bool TryAddWithoutValidation(string name, IEnumerable<string> values);
+        public bool TryAddWithoutValidation(string name, string value);
+        public bool TryGetValues(string name, out IEnumerable<string> values);
+    }
+    public sealed class HttpHeaderValueCollection<T> : ICollection<T>, IEnumerable, IEnumerable<T> where T : class {
+        public int Count { get; }
+        public bool IsReadOnly { get; }
+        public void Add(T item);
+        public void Clear();
+        public bool Contains(T item);
+        public void CopyTo(T[] array, int arrayIndex);
+        public IEnumerator<T> GetEnumerator();
+        public void ParseAdd(string input);
+        public bool Remove(T item);
+        IEnumerator System.Collections.IEnumerable.GetEnumerator();
+        public override string ToString();
+        public bool TryParseAdd(string input);
+    }
+    public sealed class HttpRequestHeaders : HttpHeaders {
+        public HttpHeaderValueCollection<MediaTypeWithQualityHeaderValue> Accept { get; }
+        public HttpHeaderValueCollection<StringWithQualityHeaderValue> AcceptCharset { get; }
+        public HttpHeaderValueCollection<StringWithQualityHeaderValue> AcceptEncoding { get; }
+        public HttpHeaderValueCollection<StringWithQualityHeaderValue> AcceptLanguage { get; }
+        public AuthenticationHeaderValue Authorization { get; set; }
+        public CacheControlHeaderValue CacheControl { get; set; }
+        public HttpHeaderValueCollection<string> Connection { get; }
+        public Nullable<bool> ConnectionClose { get; set; }
+        public Nullable<DateTimeOffset> Date { get; set; }
+        public HttpHeaderValueCollection<NameValueWithParametersHeaderValue> Expect { get; }
+        public Nullable<bool> ExpectContinue { get; set; }
+        public string From { get; set; }
+        public string Host { get; set; }
+        public HttpHeaderValueCollection<EntityTagHeaderValue> IfMatch { get; }
+        public Nullable<DateTimeOffset> IfModifiedSince { get; set; }
+        public HttpHeaderValueCollection<EntityTagHeaderValue> IfNoneMatch { get; }
+        public RangeConditionHeaderValue IfRange { get; set; }
+        public Nullable<DateTimeOffset> IfUnmodifiedSince { get; set; }
+        public Nullable<int> MaxForwards { get; set; }
+        public HttpHeaderValueCollection<NameValueHeaderValue> Pragma { get; }
+        public AuthenticationHeaderValue ProxyAuthorization { get; set; }
+        public RangeHeaderValue Range { get; set; }
+        public Uri Referrer { get; set; }
+        public HttpHeaderValueCollection<TransferCodingWithQualityHeaderValue> TE { get; }
+        public HttpHeaderValueCollection<string> Trailer { get; }
+        public HttpHeaderValueCollection<TransferCodingHeaderValue> TransferEncoding { get; }
+        public Nullable<bool> TransferEncodingChunked { get; set; }
+        public HttpHeaderValueCollection<ProductHeaderValue> Upgrade { get; }
+        public HttpHeaderValueCollection<ProductInfoHeaderValue> UserAgent { get; }
+        public HttpHeaderValueCollection<ViaHeaderValue> Via { get; }
+        public HttpHeaderValueCollection<WarningHeaderValue> Warning { get; }
+    }
+    public sealed class HttpResponseHeaders : HttpHeaders {
+        public HttpHeaderValueCollection<string> AcceptRanges { get; }
+        public Nullable<TimeSpan> Age { get; set; }
+        public CacheControlHeaderValue CacheControl { get; set; }
+        public HttpHeaderValueCollection<string> Connection { get; }
+        public Nullable<bool> ConnectionClose { get; set; }
+        public Nullable<DateTimeOffset> Date { get; set; }
+        public EntityTagHeaderValue ETag { get; set; }
+        public Uri Location { get; set; }
+        public HttpHeaderValueCollection<NameValueHeaderValue> Pragma { get; }
+        public HttpHeaderValueCollection<AuthenticationHeaderValue> ProxyAuthenticate { get; }
+        public RetryConditionHeaderValue RetryAfter { get; set; }
+        public HttpHeaderValueCollection<ProductInfoHeaderValue> Server { get; }
+        public HttpHeaderValueCollection<string> Trailer { get; }
+        public HttpHeaderValueCollection<TransferCodingHeaderValue> TransferEncoding { get; }
+        public Nullable<bool> TransferEncodingChunked { get; set; }
+        public HttpHeaderValueCollection<ProductHeaderValue> Upgrade { get; }
+        public HttpHeaderValueCollection<string> Vary { get; }
+        public HttpHeaderValueCollection<ViaHeaderValue> Via { get; }
+        public HttpHeaderValueCollection<WarningHeaderValue> Warning { get; }
+        public HttpHeaderValueCollection<AuthenticationHeaderValue> WwwAuthenticate { get; }
+    }
+    public class MediaTypeHeaderValue {
+        protected MediaTypeHeaderValue(MediaTypeHeaderValue source);
+        public MediaTypeHeaderValue(string mediaType);
+        public string CharSet { get; set; }
+        public string MediaType { get; set; }
+        public ICollection<NameValueHeaderValue> Parameters { get; }
+        public override bool Equals(object obj);
+        public override int GetHashCode();
+        public static MediaTypeHeaderValue Parse(string input);
+        public override string ToString();
+        public static bool TryParse(string input, out MediaTypeHeaderValue parsedValue);
+    }
+    public sealed class MediaTypeWithQualityHeaderValue : MediaTypeHeaderValue {
+        public MediaTypeWithQualityHeaderValue(string mediaType);
+        public MediaTypeWithQualityHeaderValue(string mediaType, double quality);
+        public Nullable<double> Quality { get; set; }
+        public static new MediaTypeWithQualityHeaderValue Parse(string input);
+        public static bool TryParse(string input, out MediaTypeWithQualityHeaderValue parsedValue);
+    }
+    public class NameValueHeaderValue {
+        protected NameValueHeaderValue(NameValueHeaderValue source);
+        public NameValueHeaderValue(string name);
+        public NameValueHeaderValue(string name, string value);
+        public string Name { get; }
+        public string Value { get; set; }
+        public override bool Equals(object obj);
+        public override int GetHashCode();
+        public static NameValueHeaderValue Parse(string input);
+        public override string ToString();
+        public static bool TryParse(string input, out NameValueHeaderValue parsedValue);
+    }
+    public class NameValueWithParametersHeaderValue : NameValueHeaderValue {
+        protected NameValueWithParametersHeaderValue(NameValueWithParametersHeaderValue source);
+        public NameValueWithParametersHeaderValue(string name);
+        public NameValueWithParametersHeaderValue(string name, string value);
+        public ICollection<NameValueHeaderValue> Parameters { get; }
+        public override bool Equals(object obj);
+        public override int GetHashCode();
+        public static new NameValueWithParametersHeaderValue Parse(string input);
+        public override string ToString();
+        public static bool TryParse(string input, out NameValueWithParametersHeaderValue parsedValue);
+    }
+    public class ProductHeaderValue {
+        public ProductHeaderValue(string name);
+        public ProductHeaderValue(string name, string version);
+        public string Name { get; }
+        public string Version { get; }
+        public override bool Equals(object obj);
+        public override int GetHashCode();
+        public static ProductHeaderValue Parse(string input);
+        public override string ToString();
+        public static bool TryParse(string input, out ProductHeaderValue parsedValue);
+    }
+    public class ProductInfoHeaderValue {
+        public ProductInfoHeaderValue(ProductHeaderValue product);
+        public ProductInfoHeaderValue(string comment);
+        public ProductInfoHeaderValue(string productName, string productVersion);
+        public string Comment { get; }
+        public ProductHeaderValue Product { get; }
+        public override bool Equals(object obj);
+        public override int GetHashCode();
+        public static ProductInfoHeaderValue Parse(string input);
+        public override string ToString();
+        public static bool TryParse(string input, out ProductInfoHeaderValue parsedValue);
+    }
+    public class RangeConditionHeaderValue {
+        public RangeConditionHeaderValue(DateTimeOffset date);
+        public RangeConditionHeaderValue(EntityTagHeaderValue entityTag);
+        public RangeConditionHeaderValue(string entityTag);
+        public Nullable<DateTimeOffset> Date { get; }
+        public EntityTagHeaderValue EntityTag { get; }
+        public override bool Equals(object obj);
+        public override int GetHashCode();
+        public static RangeConditionHeaderValue Parse(string input);
+        public override string ToString();
+        public static bool TryParse(string input, out RangeConditionHeaderValue parsedValue);
+    }
+    public class RangeHeaderValue {
+        public RangeHeaderValue();
+        public RangeHeaderValue(Nullable<long> from, Nullable<long> to);
+        public ICollection<RangeItemHeaderValue> Ranges { get; }
+        public string Unit { get; set; }
+        public override bool Equals(object obj);
+        public override int GetHashCode();
+        public static RangeHeaderValue Parse(string input);
+        public override string ToString();
+        public static bool TryParse(string input, out RangeHeaderValue parsedValue);
+    }
+    public class RangeItemHeaderValue {
+        public RangeItemHeaderValue(Nullable<long> from, Nullable<long> to);
+        public Nullable<long> From { get; }
+        public Nullable<long> To { get; }
+        public override bool Equals(object obj);
+        public override int GetHashCode();
+        public override string ToString();
+    }
+    public class RetryConditionHeaderValue {
+        public RetryConditionHeaderValue(DateTimeOffset date);
+        public RetryConditionHeaderValue(TimeSpan delta);
+        public Nullable<DateTimeOffset> Date { get; }
+        public Nullable<TimeSpan> Delta { get; }
+        public override bool Equals(object obj);
+        public override int GetHashCode();
+        public static RetryConditionHeaderValue Parse(string input);
+        public override string ToString();
+        public static bool TryParse(string input, out RetryConditionHeaderValue parsedValue);
+    }
+    public class StringWithQualityHeaderValue {
+        public StringWithQualityHeaderValue(string value);
+        public StringWithQualityHeaderValue(string value, double quality);
+        public Nullable<double> Quality { get; }
+        public string Value { get; }
+        public override bool Equals(object obj);
+        public override int GetHashCode();
+        public static StringWithQualityHeaderValue Parse(string input);
+        public override string ToString();
+        public static bool TryParse(string input, out StringWithQualityHeaderValue parsedValue);
+    }
+    public class TransferCodingHeaderValue {
+        protected TransferCodingHeaderValue(TransferCodingHeaderValue source);
+        public TransferCodingHeaderValue(string value);
+        public ICollection<NameValueHeaderValue> Parameters { get; }
+        public string Value { get; }
+        public override bool Equals(object obj);
+        public override int GetHashCode();
+        public static TransferCodingHeaderValue Parse(string input);
+        public override string ToString();
+        public static bool TryParse(string input, out TransferCodingHeaderValue parsedValue);
+    }
+    public sealed class TransferCodingWithQualityHeaderValue : TransferCodingHeaderValue {
+        public TransferCodingWithQualityHeaderValue(string value);
+        public TransferCodingWithQualityHeaderValue(string value, double quality);
+        public Nullable<double> Quality { get; set; }
+        public static new TransferCodingWithQualityHeaderValue Parse(string input);
+        public static bool TryParse(string input, out TransferCodingWithQualityHeaderValue parsedValue);
+    }
+    public class ViaHeaderValue {
+        public ViaHeaderValue(string protocolVersion, string receivedBy);
+        public ViaHeaderValue(string protocolVersion, string receivedBy, string protocolName);
+        public ViaHeaderValue(string protocolVersion, string receivedBy, string protocolName, string comment);
+        public string Comment { get; }
+        public string ProtocolName { get; }
+        public string ProtocolVersion { get; }
+        public string ReceivedBy { get; }
+        public override bool Equals(object obj);
+        public override int GetHashCode();
+        public static ViaHeaderValue Parse(string input);
+        public override string ToString();
+        public static bool TryParse(string input, out ViaHeaderValue parsedValue);
+    }
+    public class WarningHeaderValue {
+        public WarningHeaderValue(int code, string agent, string text);
+        public WarningHeaderValue(int code, string agent, string text, DateTimeOffset date);
+        public string Agent { get; }
+        public int Code { get; }
+        public Nullable<DateTimeOffset> Date { get; }
+        public string Text { get; }
+        public override bool Equals(object obj);
+        public override int GetHashCode();
+        public static WarningHeaderValue Parse(string input);
+        public override string ToString();
+        public static bool TryParse(string input, out WarningHeaderValue parsedValue);
+    }
+}
```

## System.Net.NetworkInformation

```c#
+namespace System.Net.NetworkInformation {
+    public enum DuplicateAddressDetectionState {
+        Deprecated = 3,
+        Duplicate = 2,
+        Invalid = 0,
+        Preferred = 4,
+        Tentative = 1,
+    }
+    public abstract class GatewayIPAddressInformation {
+        protected GatewayIPAddressInformation();
+        public abstract IPAddress Address { get; }
+    }
+    public class GatewayIPAddressInformationCollection : ICollection<GatewayIPAddressInformation>, IEnumerable, IEnumerable<GatewayIPAddressInformation> {
+        protected internal GatewayIPAddressInformationCollection();
+        public virtual int Count { get; }
+        public virtual bool IsReadOnly { get; }
+        public virtual GatewayIPAddressInformation this[int index] { get; }
+        public virtual void Add(GatewayIPAddressInformation address);
+        public virtual void Clear();
+        public virtual bool Contains(GatewayIPAddressInformation address);
+        public virtual void CopyTo(GatewayIPAddressInformation[] array, int offset);
+        public virtual IEnumerator<GatewayIPAddressInformation> GetEnumerator();
+        public virtual bool Remove(GatewayIPAddressInformation address);
+        IEnumerator System.Collections.IEnumerable.GetEnumerator();
+    }
+    public abstract class IcmpV4Statistics {
+        protected IcmpV4Statistics();
+        public abstract long AddressMaskRepliesReceived { get; }
+        public abstract long AddressMaskRepliesSent { get; }
+        public abstract long AddressMaskRequestsReceived { get; }
+        public abstract long AddressMaskRequestsSent { get; }
+        public abstract long DestinationUnreachableMessagesReceived { get; }
+        public abstract long DestinationUnreachableMessagesSent { get; }
+        public abstract long EchoRepliesReceived { get; }
+        public abstract long EchoRepliesSent { get; }
+        public abstract long EchoRequestsReceived { get; }
+        public abstract long EchoRequestsSent { get; }
+        public abstract long ErrorsReceived { get; }
+        public abstract long ErrorsSent { get; }
+        public abstract long MessagesReceived { get; }
+        public abstract long MessagesSent { get; }
+        public abstract long ParameterProblemsReceived { get; }
+        public abstract long ParameterProblemsSent { get; }
+        public abstract long RedirectsReceived { get; }
+        public abstract long RedirectsSent { get; }
+        public abstract long SourceQuenchesReceived { get; }
+        public abstract long SourceQuenchesSent { get; }
+        public abstract long TimeExceededMessagesReceived { get; }
+        public abstract long TimeExceededMessagesSent { get; }
+        public abstract long TimestampRepliesReceived { get; }
+        public abstract long TimestampRepliesSent { get; }
+        public abstract long TimestampRequestsReceived { get; }
+        public abstract long TimestampRequestsSent { get; }
+    }
+    public abstract class IcmpV6Statistics {
+        protected IcmpV6Statistics();
+        public abstract long DestinationUnreachableMessagesReceived { get; }
+        public abstract long DestinationUnreachableMessagesSent { get; }
+        public abstract long EchoRepliesReceived { get; }
+        public abstract long EchoRepliesSent { get; }
+        public abstract long EchoRequestsReceived { get; }
+        public abstract long EchoRequestsSent { get; }
+        public abstract long ErrorsReceived { get; }
+        public abstract long ErrorsSent { get; }
+        public abstract long MembershipQueriesReceived { get; }
+        public abstract long MembershipQueriesSent { get; }
+        public abstract long MembershipReductionsReceived { get; }
+        public abstract long MembershipReductionsSent { get; }
+        public abstract long MembershipReportsReceived { get; }
+        public abstract long MembershipReportsSent { get; }
+        public abstract long MessagesReceived { get; }
+        public abstract long MessagesSent { get; }
+        public abstract long NeighborAdvertisementsReceived { get; }
+        public abstract long NeighborAdvertisementsSent { get; }
+        public abstract long NeighborSolicitsReceived { get; }
+        public abstract long NeighborSolicitsSent { get; }
+        public abstract long PacketTooBigMessagesReceived { get; }
+        public abstract long PacketTooBigMessagesSent { get; }
+        public abstract long ParameterProblemsReceived { get; }
+        public abstract long ParameterProblemsSent { get; }
+        public abstract long RedirectsReceived { get; }
+        public abstract long RedirectsSent { get; }
+        public abstract long RouterAdvertisementsReceived { get; }
+        public abstract long RouterAdvertisementsSent { get; }
+        public abstract long RouterSolicitsReceived { get; }
+        public abstract long RouterSolicitsSent { get; }
+        public abstract long TimeExceededMessagesReceived { get; }
+        public abstract long TimeExceededMessagesSent { get; }
+    }
+    public class IPAddressCollection : ICollection<IPAddress>, IEnumerable, IEnumerable<IPAddress> {
+        protected internal IPAddressCollection();
+        public virtual int Count { get; }
+        public virtual bool IsReadOnly { get; }
+        public virtual IPAddress this[int index] { get; }
+        public virtual void Add(IPAddress address);
+        public virtual void Clear();
+        public virtual bool Contains(IPAddress address);
+        public virtual void CopyTo(IPAddress[] array, int offset);
+        public virtual IEnumerator<IPAddress> GetEnumerator();
+        public virtual bool Remove(IPAddress address);
+        IEnumerator System.Collections.IEnumerable.GetEnumerator();
+    }
+    public abstract class IPAddressInformation {
+        protected IPAddressInformation();
+        public abstract IPAddress Address { get; }
+        public abstract bool IsDnsEligible { get; }
+        public abstract bool IsTransient { get; }
+    }
+    public class IPAddressInformationCollection : ICollection<IPAddressInformation>, IEnumerable, IEnumerable<IPAddressInformation> {
+        public virtual int Count { get; }
+        public virtual bool IsReadOnly { get; }
+        public virtual IPAddressInformation this[int index] { get; }
+        public virtual void Add(IPAddressInformation address);
+        public virtual void Clear();
+        public virtual bool Contains(IPAddressInformation address);
+        public virtual void CopyTo(IPAddressInformation[] array, int offset);
+        public virtual IEnumerator<IPAddressInformation> GetEnumerator();
+        public virtual bool Remove(IPAddressInformation address);
+        IEnumerator System.Collections.IEnumerable.GetEnumerator();
+    }
+    public abstract class IPGlobalProperties {
+        protected IPGlobalProperties();
+        public abstract string DhcpScopeName { get; }
+        public abstract string DomainName { get; }
+        public abstract string HostName { get; }
+        public abstract bool IsWinsProxy { get; }
+        public abstract NetBiosNodeType NodeType { get; }
+        public abstract TcpConnectionInformation[] GetActiveTcpConnections();
+        public abstract IPEndPoint[] GetActiveTcpListeners();
+        public abstract IPEndPoint[] GetActiveUdpListeners();
+        public abstract IcmpV4Statistics GetIcmpV4Statistics();
+        public abstract IcmpV6Statistics GetIcmpV6Statistics();
+        public static IPGlobalProperties GetIPGlobalProperties();
+        public abstract IPGlobalStatistics GetIPv4GlobalStatistics();
+        public abstract IPGlobalStatistics GetIPv6GlobalStatistics();
+        public abstract TcpStatistics GetTcpIPv4Statistics();
+        public abstract TcpStatistics GetTcpIPv6Statistics();
+        public abstract UdpStatistics GetUdpIPv4Statistics();
+        public abstract UdpStatistics GetUdpIPv6Statistics();
+        public virtual Task<UnicastIPAddressInformationCollection> GetUnicastAddressesAsync();
+    }
+    public abstract class IPGlobalStatistics {
+        protected IPGlobalStatistics();
+        public abstract int DefaultTtl { get; }
+        public abstract bool ForwardingEnabled { get; }
+        public abstract int NumberOfInterfaces { get; }
+        public abstract int NumberOfIPAddresses { get; }
+        public abstract int NumberOfRoutes { get; }
+        public abstract long OutputPacketRequests { get; }
+        public abstract long OutputPacketRoutingDiscards { get; }
+        public abstract long OutputPacketsDiscarded { get; }
+        public abstract long OutputPacketsWithNoRoute { get; }
+        public abstract long PacketFragmentFailures { get; }
+        public abstract long PacketReassembliesRequired { get; }
+        public abstract long PacketReassemblyFailures { get; }
+        public abstract long PacketReassemblyTimeout { get; }
+        public abstract long PacketsFragmented { get; }
+        public abstract long PacketsReassembled { get; }
+        public abstract long ReceivedPackets { get; }
+        public abstract long ReceivedPacketsDelivered { get; }
+        public abstract long ReceivedPacketsDiscarded { get; }
+        public abstract long ReceivedPacketsForwarded { get; }
+        public abstract long ReceivedPacketsWithAddressErrors { get; }
+        public abstract long ReceivedPacketsWithHeadersErrors { get; }
+        public abstract long ReceivedPacketsWithUnknownProtocol { get; }
+    }
+    public abstract class IPInterfaceProperties {
+        protected IPInterfaceProperties();
+        public abstract IPAddressInformationCollection AnycastAddresses { get; }
+        public abstract IPAddressCollection DhcpServerAddresses { get; }
+        public abstract IPAddressCollection DnsAddresses { get; }
+        public abstract string DnsSuffix { get; }
+        public abstract GatewayIPAddressInformationCollection GatewayAddresses { get; }
+        public abstract bool IsDnsEnabled { get; }
+        public abstract bool IsDynamicDnsEnabled { get; }
+        public abstract MulticastIPAddressInformationCollection MulticastAddresses { get; }
+        public abstract UnicastIPAddressInformationCollection UnicastAddresses { get; }
+        public abstract IPAddressCollection WinsServersAddresses { get; }
+        public abstract IPv4InterfaceProperties GetIPv4Properties();
+        public abstract IPv6InterfaceProperties GetIPv6Properties();
+    }
+    public abstract class IPInterfaceStatistics {
+        protected IPInterfaceStatistics();
+        public abstract long BytesReceived { get; }
+        public abstract long BytesSent { get; }
+        public abstract long IncomingPacketsDiscarded { get; }
+        public abstract long IncomingPacketsWithErrors { get; }
+        public abstract long IncomingUnknownProtocolPackets { get; }
+        public abstract long NonUnicastPacketsReceived { get; }
+        public abstract long NonUnicastPacketsSent { get; }
+        public abstract long OutgoingPacketsDiscarded { get; }
+        public abstract long OutgoingPacketsWithErrors { get; }
+        public abstract long OutputQueueLength { get; }
+        public abstract long UnicastPacketsReceived { get; }
+        public abstract long UnicastPacketsSent { get; }
+    }
+    public enum IPStatus {
+        BadDestination = 11018,
+        BadHeader = 11042,
+        BadOption = 11007,
+        BadRoute = 11012,
+        DestinationHostUnreachable = 11003,
+        DestinationNetworkUnreachable = 11002,
+        DestinationPortUnreachable = 11005,
+        DestinationProhibited = 11004,
+        DestinationProtocolUnreachable = 11004,
+        DestinationScopeMismatch = 11045,
+        DestinationUnreachable = 11040,
+        HardwareError = 11008,
+        IcmpError = 11044,
+        NoResources = 11006,
+        PacketTooBig = 11009,
+        ParameterProblem = 11015,
+        SourceQuench = 11016,
+        Success = 0,
+        TimedOut = 11010,
+        TimeExceeded = 11041,
+        TtlExpired = 11013,
+        TtlReassemblyTimeExceeded = 11014,
+        Unknown = -1,
+        UnrecognizedNextHeader = 11043,
+    }
+    public abstract class IPv4InterfaceProperties {
+        protected IPv4InterfaceProperties();
+        public abstract int Index { get; }
+        public abstract bool IsAutomaticPrivateAddressingActive { get; }
+        public abstract bool IsAutomaticPrivateAddressingEnabled { get; }
+        public abstract bool IsDhcpEnabled { get; }
+        public abstract bool IsForwardingEnabled { get; }
+        public abstract int Mtu { get; }
+        public abstract bool UsesWins { get; }
+    }
+    public abstract class IPv6InterfaceProperties {
+        protected IPv6InterfaceProperties();
+        public abstract int Index { get; }
+        public abstract int Mtu { get; }
+        public virtual long GetScopeId(ScopeLevel scopeLevel);
+    }
+    public abstract class MulticastIPAddressInformation : IPAddressInformation {
+        protected MulticastIPAddressInformation();
+        public abstract long AddressPreferredLifetime { get; }
+        public abstract long AddressValidLifetime { get; }
+        public abstract long DhcpLeaseLifetime { get; }
+        public abstract DuplicateAddressDetectionState DuplicateAddressDetectionState { get; }
+        public abstract PrefixOrigin PrefixOrigin { get; }
+        public abstract SuffixOrigin SuffixOrigin { get; }
+    }
+    public class MulticastIPAddressInformationCollection : ICollection<MulticastIPAddressInformation>, IEnumerable, IEnumerable<MulticastIPAddressInformation> {
+        protected internal MulticastIPAddressInformationCollection();
+        public virtual int Count { get; }
+        public virtual bool IsReadOnly { get; }
+        public virtual MulticastIPAddressInformation this[int index] { get; }
+        public virtual void Add(MulticastIPAddressInformation address);
+        public virtual void Clear();
+        public virtual bool Contains(MulticastIPAddressInformation address);
+        public virtual void CopyTo(MulticastIPAddressInformation[] array, int offset);
+        public virtual IEnumerator<MulticastIPAddressInformation> GetEnumerator();
+        public virtual bool Remove(MulticastIPAddressInformation address);
+        IEnumerator System.Collections.IEnumerable.GetEnumerator();
+    }
+    public enum NetBiosNodeType {
+        Broadcast = 1,
+        Hybrid = 8,
+        Mixed = 4,
+        Peer2Peer = 2,
+        Unknown = 0,
+    }
+    public delegate void NetworkAddressChangedEventHandler(object sender, EventArgs e);
+    public static class NetworkChange {
+        public static event NetworkAddressChangedEventHandler NetworkAddressChanged;
+    }
+    public class NetworkInformationException : Exception {
+        public NetworkInformationException();
+        public NetworkInformationException(int errorCode);
+        public int ErrorCode { get; }
+    }
+    public abstract class NetworkInterface {
+        protected NetworkInterface();
+        public virtual string Description { get; }
+        public virtual string Id { get; }
+        public static int IPv6LoopbackInterfaceIndex { get; }
+        public virtual bool IsReceiveOnly { get; }
+        public static int LoopbackInterfaceIndex { get; }
+        public virtual string Name { get; }
+        public virtual NetworkInterfaceType NetworkInterfaceType { get; }
+        public virtual OperationalStatus OperationalStatus { get; }
+        public virtual long Speed { get; }
+        public virtual bool SupportsMulticast { get; }
+        public static NetworkInterface[] GetAllNetworkInterfaces();
+        public virtual IPInterfaceProperties GetIPProperties();
+        public virtual IPInterfaceStatistics GetIPStatistics();
+        public static bool GetIsNetworkAvailable();
+        public virtual PhysicalAddress GetPhysicalAddress();
+        public virtual bool Supports(NetworkInterfaceComponent networkInterfaceComponent);
+    }
+    public enum NetworkInterfaceComponent {
+        IPv4 = 0,
+        IPv6 = 1,
+    }
+    public enum NetworkInterfaceType {
+        AsymmetricDsl = 94,
+        Atm = 37,
+        BasicIsdn = 20,
+        Ethernet = 6,
+        Ethernet3Megabit = 26,
+        FastEthernetFx = 69,
+        FastEthernetT = 62,
+        Fddi = 15,
+        GenericModem = 48,
+        GigabitEthernet = 117,
+        HighPerformanceSerialBus = 144,
+        IPOverAtm = 114,
+        Isdn = 63,
+        Loopback = 24,
+        MultiRateSymmetricDsl = 143,
+        Ppp = 23,
+        PrimaryIsdn = 21,
+        RateAdaptDsl = 95,
+        Slip = 28,
+        SymmetricDsl = 96,
+        TokenRing = 9,
+        Tunnel = 131,
+        Unknown = 1,
+        VeryHighSpeedDsl = 97,
+        Wireless80211 = 71,
+        Wman = 237,
+        Wwanpp = 243,
+        Wwanpp2 = 244,
+    }
+    public enum OperationalStatus {
+        Dormant = 5,
+        Down = 2,
+        LowerLayerDown = 7,
+        NotPresent = 6,
+        Testing = 3,
+        Unknown = 4,
+        Up = 1,
+    }
+    public class PhysicalAddress {
+        public static readonly PhysicalAddress None;
+        public PhysicalAddress(byte[] address);
+        public override bool Equals(object comparand);
+        public byte[] GetAddressBytes();
+        public override int GetHashCode();
+        public static PhysicalAddress Parse(string address);
+        public override string ToString();
+    }
+    public class Ping : IDisposable {
+        public Ping();
+        public void Dispose();
+        protected virtual void Dispose(bool disposing);
+        public Task<PingReply> SendPingAsync(IPAddress address);
+        public Task<PingReply> SendPingAsync(IPAddress address, int timeout);
+        public Task<PingReply> SendPingAsync(IPAddress address, int timeout, byte[] buffer);
+        public Task<PingReply> SendPingAsync(IPAddress address, int timeout, byte[] buffer, PingOptions options);
+        public Task<PingReply> SendPingAsync(string hostNameOrAddress);
+        public Task<PingReply> SendPingAsync(string hostNameOrAddress, int timeout);
+        public Task<PingReply> SendPingAsync(string hostNameOrAddress, int timeout, byte[] buffer);
+        public Task<PingReply> SendPingAsync(string hostNameOrAddress, int timeout, byte[] buffer, PingOptions options);
+    }
+    public class PingException : InvalidOperationException {
+        public PingException(string message);
+        public PingException(string message, Exception innerException);
+    }
+    public class PingOptions {
+        public PingOptions();
+        public PingOptions(int ttl, bool dontFragment);
+        public bool DontFragment { get; set; }
+        public int Ttl { get; set; }
+    }
+    public class PingReply {
+        public IPAddress Address { get; }
+        public byte[] Buffer { get; }
+        public PingOptions Options { get; }
+        public long RoundtripTime { get; }
+        public IPStatus Status { get; }
+    }
+    public enum PrefixOrigin {
+        Dhcp = 3,
+        Manual = 1,
+        Other = 0,
+        RouterAdvertisement = 4,
+        WellKnown = 2,
+    }
+    public enum ScopeLevel {
+        Admin = 4,
+        Global = 14,
+        Interface = 1,
+        Link = 2,
+        None = 0,
+        Organization = 8,
+        Site = 5,
+        Subnet = 3,
+    }
+    public enum SuffixOrigin {
+        LinkLayerAddress = 4,
+        Manual = 1,
+        OriginDhcp = 3,
+        Other = 0,
+        Random = 5,
+        WellKnown = 2,
+    }
+    public abstract class TcpConnectionInformation {
+        protected TcpConnectionInformation();
+        public abstract IPEndPoint LocalEndPoint { get; }
+        public abstract IPEndPoint RemoteEndPoint { get; }
+        public abstract TcpState State { get; }
+    }
+    public enum TcpState {
+        Closed = 1,
+        CloseWait = 8,
+        Closing = 9,
+        DeleteTcb = 12,
+        Established = 5,
+        FinWait1 = 6,
+        FinWait2 = 7,
+        LastAck = 10,
+        Listen = 2,
+        SynReceived = 4,
+        SynSent = 3,
+        TimeWait = 11,
+        Unknown = 0,
+    }
+    public abstract class TcpStatistics {
+        protected TcpStatistics();
+        public abstract long ConnectionsAccepted { get; }
+        public abstract long ConnectionsInitiated { get; }
+        public abstract long CumulativeConnections { get; }
+        public abstract long CurrentConnections { get; }
+        public abstract long ErrorsReceived { get; }
+        public abstract long FailedConnectionAttempts { get; }
+        public abstract long MaximumConnections { get; }
+        public abstract long MaximumTransmissionTimeout { get; }
+        public abstract long MinimumTransmissionTimeout { get; }
+        public abstract long ResetConnections { get; }
+        public abstract long ResetsSent { get; }
+        public abstract long SegmentsReceived { get; }
+        public abstract long SegmentsResent { get; }
+        public abstract long SegmentsSent { get; }
+    }
+    public abstract class UdpStatistics {
+        protected UdpStatistics();
+        public abstract long DatagramsReceived { get; }
+        public abstract long DatagramsSent { get; }
+        public abstract long IncomingDatagramsDiscarded { get; }
+        public abstract long IncomingDatagramsWithErrors { get; }
+        public abstract int UdpListeners { get; }
+    }
+    public abstract class UnicastIPAddressInformation : IPAddressInformation {
+        protected UnicastIPAddressInformation();
+        public abstract long AddressPreferredLifetime { get; }
+        public abstract long AddressValidLifetime { get; }
+        public abstract long DhcpLeaseLifetime { get; }
+        public abstract DuplicateAddressDetectionState DuplicateAddressDetectionState { get; }
+        public abstract IPAddress IPv4Mask { get; }
+        public virtual int PrefixLength { get; }
+        public abstract PrefixOrigin PrefixOrigin { get; }
+        public abstract SuffixOrigin SuffixOrigin { get; }
+    }
+    public class UnicastIPAddressInformationCollection : ICollection<UnicastIPAddressInformation>, IEnumerable, IEnumerable<UnicastIPAddressInformation> {
+        protected internal UnicastIPAddressInformationCollection();
+        public virtual int Count { get; }
+        public virtual bool IsReadOnly { get; }
+        public virtual UnicastIPAddressInformation this[int index] { get; }
+        public virtual void Add(UnicastIPAddressInformation address);
+        public virtual void Clear();
+        public virtual bool Contains(UnicastIPAddressInformation address);
+        public virtual void CopyTo(UnicastIPAddressInformation[] array, int offset);
+        public virtual IEnumerator<UnicastIPAddressInformation> GetEnumerator();
+        public virtual bool Remove(UnicastIPAddressInformation address);
+        IEnumerator System.Collections.IEnumerable.GetEnumerator();
+    }
+}
```

## System.Net.Security

```c#
+namespace System.Net.Security {
+    public abstract class AuthenticatedStream : Stream {
+        protected AuthenticatedStream(Stream innerStream, bool leaveInnerStreamOpen);
+        protected Stream InnerStream { get; }
+        public abstract bool IsAuthenticated { get; }
+        public abstract bool IsEncrypted { get; }
+        public abstract bool IsMutuallyAuthenticated { get; }
+        public abstract bool IsServer { get; }
+        public abstract bool IsSigned { get; }
+        public bool LeaveInnerStreamOpen { get; }
+        protected override void Dispose(bool disposing);
+    }
+    public enum AuthenticationLevel {
+        MutualAuthRequested = 1,
+        MutualAuthRequired = 2,
+        None = 0,
+    }
+    public enum EncryptionPolicy {
+        AllowNoEncryption = 1,
+        NoEncryption = 2,
+        RequireEncryption = 0,
+    }
+    public delegate X509Certificate LocalCertificateSelectionCallback(object sender, string targetHost, X509CertificateCollection localCertificates, X509Certificate remoteCertificate, string[] acceptableIssuers);
+    public class NegotiateStream : AuthenticatedStream {
+        public NegotiateStream(Stream innerStream);
+        public NegotiateStream(Stream innerStream, bool leaveInnerStreamOpen);
+        public override bool CanRead { get; }
+        public override bool CanSeek { get; }
+        public override bool CanTimeout { get; }
+        public override bool CanWrite { get; }
+        public virtual TokenImpersonationLevel ImpersonationLevel { get; }
+        public override bool IsAuthenticated { get; }
+        public override bool IsEncrypted { get; }
+        public override bool IsMutuallyAuthenticated { get; }
+        public override bool IsServer { get; }
+        public override bool IsSigned { get; }
+        public override long Length { get; }
+        public override long Position { get; set; }
+        public override int ReadTimeout { get; set; }
+        public virtual IIdentity RemoteIdentity { get; }
+        public override int WriteTimeout { get; set; }
+        public virtual Task AuthenticateAsClientAsync();
+        public virtual Task AuthenticateAsClientAsync(NetworkCredential credential, ChannelBinding binding, string targetName);
+        public virtual Task AuthenticateAsClientAsync(NetworkCredential credential, ChannelBinding binding, string targetName, ProtectionLevel requiredProtectionLevel, TokenImpersonationLevel allowedImpersonationLevel);
+        public virtual Task AuthenticateAsClientAsync(NetworkCredential credential, string targetName);
+        public virtual Task AuthenticateAsClientAsync(NetworkCredential credential, string targetName, ProtectionLevel requiredProtectionLevel, TokenImpersonationLevel allowedImpersonationLevel);
+        public virtual Task AuthenticateAsServerAsync();
+        public virtual Task AuthenticateAsServerAsync(NetworkCredential credential, ProtectionLevel requiredProtectionLevel, TokenImpersonationLevel requiredImpersonationLevel);
+        public virtual Task AuthenticateAsServerAsync(NetworkCredential credential, ExtendedProtectionPolicy policy, ProtectionLevel requiredProtectionLevel, TokenImpersonationLevel requiredImpersonationLevel);
+        public virtual Task AuthenticateAsServerAsync(ExtendedProtectionPolicy policy);
+        public override void Flush();
+        public override int Read(byte[] buffer, int offset, int count);
+        public override long Seek(long offset, SeekOrigin origin);
+        public override void SetLength(long value);
+        public override void Write(byte[] buffer, int offset, int count);
+    }
+    public enum ProtectionLevel {
+        EncryptAndSign = 2,
+        None = 0,
+        Sign = 1,
+    }
+    public delegate bool RemoteCertificateValidationCallback(object sender, X509Certificate certificate, X509Chain chain, SslPolicyErrors sslPolicyErrors);
+    public enum SslPolicyErrors {
+        None = 0,
+        RemoteCertificateChainErrors = 4,
+        RemoteCertificateNameMismatch = 2,
+        RemoteCertificateNotAvailable = 1,
+    }
+    public class SslStream : AuthenticatedStream {
+        public SslStream(Stream innerStream);
+        public SslStream(Stream innerStream, bool leaveInnerStreamOpen);
+        public SslStream(Stream innerStream, bool leaveInnerStreamOpen, RemoteCertificateValidationCallback userCertificateValidationCallback);
+        public SslStream(Stream innerStream, bool leaveInnerStreamOpen, RemoteCertificateValidationCallback userCertificateValidationCallback, LocalCertificateSelectionCallback userCertificateSelectionCallback);
+        public SslStream(Stream innerStream, bool leaveInnerStreamOpen, RemoteCertificateValidationCallback userCertificateValidationCallback, LocalCertificateSelectionCallback userCertificateSelectionCallback, EncryptionPolicy encryptionPolicy);
+        public override bool CanRead { get; }
+        public override bool CanSeek { get; }
+        public override bool CanTimeout { get; }
+        public override bool CanWrite { get; }
+        public virtual bool CheckCertRevocationStatus { get; }
+        public virtual CipherAlgorithmType CipherAlgorithm { get; }
+        public virtual int CipherStrength { get; }
+        public virtual HashAlgorithmType HashAlgorithm { get; }
+        public virtual int HashStrength { get; }
+        public override bool IsAuthenticated { get; }
+        public override bool IsEncrypted { get; }
+        public override bool IsMutuallyAuthenticated { get; }
+        public override bool IsServer { get; }
+        public override bool IsSigned { get; }
+        public virtual ExchangeAlgorithmType KeyExchangeAlgorithm { get; }
+        public virtual int KeyExchangeStrength { get; }
+        public override long Length { get; }
+        public virtual X509Certificate LocalCertificate { get; }
+        public override long Position { get; set; }
+        public override int ReadTimeout { get; set; }
+        public virtual X509Certificate RemoteCertificate { get; }
+        public virtual SslProtocols SslProtocol { get; }
+        public TransportContext TransportContext { get; }
+        public override int WriteTimeout { get; set; }
+        public virtual Task AuthenticateAsClientAsync(string targetHost);
+        public virtual Task AuthenticateAsClientAsync(string targetHost, X509CertificateCollection clientCertificates, SslProtocols enabledSslProtocols, bool checkCertificateRevocation);
+        public virtual Task AuthenticateAsServerAsync(X509Certificate serverCertificate);
+        public virtual Task AuthenticateAsServerAsync(X509Certificate serverCertificate, bool clientCertificateRequired, SslProtocols enabledSslProtocols, bool checkCertificateRevocation);
+        public override void Flush();
+        public override int Read(byte[] buffer, int offset, int count);
+        public override long Seek(long offset, SeekOrigin origin);
+        public override void SetLength(long value);
+        public void Write(byte[] buffer);
+        public override void Write(byte[] buffer, int offset, int count);
+    }
+}
```

## System.Net.Sockets

```c#
+namespace System.Net.Sockets {
+    public enum AddressFamily {
+        AppleTalk = 16,
+        Atm = 22,
+        Banyan = 21,
+        Ccitt = 10,
+        Chaos = 5,
+        Cluster = 24,
+        DataKit = 9,
+        DataLink = 13,
+        DecNet = 12,
+        Ecma = 8,
+        FireFox = 19,
+        HyperChannel = 15,
+        Ieee12844 = 25,
+        ImpLink = 3,
+        InterNetwork = 2,
+        InterNetworkV6 = 23,
+        Ipx = 6,
+        Irda = 26,
+        Iso = 7,
+        Lat = 14,
+        NetBios = 17,
+        NetworkDesigners = 28,
+        NS = 6,
+        Osi = 7,
+        Pup = 4,
+        Sna = 11,
+        Unix = 1,
+        Unknown = -1,
+        Unspecified = 0,
+        VoiceView = 18,
+    }
+    public enum IOControlCode : long {
+        AbsorbRouterAlert = (long)2550136837,
+        AddMulticastGroupOnInterface = (long)2550136842,
+        AddressListChange = (long)671088663,
+        AddressListQuery = (long)1207959574,
+        AddressListSort = (long)3355443225,
+        AssociateHandle = (long)2281701377,
+        AsyncIO = (long)2147772029,
+        BindToInterface = (long)2550136840,
+        DataToRead = (long)1074030207,
+        DeleteMulticastGroupFromInterface = (long)2550136843,
+        EnableCircularQueuing = (long)671088642,
+        Flush = (long)671088644,
+        GetBroadcastAddress = (long)1207959557,
+        GetExtensionFunctionPointer = (long)3355443206,
+        GetGroupQos = (long)3355443208,
+        GetQos = (long)3355443207,
+        KeepAliveValues = (long)2550136836,
+        LimitBroadcasts = (long)2550136839,
+        MulticastInterface = (long)2550136841,
+        MulticastScope = (long)2281701386,
+        MultipointLoopback = (long)2281701385,
+        NamespaceChange = (long)2281701401,
+        NonBlockingIO = (long)2147772030,
+        OobDataRead = (long)1074033415,
+        QueryTargetPnpHandle = (long)1207959576,
+        ReceiveAll = (long)2550136833,
+        ReceiveAllIgmpMulticast = (long)2550136835,
+        ReceiveAllMulticast = (long)2550136834,
+        RoutingInterfaceChange = (long)2281701397,
+        RoutingInterfaceQuery = (long)3355443220,
+        SetGroupQos = (long)2281701388,
+        SetQos = (long)2281701387,
+        TranslateHandle = (long)3355443213,
+        UnicastInterface = (long)2550136838,
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct IPPacketInformation {
+        public IPAddress Address { get; }
+        public int Interface { get; }
+        public override bool Equals(object comparand);
+        public override int GetHashCode();
+        public static bool operator ==(IPPacketInformation packetInformation1, IPPacketInformation packetInformation2);
+        public static bool operator !=(IPPacketInformation packetInformation1, IPPacketInformation packetInformation2);
+    }
+    public enum IPProtectionLevel {
+        EdgeRestricted = 20,
+        Restricted = 30,
+        Unrestricted = 10,
+        Unspecified = -1,
+    }
+    public class IPv6MulticastOption {
+        public IPv6MulticastOption(IPAddress group);
+        public IPv6MulticastOption(IPAddress group, long ifindex);
+        public IPAddress Group { get; set; }
+        public long InterfaceIndex { get; set; }
+    }
+    public class LingerOption {
+        public LingerOption(bool enable, int seconds);
+        public bool Enabled { get; set; }
+        public int LingerTime { get; set; }
+    }
+    public class MulticastOption {
+        public MulticastOption(IPAddress group);
+        public MulticastOption(IPAddress group, int interfaceIndex);
+        public MulticastOption(IPAddress group, IPAddress mcint);
+        public IPAddress Group { get; set; }
+        public int InterfaceIndex { get; set; }
+        public IPAddress LocalAddress { get; set; }
+    }
+    public class NetworkStream : Stream {
+        public NetworkStream(Socket socket);
+        public NetworkStream(Socket socket, bool ownsSocket);
+        public override bool CanRead { get; }
+        public override bool CanSeek { get; }
+        public override bool CanTimeout { get; }
+        public override bool CanWrite { get; }
+        public virtual bool DataAvailable { get; }
+        public override long Length { get; }
+        public override long Position { get; set; }
+        public override int ReadTimeout { get; set; }
+        public override int WriteTimeout { get; set; }
+        protected override void Dispose(bool disposing);
+        ~NetworkStream();
+        public override void Flush();
+        public override Task FlushAsync(CancellationToken cancellationToken);
+        public override int Read(byte[] buffer, int offset, int size);
+        public override Task<int> ReadAsync(byte[] buffer, int offset, int size, CancellationToken cancellationToken);
+        public override long Seek(long offset, SeekOrigin origin);
+        public override void SetLength(long value);
+        public override void Write(byte[] buffer, int offset, int size);
+        public override Task WriteAsync(byte[] buffer, int offset, int size, CancellationToken cancellationToken);
+    }
+    public enum ProtocolType {
+        Ggp = 3,
+        Icmp = 1,
+        IcmpV6 = 58,
+        Idp = 22,
+        Igmp = 2,
+        IP = 0,
+        IPSecAuthenticationHeader = 51,
+        IPSecEncapsulatingSecurityPayload = 50,
+        IPv4 = 4,
+        IPv6 = 41,
+        IPv6DestinationOptions = 60,
+        IPv6FragmentHeader = 44,
+        IPv6HopByHopOptions = 0,
+        IPv6NoNextHeader = 59,
+        IPv6RoutingHeader = 43,
+        Ipx = 1000,
+        ND = 77,
+        Pup = 12,
+        Raw = 255,
+        Spx = 1256,
+        SpxII = 1257,
+        Tcp = 6,
+        Udp = 17,
+        Unknown = -1,
+        Unspecified = 0,
+    }
+    public enum SelectMode {
+        SelectError = 2,
+        SelectRead = 0,
+        SelectWrite = 1,
+    }
+    public class SendPacketsElement {
+        public SendPacketsElement(byte[] buffer);
+        public SendPacketsElement(byte[] buffer, int offset, int count);
+        public SendPacketsElement(byte[] buffer, int offset, int count, bool endOfPacket);
+        public SendPacketsElement(string filepath);
+        public SendPacketsElement(string filepath, int offset, int count);
+        public SendPacketsElement(string filepath, int offset, int count, bool endOfPacket);
+        public byte[] Buffer { get; }
+        public int Count { get; }
+        public bool EndOfPacket { get; }
+        public string FilePath { get; }
+        public int Offset { get; }
+    }
+    public class Socket : IDisposable {
+        public Socket(AddressFamily addressFamily, SocketType socketType, ProtocolType protocolType);
+        public Socket(SocketType socketType, ProtocolType protocolType);
+        public AddressFamily AddressFamily { get; }
+        public int Available { get; }
+        public bool Blocking { get; set; }
+        public bool Connected { get; }
+        public bool DontFragment { get; set; }
+        public bool DualMode { get; set; }
+        public bool EnableBroadcast { get; set; }
+        public bool ExclusiveAddressUse { get; set; }
+        public bool IsBound { get; }
+        public LingerOption LingerState { get; set; }
+        public EndPoint LocalEndPoint { get; }
+        public bool MulticastLoopback { get; set; }
+        public bool NoDelay { get; set; }
+        public static bool OSSupportsIPv4 { get; }
+        public static bool OSSupportsIPv6 { get; }
+        public ProtocolType ProtocolType { get; }
+        public int ReceiveBufferSize { get; set; }
+        public int ReceiveTimeout { get; set; }
+        public EndPoint RemoteEndPoint { get; }
+        public int SendBufferSize { get; set; }
+        public int SendTimeout { get; set; }
+        public SocketType SocketType { get; }
+        public short Ttl { get; set; }
+        public Socket Accept();
+        public bool AcceptAsync(SocketAsyncEventArgs e);
+        public void Bind(EndPoint localEP);
+        public static void CancelConnectAsync(SocketAsyncEventArgs e);
+        public void Connect(EndPoint remoteEP);
+        public void Connect(IPAddress address, int port);
+        public void Connect(IPAddress[] addresses, int port);
+        public void Connect(string host, int port);
+        public bool ConnectAsync(SocketAsyncEventArgs e);
+        public static bool ConnectAsync(SocketType socketType, ProtocolType protocolType, SocketAsyncEventArgs e);
+        public void Dispose();
+        protected virtual void Dispose(bool disposing);
+        ~Socket();
+        public object GetSocketOption(SocketOptionLevel optionLevel, SocketOptionName optionName);
+        public void GetSocketOption(SocketOptionLevel optionLevel, SocketOptionName optionName, byte[] optionValue);
+        public byte[] GetSocketOption(SocketOptionLevel optionLevel, SocketOptionName optionName, int optionLength);
+        public int IOControl(int ioControlCode, byte[] optionInValue, byte[] optionOutValue);
+        public int IOControl(IOControlCode ioControlCode, byte[] optionInValue, byte[] optionOutValue);
+        public void Listen(int backlog);
+        public bool Poll(int microSeconds, SelectMode mode);
+        public int Receive(byte[] buffer);
+        public int Receive(byte[] buffer, int offset, int size, SocketFlags socketFlags);
+        public int Receive(byte[] buffer, int offset, int size, SocketFlags socketFlags, out SocketError errorCode);
+        public int Receive(byte[] buffer, int size, SocketFlags socketFlags);
+        public int Receive(byte[] buffer, SocketFlags socketFlags);
+        public int Receive(IList<ArraySegment<byte>> buffers);
+        public int Receive(IList<ArraySegment<byte>> buffers, SocketFlags socketFlags);
+        public int Receive(IList<ArraySegment<byte>> buffers, SocketFlags socketFlags, out SocketError errorCode);
+        public bool ReceiveAsync(SocketAsyncEventArgs e);
+        public int ReceiveFrom(byte[] buffer, int offset, int size, SocketFlags socketFlags, ref EndPoint remoteEP);
+        public int ReceiveFrom(byte[] buffer, int size, SocketFlags socketFlags, ref EndPoint remoteEP);
+        public int ReceiveFrom(byte[] buffer, ref EndPoint remoteEP);
+        public int ReceiveFrom(byte[] buffer, SocketFlags socketFlags, ref EndPoint remoteEP);
+        public bool ReceiveFromAsync(SocketAsyncEventArgs e);
+        public int ReceiveMessageFrom(byte[] buffer, int offset, int size, ref SocketFlags socketFlags, ref EndPoint remoteEP, out IPPacketInformation ipPacketInformation);
+        public bool ReceiveMessageFromAsync(SocketAsyncEventArgs e);
+        public static void Select(IList checkRead, IList checkWrite, IList checkError, int microSeconds);
+        public int Send(byte[] buffer);
+        public int Send(byte[] buffer, int offset, int size, SocketFlags socketFlags);
+        public int Send(byte[] buffer, int offset, int size, SocketFlags socketFlags, out SocketError errorCode);
+        public int Send(byte[] buffer, int size, SocketFlags socketFlags);
+        public int Send(byte[] buffer, SocketFlags socketFlags);
+        public int Send(IList<ArraySegment<byte>> buffers);
+        public int Send(IList<ArraySegment<byte>> buffers, SocketFlags socketFlags);
+        public int Send(IList<ArraySegment<byte>> buffers, SocketFlags socketFlags, out SocketError errorCode);
+        public bool SendAsync(SocketAsyncEventArgs e);
+        public bool SendPacketsAsync(SocketAsyncEventArgs e);
+        public int SendTo(byte[] buffer, int offset, int size, SocketFlags socketFlags, EndPoint remoteEP);
+        public int SendTo(byte[] buffer, int size, SocketFlags socketFlags, EndPoint remoteEP);
+        public int SendTo(byte[] buffer, EndPoint remoteEP);
+        public int SendTo(byte[] buffer, SocketFlags socketFlags, EndPoint remoteEP);
+        public bool SendToAsync(SocketAsyncEventArgs e);
+        public void SetSocketOption(SocketOptionLevel optionLevel, SocketOptionName optionName, bool optionValue);
+        public void SetSocketOption(SocketOptionLevel optionLevel, SocketOptionName optionName, byte[] optionValue);
+        public void SetSocketOption(SocketOptionLevel optionLevel, SocketOptionName optionName, int optionValue);
+        public void SetSocketOption(SocketOptionLevel optionLevel, SocketOptionName optionName, object optionValue);
+        public void Shutdown(SocketShutdown how);
+    }
+    public class SocketAsyncEventArgs : EventArgs, IDisposable {
+        public SocketAsyncEventArgs();
+        public Socket AcceptSocket { get; set; }
+        public byte[] Buffer { get; }
+        public IList<ArraySegment<byte>> BufferList { get; set; }
+        public int BytesTransferred { get; }
+        public Exception ConnectByNameError { get; }
+        public Socket ConnectSocket { get; }
+        public int Count { get; }
+        public SocketAsyncOperation LastOperation { get; }
+        public int Offset { get; }
+        public IPPacketInformation ReceiveMessageFromPacketInfo { get; }
+        public EndPoint RemoteEndPoint { get; set; }
+        public SendPacketsElement[] SendPacketsElements { get; set; }
+        public int SendPacketsSendSize { get; set; }
+        public SocketError SocketError { get; set; }
+        public SocketFlags SocketFlags { get; set; }
+        public object UserToken { get; set; }
+        public event EventHandler<SocketAsyncEventArgs> Completed;
+        public void Dispose();
+        ~SocketAsyncEventArgs();
+        protected virtual void OnCompleted(SocketAsyncEventArgs e);
+        public void SetBuffer(byte[] buffer, int offset, int count);
+        public void SetBuffer(int offset, int count);
+    }
+    public enum SocketAsyncOperation {
+        Accept = 1,
+        Connect = 2,
+        Disconnect = 3,
+        None = 0,
+        Receive = 4,
+        ReceiveFrom = 5,
+        ReceiveMessageFrom = 6,
+        Send = 7,
+        SendPackets = 8,
+        SendTo = 9,
+    }
+    public enum SocketError {
+        AccessDenied = 10013,
+        AddressAlreadyInUse = 10048,
+        AddressFamilyNotSupported = 10047,
+        AddressNotAvailable = 10049,
+        AlreadyInProgress = 10037,
+        ConnectionAborted = 10053,
+        ConnectionRefused = 10061,
+        ConnectionReset = 10054,
+        DestinationAddressRequired = 10039,
+        Disconnecting = 10101,
+        Fault = 10014,
+        HostDown = 10064,
+        HostNotFound = 11001,
+        HostUnreachable = 10065,
+        InProgress = 10036,
+        Interrupted = 10004,
+        InvalidArgument = 10022,
+        IOPending = 997,
+        IsConnected = 10056,
+        MessageSize = 10040,
+        NetworkDown = 10050,
+        NetworkReset = 10052,
+        NetworkUnreachable = 10051,
+        NoBufferSpaceAvailable = 10055,
+        NoData = 11004,
+        NoRecovery = 11003,
+        NotConnected = 10057,
+        NotInitialized = 10093,
+        NotSocket = 10038,
+        OperationAborted = 995,
+        OperationNotSupported = 10045,
+        ProcessLimit = 10067,
+        ProtocolFamilyNotSupported = 10046,
+        ProtocolNotSupported = 10043,
+        ProtocolOption = 10042,
+        ProtocolType = 10041,
+        Shutdown = 10058,
+        SocketError = -1,
+        SocketNotSupported = 10044,
+        Success = 0,
+        SystemNotReady = 10091,
+        TimedOut = 10060,
+        TooManyOpenSockets = 10024,
+        TryAgain = 11002,
+        TypeNotFound = 10109,
+        VersionNotSupported = 10092,
+        WouldBlock = 10035,
+    }
+    public class SocketException : Exception {
+        public SocketException();
+        public SocketException(int errorCode);
+        public override string Message { get; }
+        public SocketError SocketErrorCode { get; }
+    }
+    public enum SocketFlags {
+        Broadcast = 1024,
+        ControlDataTruncated = 512,
+        DontRoute = 4,
+        Multicast = 2048,
+        None = 0,
+        OutOfBand = 1,
+        Partial = 32768,
+        Peek = 2,
+        Truncated = 256,
+    }
+    public enum SocketOptionLevel {
+        IP = 0,
+        IPv6 = 41,
+        Socket = 65535,
+        Tcp = 6,
+        Udp = 17,
+    }
+    public enum SocketOptionName {
+        AcceptConnection = 2,
+        AddMembership = 12,
+        AddSourceMembership = 15,
+        BlockSource = 17,
+        Broadcast = 32,
+        BsdUrgent = 2,
+        ChecksumCoverage = 20,
+        Debug = 1,
+        DontFragment = 14,
+        DontLinger = -129,
+        DontRoute = 16,
+        DropMembership = 13,
+        DropSourceMembership = 16,
+        Error = 4103,
+        ExclusiveAddressUse = -5,
+        Expedited = 2,
+        HeaderIncluded = 2,
+        HopLimit = 21,
+        IPOptions = 1,
+        IPProtectionLevel = 23,
+        IpTimeToLive = 4,
+        IPv6Only = 27,
+        KeepAlive = 8,
+        Linger = 128,
+        MaxConnections = 2147483647,
+        MulticastInterface = 9,
+        MulticastLoopback = 11,
+        MulticastTimeToLive = 10,
+        NoChecksum = 1,
+        NoDelay = 1,
+        OutOfBandInline = 256,
+        PacketInformation = 19,
+        ReceiveBuffer = 4098,
+        ReceiveLowWater = 4100,
+        ReceiveTimeout = 4102,
+        ReuseAddress = 4,
+        ReuseUnicastPort = 12295,
+        SendBuffer = 4097,
+        SendLowWater = 4099,
+        SendTimeout = 4101,
+        Type = 4104,
+        TypeOfService = 3,
+        UnblockSource = 18,
+        UpdateAcceptContext = 28683,
+        UpdateConnectContext = 28688,
+        UseLoopback = 64,
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct SocketReceiveFromResult {
+        public int ReceivedBytes;
+        public EndPoint RemoteEndPoint;
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct SocketReceiveMessageFromResult {
+        public int ReceivedBytes;
+        public EndPoint RemoteEndPoint;
+        public IPPacketInformation PacketInformation;
+        public SocketFlags SocketFlags;
+    }
+    public enum SocketShutdown {
+        Both = 2,
+        Receive = 0,
+        Send = 1,
+    }
+    public static class SocketTaskExtensions {
+        public static Task<Socket> AcceptAsync(this Socket socket);
+        public static Task<Socket> AcceptAsync(this Socket socket, Socket acceptSocket);
+        public static Task ConnectAsync(this Socket socket, EndPoint remoteEP);
+        public static Task ConnectAsync(this Socket socket, IPAddress address, int port);
+        public static Task ConnectAsync(this Socket socket, IPAddress[] addresses, int port);
+        public static Task ConnectAsync(this Socket socket, string host, int port);
+        public static Task<int> ReceiveAsync(this Socket socket, ArraySegment<byte> buffer, SocketFlags socketFlags);
+        public static Task<int> ReceiveAsync(this Socket socket, IList<ArraySegment<byte>> buffers, SocketFlags socketFlags);
+        public static Task<SocketReceiveFromResult> ReceiveFromAsync(this Socket socket, ArraySegment<byte> buffer, SocketFlags socketFlags, EndPoint remoteEndPoint);
+        public static Task<SocketReceiveMessageFromResult> ReceiveMessageFromAsync(this Socket socket, ArraySegment<byte> buffer, SocketFlags socketFlags, EndPoint remoteEndPoint);
+        public static Task<int> SendAsync(this Socket socket, ArraySegment<byte> buffer, SocketFlags socketFlags);
+        public static Task<int> SendAsync(this Socket socket, IList<ArraySegment<byte>> buffers, SocketFlags socketFlags);
+        public static Task<int> SendToAsync(this Socket socket, ArraySegment<byte> buffer, SocketFlags socketFlags, EndPoint remoteEP);
+    }
+    public enum SocketType {
+        Dgram = 2,
+        Raw = 3,
+        Rdm = 4,
+        Seqpacket = 5,
+        Stream = 1,
+        Unknown = -1,
+    }
+    public class TcpClient : IDisposable {
+        public TcpClient();
+        public TcpClient(AddressFamily family);
+        protected bool Active { get; set; }
+        public int Available { get; }
+        public Socket Client { get; set; }
+        public bool Connected { get; }
+        public bool ExclusiveAddressUse { get; set; }
+        public LingerOption LingerState { get; set; }
+        public bool NoDelay { get; set; }
+        public int ReceiveBufferSize { get; set; }
+        public int ReceiveTimeout { get; set; }
+        public int SendBufferSize { get; set; }
+        public int SendTimeout { get; set; }
+        public Task ConnectAsync(IPAddress address, int port);
+        public Task ConnectAsync(IPAddress[] addresses, int port);
+        public Task ConnectAsync(string host, int port);
+        public void Dispose();
+        protected virtual void Dispose(bool disposing);
+        ~TcpClient();
+        public NetworkStream GetStream();
+    }
+    public class TcpListener {
+        public TcpListener(IPAddress localaddr, int port);
+        public TcpListener(IPEndPoint localEP);
+        protected bool Active { get; }
+        public bool ExclusiveAddressUse { get; set; }
+        public EndPoint LocalEndpoint { get; }
+        public Socket Server { get; }
+        public Task<Socket> AcceptSocketAsync();
+        public Task<TcpClient> AcceptTcpClientAsync();
+        public bool Pending();
+        public void Start();
+        public void Start(int backlog);
+        public void Stop();
+    }
+    public class UdpClient : IDisposable {
+        public UdpClient();
+        public UdpClient(int port);
+        public UdpClient(int port, AddressFamily family);
+        public UdpClient(IPEndPoint localEP);
+        public UdpClient(AddressFamily family);
+        protected bool Active { get; set; }
+        public int Available { get; }
+        public Socket Client { get; set; }
+        public bool DontFragment { get; set; }
+        public bool EnableBroadcast { get; set; }
+        public bool ExclusiveAddressUse { get; set; }
+        public bool MulticastLoopback { get; set; }
+        public short Ttl { get; set; }
+        public void Dispose();
+        protected virtual void Dispose(bool disposing);
+        public void DropMulticastGroup(IPAddress multicastAddr);
+        public void DropMulticastGroup(IPAddress multicastAddr, int ifindex);
+        public void JoinMulticastGroup(int ifindex, IPAddress multicastAddr);
+        public void JoinMulticastGroup(IPAddress multicastAddr);
+        public void JoinMulticastGroup(IPAddress multicastAddr, int timeToLive);
+        public void JoinMulticastGroup(IPAddress multicastAddr, IPAddress localAddress);
+        public Task<UdpReceiveResult> ReceiveAsync();
+        public Task<int> SendAsync(byte[] datagram, int bytes, IPEndPoint endPoint);
+        public Task<int> SendAsync(byte[] datagram, int bytes, string hostname, int port);
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct UdpReceiveResult : IEquatable<UdpReceiveResult> {
+        public UdpReceiveResult(byte[] buffer, IPEndPoint remoteEndPoint);
+        public byte[] Buffer { get; }
+        public IPEndPoint RemoteEndPoint { get; }
+        public bool Equals(UdpReceiveResult other);
+        public override bool Equals(object obj);
+        public override int GetHashCode();
+        public static bool operator ==(UdpReceiveResult left, UdpReceiveResult right);
+        public static bool operator !=(UdpReceiveResult left, UdpReceiveResult right);
+    }
+}
```

## System.Net.WebSockets

```c#
+namespace System.Net.WebSockets {
+    public sealed class ClientWebSocket : WebSocket {
+        public ClientWebSocket();
+        public override Nullable<WebSocketCloseStatus> CloseStatus { get; }
+        public override string CloseStatusDescription { get; }
+        public ClientWebSocketOptions Options { get; }
+        public override WebSocketState State { get; }
+        public override string SubProtocol { get; }
+        public override void Abort();
+        public override Task CloseAsync(WebSocketCloseStatus closeStatus, string statusDescription, CancellationToken cancellationToken);
+        public override Task CloseOutputAsync(WebSocketCloseStatus closeStatus, string statusDescription, CancellationToken cancellationToken);
+        public Task ConnectAsync(Uri uri, CancellationToken cancellationToken);
+        public override void Dispose();
+        public override Task<WebSocketReceiveResult> ReceiveAsync(ArraySegment<byte> buffer, CancellationToken cancellationToken);
+        public override Task SendAsync(ArraySegment<byte> buffer, WebSocketMessageType messageType, bool endOfMessage, CancellationToken cancellationToken);
+    }
+    public sealed class ClientWebSocketOptions {
+        public X509CertificateCollection ClientCertificates { get; set; }
+        public CookieContainer Cookies { get; set; }
+        public ICredentials Credentials { get; set; }
+        public TimeSpan KeepAliveInterval { get; set; }
+        public IWebProxy Proxy { get; set; }
+        public void AddSubProtocol(string subProtocol);
+        public void SetRequestHeader(string headerName, string headerValue);
+    }
+    public abstract class WebSocket : IDisposable {
+        protected WebSocket();
+        public abstract Nullable<WebSocketCloseStatus> CloseStatus { get; }
+        public abstract string CloseStatusDescription { get; }
+        public abstract WebSocketState State { get; }
+        public abstract string SubProtocol { get; }
+        public abstract void Abort();
+        public abstract Task CloseAsync(WebSocketCloseStatus closeStatus, string statusDescription, CancellationToken cancellationToken);
+        public abstract Task CloseOutputAsync(WebSocketCloseStatus closeStatus, string statusDescription, CancellationToken cancellationToken);
+        public abstract void Dispose();
+        public abstract Task<WebSocketReceiveResult> ReceiveAsync(ArraySegment<byte> buffer, CancellationToken cancellationToken);
+        public abstract Task SendAsync(ArraySegment<byte> buffer, WebSocketMessageType messageType, bool endOfMessage, CancellationToken cancellationToken);
+    }
+    public enum WebSocketCloseStatus {
+        Empty = 1005,
+        EndpointUnavailable = 1001,
+        InternalServerError = 1011,
+        InvalidMessageType = 1003,
+        InvalidPayloadData = 1007,
+        MandatoryExtension = 1010,
+        MessageTooBig = 1009,
+        NormalClosure = 1000,
+        PolicyViolation = 1008,
+        ProtocolError = 1002,
+    }
+    public enum WebSocketError {
+        ConnectionClosedPrematurely = 8,
+        Faulted = 2,
+        HeaderError = 7,
+        InvalidMessageType = 1,
+        InvalidState = 9,
+        NativeError = 3,
+        NotAWebSocket = 4,
+        Success = 0,
+        UnsupportedProtocol = 6,
+        UnsupportedVersion = 5,
+    }
+    public sealed class WebSocketException : Exception {
+        public WebSocketException(int nativeError);
+        public WebSocketException(int nativeError, Exception innerException);
+        public WebSocketException(int nativeError, string message);
+        public WebSocketException(WebSocketError error);
+        public WebSocketException(WebSocketError error, Exception innerException);
+        public WebSocketException(WebSocketError error, int nativeError);
+        public WebSocketException(WebSocketError error, int nativeError, Exception innerException);
+        public WebSocketException(WebSocketError error, int nativeError, string message);
+        public WebSocketException(WebSocketError error, int nativeError, string message, Exception innerException);
+        public WebSocketException(WebSocketError error, string message);
+        public WebSocketException(WebSocketError error, string message, Exception innerException);
+        public WebSocketException(string message);
+        public WebSocketException(string message, Exception innerException);
+        public int ErrorCode { get; }
+        public WebSocketError WebSocketErrorCode { get; }
+    }
+    public enum WebSocketMessageType {
+        Binary = 1,
+        Close = 2,
+        Text = 0,
+    }
+    public class WebSocketReceiveResult {
+        public WebSocketReceiveResult(int count, WebSocketMessageType messageType, bool endOfMessage);
+        public WebSocketReceiveResult(int count, WebSocketMessageType messageType, bool endOfMessage, Nullable<WebSocketCloseStatus> closeStatus, string closeStatusDescription);
+        public Nullable<WebSocketCloseStatus> CloseStatus { get; }
+        public string CloseStatusDescription { get; }
+        public int Count { get; }
+        public bool EndOfMessage { get; }
+        public WebSocketMessageType MessageType { get; }
+    }
+    public enum WebSocketState {
+        Aborted = 6,
+        Closed = 5,
+        CloseReceived = 4,
+        CloseSent = 3,
+        Connecting = 1,
+        None = 0,
+        Open = 2,
+    }
+}
```

## System.Numerics

```c#
+namespace System.Numerics {
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct BigInteger : IComparable, IComparable<BigInteger>, IEquatable<BigInteger>, IFormattable {
+        public BigInteger(byte[] value);
+        public BigInteger(Decimal value);
+        public BigInteger(double value);
+        public BigInteger(int value);
+        public BigInteger(long value);
+        public BigInteger(float value);
+        public BigInteger(uint value);
+        public BigInteger(ulong value);
+        public bool IsEven { get; }
+        public bool IsOne { get; }
+        public bool IsPowerOfTwo { get; }
+        public bool IsZero { get; }
+        public static BigInteger MinusOne { get; }
+        public static BigInteger One { get; }
+        public int Sign { get; }
+        public static BigInteger Zero { get; }
+        public static BigInteger Abs(BigInteger value);
+        public static BigInteger Add(BigInteger left, BigInteger right);
+        public static int Compare(BigInteger left, BigInteger right);
+        public int CompareTo(long other);
+        public int CompareTo(BigInteger other);
+        public int CompareTo(ulong other);
+        public static BigInteger Divide(BigInteger dividend, BigInteger divisor);
+        public static BigInteger DivRem(BigInteger dividend, BigInteger divisor, out BigInteger remainder);
+        public bool Equals(long other);
+        public bool Equals(BigInteger other);
+        public override bool Equals(object obj);
+        public bool Equals(ulong other);
+        public override int GetHashCode();
+        public static BigInteger GreatestCommonDivisor(BigInteger left, BigInteger right);
+        public static double Log(BigInteger value);
+        public static double Log(BigInteger value, double baseValue);
+        public static double Log10(BigInteger value);
+        public static BigInteger Max(BigInteger left, BigInteger right);
+        public static BigInteger Min(BigInteger left, BigInteger right);
+        public static BigInteger ModPow(BigInteger value, BigInteger exponent, BigInteger modulus);
+        public static BigInteger Multiply(BigInteger left, BigInteger right);
+        public static BigInteger Negate(BigInteger value);
+        public static BigInteger operator +(BigInteger left, BigInteger right);
+        public static BigInteger operator &(BigInteger left, BigInteger right);
+        public static BigInteger operator |(BigInteger left, BigInteger right);
+        public static BigInteger operator --(BigInteger value);
+        public static BigInteger operator /(BigInteger dividend, BigInteger divisor);
+        public static bool operator ==(long left, BigInteger right);
+        public static bool operator ==(BigInteger left, long right);
+        public static bool operator ==(BigInteger left, BigInteger right);
+        public static bool operator ==(BigInteger left, ulong right);
+        public static bool operator ==(ulong left, BigInteger right);
+        public static BigInteger operator ^(BigInteger left, BigInteger right);
+        public static explicit operator BigInteger (Decimal value);
+        public static explicit operator BigInteger (double value);
+        public static explicit operator byte (BigInteger value);
+        public static explicit operator Decimal (BigInteger value);
+        public static explicit operator double (BigInteger value);
+        public static explicit operator short (BigInteger value);
+        public static explicit operator int (BigInteger value);
+        public static explicit operator long (BigInteger value);
+        public static explicit operator sbyte (BigInteger value);
+        public static explicit operator float (BigInteger value);
+        public static explicit operator ushort (BigInteger value);
+        public static explicit operator uint (BigInteger value);
+        public static explicit operator ulong (BigInteger value);
+        public static explicit operator BigInteger (float value);
+        public static bool operator >(long left, BigInteger right);
+        public static bool operator >(BigInteger left, long right);
+        public static bool operator >(BigInteger left, BigInteger right);
+        public static bool operator >(BigInteger left, ulong right);
+        public static bool operator >(ulong left, BigInteger right);
+        public static bool operator >=(long left, BigInteger right);
+        public static bool operator >=(BigInteger left, long right);
+        public static bool operator >=(BigInteger left, BigInteger right);
+        public static bool operator >=(BigInteger left, ulong right);
+        public static bool operator >=(ulong left, BigInteger right);
+        public static implicit operator BigInteger (byte value);
+        public static implicit operator BigInteger (short value);
+        public static implicit operator BigInteger (int value);
+        public static implicit operator BigInteger (long value);
+        public static implicit operator BigInteger (sbyte value);
+        public static implicit operator BigInteger (ushort value);
+        public static implicit operator BigInteger (uint value);
+        public static implicit operator BigInteger (ulong value);
+        public static BigInteger operator ++(BigInteger value);
+        public static bool operator !=(long left, BigInteger right);
+        public static bool operator !=(BigInteger left, long right);
+        public static bool operator !=(BigInteger left, BigInteger right);
+        public static bool operator !=(BigInteger left, ulong right);
+        public static bool operator !=(ulong left, BigInteger right);
+        public static BigInteger operator <<(BigInteger value, int shift);
+        public static bool operator <(long left, BigInteger right);
+        public static bool operator <(BigInteger left, long right);
+        public static bool operator <(BigInteger left, BigInteger right);
+        public static bool operator <(BigInteger left, ulong right);
+        public static bool operator <(ulong left, BigInteger right);
+        public static bool operator <=(long left, BigInteger right);
+        public static bool operator <=(BigInteger left, long right);
+        public static bool operator <=(BigInteger left, BigInteger right);
+        public static bool operator <=(BigInteger left, ulong right);
+        public static bool operator <=(ulong left, BigInteger right);
+        public static BigInteger operator %(BigInteger dividend, BigInteger divisor);
+        public static BigInteger operator *(BigInteger left, BigInteger right);
+        public static BigInteger operator ~(BigInteger value);
+        public static BigInteger operator >>(BigInteger value, int shift);
+        public static BigInteger operator -(BigInteger left, BigInteger right);
+        public static BigInteger operator -(BigInteger value);
+        public static BigInteger operator +(BigInteger value);
+        public static BigInteger Parse(string value);
+        public static BigInteger Parse(string value, NumberStyles style);
+        public static BigInteger Parse(string value, NumberStyles style, IFormatProvider provider);
+        public static BigInteger Parse(string value, IFormatProvider provider);
+        public static BigInteger Pow(BigInteger value, int exponent);
+        public static BigInteger Remainder(BigInteger dividend, BigInteger divisor);
+        public static BigInteger Subtract(BigInteger left, BigInteger right);
+        int System.IComparable.CompareTo(object obj);
+        public byte[] ToByteArray();
+        public override string ToString();
+        public string ToString(IFormatProvider provider);
+        public string ToString(string format);
+        public string ToString(string format, IFormatProvider provider);
+        public static bool TryParse(string value, NumberStyles style, IFormatProvider provider, out BigInteger result);
+        public static bool TryParse(string value, out BigInteger result);
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct Complex : IEquatable<Complex>, IFormattable {
+        public static readonly Complex ImaginaryOne;
+        public static readonly Complex One;
+        public static readonly Complex Zero;
+        public Complex(double real, double imaginary);
+        public double Imaginary { get; }
+        public double Magnitude { get; }
+        public double Phase { get; }
+        public double Real { get; }
+        public static double Abs(Complex value);
+        public static Complex Acos(Complex value);
+        public static Complex Add(Complex left, Complex right);
+        public static Complex Asin(Complex value);
+        public static Complex Atan(Complex value);
+        public static Complex Conjugate(Complex value);
+        public static Complex Cos(Complex value);
+        public static Complex Cosh(Complex value);
+        public static Complex Divide(Complex dividend, Complex divisor);
+        public bool Equals(Complex value);
+        public override bool Equals(object obj);
+        public static Complex Exp(Complex value);
+        public static Complex FromPolarCoordinates(double magnitude, double phase);
+        public override int GetHashCode();
+        public static Complex Log(Complex value);
+        public static Complex Log(Complex value, double baseValue);
+        public static Complex Log10(Complex value);
+        public static Complex Multiply(Complex left, Complex right);
+        public static Complex Negate(Complex value);
+        public static Complex operator +(Complex left, Complex right);
+        public static Complex operator /(Complex left, Complex right);
+        public static bool operator ==(Complex left, Complex right);
+        public static explicit operator Complex (Decimal value);
+        public static explicit operator Complex (BigInteger value);
+        public static implicit operator Complex (byte value);
+        public static implicit operator Complex (double value);
+        public static implicit operator Complex (short value);
+        public static implicit operator Complex (int value);
+        public static implicit operator Complex (long value);
+        public static implicit operator Complex (sbyte value);
+        public static implicit operator Complex (float value);
+        public static implicit operator Complex (ushort value);
+        public static implicit operator Complex (uint value);
+        public static implicit operator Complex (ulong value);
+        public static bool operator !=(Complex left, Complex right);
+        public static Complex operator *(Complex left, Complex right);
+        public static Complex operator -(Complex left, Complex right);
+        public static Complex operator -(Complex value);
+        public static Complex Pow(Complex value, double power);
+        public static Complex Pow(Complex value, Complex power);
+        public static Complex Reciprocal(Complex value);
+        public static Complex Sin(Complex value);
+        public static Complex Sinh(Complex value);
+        public static Complex Sqrt(Complex value);
+        public static Complex Subtract(Complex left, Complex right);
+        public static Complex Tan(Complex value);
+        public static Complex Tanh(Complex value);
+        public override string ToString();
+        public string ToString(IFormatProvider provider);
+        public string ToString(string format);
+        public string ToString(string format, IFormatProvider provider);
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct Matrix3x2 : IEquatable<Matrix3x2> {
+        public float M11;
+        public float M12;
+        public float M21;
+        public float M22;
+        public float M31;
+        public float M32;
+        public Matrix3x2(float m11, float m12, float m21, float m22, float m31, float m32);
+        public static Matrix3x2 Identity { get; }
+        public bool IsIdentity { get; }
+        public Vector2 Translation { get; set; }
+        public static Matrix3x2 Add(Matrix3x2 value1, Matrix3x2 value2);
+        public static Matrix3x2 CreateRotation(float radians);
+        public static Matrix3x2 CreateRotation(float radians, Vector2 centerPoint);
+        public static Matrix3x2 CreateScale(Vector2 scales);
+        public static Matrix3x2 CreateScale(Vector2 scales, Vector2 centerPoint);
+        public static Matrix3x2 CreateScale(float scale);
+        public static Matrix3x2 CreateScale(float scale, Vector2 centerPoint);
+        public static Matrix3x2 CreateScale(float xScale, float yScale);
+        public static Matrix3x2 CreateScale(float xScale, float yScale, Vector2 centerPoint);
+        public static Matrix3x2 CreateSkew(float radiansX, float radiansY);
+        public static Matrix3x2 CreateSkew(float radiansX, float radiansY, Vector2 centerPoint);
+        public static Matrix3x2 CreateTranslation(Vector2 position);
+        public static Matrix3x2 CreateTranslation(float xPosition, float yPosition);
+        public bool Equals(Matrix3x2 other);
+        public override bool Equals(object obj);
+        public float GetDeterminant();
+        public override int GetHashCode();
+        public static bool Invert(Matrix3x2 matrix, out Matrix3x2 result);
+        public static Matrix3x2 Lerp(Matrix3x2 matrix1, Matrix3x2 matrix2, float amount);
+        public static Matrix3x2 Multiply(Matrix3x2 value1, Matrix3x2 value2);
+        public static Matrix3x2 Multiply(Matrix3x2 value1, float value2);
+        public static Matrix3x2 Negate(Matrix3x2 value);
+        public static Matrix3x2 operator +(Matrix3x2 value1, Matrix3x2 value2);
+        public static bool operator ==(Matrix3x2 value1, Matrix3x2 value2);
+        public static bool operator !=(Matrix3x2 value1, Matrix3x2 value2);
+        public static Matrix3x2 operator *(Matrix3x2 value1, Matrix3x2 value2);
+        public static Matrix3x2 operator *(Matrix3x2 value1, float value2);
+        public static Matrix3x2 operator -(Matrix3x2 value1, Matrix3x2 value2);
+        public static Matrix3x2 operator -(Matrix3x2 value);
+        public static Matrix3x2 Subtract(Matrix3x2 value1, Matrix3x2 value2);
+        public override string ToString();
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct Matrix4x4 : IEquatable<Matrix4x4> {
+        public float M11;
+        public float M12;
+        public float M13;
+        public float M14;
+        public float M21;
+        public float M22;
+        public float M23;
+        public float M24;
+        public float M31;
+        public float M32;
+        public float M33;
+        public float M34;
+        public float M41;
+        public float M42;
+        public float M43;
+        public float M44;
+        public Matrix4x4(Matrix3x2 value);
+        public Matrix4x4(float m11, float m12, float m13, float m14, float m21, float m22, float m23, float m24, float m31, float m32, float m33, float m34, float m41, float m42, float m43, float m44);
+        public static Matrix4x4 Identity { get; }
+        public bool IsIdentity { get; }
+        public Vector3 Translation { get; set; }
+        public static Matrix4x4 Add(Matrix4x4 value1, Matrix4x4 value2);
+        public static Matrix4x4 CreateBillboard(Vector3 objectPosition, Vector3 cameraPosition, Vector3 cameraUpVector, Vector3 cameraForwardVector);
+        public static Matrix4x4 CreateConstrainedBillboard(Vector3 objectPosition, Vector3 cameraPosition, Vector3 rotateAxis, Vector3 cameraForwardVector, Vector3 objectForwardVector);
+        public static Matrix4x4 CreateFromAxisAngle(Vector3 axis, float angle);
+        public static Matrix4x4 CreateFromQuaternion(Quaternion quaternion);
+        public static Matrix4x4 CreateFromYawPitchRoll(float yaw, float pitch, float roll);
+        public static Matrix4x4 CreateLookAt(Vector3 cameraPosition, Vector3 cameraTarget, Vector3 cameraUpVector);
+        public static Matrix4x4 CreateOrthographic(float width, float height, float zNearPlane, float zFarPlane);
+        public static Matrix4x4 CreateOrthographicOffCenter(float left, float right, float bottom, float top, float zNearPlane, float zFarPlane);
+        public static Matrix4x4 CreatePerspective(float width, float height, float nearPlaneDistance, float farPlaneDistance);
+        public static Matrix4x4 CreatePerspectiveFieldOfView(float fieldOfView, float aspectRatio, float nearPlaneDistance, float farPlaneDistance);
+        public static Matrix4x4 CreatePerspectiveOffCenter(float left, float right, float bottom, float top, float nearPlaneDistance, float farPlaneDistance);
+        public static Matrix4x4 CreateReflection(Plane value);
+        public static Matrix4x4 CreateRotationX(float radians);
+        public static Matrix4x4 CreateRotationX(float radians, Vector3 centerPoint);
+        public static Matrix4x4 CreateRotationY(float radians);
+        public static Matrix4x4 CreateRotationY(float radians, Vector3 centerPoint);
+        public static Matrix4x4 CreateRotationZ(float radians);
+        public static Matrix4x4 CreateRotationZ(float radians, Vector3 centerPoint);
+        public static Matrix4x4 CreateScale(Vector3 scales);
+        public static Matrix4x4 CreateScale(Vector3 scales, Vector3 centerPoint);
+        public static Matrix4x4 CreateScale(float scale);
+        public static Matrix4x4 CreateScale(float scale, Vector3 centerPoint);
+        public static Matrix4x4 CreateScale(float xScale, float yScale, float zScale);
+        public static Matrix4x4 CreateScale(float xScale, float yScale, float zScale, Vector3 centerPoint);
+        public static Matrix4x4 CreateShadow(Vector3 lightDirection, Plane plane);
+        public static Matrix4x4 CreateTranslation(Vector3 position);
+        public static Matrix4x4 CreateTranslation(float xPosition, float yPosition, float zPosition);
+        public static Matrix4x4 CreateWorld(Vector3 position, Vector3 forward, Vector3 up);
+        public static bool Decompose(Matrix4x4 matrix, out Vector3 scale, out Quaternion rotation, out Vector3 translation);
+        public bool Equals(Matrix4x4 other);
+        public override bool Equals(object obj);
+        public float GetDeterminant();
+        public override int GetHashCode();
+        public static bool Invert(Matrix4x4 matrix, out Matrix4x4 result);
+        public static Matrix4x4 Lerp(Matrix4x4 matrix1, Matrix4x4 matrix2, float amount);
+        public static Matrix4x4 Multiply(Matrix4x4 value1, Matrix4x4 value2);
+        public static Matrix4x4 Multiply(Matrix4x4 value1, float value2);
+        public static Matrix4x4 Negate(Matrix4x4 value);
+        public static Matrix4x4 operator +(Matrix4x4 value1, Matrix4x4 value2);
+        public static bool operator ==(Matrix4x4 value1, Matrix4x4 value2);
+        public static bool operator !=(Matrix4x4 value1, Matrix4x4 value2);
+        public static Matrix4x4 operator *(Matrix4x4 value1, Matrix4x4 value2);
+        public static Matrix4x4 operator *(Matrix4x4 value1, float value2);
+        public static Matrix4x4 operator -(Matrix4x4 value1, Matrix4x4 value2);
+        public static Matrix4x4 operator -(Matrix4x4 value);
+        public static Matrix4x4 Subtract(Matrix4x4 value1, Matrix4x4 value2);
+        public override string ToString();
+        public static Matrix4x4 Transform(Matrix4x4 value, Quaternion rotation);
+        public static Matrix4x4 Transpose(Matrix4x4 matrix);
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct Plane : IEquatable<Plane> {
+        public Vector3 Normal;
+        public float D;
+        public Plane(Vector3 normal, float d);
+        public Plane(Vector4 value);
+        public Plane(float x, float y, float z, float d);
+        public static Plane CreateFromVertices(Vector3 point1, Vector3 point2, Vector3 point3);
+        public static float Dot(Plane plane, Vector4 value);
+        public static float DotCoordinate(Plane plane, Vector3 value);
+        public static float DotNormal(Plane plane, Vector3 value);
+        public bool Equals(Plane other);
+        public override bool Equals(object obj);
+        public override int GetHashCode();
+        public static Plane Normalize(Plane value);
+        public static bool operator ==(Plane value1, Plane value2);
+        public static bool operator !=(Plane value1, Plane value2);
+        public override string ToString();
+        public static Plane Transform(Plane plane, Matrix4x4 matrix);
+        public static Plane Transform(Plane plane, Quaternion rotation);
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct Quaternion : IEquatable<Quaternion> {
+        public float W;
+        public float X;
+        public float Y;
+        public float Z;
+        public Quaternion(Vector3 vectorPart, float scalarPart);
+        public Quaternion(float x, float y, float z, float w);
+        public static Quaternion Identity { get; }
+        public bool IsIdentity { get; }
+        public static Quaternion Add(Quaternion value1, Quaternion value2);
+        public static Quaternion Concatenate(Quaternion value1, Quaternion value2);
+        public static Quaternion Conjugate(Quaternion value);
+        public static Quaternion CreateFromAxisAngle(Vector3 axis, float angle);
+        public static Quaternion CreateFromRotationMatrix(Matrix4x4 matrix);
+        public static Quaternion CreateFromYawPitchRoll(float yaw, float pitch, float roll);
+        public static Quaternion Divide(Quaternion value1, Quaternion value2);
+        public static float Dot(Quaternion quaternion1, Quaternion quaternion2);
+        public bool Equals(Quaternion other);
+        public override bool Equals(object obj);
+        public override int GetHashCode();
+        public static Quaternion Inverse(Quaternion value);
+        public float Length();
+        public float LengthSquared();
+        public static Quaternion Lerp(Quaternion quaternion1, Quaternion quaternion2, float amount);
+        public static Quaternion Multiply(Quaternion value1, Quaternion value2);
+        public static Quaternion Multiply(Quaternion value1, float value2);
+        public static Quaternion Negate(Quaternion value);
+        public static Quaternion Normalize(Quaternion value);
+        public static Quaternion operator +(Quaternion value1, Quaternion value2);
+        public static Quaternion operator /(Quaternion value1, Quaternion value2);
+        public static bool operator ==(Quaternion value1, Quaternion value2);
+        public static bool operator !=(Quaternion value1, Quaternion value2);
+        public static Quaternion operator *(Quaternion value1, Quaternion value2);
+        public static Quaternion operator *(Quaternion value1, float value2);
+        public static Quaternion operator -(Quaternion value1, Quaternion value2);
+        public static Quaternion operator -(Quaternion value);
+        public static Quaternion Slerp(Quaternion quaternion1, Quaternion quaternion2, float amount);
+        public static Quaternion Subtract(Quaternion value1, Quaternion value2);
+        public override string ToString();
+    }
+    public static class Vector {
+        public static bool IsHardwareAccelerated { get; }
+        public static Vector<T> Abs<T>(Vector<T> value) where T : struct, ValueType;
+        public static Vector<T> Add<T>(Vector<T> left, Vector<T> right) where T : struct, ValueType;
+        public static Vector<T> AndNot<T>(Vector<T> left, Vector<T> right) where T : struct, ValueType;
+        public static Vector<byte> AsVectorByte<T>(Vector<T> value) where T : struct, ValueType;
+        public static Vector<double> AsVectorDouble<T>(Vector<T> value) where T : struct, ValueType;
+        public static Vector<short> AsVectorInt16<T>(Vector<T> value) where T : struct, ValueType;
+        public static Vector<int> AsVectorInt32<T>(Vector<T> value) where T : struct, ValueType;
+        public static Vector<long> AsVectorInt64<T>(Vector<T> value) where T : struct, ValueType;
+        public static Vector<sbyte> AsVectorSByte<T>(Vector<T> value) where T : struct, ValueType;
+        public static Vector<float> AsVectorSingle<T>(Vector<T> value) where T : struct, ValueType;
+        public static Vector<ushort> AsVectorUInt16<T>(Vector<T> value) where T : struct, ValueType;
+        public static Vector<uint> AsVectorUInt32<T>(Vector<T> value) where T : struct, ValueType;
+        public static Vector<ulong> AsVectorUInt64<T>(Vector<T> value) where T : struct, ValueType;
+        public static Vector<T> BitwiseAnd<T>(Vector<T> left, Vector<T> right) where T : struct, ValueType;
+        public static Vector<T> BitwiseOr<T>(Vector<T> left, Vector<T> right) where T : struct, ValueType;
+        public static Vector<float> ConditionalSelect(Vector<int> condition, Vector<float> left, Vector<float> right);
+        public static Vector<double> ConditionalSelect(Vector<long> condition, Vector<double> left, Vector<double> right);
+        public static Vector<T> ConditionalSelect<T>(Vector<T> condition, Vector<T> left, Vector<T> right) where T : struct, ValueType;
+        public static Vector<T> Divide<T>(Vector<T> left, Vector<T> right) where T : struct, ValueType;
+        public static T Dot<T>(Vector<T> left, Vector<T> right) where T : struct, ValueType;
+        public static Vector<long> Equals(Vector<double> left, Vector<double> right);
+        public static Vector<int> Equals(Vector<int> left, Vector<int> right);
+        public static Vector<long> Equals(Vector<long> left, Vector<long> right);
+        public static Vector<int> Equals(Vector<float> left, Vector<float> right);
+        public static Vector<T> Equals<T>(Vector<T> left, Vector<T> right) where T : struct, ValueType;
+        public static bool EqualsAll<T>(Vector<T> left, Vector<T> right) where T : struct, ValueType;
+        public static bool EqualsAny<T>(Vector<T> left, Vector<T> right) where T : struct, ValueType;
+        public static Vector<long> GreaterThan(Vector<double> left, Vector<double> right);
+        public static Vector<int> GreaterThan(Vector<int> left, Vector<int> right);
+        public static Vector<long> GreaterThan(Vector<long> left, Vector<long> right);
+        public static Vector<int> GreaterThan(Vector<float> left, Vector<float> right);
+        public static Vector<T> GreaterThan<T>(Vector<T> left, Vector<T> right) where T : struct, ValueType;
+        public static bool GreaterThanAll<T>(Vector<T> left, Vector<T> right) where T : struct, ValueType;
+        public static bool GreaterThanAny<T>(Vector<T> left, Vector<T> right) where T : struct, ValueType;
+        public static Vector<long> GreaterThanOrEqual(Vector<double> left, Vector<double> right);
+        public static Vector<int> GreaterThanOrEqual(Vector<int> left, Vector<int> right);
+        public static Vector<long> GreaterThanOrEqual(Vector<long> left, Vector<long> right);
+        public static Vector<int> GreaterThanOrEqual(Vector<float> left, Vector<float> right);
+        public static Vector<T> GreaterThanOrEqual<T>(Vector<T> left, Vector<T> right) where T : struct, ValueType;
+        public static bool GreaterThanOrEqualAll<T>(Vector<T> left, Vector<T> right) where T : struct, ValueType;
+        public static bool GreaterThanOrEqualAny<T>(Vector<T> left, Vector<T> right) where T : struct, ValueType;
+        public static Vector<long> LessThan(Vector<double> left, Vector<double> right);
+        public static Vector<int> LessThan(Vector<int> left, Vector<int> right);
+        public static Vector<long> LessThan(Vector<long> left, Vector<long> right);
+        public static Vector<int> LessThan(Vector<float> left, Vector<float> right);
+        public static Vector<T> LessThan<T>(Vector<T> left, Vector<T> right) where T : struct, ValueType;
+        public static bool LessThanAll<T>(Vector<T> left, Vector<T> right) where T : struct, ValueType;
+        public static bool LessThanAny<T>(Vector<T> left, Vector<T> right) where T : struct, ValueType;
+        public static Vector<long> LessThanOrEqual(Vector<double> left, Vector<double> right);
+        public static Vector<int> LessThanOrEqual(Vector<int> left, Vector<int> right);
+        public static Vector<long> LessThanOrEqual(Vector<long> left, Vector<long> right);
+        public static Vector<int> LessThanOrEqual(Vector<float> left, Vector<float> right);
+        public static Vector<T> LessThanOrEqual<T>(Vector<T> left, Vector<T> right) where T : struct, ValueType;
+        public static bool LessThanOrEqualAll<T>(Vector<T> left, Vector<T> right) where T : struct, ValueType;
+        public static bool LessThanOrEqualAny<T>(Vector<T> left, Vector<T> right) where T : struct, ValueType;
+        public static Vector<T> Max<T>(Vector<T> left, Vector<T> right) where T : struct, ValueType;
+        public static Vector<T> Min<T>(Vector<T> left, Vector<T> right) where T : struct, ValueType;
+        public static Vector<T> Multiply<T>(Vector<T> left, Vector<T> right) where T : struct, ValueType;
+        public static Vector<T> Multiply<T>(Vector<T> left, T right) where T : struct, ValueType;
+        public static Vector<T> Multiply<T>(T left, Vector<T> right) where T : struct, ValueType;
+        public static Vector<T> Negate<T>(Vector<T> value) where T : struct, ValueType;
+        public static Vector<T> OnesComplement<T>(Vector<T> value) where T : struct, ValueType;
+        public static Vector<T> SquareRoot<T>(Vector<T> value) where T : struct, ValueType;
+        public static Vector<T> Subtract<T>(Vector<T> left, Vector<T> right) where T : struct, ValueType;
+        public static Vector<T> Xor<T>(Vector<T> left, Vector<T> right) where T : struct, ValueType;
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct Vector<T> : IEquatable<Vector<T>>, IFormattable where T : struct, ValueType {
+        public Vector(T value);
+        public Vector(T[] values);
+        public Vector(T[] values, int index);
+        public static int Count { get; }
+        public static Vector<T> One { get; }
+        public T this[int index] { get; }
+        public static Vector<T> Zero { get; }
+        public void CopyTo(T[] destination);
+        public void CopyTo(T[] destination, int startIndex);
+        public bool Equals(Vector<T> other);
+        public override bool Equals(object obj);
+        public override int GetHashCode();
+        public static Vector<T> operator +(Vector<T> left, Vector<T> right);
+        public static Vector<T> operator &(Vector<T> left, Vector<T> right);
+        public static Vector<T> operator |(Vector<T> left, Vector<T> right);
+        public static Vector<T> operator /(Vector<T> left, Vector<T> right);
+        public static bool operator ==(Vector<T> left, Vector<T> right);
+        public static Vector<T> operator ^(Vector<T> left, Vector<T> right);
+        public static explicit operator Vector<byte> (Vector<T> value);
+        public static explicit operator Vector<double> (Vector<T> value);
+        public static explicit operator Vector<short> (Vector<T> value);
+        public static explicit operator Vector<int> (Vector<T> value);
+        public static explicit operator Vector<long> (Vector<T> value);
+        public static explicit operator Vector<sbyte> (Vector<T> value);
+        public static explicit operator Vector<float> (Vector<T> value);
+        public static explicit operator Vector<ushort> (Vector<T> value);
+        public static explicit operator Vector<uint> (Vector<T> value);
+        public static explicit operator Vector<ulong> (Vector<T> value);
+        public static bool operator !=(Vector<T> left, Vector<T> right);
+        public static Vector<T> operator *(Vector<T> left, Vector<T> right);
+        public static Vector<T> operator *(Vector<T> value, T factor);
+        public static Vector<T> operator *(T factor, Vector<T> value);
+        public static Vector<T> operator ~(Vector<T> value);
+        public static Vector<T> operator -(Vector<T> left, Vector<T> right);
+        public static Vector<T> operator -(Vector<T> value);
+        public override string ToString();
+        public string ToString(string format);
+        public string ToString(string format, IFormatProvider formatProvider);
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct Vector2 : IEquatable<Vector2>, IFormattable {
+        public float X;
+        public float Y;
+        public Vector2(float value);
+        public Vector2(float x, float y);
+        public static Vector2 One { get; }
+        public static Vector2 UnitX { get; }
+        public static Vector2 UnitY { get; }
+        public static Vector2 Zero { get; }
+        public static Vector2 Abs(Vector2 value);
+        public static Vector2 Add(Vector2 left, Vector2 right);
+        public static Vector2 Clamp(Vector2 value1, Vector2 min, Vector2 max);
+        public void CopyTo(float[] array);
+        public void CopyTo(float[] array, int index);
+        public static float Distance(Vector2 value1, Vector2 value2);
+        public static float DistanceSquared(Vector2 value1, Vector2 value2);
+        public static Vector2 Divide(Vector2 left, Vector2 right);
+        public static Vector2 Divide(Vector2 left, float divisor);
+        public static float Dot(Vector2 value1, Vector2 value2);
+        public bool Equals(Vector2 other);
+        public override bool Equals(object obj);
+        public override int GetHashCode();
+        public float Length();
+        public float LengthSquared();
+        public static Vector2 Lerp(Vector2 value1, Vector2 value2, float amount);
+        public static Vector2 Max(Vector2 value1, Vector2 value2);
+        public static Vector2 Min(Vector2 value1, Vector2 value2);
+        public static Vector2 Multiply(Vector2 left, Vector2 right);
+        public static Vector2 Multiply(Vector2 left, float right);
+        public static Vector2 Multiply(float left, Vector2 right);
+        public static Vector2 Negate(Vector2 value);
+        public static Vector2 Normalize(Vector2 value);
+        public static Vector2 operator +(Vector2 left, Vector2 right);
+        public static Vector2 operator /(Vector2 left, Vector2 right);
+        public static Vector2 operator /(Vector2 value1, float value2);
+        public static bool operator ==(Vector2 left, Vector2 right);
+        public static bool operator !=(Vector2 left, Vector2 right);
+        public static Vector2 operator *(Vector2 left, Vector2 right);
+        public static Vector2 operator *(Vector2 left, float right);
+        public static Vector2 operator *(float left, Vector2 right);
+        public static Vector2 operator -(Vector2 left, Vector2 right);
+        public static Vector2 operator -(Vector2 value);
+        public static Vector2 Reflect(Vector2 vector, Vector2 normal);
+        public static Vector2 SquareRoot(Vector2 value);
+        public static Vector2 Subtract(Vector2 left, Vector2 right);
+        public override string ToString();
+        public string ToString(string format);
+        public string ToString(string format, IFormatProvider formatProvider);
+        public static Vector2 Transform(Vector2 position, Matrix3x2 matrix);
+        public static Vector2 Transform(Vector2 position, Matrix4x4 matrix);
+        public static Vector2 Transform(Vector2 value, Quaternion rotation);
+        public static Vector2 TransformNormal(Vector2 normal, Matrix3x2 matrix);
+        public static Vector2 TransformNormal(Vector2 normal, Matrix4x4 matrix);
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct Vector3 : IEquatable<Vector3>, IFormattable {
+        public float X;
+        public float Y;
+        public float Z;
+        public Vector3(Vector2 value, float z);
+        public Vector3(float value);
+        public Vector3(float x, float y, float z);
+        public static Vector3 One { get; }
+        public static Vector3 UnitX { get; }
+        public static Vector3 UnitY { get; }
+        public static Vector3 UnitZ { get; }
+        public static Vector3 Zero { get; }
+        public static Vector3 Abs(Vector3 value);
+        public static Vector3 Add(Vector3 left, Vector3 right);
+        public static Vector3 Clamp(Vector3 value1, Vector3 min, Vector3 max);
+        public void CopyTo(float[] array);
+        public void CopyTo(float[] array, int index);
+        public static Vector3 Cross(Vector3 vector1, Vector3 vector2);
+        public static float Distance(Vector3 value1, Vector3 value2);
+        public static float DistanceSquared(Vector3 value1, Vector3 value2);
+        public static Vector3 Divide(Vector3 left, Vector3 right);
+        public static Vector3 Divide(Vector3 left, float divisor);
+        public static float Dot(Vector3 vector1, Vector3 vector2);
+        public bool Equals(Vector3 other);
+        public override bool Equals(object obj);
+        public override int GetHashCode();
+        public float Length();
+        public float LengthSquared();
+        public static Vector3 Lerp(Vector3 value1, Vector3 value2, float amount);
+        public static Vector3 Max(Vector3 value1, Vector3 value2);
+        public static Vector3 Min(Vector3 value1, Vector3 value2);
+        public static Vector3 Multiply(Vector3 left, Vector3 right);
+        public static Vector3 Multiply(Vector3 left, float right);
+        public static Vector3 Multiply(float left, Vector3 right);
+        public static Vector3 Negate(Vector3 value);
+        public static Vector3 Normalize(Vector3 value);
+        public static Vector3 operator +(Vector3 left, Vector3 right);
+        public static Vector3 operator /(Vector3 left, Vector3 right);
+        public static Vector3 operator /(Vector3 value1, float value2);
+        public static bool operator ==(Vector3 left, Vector3 right);
+        public static bool operator !=(Vector3 left, Vector3 right);
+        public static Vector3 operator *(Vector3 left, Vector3 right);
+        public static Vector3 operator *(Vector3 left, float right);
+        public static Vector3 operator *(float left, Vector3 right);
+        public static Vector3 operator -(Vector3 left, Vector3 right);
+        public static Vector3 operator -(Vector3 value);
+        public static Vector3 Reflect(Vector3 vector, Vector3 normal);
+        public static Vector3 SquareRoot(Vector3 value);
+        public static Vector3 Subtract(Vector3 left, Vector3 right);
+        public override string ToString();
+        public string ToString(string format);
+        public string ToString(string format, IFormatProvider formatProvider);
+        public static Vector3 Transform(Vector3 position, Matrix4x4 matrix);
+        public static Vector3 Transform(Vector3 value, Quaternion rotation);
+        public static Vector3 TransformNormal(Vector3 normal, Matrix4x4 matrix);
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct Vector4 : IEquatable<Vector4>, IFormattable {
+        public float W;
+        public float X;
+        public float Y;
+        public float Z;
+        public Vector4(Vector2 value, float z, float w);
+        public Vector4(Vector3 value, float w);
+        public Vector4(float value);
+        public Vector4(float x, float y, float z, float w);
+        public static Vector4 One { get; }
+        public static Vector4 UnitW { get; }
+        public static Vector4 UnitX { get; }
+        public static Vector4 UnitY { get; }
+        public static Vector4 UnitZ { get; }
+        public static Vector4 Zero { get; }
+        public static Vector4 Abs(Vector4 value);
+        public static Vector4 Add(Vector4 left, Vector4 right);
+        public static Vector4 Clamp(Vector4 value1, Vector4 min, Vector4 max);
+        public void CopyTo(float[] array);
+        public void CopyTo(float[] array, int index);
+        public static float Distance(Vector4 value1, Vector4 value2);
+        public static float DistanceSquared(Vector4 value1, Vector4 value2);
+        public static Vector4 Divide(Vector4 left, Vector4 right);
+        public static Vector4 Divide(Vector4 left, float divisor);
+        public static float Dot(Vector4 vector1, Vector4 vector2);
+        public bool Equals(Vector4 other);
+        public override bool Equals(object obj);
+        public override int GetHashCode();
+        public float Length();
+        public float LengthSquared();
+        public static Vector4 Lerp(Vector4 value1, Vector4 value2, float amount);
+        public static Vector4 Max(Vector4 value1, Vector4 value2);
+        public static Vector4 Min(Vector4 value1, Vector4 value2);
+        public static Vector4 Multiply(Vector4 left, Vector4 right);
+        public static Vector4 Multiply(Vector4 left, float right);
+        public static Vector4 Multiply(float left, Vector4 right);
+        public static Vector4 Negate(Vector4 value);
+        public static Vector4 Normalize(Vector4 vector);
+        public static Vector4 operator +(Vector4 left, Vector4 right);
+        public static Vector4 operator /(Vector4 left, Vector4 right);
+        public static Vector4 operator /(Vector4 value1, float value2);
+        public static bool operator ==(Vector4 left, Vector4 right);
+        public static bool operator !=(Vector4 left, Vector4 right);
+        public static Vector4 operator *(Vector4 left, Vector4 right);
+        public static Vector4 operator *(Vector4 left, float right);
+        public static Vector4 operator *(float left, Vector4 right);
+        public static Vector4 operator -(Vector4 left, Vector4 right);
+        public static Vector4 operator -(Vector4 value);
+        public static Vector4 SquareRoot(Vector4 value);
+        public static Vector4 Subtract(Vector4 left, Vector4 right);
+        public override string ToString();
+        public string ToString(string format);
+        public string ToString(string format, IFormatProvider formatProvider);
+        public static Vector4 Transform(Vector2 position, Matrix4x4 matrix);
+        public static Vector4 Transform(Vector2 value, Quaternion rotation);
+        public static Vector4 Transform(Vector3 position, Matrix4x4 matrix);
+        public static Vector4 Transform(Vector3 value, Quaternion rotation);
+        public static Vector4 Transform(Vector4 vector, Matrix4x4 matrix);
+        public static Vector4 Transform(Vector4 value, Quaternion rotation);
+    }
+}
```

## System.Reflection

```c#
+namespace System.Reflection {
+    public sealed class AmbiguousMatchException : Exception {
+        public AmbiguousMatchException();
+        public AmbiguousMatchException(string message);
+        public AmbiguousMatchException(string message, Exception inner);
+    }
+    public abstract class Assembly : ICustomAttributeProvider {
+        protected Assembly();
+        public virtual string CodeBase { get; }
+        public virtual IEnumerable<CustomAttributeData> CustomAttributes { get; }
+        public abstract IEnumerable<TypeInfo> DefinedTypes { get; }
+        public virtual MethodInfo EntryPoint { get; }
+        public virtual IEnumerable<Type> ExportedTypes { get; }
+        public virtual string FullName { get; }
+        public virtual string ImageRuntimeVersion { get; }
+        public virtual bool IsDynamic { get; }
+        public virtual string Location { get; }
+        public virtual Module ManifestModule { get; }
+        public abstract IEnumerable<Module> Modules { get; }
+        public object CreateInstance(string typeName);
+        public object CreateInstance(string typeName, bool ignoreCase);
+        public static string CreateQualifiedName(string assemblyName, string typeName);
+        public override bool Equals(object o);
+        [MethodImpl(NoInlining)]public static Assembly GetCallingAssembly();
+        public virtual object[] GetCustomAttributes(bool inherit);
+        public virtual object[] GetCustomAttributes(Type attributeType, bool inherit);
+        public static Assembly GetEntryAssembly();
+        [MethodImpl(NoInlining)]public static Assembly GetExecutingAssembly();
+        public virtual Type[] GetExportedTypes();
+        public override int GetHashCode();
+        public virtual ManifestResourceInfo GetManifestResourceInfo(string resourceName);
+        public virtual string[] GetManifestResourceNames();
+        public virtual Stream GetManifestResourceStream(string name);
+        public virtual Stream GetManifestResourceStream(Type type, string name);
+        public Module[] GetModules();
+        public virtual AssemblyName GetName();
+        public virtual AssemblyName[] GetReferencedAssemblies();
+        public virtual Type GetType(string name);
+        public virtual Type GetType(string name, bool throwOnError);
+        public virtual Type GetType(string name, bool throwOnError, bool ignoreCase);
+        public virtual Type[] GetTypes();
+        public virtual bool IsDefined(Type attributeType, bool inherit);
+        [MethodImpl(NoInlining)]public static Assembly Load(byte[] rawAssembly);
+        [MethodImpl(NoInlining)]public static Assembly Load(byte[] rawAssembly, byte[] rawSymbolStore);
+        public static Assembly Load(AssemblyName assemblyRef);
+        [MethodImpl(NoInlining)]public static Assembly Load(string assemblyString);
+        object[] System.Reflection.ICustomAttributeProvider.GetCustomAttributes(bool inherit);
+        object[] System.Reflection.ICustomAttributeProvider.GetCustomAttributes(Type attributeType, bool inherit);
+        bool System.Reflection.ICustomAttributeProvider.IsDefined(Type attributeType, bool inherit);
+        public override string ToString();
+    }
+    public sealed class AssemblyAlgorithmIdAttribute : Attribute {
+        public AssemblyAlgorithmIdAttribute(AssemblyHashAlgorithm algorithmId);
+        public AssemblyAlgorithmIdAttribute(uint algorithmId);
+        public uint AlgorithmId { get; }
+    }
+    public sealed class AssemblyCompanyAttribute : Attribute {
+        public AssemblyCompanyAttribute(string company);
+        public string Company { get; }
+    }
+    public sealed class AssemblyConfigurationAttribute : Attribute {
+        public AssemblyConfigurationAttribute(string configuration);
+        public string Configuration { get; }
+    }
+    public enum AssemblyContentType {
+        Default = 0,
+        WindowsRuntime = 1,
+    }
+    public sealed class AssemblyCopyrightAttribute : Attribute {
+        public AssemblyCopyrightAttribute(string copyright);
+        public string Copyright { get; }
+    }
+    public sealed class AssemblyCultureAttribute : Attribute {
+        public AssemblyCultureAttribute(string culture);
+        public string Culture { get; }
+    }
+    public sealed class AssemblyDefaultAliasAttribute : Attribute {
+        public AssemblyDefaultAliasAttribute(string defaultAlias);
+        public string DefaultAlias { get; }
+    }
+    public sealed class AssemblyDelaySignAttribute : Attribute {
+        public AssemblyDelaySignAttribute(bool delaySign);
+        public bool DelaySign { get; }
+    }
+    public sealed class AssemblyDescriptionAttribute : Attribute {
+        public AssemblyDescriptionAttribute(string description);
+        public string Description { get; }
+    }
+    public static class AssemblyExtensions {
+        public static Type[] GetExportedTypes(this Assembly assembly);
+        public static Module[] GetModules(this Assembly assembly);
+        public static Type[] GetTypes(this Assembly assembly);
+    }
+    public sealed class AssemblyFileVersionAttribute : Attribute {
+        public AssemblyFileVersionAttribute(string version);
+        public string Version { get; }
+    }
+    public enum AssemblyFlags {
+        ContentTypeMask = 3584,
+        DisableJitCompileOptimizer = 16384,
+        EnableJitCompileTracking = 32768,
+        PublicKey = 1,
+        Retargetable = 256,
+        WindowsRuntime = 512,
+    }
+    public sealed class AssemblyFlagsAttribute : Attribute {
+        public AssemblyFlagsAttribute(AssemblyNameFlags assemblyFlags);
+        public int AssemblyFlags { get; }
+    }
+    public enum AssemblyHashAlgorithm {
+        MD5 = 32771,
+        None = 0,
+        Sha1 = 32772,
+        Sha256 = 32780,
+        Sha384 = 32781,
+        Sha512 = 32782,
+    }
+    public sealed class AssemblyInformationalVersionAttribute : Attribute {
+        public AssemblyInformationalVersionAttribute(string informationalVersion);
+        public string InformationalVersion { get; }
+    }
+    public sealed class AssemblyKeyFileAttribute : Attribute {
+        public AssemblyKeyFileAttribute(string keyFile);
+        public string KeyFile { get; }
+    }
+    public sealed class AssemblyKeyNameAttribute : Attribute {
+        public AssemblyKeyNameAttribute(string keyName);
+        public string KeyName { get; }
+    }
+    public sealed class AssemblyMetadataAttribute : Attribute {
+        public AssemblyMetadataAttribute(string key, string value);
+        public string Key { get; }
+        public string Value { get; }
+    }
+    public sealed class AssemblyName {
+        public AssemblyName();
+        public AssemblyName(string assemblyName);
+        public AssemblyContentType ContentType { get; set; }
+        public CultureInfo CultureInfo { get; set; }
+        public string CultureName { get; set; }
+        public AssemblyNameFlags Flags { get; set; }
+        public string FullName { get; }
+        public AssemblyHashAlgorithm HashAlgorithm { get; set; }
+        public string Name { get; set; }
+        public ProcessorArchitecture ProcessorArchitecture { get; set; }
+        public Version Version { get; set; }
+        public byte[] GetPublicKey();
+        public byte[] GetPublicKeyToken();
+        public void SetPublicKey(byte[] publicKey);
+        public void SetPublicKeyToken(byte[] publicKeyToken);
+        public override string ToString();
+    }
+    public enum AssemblyNameFlags {
+        EnableJITcompileOptimizer = 16384,
+        EnableJITcompileTracking = 32768,
+        None = 0,
+        PublicKey = 1,
+        Retargetable = 256,
+    }
+    public sealed class AssemblyProductAttribute : Attribute {
+        public AssemblyProductAttribute(string product);
+        public string Product { get; }
+    }
+    public sealed class AssemblySignatureKeyAttribute : Attribute {
+        public AssemblySignatureKeyAttribute(string publicKey, string countersignature);
+        public string Countersignature { get; }
+        public string PublicKey { get; }
+    }
+    public sealed class AssemblyTitleAttribute : Attribute {
+        public AssemblyTitleAttribute(string title);
+        public string Title { get; }
+    }
+    public sealed class AssemblyTrademarkAttribute : Attribute {
+        public AssemblyTrademarkAttribute(string trademark);
+        public string Trademark { get; }
+    }
+    public sealed class AssemblyVersionAttribute : Attribute {
+        public AssemblyVersionAttribute(string version);
+        public string Version { get; }
+    }
+    public abstract class Binder {
+        protected Binder();
+        public abstract FieldInfo BindToField(BindingFlags bindingAttr, FieldInfo[] match, object value, CultureInfo culture);
+        public abstract MethodBase BindToMethod(BindingFlags bindingAttr, MethodBase[] match, ref object[] args, ParameterModifier[] modifiers, CultureInfo culture, string[] names, out object state);
+        public abstract object ChangeType(object value, Type type, CultureInfo culture);
+        public abstract void ReorderArgumentArray(ref object[] args, object state);
+        public abstract MethodBase SelectMethod(BindingFlags bindingAttr, MethodBase[] match, Type[] types, ParameterModifier[] modifiers);
+        public abstract PropertyInfo SelectProperty(BindingFlags bindingAttr, PropertyInfo[] match, Type returnType, Type[] indexes, ParameterModifier[] modifiers);
+    }
+    public enum BindingFlags {
+        CreateInstance = 512,
+        DeclaredOnly = 2,
+        Default = 0,
+        ExactBinding = 65536,
+        FlattenHierarchy = 64,
+        GetField = 1024,
+        GetProperty = 4096,
+        IgnoreCase = 1,
+        IgnoreReturn = 16777216,
+        Instance = 4,
+        InvokeMethod = 256,
+        NonPublic = 32,
+        OptionalParamBinding = 262144,
+        Public = 16,
+        PutDispProperty = 16384,
+        PutRefDispProperty = 32768,
+        SetField = 2048,
+        SetProperty = 8192,
+        Static = 8,
+        SuppressChangeType = 131072,
+    }
+    public enum CallingConventions {
+        Any = 3,
+        ExplicitThis = 64,
+        HasThis = 32,
+        Standard = 1,
+        VarArgs = 2,
+    }
+    public abstract class ConstructorInfo : MethodBase {
+        public static readonly string ConstructorName;
+        public static readonly string TypeConstructorName;
+        protected ConstructorInfo();
+        public override MemberTypes MemberType { get; }
+        public override bool Equals(object obj);
+        public override int GetHashCode();
+        public virtual object Invoke(object[] parameters);
+        public abstract object Invoke(BindingFlags invokeAttr, Binder binder, object[] parameters, CultureInfo culture);
+    }
+    public class CustomAttributeData {
+        public virtual Type AttributeType { get; }
+        public virtual ConstructorInfo Constructor { get; }
+        public virtual IList<CustomAttributeTypedArgument> ConstructorArguments { get; }
+        public virtual IList<CustomAttributeNamedArgument> NamedArguments { get; }
+        public override bool Equals(object obj);
+        public static IList<CustomAttributeData> GetCustomAttributes(Assembly target);
+        public static IList<CustomAttributeData> GetCustomAttributes(MemberInfo target);
+        public static IList<CustomAttributeData> GetCustomAttributes(Module target);
+        public static IList<CustomAttributeData> GetCustomAttributes(ParameterInfo target);
+        public override int GetHashCode();
+        public override string ToString();
+    }
+    public static class CustomAttributeExtensions {
+        public static Attribute GetCustomAttribute(this Assembly element, Type attributeType);
+        public static Attribute GetCustomAttribute(this MemberInfo element, Type attributeType);
+        public static Attribute GetCustomAttribute(this MemberInfo element, Type attributeType, bool inherit);
+        public static Attribute GetCustomAttribute(this Module element, Type attributeType);
+        public static Attribute GetCustomAttribute(this ParameterInfo element, Type attributeType);
+        public static Attribute GetCustomAttribute(this ParameterInfo element, Type attributeType, bool inherit);
+        public static T GetCustomAttribute<T>(this Assembly element) where T : Attribute;
+        public static T GetCustomAttribute<T>(this MemberInfo element) where T : Attribute;
+        public static T GetCustomAttribute<T>(this MemberInfo element, bool inherit) where T : Attribute;
+        public static T GetCustomAttribute<T>(this Module element) where T : Attribute;
+        public static T GetCustomAttribute<T>(this ParameterInfo element) where T : Attribute;
+        public static T GetCustomAttribute<T>(this ParameterInfo element, bool inherit) where T : Attribute;
+        public static IEnumerable<Attribute> GetCustomAttributes(this Assembly element);
+        public static IEnumerable<Attribute> GetCustomAttributes(this Assembly element, Type attributeType);
+        public static IEnumerable<Attribute> GetCustomAttributes(this MemberInfo element);
+        public static IEnumerable<Attribute> GetCustomAttributes(this MemberInfo element, bool inherit);
+        public static IEnumerable<Attribute> GetCustomAttributes(this MemberInfo element, Type attributeType);
+        public static IEnumerable<Attribute> GetCustomAttributes(this MemberInfo element, Type attributeType, bool inherit);
+        public static IEnumerable<Attribute> GetCustomAttributes(this Module element);
+        public static IEnumerable<Attribute> GetCustomAttributes(this Module element, Type attributeType);
+        public static IEnumerable<Attribute> GetCustomAttributes(this ParameterInfo element);
+        public static IEnumerable<Attribute> GetCustomAttributes(this ParameterInfo element, bool inherit);
+        public static IEnumerable<Attribute> GetCustomAttributes(this ParameterInfo element, Type attributeType);
+        public static IEnumerable<Attribute> GetCustomAttributes(this ParameterInfo element, Type attributeType, bool inherit);
+        public static IEnumerable<T> GetCustomAttributes<T>(this Assembly element) where T : Attribute;
+        public static IEnumerable<T> GetCustomAttributes<T>(this MemberInfo element) where T : Attribute;
+        public static IEnumerable<T> GetCustomAttributes<T>(this MemberInfo element, bool inherit) where T : Attribute;
+        public static IEnumerable<T> GetCustomAttributes<T>(this Module element) where T : Attribute;
+        public static IEnumerable<T> GetCustomAttributes<T>(this ParameterInfo element) where T : Attribute;
+        public static IEnumerable<T> GetCustomAttributes<T>(this ParameterInfo element, bool inherit) where T : Attribute;
+        public static bool IsDefined(this Assembly element, Type attributeType);
+        public static bool IsDefined(this MemberInfo element, Type attributeType);
+        public static bool IsDefined(this MemberInfo element, Type attributeType, bool inherit);
+        public static bool IsDefined(this Module element, Type attributeType);
+        public static bool IsDefined(this ParameterInfo element, Type attributeType);
+        public static bool IsDefined(this ParameterInfo element, Type attributeType, bool inherit);
+    }
+    public class CustomAttributeFormatException : FormatException {
+        public CustomAttributeFormatException();
+        public CustomAttributeFormatException(string message);
+        public CustomAttributeFormatException(string message, Exception inner);
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct CustomAttributeNamedArgument {
+        public bool IsField { get; }
+        public string MemberName { get; }
+        public CustomAttributeTypedArgument TypedValue { get; }
+        public override bool Equals(object obj);
+        public override int GetHashCode();
+        public static bool operator ==(CustomAttributeNamedArgument left, CustomAttributeNamedArgument right);
+        public static bool operator !=(CustomAttributeNamedArgument left, CustomAttributeNamedArgument right);
+        public override string ToString();
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct CustomAttributeTypedArgument {
+        public Type ArgumentType { get; }
+        public object Value { get; }
+        public override bool Equals(object obj);
+        public override int GetHashCode();
+        public static bool operator ==(CustomAttributeTypedArgument left, CustomAttributeTypedArgument right);
+        public static bool operator !=(CustomAttributeTypedArgument left, CustomAttributeTypedArgument right);
+        public override string ToString();
+    }
+    public enum DeclarativeSecurityAction : short {
+        Assert = (short)3,
+        Demand = (short)2,
+        Deny = (short)4,
+        InheritanceDemand = (short)7,
+        LinkDemand = (short)6,
+        None = (short)0,
+        PermitOnly = (short)5,
+        RequestMinimum = (short)8,
+        RequestOptional = (short)9,
+        RequestRefuse = (short)10,
+    }
+    public sealed class DefaultMemberAttribute : Attribute {
+        public DefaultMemberAttribute(string memberName);
+        public string MemberName { get; }
+    }
+    public abstract class DispatchProxy {
+        protected DispatchProxy();
+        public static T Create<T, TProxy>() where TProxy : DispatchProxy;
+        protected abstract object Invoke(MethodInfo targetMethod, object[] args);
+    }
+    public enum EventAttributes {
+        None = 0,
+        ReservedMask = 1024,
+        RTSpecialName = 1024,
+        SpecialName = 512,
+    }
+    public abstract class EventInfo : MemberInfo {
+        protected EventInfo();
+        public virtual MethodInfo AddMethod { get; }
+        public abstract EventAttributes Attributes { get; }
+        public virtual Type EventHandlerType { get; }
+        public virtual bool IsMulticast { get; }
+        public bool IsSpecialName { get; }
+        public override MemberTypes MemberType { get; }
+        public virtual MethodInfo RaiseMethod { get; }
+        public virtual MethodInfo RemoveMethod { get; }
+        public virtual void AddEventHandler(object target, Delegate handler);
+        public override bool Equals(object obj);
+        public MethodInfo GetAddMethod();
+        public abstract MethodInfo GetAddMethod(bool nonPublic);
+        public override int GetHashCode();
+        public MethodInfo GetRaiseMethod();
+        public abstract MethodInfo GetRaiseMethod(bool nonPublic);
+        public MethodInfo GetRemoveMethod();
+        public abstract MethodInfo GetRemoveMethod(bool nonPublic);
+        public virtual void RemoveEventHandler(object target, Delegate handler);
+    }
+    public static class EventInfoExtensions {
+        public static MethodInfo GetAddMethod(this EventInfo eventInfo);
+        public static MethodInfo GetAddMethod(this EventInfo eventInfo, bool nonPublic);
+        public static MethodInfo GetRaiseMethod(this EventInfo eventInfo);
+        public static MethodInfo GetRaiseMethod(this EventInfo eventInfo, bool nonPublic);
+        public static MethodInfo GetRemoveMethod(this EventInfo eventInfo);
+        public static MethodInfo GetRemoveMethod(this EventInfo eventInfo, bool nonPublic);
+    }
+    public enum FieldAttributes {
+        Assembly = 3,
+        FamANDAssem = 2,
+        Family = 4,
+        FamORAssem = 5,
+        FieldAccessMask = 7,
+        HasDefault = 32768,
+        HasFieldMarshal = 4096,
+        HasFieldRVA = 256,
+        InitOnly = 32,
+        Literal = 64,
+        NotSerialized = 128,
+        PinvokeImpl = 8192,
+        Private = 1,
+        PrivateScope = 0,
+        Public = 6,
+        ReservedMask = 38144,
+        RTSpecialName = 1024,
+        SpecialName = 512,
+        Static = 16,
+    }
+    public abstract class FieldInfo : MemberInfo {
+        protected FieldInfo();
+        public abstract FieldAttributes Attributes { get; }
+        public abstract RuntimeFieldHandle FieldHandle { get; }
+        public abstract Type FieldType { get; }
+        public bool IsAssembly { get; }
+        public bool IsFamily { get; }
+        public bool IsFamilyAndAssembly { get; }
+        public bool IsFamilyOrAssembly { get; }
+        public bool IsInitOnly { get; }
+        public bool IsLiteral { get; }
+        public bool IsNotSerialized { get; }
+        public bool IsPinvokeImpl { get; }
+        public bool IsPrivate { get; }
+        public bool IsPublic { get; }
+        public bool IsSpecialName { get; }
+        public bool IsStatic { get; }
+        public override MemberTypes MemberType { get; }
+        public override bool Equals(object obj);
+        public static FieldInfo GetFieldFromHandle(RuntimeFieldHandle handle);
+        public static FieldInfo GetFieldFromHandle(RuntimeFieldHandle handle, RuntimeTypeHandle declaringType);
+        public override int GetHashCode();
+        public virtual Type[] GetOptionalCustomModifiers();
+        public virtual object GetRawConstantValue();
+        public virtual Type[] GetRequiredCustomModifiers();
+        public abstract object GetValue(object obj);
+        public virtual void SetValue(object obj, object value);
+        public abstract void SetValue(object obj, object value, BindingFlags invokeAttr, Binder binder, CultureInfo culture);
+    }
+    public enum GenericParameterAttributes {
+        Contravariant = 2,
+        Covariant = 1,
+        DefaultConstructorConstraint = 16,
+        None = 0,
+        NotNullableValueTypeConstraint = 8,
+        ReferenceTypeConstraint = 4,
+        SpecialConstraintMask = 28,
+        VarianceMask = 3,
+    }
+    public interface ICustomAttributeProvider {
+        object[] GetCustomAttributes(bool inherit);
+        object[] GetCustomAttributes(Type attributeType, bool inherit);
+        bool IsDefined(Type attributeType, bool inherit);
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct InterfaceMapping {
+        public MethodInfo[] InterfaceMethods;
+        public MethodInfo[] TargetMethods;
+        public Type InterfaceType;
+        public Type TargetType;
+    }
+    public static class IntrospectionExtensions {
+        public static TypeInfo GetTypeInfo(this Type type);
+    }
+    public class InvalidFilterCriteriaException : Exception {
+        public InvalidFilterCriteriaException();
+        public InvalidFilterCriteriaException(string message);
+        public InvalidFilterCriteriaException(string message, Exception inner);
+    }
+    public interface IReflect {
+        Type UnderlyingSystemType { get; }
+        FieldInfo GetField(string name, BindingFlags bindingAttr);
+        FieldInfo[] GetFields(BindingFlags bindingAttr);
+        MemberInfo[] GetMember(string name, BindingFlags bindingAttr);
+        MemberInfo[] GetMembers(BindingFlags bindingAttr);
+        MethodInfo GetMethod(string name, BindingFlags bindingAttr);
+        MethodInfo GetMethod(string name, BindingFlags bindingAttr, Binder binder, Type[] types, ParameterModifier[] modifiers);
+        MethodInfo[] GetMethods(BindingFlags bindingAttr);
+        PropertyInfo[] GetProperties(BindingFlags bindingAttr);
+        PropertyInfo GetProperty(string name, BindingFlags bindingAttr);
+        PropertyInfo GetProperty(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers);
+        object InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, object[] args, ParameterModifier[] modifiers, CultureInfo culture, string[] namedParameters);
+    }
+    public interface IReflectableType {
+        TypeInfo GetTypeInfo();
+    }
+    public class LocalVariableInfo {
+        protected LocalVariableInfo();
+        public virtual bool IsPinned { get; }
+        public virtual int LocalIndex { get; }
+        public virtual Type LocalType { get; }
+        public override string ToString();
+    }
+    public enum ManifestResourceAttributes {
+        Private = 2,
+        Public = 1,
+        VisibilityMask = 7,
+    }
+    public class ManifestResourceInfo {
+        public ManifestResourceInfo(Assembly containingAssembly, string containingFileName, ResourceLocation resourceLocation);
+        public virtual string FileName { get; }
+        public virtual Assembly ReferencedAssembly { get; }
+        public virtual ResourceLocation ResourceLocation { get; }
+    }
+    public delegate bool MemberFilter(MemberInfo m, object filterCriteria);
+    public abstract class MemberInfo : ICustomAttributeProvider {
+        protected MemberInfo();
+        public virtual IEnumerable<CustomAttributeData> CustomAttributes { get; }
+        public abstract Type DeclaringType { get; }
+        public abstract MemberTypes MemberType { get; }
+        public virtual int MetadataToken { get; }
+        public virtual Module Module { get; }
+        public abstract string Name { get; }
+        public abstract Type ReflectedType { get; }
+        public override bool Equals(object obj);
+        public abstract object[] GetCustomAttributes(bool inherit);
+        public abstract object[] GetCustomAttributes(Type attributeType, bool inherit);
+        public override int GetHashCode();
+        public abstract bool IsDefined(Type attributeType, bool inherit);
+        object[] System.Reflection.ICustomAttributeProvider.GetCustomAttributes(bool inherit);
+        object[] System.Reflection.ICustomAttributeProvider.GetCustomAttributes(Type attributeType, bool inherit);
+        bool System.Reflection.ICustomAttributeProvider.IsDefined(Type attributeType, bool inherit);
+    }
+    public static class MemberInfoExtensions {
+        public static int GetMetadataToken(this MemberInfo member);
+        public static bool HasMetadataToken(this MemberInfo member);
+    }
+    public enum MemberTypes {
+        All = 191,
+        Constructor = 1,
+        Custom = 64,
+        Event = 2,
+        Field = 4,
+        Method = 8,
+        NestedType = 128,
+        Property = 16,
+        TypeInfo = 32,
+    }
+    public enum MethodAttributes {
+        Abstract = 1024,
+        Assembly = 3,
+        CheckAccessOnOverride = 512,
+        FamANDAssem = 2,
+        Family = 4,
+        FamORAssem = 5,
+        Final = 32,
+        HasSecurity = 16384,
+        HideBySig = 128,
+        MemberAccessMask = 7,
+        NewSlot = 256,
+        PinvokeImpl = 8192,
+        Private = 1,
+        PrivateScope = 0,
+        Public = 6,
+        RequireSecObject = 32768,
+        ReservedMask = 53248,
+        ReuseSlot = 0,
+        RTSpecialName = 4096,
+        SpecialName = 2048,
+        Static = 16,
+        UnmanagedExport = 8,
+        Virtual = 64,
+        VtableLayoutMask = 256,
+    }
+    public abstract class MethodBase : MemberInfo {
+        protected MethodBase();
+        public abstract MethodAttributes Attributes { get; }
+        public virtual CallingConventions CallingConvention { get; }
+        public virtual bool ContainsGenericParameters { get; }
+        public bool IsAbstract { get; }
+        public bool IsAssembly { get; }
+        public bool IsConstructor { get; }
+        public bool IsFamily { get; }
+        public bool IsFamilyAndAssembly { get; }
+        public bool IsFamilyOrAssembly { get; }
+        public bool IsFinal { get; }
+        public virtual bool IsGenericMethod { get; }
+        public virtual bool IsGenericMethodDefinition { get; }
+        public bool IsHideBySig { get; }
+        public bool IsPrivate { get; }
+        public bool IsPublic { get; }
+        public bool IsSpecialName { get; }
+        public bool IsStatic { get; }
+        public bool IsVirtual { get; }
+        public abstract RuntimeMethodHandle MethodHandle { get; }
+        public abstract MethodImplAttributes MethodImplementationFlags { get; }
+        public override bool Equals(object obj);
+        [MethodImpl(NoInlining)]public static MethodBase GetCurrentMethod();
+        public virtual Type[] GetGenericArguments();
+        public override int GetHashCode();
+        public static MethodBase GetMethodFromHandle(RuntimeMethodHandle handle);
+        public static MethodBase GetMethodFromHandle(RuntimeMethodHandle handle, RuntimeTypeHandle declaringType);
+        public abstract MethodImplAttributes GetMethodImplementationFlags();
+        public abstract ParameterInfo[] GetParameters();
+        public virtual object Invoke(object obj, object[] parameters);
+        public abstract object Invoke(object obj, BindingFlags invokeAttr, Binder binder, object[] parameters, CultureInfo culture);
+    }
+    public enum MethodImplAttributes {
+        AggressiveInlining = 256,
+        CodeTypeMask = 3,
+        ForwardRef = 16,
+        IL = 0,
+        InternalCall = 4096,
+        Managed = 0,
+        ManagedMask = 4,
+        MaxMethodImplVal = 65535,
+        Native = 1,
+        NoInlining = 8,
+        NoOptimization = 64,
+        OPTIL = 2,
+        PreserveSig = 128,
+        Runtime = 3,
+        Synchronized = 32,
+        Unmanaged = 4,
+    }
+    public enum MethodImportAttributes : short {
+        BestFitMappingDisable = (short)32,
+        BestFitMappingEnable = (short)16,
+        BestFitMappingMask = (short)48,
+        CallingConventionCDecl = (short)512,
+        CallingConventionFastCall = (short)1280,
+        CallingConventionMask = (short)1792,
+        CallingConventionStdCall = (short)768,
+        CallingConventionThisCall = (short)1024,
+        CallingConventionWinApi = (short)256,
+        CharSetAnsi = (short)2,
+        CharSetAuto = (short)6,
+        CharSetMask = (short)6,
+        CharSetUnicode = (short)4,
+        ExactSpelling = (short)1,
+        None = (short)0,
+        SetLastError = (short)64,
+        ThrowOnUnmappableCharDisable = (short)8192,
+        ThrowOnUnmappableCharEnable = (short)4096,
+        ThrowOnUnmappableCharMask = (short)12288,
+    }
+    public abstract class MethodInfo : MethodBase {
+        protected MethodInfo();
+        public override MemberTypes MemberType { get; }
+        public virtual ParameterInfo ReturnParameter { get; }
+        public virtual Type ReturnType { get; }
+        public abstract ICustomAttributeProvider ReturnTypeCustomAttributes { get; }
+        public virtual Delegate CreateDelegate(Type delegateType);
+        public virtual Delegate CreateDelegate(Type delegateType, object target);
+        public override bool Equals(object obj);
+        public abstract MethodInfo GetBaseDefinition();
+        public override Type[] GetGenericArguments();
+        public virtual MethodInfo GetGenericMethodDefinition();
+        public override int GetHashCode();
+        public virtual MethodInfo MakeGenericMethod(params Type[] typeArguments);
+    }
+    public static class MethodInfoExtensions {
+        public static MethodInfo GetBaseDefinition(this MethodInfo method);
+    }
+    public enum MethodSemanticsAttributes {
+        Adder = 8,
+        Getter = 2,
+        Other = 4,
+        Raiser = 32,
+        Remover = 16,
+        Setter = 1,
+    }
+    public sealed class Missing {
+        public static readonly Missing Value;
+    }
+    public abstract class Module : ICustomAttributeProvider {
+        public static readonly TypeFilter FilterTypeName;
+        public static readonly TypeFilter FilterTypeNameIgnoreCase;
+        protected Module();
+        public virtual Assembly Assembly { get; }
+        public virtual IEnumerable<CustomAttributeData> CustomAttributes { get; }
+        public virtual string FullyQualifiedName { get; }
+        public virtual int MetadataToken { get; }
+        public virtual Guid ModuleVersionId { get; }
+        public virtual string Name { get; }
+        public virtual string ScopeName { get; }
+        public override bool Equals(object o);
+        public virtual Type[] FindTypes(TypeFilter filter, object filterCriteria);
+        public virtual object[] GetCustomAttributes(bool inherit);
+        public virtual object[] GetCustomAttributes(Type attributeType, bool inherit);
+        public FieldInfo GetField(string name);
+        public virtual FieldInfo GetField(string name, BindingFlags bindingAttr);
+        public FieldInfo[] GetFields();
+        public virtual FieldInfo[] GetFields(BindingFlags bindingFlags);
+        public override int GetHashCode();
+        public MethodInfo GetMethod(string name);
+        public MethodInfo GetMethod(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
+        public MethodInfo GetMethod(string name, Type[] types);
+        protected virtual MethodInfo GetMethodImpl(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
+        public MethodInfo[] GetMethods();
+        public virtual MethodInfo[] GetMethods(BindingFlags bindingFlags);
+        public virtual Type GetType(string className);
+        public virtual Type GetType(string className, bool ignoreCase);
+        public virtual Type GetType(string className, bool throwOnError, bool ignoreCase);
+        public virtual Type[] GetTypes();
+        public virtual bool IsDefined(Type attributeType, bool inherit);
+        public FieldInfo ResolveField(int metadataToken);
+        public virtual FieldInfo ResolveField(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);
+        public MethodBase ResolveMethod(int metadataToken);
+        public virtual MethodBase ResolveMethod(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);
+        public virtual string ResolveString(int metadataToken);
+        public Type ResolveType(int metadataToken);
+        public virtual Type ResolveType(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);
+        object[] System.Reflection.ICustomAttributeProvider.GetCustomAttributes(bool inherit);
+        object[] System.Reflection.ICustomAttributeProvider.GetCustomAttributes(Type attributeType, bool inherit);
+        bool System.Reflection.ICustomAttributeProvider.IsDefined(Type attributeType, bool inherit);
+        public override string ToString();
+    }
+    public static class ModuleExtensions {
+        public static Guid GetModuleVersionId(this Module module);
+        public static bool HasModuleVersionId(this Module module);
+    }
+    public enum ParameterAttributes {
+        HasDefault = 4096,
+        HasFieldMarshal = 8192,
+        In = 1,
+        Lcid = 4,
+        None = 0,
+        Optional = 16,
+        Out = 2,
+        Reserved3 = 16384,
+        Reserved4 = 32768,
+        ReservedMask = 61440,
+        Retval = 8,
+    }
+    public class ParameterInfo : ICustomAttributeProvider {
+        protected ParameterInfo();
+        public virtual ParameterAttributes Attributes { get; }
+        public virtual IEnumerable<CustomAttributeData> CustomAttributes { get; }
+        public virtual object DefaultValue { get; }
+        public virtual bool HasDefaultValue { get; }
+        public bool IsIn { get; }
+        public bool IsOptional { get; }
+        public bool IsOut { get; }
+        public bool IsRetval { get; }
+        public virtual MemberInfo Member { get; }
+        public virtual int MetadataToken { get; }
+        public virtual string Name { get; }
+        public virtual Type ParameterType { get; }
+        public virtual int Position { get; }
+        public virtual object RawDefaultValue { get; }
+        public virtual object[] GetCustomAttributes(bool inherit);
+        public virtual object[] GetCustomAttributes(Type attributeType, bool inherit);
+        public virtual Type[] GetOptionalCustomModifiers();
+        public virtual Type[] GetRequiredCustomModifiers();
+        public virtual bool IsDefined(Type attributeType, bool inherit);
+        object[] System.Reflection.ICustomAttributeProvider.GetCustomAttributes(bool inherit);
+        object[] System.Reflection.ICustomAttributeProvider.GetCustomAttributes(Type attributeType, bool inherit);
+        bool System.Reflection.ICustomAttributeProvider.IsDefined(Type attributeType, bool inherit);
+        public override string ToString();
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct ParameterModifier {
+        public ParameterModifier(int parameterCount);
+        public bool this[int index] { get; set; }
+    }
+    public enum ProcessorArchitecture {
+        Amd64 = 4,
+        Arm = 5,
+        IA64 = 3,
+        MSIL = 1,
+        None = 0,
+        X86 = 2,
+    }
+    public enum PropertyAttributes {
+        HasDefault = 4096,
+        None = 0,
+        Reserved2 = 8192,
+        Reserved3 = 16384,
+        Reserved4 = 32768,
+        ReservedMask = 62464,
+        RTSpecialName = 1024,
+        SpecialName = 512,
+    }
+    public abstract class PropertyInfo : MemberInfo {
+        protected PropertyInfo();
+        public abstract PropertyAttributes Attributes { get; }
+        public abstract bool CanRead { get; }
+        public abstract bool CanWrite { get; }
+        public virtual MethodInfo GetMethod { get; }
+        public bool IsSpecialName { get; }
+        public override MemberTypes MemberType { get; }
+        public abstract Type PropertyType { get; }
+        public virtual MethodInfo SetMethod { get; }
+        public override bool Equals(object obj);
+        public MethodInfo[] GetAccessors();
+        public abstract MethodInfo[] GetAccessors(bool nonPublic);
+        public virtual object GetConstantValue();
+        public MethodInfo GetGetMethod();
+        public abstract MethodInfo GetGetMethod(bool nonPublic);
+        public override int GetHashCode();
+        public abstract ParameterInfo[] GetIndexParameters();
+        public virtual Type[] GetOptionalCustomModifiers();
+        public virtual object GetRawConstantValue();
+        public virtual Type[] GetRequiredCustomModifiers();
+        public MethodInfo GetSetMethod();
+        public abstract MethodInfo GetSetMethod(bool nonPublic);
+        public object GetValue(object obj);
+        public virtual object GetValue(object obj, object[] index);
+        public abstract object GetValue(object obj, BindingFlags invokeAttr, Binder binder, object[] index, CultureInfo culture);
+        public void SetValue(object obj, object value);
+        public virtual void SetValue(object obj, object value, object[] index);
+        public abstract void SetValue(object obj, object value, BindingFlags invokeAttr, Binder binder, object[] index, CultureInfo culture);
+    }
+    public static class PropertyInfoExtensions {
+        public static MethodInfo[] GetAccessors(this PropertyInfo property);
+        public static MethodInfo[] GetAccessors(this PropertyInfo property, bool nonPublic);
+        public static MethodInfo GetGetMethod(this PropertyInfo property);
+        public static MethodInfo GetGetMethod(this PropertyInfo property, bool nonPublic);
+        public static MethodInfo GetSetMethod(this PropertyInfo property);
+        public static MethodInfo GetSetMethod(this PropertyInfo property, bool nonPublic);
+    }
+    public abstract class ReflectionContext {
+        protected ReflectionContext();
+        public virtual TypeInfo GetTypeForObject(object value);
+        public abstract Assembly MapAssembly(Assembly assembly);
+        public abstract TypeInfo MapType(TypeInfo type);
+    }
+    public sealed class ReflectionTypeLoadException : Exception {
+        public ReflectionTypeLoadException(Type[] classes, Exception[] exceptions);
+        public ReflectionTypeLoadException(Type[] classes, Exception[] exceptions, string message);
+        public Exception[] LoaderExceptions { get; }
+        public Type[] Types { get; }
+    }
+    public enum ResourceAttributes {
+        Private = 2,
+        Public = 1,
+    }
+    public enum ResourceLocation {
+        ContainedInAnotherAssembly = 2,
+        ContainedInManifestFile = 4,
+        Embedded = 1,
+    }
+    public static class RuntimeReflectionExtensions {
+        public static MethodInfo GetMethodInfo(this Delegate del);
+        public static MethodInfo GetRuntimeBaseDefinition(this MethodInfo method);
+        public static EventInfo GetRuntimeEvent(this Type type, string name);
+        public static IEnumerable<EventInfo> GetRuntimeEvents(this Type type);
+        public static FieldInfo GetRuntimeField(this Type type, string name);
+        public static IEnumerable<FieldInfo> GetRuntimeFields(this Type type);
+        public static InterfaceMapping GetRuntimeInterfaceMap(this TypeInfo typeInfo, Type interfaceType);
+        public static MethodInfo GetRuntimeMethod(this Type type, string name, Type[] parameters);
+        public static IEnumerable<MethodInfo> GetRuntimeMethods(this Type type);
+        public static IEnumerable<PropertyInfo> GetRuntimeProperties(this Type type);
+        public static PropertyInfo GetRuntimeProperty(this Type type, string name);
+    }
+    public class TargetException : Exception {
+        public TargetException();
+        public TargetException(string message);
+        public TargetException(string message, Exception inner);
+    }
+    public sealed class TargetInvocationException : Exception {
+        public TargetInvocationException(Exception inner);
+        public TargetInvocationException(string message, Exception inner);
+    }
+    public sealed class TargetParameterCountException : Exception {
+        public TargetParameterCountException();
+        public TargetParameterCountException(string message);
+        public TargetParameterCountException(string message, Exception inner);
+    }
+    public enum TypeAttributes {
+        Abstract = 128,
+        AnsiClass = 0,
+        AutoClass = 131072,
+        AutoLayout = 0,
+        BeforeFieldInit = 1048576,
+        Class = 0,
+        ClassSemanticsMask = 32,
+        CustomFormatClass = 196608,
+        CustomFormatMask = 12582912,
+        ExplicitLayout = 16,
+        HasSecurity = 262144,
+        Import = 4096,
+        Interface = 32,
+        LayoutMask = 24,
+        NestedAssembly = 5,
+        NestedFamANDAssem = 6,
+        NestedFamily = 4,
+        NestedFamORAssem = 7,
+        NestedPrivate = 3,
+        NestedPublic = 2,
+        NotPublic = 0,
+        Public = 1,
+        ReservedMask = 264192,
+        RTSpecialName = 2048,
+        Sealed = 256,
+        SequentialLayout = 8,
+        Serializable = 8192,
+        SpecialName = 1024,
+        StringFormatMask = 196608,
+        UnicodeClass = 65536,
+        VisibilityMask = 7,
+        WindowsRuntime = 16384,
+    }
+    public static class TypeExtensions {
+        public static ConstructorInfo GetConstructor(this Type type, Type[] types);
+        public static ConstructorInfo[] GetConstructors(this Type type);
+        public static ConstructorInfo[] GetConstructors(this Type type, BindingFlags bindingAttr);
+        public static MemberInfo[] GetDefaultMembers(this Type type);
+        public static EventInfo GetEvent(this Type type, string name);
+        public static EventInfo GetEvent(this Type type, string name, BindingFlags bindingAttr);
+        public static EventInfo[] GetEvents(this Type type);
+        public static EventInfo[] GetEvents(this Type type, BindingFlags bindingAttr);
+        public static FieldInfo GetField(this Type type, string name);
+        public static FieldInfo GetField(this Type type, string name, BindingFlags bindingAttr);
+        public static FieldInfo[] GetFields(this Type type);
+        public static FieldInfo[] GetFields(this Type type, BindingFlags bindingAttr);
+        public static Type[] GetGenericArguments(this Type type);
+        public static Type[] GetInterfaces(this Type type);
+        public static MemberInfo[] GetMember(this Type type, string name);
+        public static MemberInfo[] GetMember(this Type type, string name, BindingFlags bindingAttr);
+        public static MemberInfo[] GetMembers(this Type type);
+        public static MemberInfo[] GetMembers(this Type type, BindingFlags bindingAttr);
+        public static MethodInfo GetMethod(this Type type, string name);
+        public static MethodInfo GetMethod(this Type type, string name, BindingFlags bindingAttr);
+        public static MethodInfo GetMethod(this Type type, string name, Type[] types);
+        public static MethodInfo[] GetMethods(this Type type);
+        public static MethodInfo[] GetMethods(this Type type, BindingFlags bindingAttr);
+        public static Type GetNestedType(this Type type, string name, BindingFlags bindingAttr);
+        public static Type[] GetNestedTypes(this Type type, BindingFlags bindingAttr);
+        public static PropertyInfo[] GetProperties(this Type type);
+        public static PropertyInfo[] GetProperties(this Type type, BindingFlags bindingAttr);
+        public static PropertyInfo GetProperty(this Type type, string name);
+        public static PropertyInfo GetProperty(this Type type, string name, BindingFlags bindingAttr);
+        public static PropertyInfo GetProperty(this Type type, string name, Type returnType);
+        public static PropertyInfo GetProperty(this Type type, string name, Type returnType, Type[] types);
+        public static bool IsAssignableFrom(this Type type, Type c);
+        public static bool IsInstanceOfType(this Type type, object o);
+    }
+    public delegate bool TypeFilter(Type m, object filterCriteria);
+    public abstract class TypeInfo : MemberInfo, IReflectableType {
+        public abstract Assembly Assembly { get; }
+        public abstract string AssemblyQualifiedName { get; }
+        public abstract TypeAttributes Attributes { get; }
+        public abstract Type BaseType { get; }
+        public abstract bool ContainsGenericParameters { get; }
+        public virtual IEnumerable<ConstructorInfo> DeclaredConstructors { get; }
+        public virtual IEnumerable<EventInfo> DeclaredEvents { get; }
+        public virtual IEnumerable<FieldInfo> DeclaredFields { get; }
+        public virtual IEnumerable<MemberInfo> DeclaredMembers { get; }
+        public virtual IEnumerable<MethodInfo> DeclaredMethods { get; }
+        public virtual IEnumerable<TypeInfo> DeclaredNestedTypes { get; }
+        public virtual IEnumerable<PropertyInfo> DeclaredProperties { get; }
+        public abstract MethodBase DeclaringMethod { get; }
+        public abstract string FullName { get; }
+        public abstract GenericParameterAttributes GenericParameterAttributes { get; }
+        public abstract int GenericParameterPosition { get; }
+        public abstract Type[] GenericTypeArguments { get; }
+        public virtual Type[] GenericTypeParameters { get; }
+        public abstract Guid GUID { get; }
+        public bool HasElementType { get; }
+        public virtual IEnumerable<Type> ImplementedInterfaces { get; }
+        public bool IsAbstract { get; }
+        public bool IsAnsiClass { get; }
+        public bool IsArray { get; }
+        public bool IsAutoClass { get; }
+        public bool IsAutoLayout { get; }
+        public bool IsByRef { get; }
+        public bool IsClass { get; }
+        public virtual bool IsCOMObject { get; }
+        public abstract bool IsEnum { get; }
+        public bool IsExplicitLayout { get; }
+        public abstract bool IsGenericParameter { get; }
+        public abstract bool IsGenericType { get; }
+        public abstract bool IsGenericTypeDefinition { get; }
+        public bool IsImport { get; }
+        public bool IsInterface { get; }
+        public bool IsLayoutSequential { get; }
+        public bool IsMarshalByRef { get; }
+        public bool IsNested { get; }
+        public bool IsNestedAssembly { get; }
+        public bool IsNestedFamANDAssem { get; }
+        public bool IsNestedFamily { get; }
+        public bool IsNestedFamORAssem { get; }
+        public bool IsNestedPrivate { get; }
+        public bool IsNestedPublic { get; }
+        public bool IsNotPublic { get; }
+        public bool IsPointer { get; }
+        public virtual bool IsPrimitive { get; }
+        public bool IsPublic { get; }
+        public bool IsSealed { get; }
+        public abstract bool IsSerializable { get; }
+        public bool IsSpecialName { get; }
+        public bool IsUnicodeClass { get; }
+        public virtual bool IsValueType { get; }
+        public bool IsVisible { get; }
+        public override MemberTypes MemberType { get; }
+        public abstract string Namespace { get; }
+        public virtual StructLayoutAttribute StructLayoutAttribute { get; }
+        public ConstructorInfo TypeInitializer { get; }
+        public virtual Type UnderlyingSystemType { get; }
+        public virtual Type AsType();
+        public virtual Type[] FindInterfaces(TypeFilter filter, object filterCriteria);
+        public virtual MemberInfo[] FindMembers(MemberTypes memberType, BindingFlags bindingAttr, MemberFilter filter, object filterCriteria);
+        public abstract int GetArrayRank();
+        public ConstructorInfo GetConstructor(Type[] types);
+        public ConstructorInfo[] GetConstructors();
+        public virtual ConstructorInfo[] GetConstructors(BindingFlags bindingAttr);
+        public virtual EventInfo GetDeclaredEvent(string name);
+        public virtual FieldInfo GetDeclaredField(string name);
+        public virtual MethodInfo GetDeclaredMethod(string name);
+        public virtual IEnumerable<MethodInfo> GetDeclaredMethods(string name);
+        public virtual TypeInfo GetDeclaredNestedType(string name);
+        public virtual PropertyInfo GetDeclaredProperty(string name);
+        public virtual MemberInfo[] GetDefaultMembers();
+        public abstract Type GetElementType();
+        public virtual string GetEnumName(object value);
+        public virtual string[] GetEnumNames();
+        public virtual Type GetEnumUnderlyingType();
+        public virtual Array GetEnumValues();
+        public EventInfo GetEvent(string name);
+        public virtual EventInfo GetEvent(string name, BindingFlags bindingAttr);
+        public virtual EventInfo[] GetEvents();
+        public virtual EventInfo[] GetEvents(BindingFlags bindingAttr);
+        public FieldInfo GetField(string name);
+        public virtual FieldInfo GetField(string name, BindingFlags bindingAttr);
+        public FieldInfo[] GetFields();
+        public virtual FieldInfo[] GetFields(BindingFlags bindingAttr);
+        public virtual Type[] GetGenericArguments();
+        public abstract Type[] GetGenericParameterConstraints();
+        public abstract Type GetGenericTypeDefinition();
+        public Type GetInterface(string name);
+        public virtual Type GetInterface(string name, bool ignoreCase);
+        public virtual Type[] GetInterfaces();
+        public MemberInfo[] GetMember(string name);
+        public virtual MemberInfo[] GetMember(string name, BindingFlags bindingAttr);
+        public virtual MemberInfo[] GetMember(string name, MemberTypes type, BindingFlags bindingAttr);
+        public MemberInfo[] GetMembers();
+        public virtual MemberInfo[] GetMembers(BindingFlags bindingAttr);
+        public MethodInfo GetMethod(string name);
+        public MethodInfo GetMethod(string name, BindingFlags bindingAttr);
+        public MethodInfo GetMethod(string name, Type[] types);
+        public MethodInfo GetMethod(string name, Type[] types, ParameterModifier[] modifiers);
+        public MethodInfo[] GetMethods();
+        public virtual MethodInfo[] GetMethods(BindingFlags bindingAttr);
+        public Type GetNestedType(string name);
+        public virtual Type GetNestedType(string name, BindingFlags bindingAttr);
+        public Type[] GetNestedTypes();
+        public virtual Type[] GetNestedTypes(BindingFlags bindingAttr);
+        public PropertyInfo[] GetProperties();
+        public virtual PropertyInfo[] GetProperties(BindingFlags bindingAttr);
+        public PropertyInfo GetProperty(string name);
+        public PropertyInfo GetProperty(string name, BindingFlags bindingAttr);
+        public PropertyInfo GetProperty(string name, Type returnType);
+        public PropertyInfo GetProperty(string name, Type returnType, Type[] types);
+        public PropertyInfo GetProperty(string name, Type returnType, Type[] types, ParameterModifier[] modifiers);
+        public PropertyInfo GetProperty(string name, Type[] types);
+        public virtual bool IsAssignableFrom(TypeInfo typeInfo);
+        public virtual bool IsAssignableFrom(Type c);
+        public virtual bool IsEnumDefined(object value);
+        public virtual bool IsEquivalentTo(Type other);
+        public virtual bool IsInstanceOfType(object o);
+        public virtual bool IsSubclassOf(Type c);
+        public abstract Type MakeArrayType();
+        public abstract Type MakeArrayType(int rank);
+        public abstract Type MakeByRefType();
+        public abstract Type MakeGenericType(params Type[] typeArguments);
+        public abstract Type MakePointerType();
+        TypeInfo System.Reflection.IReflectableType.GetTypeInfo();
+    }
+}
```

## System.Reflection.Context

```c#
+namespace System.Reflection.Context {
+    public abstract class CustomReflectionContext : ReflectionContext {
+        protected CustomReflectionContext();
+        protected CustomReflectionContext(ReflectionContext source);
+        protected virtual IEnumerable<PropertyInfo> AddProperties(Type type);
+        protected PropertyInfo CreateProperty(Type propertyType, string name, Func<object, object> getter, Action<object, object> setter);
+        protected PropertyInfo CreateProperty(Type propertyType, string name, Func<object, object> getter, Action<object, object> setter, IEnumerable<Attribute> propertyCustomAttributes, IEnumerable<Attribute> getterCustomAttributes, IEnumerable<Attribute> setterCustomAttributes);
+        protected virtual IEnumerable<object> GetCustomAttributes(MemberInfo member, IEnumerable<object> declaredAttributes);
+        protected virtual IEnumerable<object> GetCustomAttributes(ParameterInfo parameter, IEnumerable<object> declaredAttributes);
+        public override Assembly MapAssembly(Assembly assembly);
+        public override TypeInfo MapType(TypeInfo type);
+    }
+}
```

## System.Reflection.Emit

```c#
+namespace System.Reflection.Emit {
+    public sealed class AssemblyBuilder : Assembly {
+        public override string CodeBase { get; }
+        public override IEnumerable<TypeInfo> DefinedTypes { get; }
+        public override MethodInfo EntryPoint { get; }
+        public override string FullName { get; }
+        public override string ImageRuntimeVersion { get; }
+        public override bool IsDynamic { get; }
+        public override string Location { get; }
+        public override Module ManifestModule { get; }
+        public override IEnumerable<Module> Modules { get; }
+        public static AssemblyBuilder DefineDynamicAssembly(AssemblyName name, AssemblyBuilderAccess access);
+        public static AssemblyBuilder DefineDynamicAssembly(AssemblyName name, AssemblyBuilderAccess access, IEnumerable<CustomAttributeBuilder> assemblyAttributes);
+        public ModuleBuilder DefineDynamicModule(string name);
+        [MethodImpl(NoInlining)]public ModuleBuilder DefineDynamicModule(string name, bool emitSymbolInfo);
+        public override bool Equals(object obj);
+        public override object[] GetCustomAttributes(bool inherit);
+        public override object[] GetCustomAttributes(Type attributeType, bool inherit);
+        public ModuleBuilder GetDynamicModule(string name);
+        public override Type[] GetExportedTypes();
+        public override int GetHashCode();
+        public override ManifestResourceInfo GetManifestResourceInfo(string resourceName);
+        public override string[] GetManifestResourceNames();
+        public override Stream GetManifestResourceStream(string name);
+        public override Stream GetManifestResourceStream(Type type, string name);
+        public override AssemblyName[] GetReferencedAssemblies();
+        public override Type GetType(string name, bool throwOnError, bool ignoreCase);
+        public override bool IsDefined(Type attributeType, bool inherit);
+        public void SetCustomAttribute(ConstructorInfo con, byte[] binaryAttribute);
+        public void SetCustomAttribute(CustomAttributeBuilder customBuilder);
+    }
+    public enum AssemblyBuilderAccess {
+        Run = 1,
+        RunAndCollect = 9,
+    }
+    public sealed class ConstructorBuilder : ConstructorInfo {
+        public override MethodAttributes Attributes { get; }
+        public override CallingConventions CallingConvention { get; }
+        public override Type DeclaringType { get; }
+        public bool InitLocals { get; set; }
+        public override RuntimeMethodHandle MethodHandle { get; }
+        public override MethodImplAttributes MethodImplementationFlags { get; }
+        public override Module Module { get; }
+        public override string Name { get; }
+        public override Type ReflectedType { get; }
+        public string Signature { get; }
+        public ParameterBuilder DefineParameter(int iSequence, ParameterAttributes attributes, string strParamName);
+        public override object[] GetCustomAttributes(bool inherit);
+        public override object[] GetCustomAttributes(Type attributeType, bool inherit);
+        public ILGenerator GetILGenerator();
+        public ILGenerator GetILGenerator(int streamSize);
+        public override MethodImplAttributes GetMethodImplementationFlags();
+        public Module GetModule();
+        public override ParameterInfo[] GetParameters();
+        public MethodToken GetToken();
+        public override object Invoke(object obj, BindingFlags invokeAttr, Binder binder, object[] parameters, CultureInfo culture);
+        public override object Invoke(BindingFlags invokeAttr, Binder binder, object[] parameters, CultureInfo culture);
+        public override bool IsDefined(Type attributeType, bool inherit);
+        public void SetCustomAttribute(ConstructorInfo con, byte[] binaryAttribute);
+        public void SetCustomAttribute(CustomAttributeBuilder customBuilder);
+        public void SetImplementationFlags(MethodImplAttributes attributes);
+        public override string ToString();
+    }
+    public class CustomAttributeBuilder {
+        public CustomAttributeBuilder(ConstructorInfo con, object[] constructorArgs);
+        public CustomAttributeBuilder(ConstructorInfo con, object[] constructorArgs, FieldInfo[] namedFields, object[] fieldValues);
+        public CustomAttributeBuilder(ConstructorInfo con, object[] constructorArgs, PropertyInfo[] namedProperties, object[] propertyValues);
+        public CustomAttributeBuilder(ConstructorInfo con, object[] constructorArgs, PropertyInfo[] namedProperties, object[] propertyValues, FieldInfo[] namedFields, object[] fieldValues);
+    }
+    public sealed class DynamicMethod : MethodInfo {
+        public DynamicMethod(string name, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] parameterTypes, Module m, bool skipVisibility);
+        public DynamicMethod(string name, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] parameterTypes, Type owner, bool skipVisibility);
+        public DynamicMethod(string name, Type returnType, Type[] parameterTypes);
+        public DynamicMethod(string name, Type returnType, Type[] parameterTypes, bool restrictedSkipVisibility);
+        public DynamicMethod(string name, Type returnType, Type[] parameterTypes, Module m);
+        public DynamicMethod(string name, Type returnType, Type[] parameterTypes, Module m, bool skipVisibility);
+        public DynamicMethod(string name, Type returnType, Type[] parameterTypes, Type owner);
+        public DynamicMethod(string name, Type returnType, Type[] parameterTypes, Type owner, bool skipVisibility);
+        public override MethodAttributes Attributes { get; }
+        public override CallingConventions CallingConvention { get; }
+        public override Type DeclaringType { get; }
+        public bool InitLocals { get; set; }
+        public override RuntimeMethodHandle MethodHandle { get; }
+        public override MethodImplAttributes MethodImplementationFlags { get; }
+        public override Module Module { get; }
+        public override string Name { get; }
+        public override Type ReflectedType { get; }
+        public override ParameterInfo ReturnParameter { get; }
+        public override Type ReturnType { get; }
+        public override ICustomAttributeProvider ReturnTypeCustomAttributes { get; }
+        public sealed override Delegate CreateDelegate(Type delegateType);
+        public sealed override Delegate CreateDelegate(Type delegateType, object target);
+        public ParameterBuilder DefineParameter(int position, ParameterAttributes attributes, string parameterName);
+        public override MethodInfo GetBaseDefinition();
+        public override object[] GetCustomAttributes(bool inherit);
+        public override object[] GetCustomAttributes(Type attributeType, bool inherit);
+        public ILGenerator GetILGenerator();
+        public ILGenerator GetILGenerator(int streamSize);
+        public override MethodImplAttributes GetMethodImplementationFlags();
+        public override ParameterInfo[] GetParameters();
+        public override object Invoke(object obj, BindingFlags invokeAttr, Binder binder, object[] parameters, CultureInfo culture);
+        public override bool IsDefined(Type attributeType, bool inherit);
+        public override string ToString();
+    }
+    public sealed class EnumBuilder : TypeInfo {
+        public override Assembly Assembly { get; }
+        public override string AssemblyQualifiedName { get; }
+        public override TypeAttributes Attributes { get; }
+        public override Type BaseType { get; }
+        public override bool ContainsGenericParameters { get; }
+        public override MethodBase DeclaringMethod { get; }
+        public override Type DeclaringType { get; }
+        public override string FullName { get; }
+        public override GenericParameterAttributes GenericParameterAttributes { get; }
+        public override int GenericParameterPosition { get; }
+        public override Type[] GenericTypeArguments { get; }
+        public override Guid GUID { get; }
+        public override bool IsConstructedGenericType { get; }
+        public override bool IsEnum { get; }
+        public override bool IsGenericParameter { get; }
+        public override bool IsGenericType { get; }
+        public override bool IsGenericTypeDefinition { get; }
+        public override bool IsSerializable { get; }
+        public override Module Module { get; }
+        public override string Name { get; }
+        public override string Namespace { get; }
+        public override Type ReflectedType { get; }
+        public override RuntimeTypeHandle TypeHandle { get; }
+        public TypeToken TypeToken { get; }
+        public FieldBuilder UnderlyingField { get; }
+        public override Type UnderlyingSystemType { get; }
+        public Type CreateType();
+        public TypeInfo CreateTypeInfo();
+        public FieldBuilder DefineLiteral(string literalName, object literalValue);
+        public override int GetArrayRank();
+        protected override TypeAttributes GetAttributeFlagsImpl();
+        protected override ConstructorInfo GetConstructorImpl(BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
+        public override ConstructorInfo[] GetConstructors(BindingFlags bindingAttr);
+        public override object[] GetCustomAttributes(bool inherit);
+        public override object[] GetCustomAttributes(Type attributeType, bool inherit);
+        public override Type GetElementType();
+        public override Type GetEnumUnderlyingType();
+        public override EventInfo GetEvent(string name, BindingFlags bindingAttr);
+        public override EventInfo[] GetEvents();
+        public override EventInfo[] GetEvents(BindingFlags bindingAttr);
+        public override FieldInfo GetField(string name, BindingFlags bindingAttr);
+        public override FieldInfo[] GetFields(BindingFlags bindingAttr);
+        public override Type[] GetGenericParameterConstraints();
+        public override Type GetGenericTypeDefinition();
+        public override Type GetInterface(string name, bool ignoreCase);
+        public override InterfaceMapping GetInterfaceMap(Type interfaceType);
+        public override Type[] GetInterfaces();
+        public override MemberInfo[] GetMember(string name, MemberTypes type, BindingFlags bindingAttr);
+        public override MemberInfo[] GetMembers(BindingFlags bindingAttr);
+        protected override MethodInfo GetMethodImpl(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
+        public override MethodInfo[] GetMethods(BindingFlags bindingAttr);
+        public override Type GetNestedType(string name, BindingFlags bindingAttr);
+        public override Type[] GetNestedTypes(BindingFlags bindingAttr);
+        public override PropertyInfo[] GetProperties(BindingFlags bindingAttr);
+        protected override PropertyInfo GetPropertyImpl(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers);
+        protected override bool HasElementTypeImpl();
+        public override object InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, object[] args, ParameterModifier[] modifiers, CultureInfo culture, string[] namedParameters);
+        protected override bool IsArrayImpl();
+        public override bool IsAssignableFrom(TypeInfo typeInfo);
+        protected override bool IsByRefImpl();
+        protected override bool IsCOMObjectImpl();
+        public override bool IsDefined(Type attributeType, bool inherit);
+        protected override bool IsPointerImpl();
+        protected override bool IsPrimitiveImpl();
+        protected override bool IsValueTypeImpl();
+        public override Type MakeArrayType();
+        public override Type MakeArrayType(int rank);
+        public override Type MakeByRefType();
+        public override Type MakeGenericType(params Type[] typeArguments);
+        public override Type MakePointerType();
+        public void SetCustomAttribute(ConstructorInfo con, byte[] binaryAttribute);
+        public void SetCustomAttribute(CustomAttributeBuilder customBuilder);
+    }
+    public sealed class EventBuilder {
+        public void AddOtherMethod(MethodBuilder mdBuilder);
+        public EventToken GetEventToken();
+        public void SetAddOnMethod(MethodBuilder mdBuilder);
+        public void SetCustomAttribute(ConstructorInfo con, byte[] binaryAttribute);
+        public void SetCustomAttribute(CustomAttributeBuilder customBuilder);
+        public void SetRaiseMethod(MethodBuilder mdBuilder);
+        public void SetRemoveOnMethod(MethodBuilder mdBuilder);
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct EventToken {
+        public static readonly EventToken Empty;
+        public int Token { get; }
+        public override bool Equals(object obj);
+        public bool Equals(EventToken obj);
+        public override int GetHashCode();
+        public static bool operator ==(EventToken a, EventToken b);
+        public static bool operator !=(EventToken a, EventToken b);
+    }
+    public sealed class FieldBuilder : FieldInfo {
+        public override FieldAttributes Attributes { get; }
+        public override Type DeclaringType { get; }
+        public override RuntimeFieldHandle FieldHandle { get; }
+        public override Type FieldType { get; }
+        public override Module Module { get; }
+        public override string Name { get; }
+        public override Type ReflectedType { get; }
+        public override object[] GetCustomAttributes(bool inherit);
+        public override object[] GetCustomAttributes(Type attributeType, bool inherit);
+        public FieldToken GetToken();
+        public override object GetValue(object obj);
+        public override bool IsDefined(Type attributeType, bool inherit);
+        public void SetConstant(object defaultValue);
+        public void SetCustomAttribute(ConstructorInfo con, byte[] binaryAttribute);
+        public void SetCustomAttribute(CustomAttributeBuilder customBuilder);
+        public void SetOffset(int iOffset);
+        public override void SetValue(object obj, object val, BindingFlags invokeAttr, Binder binder, CultureInfo culture);
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct FieldToken {
+        public static readonly FieldToken Empty;
+        public int Token { get; }
+        public override bool Equals(object obj);
+        public bool Equals(FieldToken obj);
+        public override int GetHashCode();
+        public static bool operator ==(FieldToken a, FieldToken b);
+        public static bool operator !=(FieldToken a, FieldToken b);
+    }
+    public enum FlowControl {
+        Branch = 0,
+        Break = 1,
+        Call = 2,
+        Cond_Branch = 3,
+        Meta = 4,
+        Next = 5,
+        Return = 7,
+        Throw = 8,
+    }
+    public sealed class GenericTypeParameterBuilder : TypeInfo {
+        public override Assembly Assembly { get; }
+        public override string AssemblyQualifiedName { get; }
+        public override TypeAttributes Attributes { get; }
+        public override Type BaseType { get; }
+        public override bool ContainsGenericParameters { get; }
+        public override MethodBase DeclaringMethod { get; }
+        public override Type DeclaringType { get; }
+        public override string FullName { get; }
+        public override GenericParameterAttributes GenericParameterAttributes { get; }
+        public override int GenericParameterPosition { get; }
+        public override Type[] GenericTypeArguments { get; }
+        public override Guid GUID { get; }
+        public override bool IsConstructedGenericType { get; }
+        public override bool IsEnum { get; }
+        public override bool IsGenericParameter { get; }
+        public override bool IsGenericType { get; }
+        public override bool IsGenericTypeDefinition { get; }
+        public override bool IsSerializable { get; }
+        public override Module Module { get; }
+        public override string Name { get; }
+        public override string Namespace { get; }
+        public override Type ReflectedType { get; }
+        public override RuntimeTypeHandle TypeHandle { get; }
+        public override Type UnderlyingSystemType { get; }
+        public override bool Equals(object o);
+        public override int GetArrayRank();
+        protected override TypeAttributes GetAttributeFlagsImpl();
+        protected override ConstructorInfo GetConstructorImpl(BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
+        public override ConstructorInfo[] GetConstructors(BindingFlags bindingAttr);
+        public override object[] GetCustomAttributes(bool inherit);
+        public override object[] GetCustomAttributes(Type attributeType, bool inherit);
+        public override Type GetElementType();
+        public override EventInfo GetEvent(string name, BindingFlags bindingAttr);
+        public override EventInfo[] GetEvents();
+        public override EventInfo[] GetEvents(BindingFlags bindingAttr);
+        public override FieldInfo GetField(string name, BindingFlags bindingAttr);
+        public override FieldInfo[] GetFields(BindingFlags bindingAttr);
+        public override Type[] GetGenericArguments();
+        public override Type[] GetGenericParameterConstraints();
+        public override Type GetGenericTypeDefinition();
+        public override int GetHashCode();
+        public override Type GetInterface(string name, bool ignoreCase);
+        public override InterfaceMapping GetInterfaceMap(Type interfaceType);
+        public override Type[] GetInterfaces();
+        public override MemberInfo[] GetMember(string name, MemberTypes type, BindingFlags bindingAttr);
+        public override MemberInfo[] GetMembers(BindingFlags bindingAttr);
+        protected override MethodInfo GetMethodImpl(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
+        public override MethodInfo[] GetMethods(BindingFlags bindingAttr);
+        public override Type GetNestedType(string name, BindingFlags bindingAttr);
+        public override Type[] GetNestedTypes(BindingFlags bindingAttr);
+        public override PropertyInfo[] GetProperties(BindingFlags bindingAttr);
+        protected override PropertyInfo GetPropertyImpl(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers);
+        protected override bool HasElementTypeImpl();
+        public override object InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, object[] args, ParameterModifier[] modifiers, CultureInfo culture, string[] namedParameters);
+        protected override bool IsArrayImpl();
+        public override bool IsAssignableFrom(TypeInfo typeInfo);
+        public override bool IsAssignableFrom(Type c);
+        protected override bool IsByRefImpl();
+        protected override bool IsCOMObjectImpl();
+        public override bool IsDefined(Type attributeType, bool inherit);
+        protected override bool IsPointerImpl();
+        protected override bool IsPrimitiveImpl();
+        public override bool IsSubclassOf(Type c);
+        protected override bool IsValueTypeImpl();
+        public override Type MakeArrayType();
+        public override Type MakeArrayType(int rank);
+        public override Type MakeByRefType();
+        public override Type MakeGenericType(params Type[] typeArguments);
+        public override Type MakePointerType();
+        public void SetBaseTypeConstraint(Type baseTypeConstraint);
+        public void SetCustomAttribute(ConstructorInfo con, byte[] binaryAttribute);
+        public void SetCustomAttribute(CustomAttributeBuilder customBuilder);
+        public void SetGenericParameterAttributes(GenericParameterAttributes genericParameterAttributes);
+        public void SetInterfaceConstraints(params Type[] interfaceConstraints);
+        public override string ToString();
+    }
+    public class ILGenerator {
+        public virtual int ILOffset { get; }
+        public virtual void BeginCatchBlock(Type exceptionType);
+        public virtual void BeginExceptFilterBlock();
+        public virtual Label BeginExceptionBlock();
+        public virtual void BeginFaultBlock();
+        public virtual void BeginFinallyBlock();
+        public virtual void BeginScope();
+        public virtual LocalBuilder DeclareLocal(Type localType);
+        public virtual LocalBuilder DeclareLocal(Type localType, bool pinned);
+        public virtual Label DefineLabel();
+        public virtual void Emit(OpCode opcode);
+        public virtual void Emit(OpCode opcode, byte arg);
+        public virtual void Emit(OpCode opcode, double arg);
+        public virtual void Emit(OpCode opcode, short arg);
+        public virtual void Emit(OpCode opcode, int arg);
+        public virtual void Emit(OpCode opcode, long arg);
+        public virtual void Emit(OpCode opcode, ConstructorInfo con);
+        public virtual void Emit(OpCode opcode, Label label);
+        public virtual void Emit(OpCode opcode, Label[] labels);
+        public virtual void Emit(OpCode opcode, LocalBuilder local);
+        public virtual void Emit(OpCode opcode, SignatureHelper signature);
+        public virtual void Emit(OpCode opcode, FieldInfo field);
+        public virtual void Emit(OpCode opcode, MethodInfo meth);
+        public void Emit(OpCode opcode, sbyte arg);
+        public virtual void Emit(OpCode opcode, float arg);
+        public virtual void Emit(OpCode opcode, string str);
+        public virtual void Emit(OpCode opcode, Type cls);
+        public virtual void EmitCall(OpCode opcode, MethodInfo methodInfo, Type[] optionalParameterTypes);
+        public virtual void EmitCalli(OpCode opcode, CallingConventions callingConvention, Type returnType, Type[] parameterTypes, Type[] optionalParameterTypes);
+        public virtual void EmitWriteLine(LocalBuilder localBuilder);
+        public virtual void EmitWriteLine(FieldInfo fld);
+        public virtual void EmitWriteLine(string value);
+        public virtual void EndExceptionBlock();
+        public virtual void EndScope();
+        public virtual void MarkLabel(Label loc);
+        public virtual void MarkSequencePoint(ISymbolDocumentWriter document, int startLine, int startColumn, int endLine, int endColumn);
+        public virtual void ThrowException(Type excType);
+        public virtual void UsingNamespace(string usingNamespace);
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct Label {
+        public override bool Equals(object obj);
+        public bool Equals(Label obj);
+        public override int GetHashCode();
+        public static bool operator ==(Label a, Label b);
+        public static bool operator !=(Label a, Label b);
+    }
+    public sealed class LocalBuilder : LocalVariableInfo {
+        public override bool IsPinned { get; }
+        public override int LocalIndex { get; }
+        public override Type LocalType { get; }
+        public void SetLocalSymInfo(string name);
+        public void SetLocalSymInfo(string name, int startOffset, int endOffset);
+    }
+    public sealed class MethodBuilder : MethodInfo {
+        public override MethodAttributes Attributes { get; }
+        public override CallingConventions CallingConvention { get; }
+        public override bool ContainsGenericParameters { get; }
+        public override Type DeclaringType { get; }
+        public bool InitLocals { get; set; }
+        public override bool IsGenericMethod { get; }
+        public override bool IsGenericMethodDefinition { get; }
+        public override RuntimeMethodHandle MethodHandle { get; }
+        public override MethodImplAttributes MethodImplementationFlags { get; }
+        public override Module Module { get; }
+        public override string Name { get; }
+        public override Type ReflectedType { get; }
+        public override ParameterInfo ReturnParameter { get; }
+        public override Type ReturnType { get; }
+        public override ICustomAttributeProvider ReturnTypeCustomAttributes { get; }
+        public string Signature { get; }
+        public GenericTypeParameterBuilder[] DefineGenericParameters(params string[] names);
+        public ParameterBuilder DefineParameter(int position, ParameterAttributes attributes, string strParamName);
+        public override bool Equals(object obj);
+        public override MethodInfo GetBaseDefinition();
+        public override object[] GetCustomAttributes(bool inherit);
+        public override object[] GetCustomAttributes(Type attributeType, bool inherit);
+        public override Type[] GetGenericArguments();
+        public override MethodInfo GetGenericMethodDefinition();
+        public override int GetHashCode();
+        public ILGenerator GetILGenerator();
+        public ILGenerator GetILGenerator(int size);
+        public override MethodImplAttributes GetMethodImplementationFlags();
+        public Module GetModule();
+        public override ParameterInfo[] GetParameters();
+        public MethodToken GetToken();
+        public override object Invoke(object obj, BindingFlags invokeAttr, Binder binder, object[] parameters, CultureInfo culture);
+        public override bool IsDefined(Type attributeType, bool inherit);
+        public override MethodInfo MakeGenericMethod(params Type[] typeArguments);
+        public void SetCustomAttribute(ConstructorInfo con, byte[] binaryAttribute);
+        public void SetCustomAttribute(CustomAttributeBuilder customBuilder);
+        public void SetImplementationFlags(MethodImplAttributes attributes);
+        public void SetParameters(params Type[] parameterTypes);
+        public void SetReturnType(Type returnType);
+        public void SetSignature(Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers, Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers);
+        public override string ToString();
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct MethodToken {
+        public static readonly MethodToken Empty;
+        public int Token { get; }
+        public override bool Equals(object obj);
+        public bool Equals(MethodToken obj);
+        public override int GetHashCode();
+        public static bool operator ==(MethodToken a, MethodToken b);
+        public static bool operator !=(MethodToken a, MethodToken b);
+    }
+    public class ModuleBuilder : Module {
+        public override Assembly Assembly { get; }
+        public override string FullyQualifiedName { get; }
+        public override int MetadataToken { get; }
+        public override Guid ModuleVersionId { get; }
+        public override string Name { get; }
+        public override string ScopeName { get; }
+        public void CreateGlobalFunctions();
+        public ISymbolDocumentWriter DefineDocument(string url, Guid language, Guid languageVendor, Guid documentType);
+        public EnumBuilder DefineEnum(string name, TypeAttributes visibility, Type underlyingType);
+        public MethodBuilder DefineGlobalMethod(string name, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] parameterTypes);
+        public MethodBuilder DefineGlobalMethod(string name, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] requiredReturnTypeCustomModifiers, Type[] optionalReturnTypeCustomModifiers, Type[] parameterTypes, Type[][] requiredParameterTypeCustomModifiers, Type[][] optionalParameterTypeCustomModifiers);
+        public MethodBuilder DefineGlobalMethod(string name, MethodAttributes attributes, Type returnType, Type[] parameterTypes);
+        public FieldBuilder DefineInitializedData(string name, byte[] data, FieldAttributes attributes);
+        public TypeBuilder DefineType(string name);
+        public TypeBuilder DefineType(string name, TypeAttributes attr);
+        public TypeBuilder DefineType(string name, TypeAttributes attr, Type parent);
+        public TypeBuilder DefineType(string name, TypeAttributes attr, Type parent, int typesize);
+        public TypeBuilder DefineType(string name, TypeAttributes attr, Type parent, PackingSize packsize);
+        public TypeBuilder DefineType(string name, TypeAttributes attr, Type parent, PackingSize packingSize, int typesize);
+        public TypeBuilder DefineType(string name, TypeAttributes attr, Type parent, Type[] interfaces);
+        public FieldBuilder DefineUninitializedData(string name, int size, FieldAttributes attributes);
+        public override bool Equals(object obj);
+        public MethodInfo GetArrayMethod(Type arrayClass, string methodName, CallingConventions callingConvention, Type returnType, Type[] parameterTypes);
+        public MethodToken GetArrayMethodToken(Type arrayClass, string methodName, CallingConventions callingConvention, Type returnType, Type[] parameterTypes);
+        public MethodToken GetConstructorToken(ConstructorInfo con);
+        public override object[] GetCustomAttributes(bool inherit);
+        public override object[] GetCustomAttributes(Type attributeType, bool inherit);
+        public override FieldInfo GetField(string name, BindingFlags bindingAttr);
+        public override FieldInfo[] GetFields(BindingFlags bindingFlags);
+        public FieldToken GetFieldToken(FieldInfo field);
+        public override int GetHashCode();
+        protected override MethodInfo GetMethodImpl(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
+        public override MethodInfo[] GetMethods(BindingFlags bindingFlags);
+        public MethodToken GetMethodToken(MethodInfo method);
+        public SignatureToken GetSignatureToken(byte[] sigBytes, int sigLength);
+        public SignatureToken GetSignatureToken(SignatureHelper sigHelper);
+        public StringToken GetStringConstant(string str);
+        public override Type GetType(string className);
+        public override Type GetType(string className, bool ignoreCase);
+        public override Type GetType(string className, bool throwOnError, bool ignoreCase);
+        public override Type[] GetTypes();
+        public TypeToken GetTypeToken(string name);
+        public TypeToken GetTypeToken(Type type);
+        public override bool IsDefined(Type attributeType, bool inherit);
+        public bool IsTransient();
+        public override FieldInfo ResolveField(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);
+        public override MethodBase ResolveMethod(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);
+        public override string ResolveString(int metadataToken);
+        public override Type ResolveType(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);
+        public void SetCustomAttribute(ConstructorInfo con, byte[] binaryAttribute);
+        public void SetCustomAttribute(CustomAttributeBuilder customBuilder);
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct OpCode {
+        public FlowControl FlowControl { get; }
+        public string Name { get; }
+        public OpCodeType OpCodeType { get; }
+        public OperandType OperandType { get; }
+        public int Size { get; }
+        public StackBehaviour StackBehaviourPop { get; }
+        public StackBehaviour StackBehaviourPush { get; }
+        public short Value { get; }
+        public override bool Equals(object obj);
+        public bool Equals(OpCode obj);
+        public override int GetHashCode();
+        public static bool operator ==(OpCode a, OpCode b);
+        public static bool operator !=(OpCode a, OpCode b);
+        public override string ToString();
+    }
+    public class OpCodes {
+        public static readonly OpCode Add;
+        public static readonly OpCode Add_Ovf;
+        public static readonly OpCode Add_Ovf_Un;
+        public static readonly OpCode And;
+        public static readonly OpCode Arglist;
+        public static readonly OpCode Beq;
+        public static readonly OpCode Beq_S;
+        public static readonly OpCode Bge;
+        public static readonly OpCode Bge_S;
+        public static readonly OpCode Bge_Un;
+        public static readonly OpCode Bge_Un_S;
+        public static readonly OpCode Bgt;
+        public static readonly OpCode Bgt_S;
+        public static readonly OpCode Bgt_Un;
+        public static readonly OpCode Bgt_Un_S;
+        public static readonly OpCode Ble;
+        public static readonly OpCode Ble_S;
+        public static readonly OpCode Ble_Un;
+        public static readonly OpCode Ble_Un_S;
+        public static readonly OpCode Blt;
+        public static readonly OpCode Blt_S;
+        public static readonly OpCode Blt_Un;
+        public static readonly OpCode Blt_Un_S;
+        public static readonly OpCode Bne_Un;
+        public static readonly OpCode Bne_Un_S;
+        public static readonly OpCode Box;
+        public static readonly OpCode Br;
+        public static readonly OpCode Br_S;
+        public static readonly OpCode Break;
+        public static readonly OpCode Brfalse;
+        public static readonly OpCode Brfalse_S;
+        public static readonly OpCode Brtrue;
+        public static readonly OpCode Brtrue_S;
+        public static readonly OpCode Call;
+        public static readonly OpCode Calli;
+        public static readonly OpCode Callvirt;
+        public static readonly OpCode Castclass;
+        public static readonly OpCode Ceq;
+        public static readonly OpCode Cgt;
+        public static readonly OpCode Cgt_Un;
+        public static readonly OpCode Ckfinite;
+        public static readonly OpCode Clt;
+        public static readonly OpCode Clt_Un;
+        public static readonly OpCode Constrained;
+        public static readonly OpCode Conv_I;
+        public static readonly OpCode Conv_I1;
+        public static readonly OpCode Conv_I2;
+        public static readonly OpCode Conv_I4;
+        public static readonly OpCode Conv_I8;
+        public static readonly OpCode Conv_Ovf_I;
+        public static readonly OpCode Conv_Ovf_I_Un;
+        public static readonly OpCode Conv_Ovf_I1;
+        public static readonly OpCode Conv_Ovf_I1_Un;
+        public static readonly OpCode Conv_Ovf_I2;
+        public static readonly OpCode Conv_Ovf_I2_Un;
+        public static readonly OpCode Conv_Ovf_I4;
+        public static readonly OpCode Conv_Ovf_I4_Un;
+        public static readonly OpCode Conv_Ovf_I8;
+        public static readonly OpCode Conv_Ovf_I8_Un;
+        public static readonly OpCode Conv_Ovf_U;
+        public static readonly OpCode Conv_Ovf_U_Un;
+        public static readonly OpCode Conv_Ovf_U1;
+        public static readonly OpCode Conv_Ovf_U1_Un;
+        public static readonly OpCode Conv_Ovf_U2;
+        public static readonly OpCode Conv_Ovf_U2_Un;
+        public static readonly OpCode Conv_Ovf_U4;
+        public static readonly OpCode Conv_Ovf_U4_Un;
+        public static readonly OpCode Conv_Ovf_U8;
+        public static readonly OpCode Conv_Ovf_U8_Un;
+        public static readonly OpCode Conv_R_Un;
+        public static readonly OpCode Conv_R4;
+        public static readonly OpCode Conv_R8;
+        public static readonly OpCode Conv_U;
+        public static readonly OpCode Conv_U1;
+        public static readonly OpCode Conv_U2;
+        public static readonly OpCode Conv_U4;
+        public static readonly OpCode Conv_U8;
+        public static readonly OpCode Cpblk;
+        public static readonly OpCode Cpobj;
+        public static readonly OpCode Div;
+        public static readonly OpCode Div_Un;
+        public static readonly OpCode Dup;
+        public static readonly OpCode Endfilter;
+        public static readonly OpCode Endfinally;
+        public static readonly OpCode Initblk;
+        public static readonly OpCode Initobj;
+        public static readonly OpCode Isinst;
+        public static readonly OpCode Jmp;
+        public static readonly OpCode Ldarg;
+        public static readonly OpCode Ldarg_0;
+        public static readonly OpCode Ldarg_1;
+        public static readonly OpCode Ldarg_2;
+        public static readonly OpCode Ldarg_3;
+        public static readonly OpCode Ldarg_S;
+        public static readonly OpCode Ldarga;
+        public static readonly OpCode Ldarga_S;
+        public static readonly OpCode Ldc_I4;
+        public static readonly OpCode Ldc_I4_0;
+        public static readonly OpCode Ldc_I4_1;
+        public static readonly OpCode Ldc_I4_2;
+        public static readonly OpCode Ldc_I4_3;
+        public static readonly OpCode Ldc_I4_4;
+        public static readonly OpCode Ldc_I4_5;
+        public static readonly OpCode Ldc_I4_6;
+        public static readonly OpCode Ldc_I4_7;
+        public static readonly OpCode Ldc_I4_8;
+        public static readonly OpCode Ldc_I4_M1;
+        public static readonly OpCode Ldc_I4_S;
+        public static readonly OpCode Ldc_I8;
+        public static readonly OpCode Ldc_R4;
+        public static readonly OpCode Ldc_R8;
+        public static readonly OpCode Ldelem;
+        public static readonly OpCode Ldelem_I;
+        public static readonly OpCode Ldelem_I1;
+        public static readonly OpCode Ldelem_I2;
+        public static readonly OpCode Ldelem_I4;
+        public static readonly OpCode Ldelem_I8;
+        public static readonly OpCode Ldelem_R4;
+        public static readonly OpCode Ldelem_R8;
+        public static readonly OpCode Ldelem_Ref;
+        public static readonly OpCode Ldelem_U1;
+        public static readonly OpCode Ldelem_U2;
+        public static readonly OpCode Ldelem_U4;
+        public static readonly OpCode Ldelema;
+        public static readonly OpCode Ldfld;
+        public static readonly OpCode Ldflda;
+        public static readonly OpCode Ldftn;
+        public static readonly OpCode Ldind_I;
+        public static readonly OpCode Ldind_I1;
+        public static readonly OpCode Ldind_I2;
+        public static readonly OpCode Ldind_I4;
+        public static readonly OpCode Ldind_I8;
+        public static readonly OpCode Ldind_R4;
+        public static readonly OpCode Ldind_R8;
+        public static readonly OpCode Ldind_Ref;
+        public static readonly OpCode Ldind_U1;
+        public static readonly OpCode Ldind_U2;
+        public static readonly OpCode Ldind_U4;
+        public static readonly OpCode Ldlen;
+        public static readonly OpCode Ldloc;
+        public static readonly OpCode Ldloc_0;
+        public static readonly OpCode Ldloc_1;
+        public static readonly OpCode Ldloc_2;
+        public static readonly OpCode Ldloc_3;
+        public static readonly OpCode Ldloc_S;
+        public static readonly OpCode Ldloca;
+        public static readonly OpCode Ldloca_S;
+        public static readonly OpCode Ldnull;
+        public static readonly OpCode Ldobj;
+        public static readonly OpCode Ldsfld;
+        public static readonly OpCode Ldsflda;
+        public static readonly OpCode Ldstr;
+        public static readonly OpCode Ldtoken;
+        public static readonly OpCode Ldvirtftn;
+        public static readonly OpCode Leave;
+        public static readonly OpCode Leave_S;
+        public static readonly OpCode Localloc;
+        public static readonly OpCode Mkrefany;
+        public static readonly OpCode Mul;
+        public static readonly OpCode Mul_Ovf;
+        public static readonly OpCode Mul_Ovf_Un;
+        public static readonly OpCode Neg;
+        public static readonly OpCode Newarr;
+        public static readonly OpCode Newobj;
+        public static readonly OpCode Nop;
+        public static readonly OpCode Not;
+        public static readonly OpCode Or;
+        public static readonly OpCode Pop;
+        public static readonly OpCode Prefix1;
+        public static readonly OpCode Prefix2;
+        public static readonly OpCode Prefix3;
+        public static readonly OpCode Prefix4;
+        public static readonly OpCode Prefix5;
+        public static readonly OpCode Prefix6;
+        public static readonly OpCode Prefix7;
+        public static readonly OpCode Prefixref;
+        public static readonly OpCode Readonly;
+        public static readonly OpCode Refanytype;
+        public static readonly OpCode Refanyval;
+        public static readonly OpCode Rem;
+        public static readonly OpCode Rem_Un;
+        public static readonly OpCode Ret;
+        public static readonly OpCode Rethrow;
+        public static readonly OpCode Shl;
+        public static readonly OpCode Shr;
+        public static readonly OpCode Shr_Un;
+        public static readonly OpCode Sizeof;
+        public static readonly OpCode Starg;
+        public static readonly OpCode Starg_S;
+        public static readonly OpCode Stelem;
+        public static readonly OpCode Stelem_I;
+        public static readonly OpCode Stelem_I1;
+        public static readonly OpCode Stelem_I2;
+        public static readonly OpCode Stelem_I4;
+        public static readonly OpCode Stelem_I8;
+        public static readonly OpCode Stelem_R4;
+        public static readonly OpCode Stelem_R8;
+        public static readonly OpCode Stelem_Ref;
+        public static readonly OpCode Stfld;
+        public static readonly OpCode Stind_I;
+        public static readonly OpCode Stind_I1;
+        public static readonly OpCode Stind_I2;
+        public static readonly OpCode Stind_I4;
+        public static readonly OpCode Stind_I8;
+        public static readonly OpCode Stind_R4;
+        public static readonly OpCode Stind_R8;
+        public static readonly OpCode Stind_Ref;
+        public static readonly OpCode Stloc;
+        public static readonly OpCode Stloc_0;
+        public static readonly OpCode Stloc_1;
+        public static readonly OpCode Stloc_2;
+        public static readonly OpCode Stloc_3;
+        public static readonly OpCode Stloc_S;
+        public static readonly OpCode Stobj;
+        public static readonly OpCode Stsfld;
+        public static readonly OpCode Sub;
+        public static readonly OpCode Sub_Ovf;
+        public static readonly OpCode Sub_Ovf_Un;
+        public static readonly OpCode Switch;
+        public static readonly OpCode Tailcall;
+        public static readonly OpCode Throw;
+        public static readonly OpCode Unaligned;
+        public static readonly OpCode Unbox;
+        public static readonly OpCode Unbox_Any;
+        public static readonly OpCode Volatile;
+        public static readonly OpCode Xor;
+        public static bool TakesSingleByteArgument(OpCode inst);
+    }
+    public enum OpCodeType {
+        Macro = 1,
+        Nternal = 2,
+        Objmodel = 3,
+        Prefix = 4,
+        Primitive = 5,
+    }
+    public enum OperandType {
+        InlineBrTarget = 0,
+        InlineField = 1,
+        InlineI = 2,
+        InlineI8 = 3,
+        InlineMethod = 4,
+        InlineNone = 5,
+        InlineR = 7,
+        InlineSig = 9,
+        InlineString = 10,
+        InlineSwitch = 11,
+        InlineTok = 12,
+        InlineType = 13,
+        InlineVar = 14,
+        ShortInlineBrTarget = 15,
+        ShortInlineI = 16,
+        ShortInlineR = 17,
+        ShortInlineVar = 18,
+    }
+    public enum PackingSize {
+        Size1 = 1,
+        Size128 = 128,
+        Size16 = 16,
+        Size2 = 2,
+        Size32 = 32,
+        Size4 = 4,
+        Size64 = 64,
+        Size8 = 8,
+        Unspecified = 0,
+    }
+    public class ParameterBuilder {
+        public virtual int Attributes { get; }
+        public bool IsIn { get; }
+        public bool IsOptional { get; }
+        public bool IsOut { get; }
+        public virtual string Name { get; }
+        public virtual int Position { get; }
+        public virtual ParameterToken GetToken();
+        public virtual void SetConstant(object defaultValue);
+        public void SetCustomAttribute(ConstructorInfo con, byte[] binaryAttribute);
+        public void SetCustomAttribute(CustomAttributeBuilder customBuilder);
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct ParameterToken {
+        public static readonly ParameterToken Empty;
+        public int Token { get; }
+        public override bool Equals(object obj);
+        public bool Equals(ParameterToken obj);
+        public override int GetHashCode();
+        public static bool operator ==(ParameterToken a, ParameterToken b);
+        public static bool operator !=(ParameterToken a, ParameterToken b);
+    }
+    public enum PEFileKinds {
+        ConsoleApplication = 2,
+        Dll = 1,
+        WindowApplication = 3,
+    }
+    public sealed class PropertyBuilder : PropertyInfo {
+        public override PropertyAttributes Attributes { get; }
+        public override bool CanRead { get; }
+        public override bool CanWrite { get; }
+        public override Type DeclaringType { get; }
+        public override Module Module { get; }
+        public override string Name { get; }
+        public PropertyToken PropertyToken { get; }
+        public override Type PropertyType { get; }
+        public override Type ReflectedType { get; }
+        public void AddOtherMethod(MethodBuilder mdBuilder);
+        public override MethodInfo[] GetAccessors(bool nonPublic);
+        public override object[] GetCustomAttributes(bool inherit);
+        public override object[] GetCustomAttributes(Type attributeType, bool inherit);
+        public override MethodInfo GetGetMethod(bool nonPublic);
+        public override ParameterInfo[] GetIndexParameters();
+        public override MethodInfo GetSetMethod(bool nonPublic);
+        public override object GetValue(object obj, object[] index);
+        public override object GetValue(object obj, BindingFlags invokeAttr, Binder binder, object[] index, CultureInfo culture);
+        public override bool IsDefined(Type attributeType, bool inherit);
+        public void SetConstant(object defaultValue);
+        public void SetCustomAttribute(ConstructorInfo con, byte[] binaryAttribute);
+        public void SetCustomAttribute(CustomAttributeBuilder customBuilder);
+        public void SetGetMethod(MethodBuilder mdBuilder);
+        public void SetSetMethod(MethodBuilder mdBuilder);
+        public override void SetValue(object obj, object value, object[] index);
+        public override void SetValue(object obj, object value, BindingFlags invokeAttr, Binder binder, object[] index, CultureInfo culture);
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct PropertyToken {
+        public static readonly PropertyToken Empty;
+        public int Token { get; }
+        public override bool Equals(object obj);
+        public bool Equals(PropertyToken obj);
+        public override int GetHashCode();
+        public static bool operator ==(PropertyToken a, PropertyToken b);
+        public static bool operator !=(PropertyToken a, PropertyToken b);
+    }
+    public sealed class SignatureHelper {
+        public void AddArgument(Type clsArgument);
+        public void AddArgument(Type argument, bool pinned);
+        public void AddArgument(Type argument, Type[] requiredCustomModifiers, Type[] optionalCustomModifiers);
+        public void AddArguments(Type[] arguments, Type[][] requiredCustomModifiers, Type[][] optionalCustomModifiers);
+        public void AddSentinel();
+        public override bool Equals(object obj);
+        public static SignatureHelper GetFieldSigHelper(Module mod);
+        public override int GetHashCode();
+        public static SignatureHelper GetLocalVarSigHelper();
+        public static SignatureHelper GetLocalVarSigHelper(Module mod);
+        public static SignatureHelper GetMethodSigHelper(CallingConventions callingConvention, Type returnType);
+        public static SignatureHelper GetMethodSigHelper(Module mod, CallingConventions callingConvention, Type returnType);
+        public static SignatureHelper GetMethodSigHelper(Module mod, CallingConvention unmanagedCallConv, Type returnType);
+        public static SignatureHelper GetMethodSigHelper(Module mod, Type returnType, Type[] parameterTypes);
+        public static SignatureHelper GetMethodSigHelper(CallingConvention unmanagedCallingConvention, Type returnType);
+        public static SignatureHelper GetPropertySigHelper(Module mod, CallingConventions callingConvention, Type returnType, Type[] requiredReturnTypeCustomModifiers, Type[] optionalReturnTypeCustomModifiers, Type[] parameterTypes, Type[][] requiredParameterTypeCustomModifiers, Type[][] optionalParameterTypeCustomModifiers);
+        public static SignatureHelper GetPropertySigHelper(Module mod, Type returnType, Type[] parameterTypes);
+        public static SignatureHelper GetPropertySigHelper(Module mod, Type returnType, Type[] requiredReturnTypeCustomModifiers, Type[] optionalReturnTypeCustomModifiers, Type[] parameterTypes, Type[][] requiredParameterTypeCustomModifiers, Type[][] optionalParameterTypeCustomModifiers);
+        public byte[] GetSignature();
+        public override string ToString();
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct SignatureToken {
+        public static readonly SignatureToken Empty;
+        public int Token { get; }
+        public override bool Equals(object obj);
+        public bool Equals(SignatureToken obj);
+        public override int GetHashCode();
+        public static bool operator ==(SignatureToken a, SignatureToken b);
+        public static bool operator !=(SignatureToken a, SignatureToken b);
+    }
+    public enum StackBehaviour {
+        Pop0 = 0,
+        Pop1 = 1,
+        Pop1_pop1 = 2,
+        Popi = 3,
+        Popi_pop1 = 4,
+        Popi_popi = 5,
+        Popi_popi_popi = 7,
+        Popi_popi8 = 6,
+        Popi_popr4 = 8,
+        Popi_popr8 = 9,
+        Popref = 10,
+        Popref_pop1 = 11,
+        Popref_popi = 12,
+        Popref_popi_pop1 = 28,
+        Popref_popi_popi = 13,
+        Popref_popi_popi8 = 14,
+        Popref_popi_popr4 = 15,
+        Popref_popi_popr8 = 16,
+        Popref_popi_popref = 17,
+        Push0 = 18,
+        Push1 = 19,
+        Push1_push1 = 20,
+        Pushi = 21,
+        Pushi8 = 22,
+        Pushr4 = 23,
+        Pushr8 = 24,
+        Pushref = 25,
+        Varpop = 26,
+        Varpush = 27,
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct StringToken {
+        public int Token { get; }
+        public override bool Equals(object obj);
+        public bool Equals(StringToken obj);
+        public override int GetHashCode();
+        public static bool operator ==(StringToken a, StringToken b);
+        public static bool operator !=(StringToken a, StringToken b);
+    }
+    public sealed class TypeBuilder : TypeInfo {
+        public const int UnspecifiedTypeSize = 0;
+        public override Assembly Assembly { get; }
+        public override string AssemblyQualifiedName { get; }
+        public override TypeAttributes Attributes { get; }
+        public override Type BaseType { get; }
+        public override bool ContainsGenericParameters { get; }
+        public override MethodBase DeclaringMethod { get; }
+        public override Type DeclaringType { get; }
+        public override string FullName { get; }
+        public override GenericParameterAttributes GenericParameterAttributes { get; }
+        public override int GenericParameterPosition { get; }
+        public override Type[] GenericTypeArguments { get; }
+        public override Guid GUID { get; }
+        public override bool IsConstructedGenericType { get; }
+        public override bool IsEnum { get; }
+        public override bool IsGenericParameter { get; }
+        public override bool IsGenericType { get; }
+        public override bool IsGenericTypeDefinition { get; }
+        public override bool IsSerializable { get; }
+        public override Module Module { get; }
+        public override string Name { get; }
+        public override string Namespace { get; }
+        public PackingSize PackingSize { get; }
+        public override Type ReflectedType { get; }
+        public int Size { get; }
+        public override RuntimeTypeHandle TypeHandle { get; }
+        public TypeToken TypeToken { get; }
+        public override Type UnderlyingSystemType { get; }
+        public void AddInterfaceImplementation(Type interfaceType);
+        public Type CreateType();
+        public TypeInfo CreateTypeInfo();
+        public ConstructorBuilder DefineConstructor(MethodAttributes attributes, CallingConventions callingConvention, Type[] parameterTypes);
+        public ConstructorBuilder DefineConstructor(MethodAttributes attributes, CallingConventions callingConvention, Type[] parameterTypes, Type[][] requiredCustomModifiers, Type[][] optionalCustomModifiers);
+        public ConstructorBuilder DefineDefaultConstructor(MethodAttributes attributes);
+        public EventBuilder DefineEvent(string name, EventAttributes attributes, Type eventtype);
+        public FieldBuilder DefineField(string fieldName, Type type, FieldAttributes attributes);
+        public FieldBuilder DefineField(string fieldName, Type type, Type[] requiredCustomModifiers, Type[] optionalCustomModifiers, FieldAttributes attributes);
+        public GenericTypeParameterBuilder[] DefineGenericParameters(params string[] names);
+        public FieldBuilder DefineInitializedData(string name, byte[] data, FieldAttributes attributes);
+        public MethodBuilder DefineMethod(string name, MethodAttributes attributes);
+        public MethodBuilder DefineMethod(string name, MethodAttributes attributes, CallingConventions callingConvention);
+        public MethodBuilder DefineMethod(string name, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] parameterTypes);
+        public MethodBuilder DefineMethod(string name, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers, Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers);
+        public MethodBuilder DefineMethod(string name, MethodAttributes attributes, Type returnType, Type[] parameterTypes);
+        public void DefineMethodOverride(MethodInfo methodInfoBody, MethodInfo methodInfoDeclaration);
+        public TypeBuilder DefineNestedType(string name);
+        public TypeBuilder DefineNestedType(string name, TypeAttributes attr);
+        public TypeBuilder DefineNestedType(string name, TypeAttributes attr, Type parent);
+        public TypeBuilder DefineNestedType(string name, TypeAttributes attr, Type parent, int typeSize);
+        public TypeBuilder DefineNestedType(string name, TypeAttributes attr, Type parent, PackingSize packSize);
+        public TypeBuilder DefineNestedType(string name, TypeAttributes attr, Type parent, PackingSize packSize, int typeSize);
+        public TypeBuilder DefineNestedType(string name, TypeAttributes attr, Type parent, Type[] interfaces);
+        public PropertyBuilder DefineProperty(string name, PropertyAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] parameterTypes);
+        public PropertyBuilder DefineProperty(string name, PropertyAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers, Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers);
+        public PropertyBuilder DefineProperty(string name, PropertyAttributes attributes, Type returnType, Type[] parameterTypes);
+        public PropertyBuilder DefineProperty(string name, PropertyAttributes attributes, Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers, Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers);
+        public ConstructorBuilder DefineTypeInitializer();
+        public FieldBuilder DefineUninitializedData(string name, int size, FieldAttributes attributes);
+        public override int GetArrayRank();
+        protected override TypeAttributes GetAttributeFlagsImpl();
+        public static ConstructorInfo GetConstructor(Type type, ConstructorInfo constructor);
+        protected override ConstructorInfo GetConstructorImpl(BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
+        public override ConstructorInfo[] GetConstructors(BindingFlags bindingAttr);
+        public override object[] GetCustomAttributes(bool inherit);
+        public override object[] GetCustomAttributes(Type attributeType, bool inherit);
+        public override Type GetElementType();
+        public override EventInfo GetEvent(string name, BindingFlags bindingAttr);
+        public override EventInfo[] GetEvents();
+        public override EventInfo[] GetEvents(BindingFlags bindingAttr);
+        public override FieldInfo GetField(string name, BindingFlags bindingAttr);
+        public static FieldInfo GetField(Type type, FieldInfo field);
+        public override FieldInfo[] GetFields(BindingFlags bindingAttr);
+        public override Type[] GetGenericArguments();
+        public override Type[] GetGenericParameterConstraints();
+        public override Type GetGenericTypeDefinition();
+        public override Type GetInterface(string name, bool ignoreCase);
+        public override InterfaceMapping GetInterfaceMap(Type interfaceType);
+        public override Type[] GetInterfaces();
+        public override MemberInfo[] GetMember(string name, MemberTypes type, BindingFlags bindingAttr);
+        public override MemberInfo[] GetMembers(BindingFlags bindingAttr);
+        public static MethodInfo GetMethod(Type type, MethodInfo method);
+        protected override MethodInfo GetMethodImpl(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
+        public override MethodInfo[] GetMethods(BindingFlags bindingAttr);
+        public override Type GetNestedType(string name, BindingFlags bindingAttr);
+        public override Type[] GetNestedTypes(BindingFlags bindingAttr);
+        public override PropertyInfo[] GetProperties(BindingFlags bindingAttr);
+        protected override PropertyInfo GetPropertyImpl(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers);
+        protected override bool HasElementTypeImpl();
+        public override object InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, object[] args, ParameterModifier[] modifiers, CultureInfo culture, string[] namedParameters);
+        protected override bool IsArrayImpl();
+        public override bool IsAssignableFrom(TypeInfo typeInfo);
+        public override bool IsAssignableFrom(Type c);
+        protected override bool IsByRefImpl();
+        protected override bool IsCOMObjectImpl();
+        public bool IsCreated();
+        public override bool IsDefined(Type attributeType, bool inherit);
+        protected override bool IsPointerImpl();
+        protected override bool IsPrimitiveImpl();
+        public override bool IsSubclassOf(Type c);
+        public override Type MakeArrayType();
+        public override Type MakeArrayType(int rank);
+        public override Type MakeByRefType();
+        public override Type MakeGenericType(params Type[] typeArguments);
+        public override Type MakePointerType();
+        public void SetCustomAttribute(ConstructorInfo con, byte[] binaryAttribute);
+        public void SetCustomAttribute(CustomAttributeBuilder customBuilder);
+        public void SetParent(Type parent);
+        public override string ToString();
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct TypeToken {
+        public static readonly TypeToken Empty;
+        public int Token { get; }
+        public override bool Equals(object obj);
+        public bool Equals(TypeToken obj);
+        public override int GetHashCode();
+        public static bool operator ==(TypeToken a, TypeToken b);
+        public static bool operator !=(TypeToken a, TypeToken b);
+    }
+}
```

## System.Reflection.Metadata

```c#
+namespace System.Reflection.Metadata {
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct AssemblyDefinition {
+        public StringHandle Culture { get; }
+        public AssemblyFlags Flags { get; }
+        public AssemblyHashAlgorithm HashAlgorithm { get; }
+        public StringHandle Name { get; }
+        public BlobHandle PublicKey { get; }
+        public Version Version { get; }
+        public CustomAttributeHandleCollection GetCustomAttributes();
+        public DeclarativeSecurityAttributeHandleCollection GetDeclarativeSecurityAttributes();
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct AssemblyDefinitionHandle : IEquatable<AssemblyDefinitionHandle> {
+        public bool IsNil { get; }
+        public override bool Equals(object obj);
+        public bool Equals(AssemblyDefinitionHandle other);
+        public override int GetHashCode();
+        public static bool operator ==(AssemblyDefinitionHandle left, AssemblyDefinitionHandle right);
+        public static explicit operator AssemblyDefinitionHandle (EntityHandle handle);
+        public static explicit operator AssemblyDefinitionHandle (Handle handle);
+        public static implicit operator Handle (AssemblyDefinitionHandle handle);
+        public static implicit operator EntityHandle (AssemblyDefinitionHandle handle);
+        public static bool operator !=(AssemblyDefinitionHandle left, AssemblyDefinitionHandle right);
+    }
+    public static class AssemblyExtensions {
+        public unsafe static bool TryGetRawMetadata(this Assembly assembly, out byte* blob, out int length);
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct AssemblyFile {
+        public bool ContainsMetadata { get; }
+        public BlobHandle HashValue { get; }
+        public StringHandle Name { get; }
+        public CustomAttributeHandleCollection GetCustomAttributes();
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct AssemblyFileHandle : IEquatable<AssemblyFileHandle> {
+        public bool IsNil { get; }
+        public override bool Equals(object obj);
+        public bool Equals(AssemblyFileHandle other);
+        public override int GetHashCode();
+        public static bool operator ==(AssemblyFileHandle left, AssemblyFileHandle right);
+        public static explicit operator AssemblyFileHandle (EntityHandle handle);
+        public static explicit operator AssemblyFileHandle (Handle handle);
+        public static implicit operator Handle (AssemblyFileHandle handle);
+        public static implicit operator EntityHandle (AssemblyFileHandle handle);
+        public static bool operator !=(AssemblyFileHandle left, AssemblyFileHandle right);
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct AssemblyFileHandleCollection : IEnumerable, IEnumerable<AssemblyFileHandle>, IReadOnlyCollection<AssemblyFileHandle> {
+        public int Count { get; }
+        public AssemblyFileHandleCollection.Enumerator GetEnumerator();
+        IEnumerator<AssemblyFileHandle> System.Collections.Generic.IEnumerable<System.Reflection.Metadata.AssemblyFileHandle>.GetEnumerator();
+        IEnumerator System.Collections.IEnumerable.GetEnumerator();
+        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+        public struct Enumerator : IDisposable, IEnumerator, IEnumerator<AssemblyFileHandle> {
+            public AssemblyFileHandle Current { get; }
+            object System.Collections.IEnumerator.Current { get; }
+            public bool MoveNext();
+            void System.Collections.IEnumerator.Reset();
+            void System.IDisposable.Dispose();
+        }
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct AssemblyReference {
+        public StringHandle Culture { get; }
+        public AssemblyFlags Flags { get; }
+        public BlobHandle HashValue { get; }
+        public StringHandle Name { get; }
+        public BlobHandle PublicKeyOrToken { get; }
+        public Version Version { get; }
+        public CustomAttributeHandleCollection GetCustomAttributes();
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct AssemblyReferenceHandle : IEquatable<AssemblyReferenceHandle> {
+        public bool IsNil { get; }
+        public override bool Equals(object obj);
+        public bool Equals(AssemblyReferenceHandle other);
+        public override int GetHashCode();
+        public static bool operator ==(AssemblyReferenceHandle left, AssemblyReferenceHandle right);
+        public static explicit operator AssemblyReferenceHandle (EntityHandle handle);
+        public static explicit operator AssemblyReferenceHandle (Handle handle);
+        public static implicit operator Handle (AssemblyReferenceHandle handle);
+        public static implicit operator EntityHandle (AssemblyReferenceHandle handle);
+        public static bool operator !=(AssemblyReferenceHandle left, AssemblyReferenceHandle right);
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct AssemblyReferenceHandleCollection : IEnumerable, IEnumerable<AssemblyReferenceHandle>, IReadOnlyCollection<AssemblyReferenceHandle> {
+        public int Count { get; }
+        public AssemblyReferenceHandleCollection.Enumerator GetEnumerator();
+        IEnumerator<AssemblyReferenceHandle> System.Collections.Generic.IEnumerable<System.Reflection.Metadata.AssemblyReferenceHandle>.GetEnumerator();
+        IEnumerator System.Collections.IEnumerable.GetEnumerator();
+        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+        public struct Enumerator : IDisposable, IEnumerator, IEnumerator<AssemblyReferenceHandle> {
+            public AssemblyReferenceHandle Current { get; }
+            object System.Collections.IEnumerator.Current { get; }
+            public bool MoveNext();
+            void System.Collections.IEnumerator.Reset();
+            void System.IDisposable.Dispose();
+        }
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct BlobHandle : IEquatable<BlobHandle> {
+        public bool IsNil { get; }
+        public override bool Equals(object obj);
+        public bool Equals(BlobHandle other);
+        public override int GetHashCode();
+        public static bool operator ==(BlobHandle left, BlobHandle right);
+        public static explicit operator BlobHandle (Handle handle);
+        public static implicit operator Handle (BlobHandle handle);
+        public static bool operator !=(BlobHandle left, BlobHandle right);
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct BlobReader {
+        public unsafe BlobReader(byte* buffer, int length);
+        public int Length { get; }
+        public int Offset { get; }
+        public int RemainingBytes { get; }
+        public BlobHandle ReadBlobHandle();
+        public bool ReadBoolean();
+        public byte ReadByte();
+        public byte[] ReadBytes(int byteCount);
+        public char ReadChar();
+        public int ReadCompressedInteger();
+        public int ReadCompressedSignedInteger();
+        public object ReadConstant(ConstantTypeCode typeCode);
+        public DateTime ReadDateTime();
+        public Decimal ReadDecimal();
+        public double ReadDouble();
+        public Guid ReadGuid();
+        public short ReadInt16();
+        public int ReadInt32();
+        public long ReadInt64();
+        public sbyte ReadSByte();
+        public SerializationTypeCode ReadSerializationTypeCode();
+        public string ReadSerializedString();
+        public SignatureHeader ReadSignatureHeader();
+        public SignatureTypeCode ReadSignatureTypeCode();
+        public float ReadSingle();
+        public EntityHandle ReadTypeHandle();
+        public ushort ReadUInt16();
+        public uint ReadUInt32();
+        public ulong ReadUInt64();
+        public string ReadUTF16(int byteCount);
+        public string ReadUTF8(int byteCount);
+        public void Reset();
+        public bool TryReadCompressedInteger(out int value);
+        public bool TryReadCompressedSignedInteger(out int value);
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct Constant {
+        public EntityHandle Parent { get; }
+        public ConstantTypeCode TypeCode { get; }
+        public BlobHandle Value { get; }
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct ConstantHandle : IEquatable<ConstantHandle> {
+        public bool IsNil { get; }
+        public override bool Equals(object obj);
+        public bool Equals(ConstantHandle other);
+        public override int GetHashCode();
+        public static bool operator ==(ConstantHandle left, ConstantHandle right);
+        public static explicit operator ConstantHandle (EntityHandle handle);
+        public static explicit operator ConstantHandle (Handle handle);
+        public static implicit operator Handle (ConstantHandle handle);
+        public static implicit operator EntityHandle (ConstantHandle handle);
+        public static bool operator !=(ConstantHandle left, ConstantHandle right);
+    }
+    public enum ConstantTypeCode : byte {
+        Boolean = (byte)2,
+        Byte = (byte)5,
+        Char = (byte)3,
+        Double = (byte)13,
+        Int16 = (byte)6,
+        Int32 = (byte)8,
+        Int64 = (byte)10,
+        Invalid = (byte)0,
+        NullReference = (byte)18,
+        SByte = (byte)4,
+        Single = (byte)12,
+        String = (byte)14,
+        UInt16 = (byte)7,
+        UInt32 = (byte)9,
+        UInt64 = (byte)11,
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct CustomAttribute {
+        public EntityHandle Constructor { get; }
+        public EntityHandle Parent { get; }
+        public BlobHandle Value { get; }
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct CustomAttributeHandle : IEquatable<CustomAttributeHandle> {
+        public bool IsNil { get; }
+        public override bool Equals(object obj);
+        public bool Equals(CustomAttributeHandle other);
+        public override int GetHashCode();
+        public static bool operator ==(CustomAttributeHandle left, CustomAttributeHandle right);
+        public static explicit operator CustomAttributeHandle (EntityHandle handle);
+        public static explicit operator CustomAttributeHandle (Handle handle);
+        public static implicit operator Handle (CustomAttributeHandle handle);
+        public static implicit operator EntityHandle (CustomAttributeHandle handle);
+        public static bool operator !=(CustomAttributeHandle left, CustomAttributeHandle right);
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct CustomAttributeHandleCollection : IEnumerable, IEnumerable<CustomAttributeHandle>, IReadOnlyCollection<CustomAttributeHandle> {
+        public int Count { get; }
+        public CustomAttributeHandleCollection.Enumerator GetEnumerator();
+        IEnumerator<CustomAttributeHandle> System.Collections.Generic.IEnumerable<System.Reflection.Metadata.CustomAttributeHandle>.GetEnumerator();
+        IEnumerator System.Collections.IEnumerable.GetEnumerator();
+        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+        public struct Enumerator : IDisposable, IEnumerator, IEnumerator<CustomAttributeHandle> {
+            public CustomAttributeHandle Current { get; }
+            object System.Collections.IEnumerator.Current { get; }
+            public bool MoveNext();
+            void System.Collections.IEnumerator.Reset();
+            void System.IDisposable.Dispose();
+        }
+    }
+    public enum CustomAttributeNamedArgumentKind : byte {
+        Field = (byte)83,
+        Property = (byte)84,
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct CustomDebugInformation {
+        public GuidHandle Kind { get; }
+        public EntityHandle Parent { get; }
+        public BlobHandle Value { get; }
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct CustomDebugInformationHandle : IEquatable<CustomDebugInformationHandle> {
+        public bool IsNil { get; }
+        public override bool Equals(object obj);
+        public bool Equals(CustomDebugInformationHandle other);
+        public override int GetHashCode();
+        public static bool operator ==(CustomDebugInformationHandle left, CustomDebugInformationHandle right);
+        public static explicit operator CustomDebugInformationHandle (EntityHandle handle);
+        public static explicit operator CustomDebugInformationHandle (Handle handle);
+        public static implicit operator Handle (CustomDebugInformationHandle handle);
+        public static implicit operator EntityHandle (CustomDebugInformationHandle handle);
+        public static bool operator !=(CustomDebugInformationHandle left, CustomDebugInformationHandle right);
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct CustomDebugInformationHandleCollection : IEnumerable, IEnumerable<CustomDebugInformationHandle>, IReadOnlyCollection<CustomDebugInformationHandle> {
+        public int Count { get; }
+        public CustomDebugInformationHandleCollection.Enumerator GetEnumerator();
+        IEnumerator<CustomDebugInformationHandle> System.Collections.Generic.IEnumerable<System.Reflection.Metadata.CustomDebugInformationHandle>.GetEnumerator();
+        IEnumerator System.Collections.IEnumerable.GetEnumerator();
+        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+        public struct Enumerator : IDisposable, IEnumerator, IEnumerator<CustomDebugInformationHandle> {
+            public CustomDebugInformationHandle Current { get; }
+            object System.Collections.IEnumerator.Current { get; }
+            public bool MoveNext();
+            void System.Collections.IEnumerator.Reset();
+            void System.IDisposable.Dispose();
+        }
+    }
+    public sealed class DebugMetadataHeader {
+        public MethodDefinitionHandle EntryPoint { get; }
+        public ImmutableArray<byte> Id { get; }
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct DeclarativeSecurityAttribute {
+        public DeclarativeSecurityAction Action { get; }
+        public EntityHandle Parent { get; }
+        public BlobHandle PermissionSet { get; }
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct DeclarativeSecurityAttributeHandle : IEquatable<DeclarativeSecurityAttributeHandle> {
+        public bool IsNil { get; }
+        public override bool Equals(object obj);
+        public bool Equals(DeclarativeSecurityAttributeHandle other);
+        public override int GetHashCode();
+        public static bool operator ==(DeclarativeSecurityAttributeHandle left, DeclarativeSecurityAttributeHandle right);
+        public static explicit operator DeclarativeSecurityAttributeHandle (EntityHandle handle);
+        public static explicit operator DeclarativeSecurityAttributeHandle (Handle handle);
+        public static implicit operator Handle (DeclarativeSecurityAttributeHandle handle);
+        public static implicit operator EntityHandle (DeclarativeSecurityAttributeHandle handle);
+        public static bool operator !=(DeclarativeSecurityAttributeHandle left, DeclarativeSecurityAttributeHandle right);
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct DeclarativeSecurityAttributeHandleCollection : IEnumerable, IEnumerable<DeclarativeSecurityAttributeHandle>, IReadOnlyCollection<DeclarativeSecurityAttributeHandle> {
+        public int Count { get; }
+        public DeclarativeSecurityAttributeHandleCollection.Enumerator GetEnumerator();
+        IEnumerator<DeclarativeSecurityAttributeHandle> System.Collections.Generic.IEnumerable<System.Reflection.Metadata.DeclarativeSecurityAttributeHandle>.GetEnumerator();
+        IEnumerator System.Collections.IEnumerable.GetEnumerator();
+        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+        public struct Enumerator : IDisposable, IEnumerator, IEnumerator<DeclarativeSecurityAttributeHandle> {
+            public DeclarativeSecurityAttributeHandle Current { get; }
+            object System.Collections.IEnumerator.Current { get; }
+            public bool MoveNext();
+            void System.Collections.IEnumerator.Reset();
+            void System.IDisposable.Dispose();
+        }
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct Document {
+        public BlobHandle Hash { get; }
+        public GuidHandle HashAlgorithm { get; }
+        public GuidHandle Language { get; }
+        public DocumentNameBlobHandle Name { get; }
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct DocumentHandle : IEquatable<DocumentHandle> {
+        public bool IsNil { get; }
+        public override bool Equals(object obj);
+        public bool Equals(DocumentHandle other);
+        public override int GetHashCode();
+        public static bool operator ==(DocumentHandle left, DocumentHandle right);
+        public static explicit operator DocumentHandle (EntityHandle handle);
+        public static explicit operator DocumentHandle (Handle handle);
+        public static implicit operator Handle (DocumentHandle handle);
+        public static implicit operator EntityHandle (DocumentHandle handle);
+        public static bool operator !=(DocumentHandle left, DocumentHandle right);
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct DocumentHandleCollection : IEnumerable, IEnumerable<DocumentHandle>, IReadOnlyCollection<DocumentHandle> {
+        public int Count { get; }
+        public DocumentHandleCollection.Enumerator GetEnumerator();
+        IEnumerator<DocumentHandle> System.Collections.Generic.IEnumerable<System.Reflection.Metadata.DocumentHandle>.GetEnumerator();
+        IEnumerator System.Collections.IEnumerable.GetEnumerator();
+        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+        public struct Enumerator : IDisposable, IEnumerator, IEnumerator<DocumentHandle> {
+            public DocumentHandle Current { get; }
+            object System.Collections.IEnumerator.Current { get; }
+            public bool MoveNext();
+            void System.Collections.IEnumerator.Reset();
+            void System.IDisposable.Dispose();
+        }
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct DocumentNameBlobHandle : IEquatable<DocumentNameBlobHandle> {
+        public bool IsNil { get; }
+        public override bool Equals(object obj);
+        public bool Equals(DocumentNameBlobHandle other);
+        public override int GetHashCode();
+        public static bool operator ==(DocumentNameBlobHandle left, DocumentNameBlobHandle right);
+        public static explicit operator DocumentNameBlobHandle (BlobHandle handle);
+        public static implicit operator BlobHandle (DocumentNameBlobHandle handle);
+        public static bool operator !=(DocumentNameBlobHandle left, DocumentNameBlobHandle right);
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct EntityHandle : IEquatable<EntityHandle> {
+        public static readonly AssemblyDefinitionHandle AssemblyDefinition;
+        public static readonly ModuleDefinitionHandle ModuleDefinition;
+        public bool IsNil { get; }
+        public HandleKind Kind { get; }
+        public override bool Equals(object obj);
+        public bool Equals(EntityHandle other);
+        public override int GetHashCode();
+        public static bool operator ==(EntityHandle left, EntityHandle right);
+        public static explicit operator EntityHandle (Handle handle);
+        public static implicit operator Handle (EntityHandle handle);
+        public static bool operator !=(EntityHandle left, EntityHandle right);
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct EventAccessors {
+        public MethodDefinitionHandle Adder { get; }
+        public MethodDefinitionHandle Raiser { get; }
+        public MethodDefinitionHandle Remover { get; }
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct EventDefinition {
+        public EventAttributes Attributes { get; }
+        public StringHandle Name { get; }
+        public EntityHandle Type { get; }
+        public EventAccessors GetAccessors();
+        public CustomAttributeHandleCollection GetCustomAttributes();
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct EventDefinitionHandle : IEquatable<EventDefinitionHandle> {
+        public bool IsNil { get; }
+        public override bool Equals(object obj);
+        public bool Equals(EventDefinitionHandle other);
+        public override int GetHashCode();
+        public static bool operator ==(EventDefinitionHandle left, EventDefinitionHandle right);
+        public static explicit operator EventDefinitionHandle (EntityHandle handle);
+        public static explicit operator EventDefinitionHandle (Handle handle);
+        public static implicit operator Handle (EventDefinitionHandle handle);
+        public static implicit operator EntityHandle (EventDefinitionHandle handle);
+        public static bool operator !=(EventDefinitionHandle left, EventDefinitionHandle right);
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct EventDefinitionHandleCollection : IEnumerable, IEnumerable<EventDefinitionHandle>, IReadOnlyCollection<EventDefinitionHandle> {
+        public int Count { get; }
+        public EventDefinitionHandleCollection.Enumerator GetEnumerator();
+        IEnumerator<EventDefinitionHandle> System.Collections.Generic.IEnumerable<System.Reflection.Metadata.EventDefinitionHandle>.GetEnumerator();
+        IEnumerator System.Collections.IEnumerable.GetEnumerator();
+        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+        public struct Enumerator : IDisposable, IEnumerator, IEnumerator<EventDefinitionHandle> {
+            public EventDefinitionHandle Current { get; }
+            object System.Collections.IEnumerator.Current { get; }
+            public bool MoveNext();
+            void System.Collections.IEnumerator.Reset();
+            void System.IDisposable.Dispose();
+        }
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct ExceptionRegion {
+        public EntityHandle CatchType { get; }
+        public int FilterOffset { get; }
+        public int HandlerLength { get; }
+        public int HandlerOffset { get; }
+        public ExceptionRegionKind Kind { get; }
+        public int TryLength { get; }
+        public int TryOffset { get; }
+    }
+    public enum ExceptionRegionKind : ushort {
+        Catch = (ushort)0,
+        Fault = (ushort)4,
+        Filter = (ushort)1,
+        Finally = (ushort)2,
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct ExportedType {
+        public TypeAttributes Attributes { get; }
+        public EntityHandle Implementation { get; }
+        public bool IsForwarder { get; }
+        public StringHandle Name { get; }
+        public StringHandle Namespace { get; }
+        public NamespaceDefinitionHandle NamespaceDefinition { get; }
+        public CustomAttributeHandleCollection GetCustomAttributes();
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct ExportedTypeHandle : IEquatable<ExportedTypeHandle> {
+        public bool IsNil { get; }
+        public override bool Equals(object obj);
+        public bool Equals(ExportedTypeHandle other);
+        public override int GetHashCode();
+        public static bool operator ==(ExportedTypeHandle left, ExportedTypeHandle right);
+        public static explicit operator ExportedTypeHandle (EntityHandle handle);
+        public static explicit operator ExportedTypeHandle (Handle handle);
+        public static implicit operator Handle (ExportedTypeHandle handle);
+        public static implicit operator EntityHandle (ExportedTypeHandle handle);
+        public static bool operator !=(ExportedTypeHandle left, ExportedTypeHandle right);
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct ExportedTypeHandleCollection : IEnumerable, IEnumerable<ExportedTypeHandle>, IReadOnlyCollection<ExportedTypeHandle> {
+        public int Count { get; }
+        public ExportedTypeHandleCollection.Enumerator GetEnumerator();
+        IEnumerator<ExportedTypeHandle> System.Collections.Generic.IEnumerable<System.Reflection.Metadata.ExportedTypeHandle>.GetEnumerator();
+        IEnumerator System.Collections.IEnumerable.GetEnumerator();
+        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+        public struct Enumerator : IDisposable, IEnumerator, IEnumerator<ExportedTypeHandle> {
+            public ExportedTypeHandle Current { get; }
+            object System.Collections.IEnumerator.Current { get; }
+            public bool MoveNext();
+            void System.Collections.IEnumerator.Reset();
+            void System.IDisposable.Dispose();
+        }
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct FieldDefinition {
+        public FieldAttributes Attributes { get; }
+        public StringHandle Name { get; }
+        public BlobHandle Signature { get; }
+        public CustomAttributeHandleCollection GetCustomAttributes();
+        public TypeDefinitionHandle GetDeclaringType();
+        public ConstantHandle GetDefaultValue();
+        public BlobHandle GetMarshallingDescriptor();
+        public int GetOffset();
+        public int GetRelativeVirtualAddress();
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct FieldDefinitionHandle : IEquatable<FieldDefinitionHandle> {
+        public bool IsNil { get; }
+        public override bool Equals(object obj);
+        public bool Equals(FieldDefinitionHandle other);
+        public override int GetHashCode();
+        public static bool operator ==(FieldDefinitionHandle left, FieldDefinitionHandle right);
+        public static explicit operator FieldDefinitionHandle (EntityHandle handle);
+        public static explicit operator FieldDefinitionHandle (Handle handle);
+        public static implicit operator Handle (FieldDefinitionHandle handle);
+        public static implicit operator EntityHandle (FieldDefinitionHandle handle);
+        public static bool operator !=(FieldDefinitionHandle left, FieldDefinitionHandle right);
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct FieldDefinitionHandleCollection : IEnumerable, IEnumerable<FieldDefinitionHandle>, IReadOnlyCollection<FieldDefinitionHandle> {
+        public int Count { get; }
+        public FieldDefinitionHandleCollection.Enumerator GetEnumerator();
+        IEnumerator<FieldDefinitionHandle> System.Collections.Generic.IEnumerable<System.Reflection.Metadata.FieldDefinitionHandle>.GetEnumerator();
+        IEnumerator System.Collections.IEnumerable.GetEnumerator();
+        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+        public struct Enumerator : IDisposable, IEnumerator, IEnumerator<FieldDefinitionHandle> {
+            public FieldDefinitionHandle Current { get; }
+            object System.Collections.IEnumerator.Current { get; }
+            public bool MoveNext();
+            void System.Collections.IEnumerator.Reset();
+            void System.IDisposable.Dispose();
+        }
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct GenericParameter {
+        public GenericParameterAttributes Attributes { get; }
+        public int Index { get; }
+        public StringHandle Name { get; }
+        public EntityHandle Parent { get; }
+        public GenericParameterConstraintHandleCollection GetConstraints();
+        public CustomAttributeHandleCollection GetCustomAttributes();
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct GenericParameterConstraint {
+        public GenericParameterHandle Parameter { get; }
+        public EntityHandle Type { get; }
+        public CustomAttributeHandleCollection GetCustomAttributes();
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct GenericParameterConstraintHandle : IEquatable<GenericParameterConstraintHandle> {
+        public bool IsNil { get; }
+        public override bool Equals(object obj);
+        public bool Equals(GenericParameterConstraintHandle other);
+        public override int GetHashCode();
+        public static bool operator ==(GenericParameterConstraintHandle left, GenericParameterConstraintHandle right);
+        public static explicit operator GenericParameterConstraintHandle (EntityHandle handle);
+        public static explicit operator GenericParameterConstraintHandle (Handle handle);
+        public static implicit operator Handle (GenericParameterConstraintHandle handle);
+        public static implicit operator EntityHandle (GenericParameterConstraintHandle handle);
+        public static bool operator !=(GenericParameterConstraintHandle left, GenericParameterConstraintHandle right);
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct GenericParameterConstraintHandleCollection : IEnumerable, IEnumerable<GenericParameterConstraintHandle>, IReadOnlyCollection<GenericParameterConstraintHandle>, IReadOnlyList<GenericParameterConstraintHandle> {
+        public int Count { get; }
+        public GenericParameterConstraintHandle this[int index] { get; }
+        public GenericParameterConstraintHandleCollection.Enumerator GetEnumerator();
+        IEnumerator<GenericParameterConstraintHandle> System.Collections.Generic.IEnumerable<System.Reflection.Metadata.GenericParameterConstraintHandle>.GetEnumerator();
+        IEnumerator System.Collections.IEnumerable.GetEnumerator();
+        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+        public struct Enumerator : IDisposable, IEnumerator, IEnumerator<GenericParameterConstraintHandle> {
+            public GenericParameterConstraintHandle Current { get; }
+            object System.Collections.IEnumerator.Current { get; }
+            public bool MoveNext();
+            void System.Collections.IEnumerator.Reset();
+            void System.IDisposable.Dispose();
+        }
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct GenericParameterHandle : IEquatable<GenericParameterHandle> {
+        public bool IsNil { get; }
+        public override bool Equals(object obj);
+        public bool Equals(GenericParameterHandle other);
+        public override int GetHashCode();
+        public static bool operator ==(GenericParameterHandle left, GenericParameterHandle right);
+        public static explicit operator GenericParameterHandle (EntityHandle handle);
+        public static explicit operator GenericParameterHandle (Handle handle);
+        public static implicit operator Handle (GenericParameterHandle handle);
+        public static implicit operator EntityHandle (GenericParameterHandle handle);
+        public static bool operator !=(GenericParameterHandle left, GenericParameterHandle right);
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct GenericParameterHandleCollection : IEnumerable, IEnumerable<GenericParameterHandle>, IReadOnlyCollection<GenericParameterHandle>, IReadOnlyList<GenericParameterHandle> {
+        public int Count { get; }
+        public GenericParameterHandle this[int index] { get; }
+        public GenericParameterHandleCollection.Enumerator GetEnumerator();
+        IEnumerator<GenericParameterHandle> System.Collections.Generic.IEnumerable<System.Reflection.Metadata.GenericParameterHandle>.GetEnumerator();
+        IEnumerator System.Collections.IEnumerable.GetEnumerator();
+        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+        public struct Enumerator : IDisposable, IEnumerator, IEnumerator<GenericParameterHandle> {
+            public GenericParameterHandle Current { get; }
+            object System.Collections.IEnumerator.Current { get; }
+            public bool MoveNext();
+            void System.Collections.IEnumerator.Reset();
+            void System.IDisposable.Dispose();
+        }
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct GuidHandle : IEquatable<GuidHandle> {
+        public bool IsNil { get; }
+        public override bool Equals(object obj);
+        public bool Equals(GuidHandle other);
+        public override int GetHashCode();
+        public static bool operator ==(GuidHandle left, GuidHandle right);
+        public static explicit operator GuidHandle (Handle handle);
+        public static implicit operator Handle (GuidHandle handle);
+        public static bool operator !=(GuidHandle left, GuidHandle right);
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct Handle : IEquatable<Handle> {
+        public static readonly AssemblyDefinitionHandle AssemblyDefinition;
+        public static readonly ModuleDefinitionHandle ModuleDefinition;
+        public bool IsNil { get; }
+        public HandleKind Kind { get; }
+        public override bool Equals(object obj);
+        public bool Equals(Handle other);
+        public override int GetHashCode();
+        public static bool operator ==(Handle left, Handle right);
+        public static bool operator !=(Handle left, Handle right);
+    }
+    public sealed class HandleComparer : IComparer<EntityHandle>, IComparer<Handle>, IEqualityComparer<EntityHandle>, IEqualityComparer<Handle> {
+        public static HandleComparer Default { get; }
+        public int Compare(EntityHandle x, EntityHandle y);
+        public int Compare(Handle x, Handle y);
+        public bool Equals(EntityHandle x, EntityHandle y);
+        public bool Equals(Handle x, Handle y);
+        public int GetHashCode(EntityHandle obj);
+        public int GetHashCode(Handle obj);
+    }
+    public enum HandleKind : byte {
+        AssemblyDefinition = (byte)32,
+        AssemblyFile = (byte)38,
+        AssemblyReference = (byte)35,
+        Blob = (byte)113,
+        Constant = (byte)11,
+        CustomAttribute = (byte)12,
+        CustomDebugInformation = (byte)55,
+        DeclarativeSecurityAttribute = (byte)14,
+        Document = (byte)48,
+        EventDefinition = (byte)20,
+        ExportedType = (byte)39,
+        FieldDefinition = (byte)4,
+        GenericParameter = (byte)42,
+        GenericParameterConstraint = (byte)44,
+        Guid = (byte)114,
+        ImportScope = (byte)53,
+        InterfaceImplementation = (byte)9,
+        LocalConstant = (byte)52,
+        LocalScope = (byte)50,
+        LocalVariable = (byte)51,
+        ManifestResource = (byte)40,
+        MemberReference = (byte)10,
+        MethodDebugInformation = (byte)49,
+        MethodDefinition = (byte)6,
+        MethodImplementation = (byte)25,
+        MethodSpecification = (byte)43,
+        ModuleDefinition = (byte)0,
+        ModuleReference = (byte)26,
+        NamespaceDefinition = (byte)124,
+        Parameter = (byte)8,
+        PropertyDefinition = (byte)23,
+        StandaloneSignature = (byte)17,
+        String = (byte)120,
+        TypeDefinition = (byte)2,
+        TypeReference = (byte)1,
+        TypeSpecification = (byte)27,
+        UserString = (byte)112,
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct ImportDefinition {
+        public BlobHandle Alias { get; }
+        public ImportDefinitionKind Kind { get; }
+        public AssemblyReferenceHandle TargetAssembly { get; }
+        public BlobHandle TargetNamespace { get; }
+        public EntityHandle TargetType { get; }
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct ImportDefinitionCollection : IEnumerable, IEnumerable<ImportDefinition> {
+        public ImportDefinitionCollection.Enumerator GetEnumerator();
+        IEnumerator<ImportDefinition> System.Collections.Generic.IEnumerable<System.Reflection.Metadata.ImportDefinition>.GetEnumerator();
+        IEnumerator System.Collections.IEnumerable.GetEnumerator();
+        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+        public struct Enumerator : IDisposable, IEnumerator, IEnumerator<ImportDefinition> {
+            public ImportDefinition Current { get; }
+            object System.Collections.IEnumerator.Current { get; }
+            public bool MoveNext();
+            public void Reset();
+            void System.IDisposable.Dispose();
+        }
+    }
+    public enum ImportDefinitionKind {
+        AliasAssemblyNamespace = 8,
+        AliasAssemblyReference = 6,
+        AliasNamespace = 7,
+        AliasType = 9,
+        ImportAssemblyNamespace = 2,
+        ImportAssemblyReferenceAlias = 5,
+        ImportNamespace = 1,
+        ImportType = 3,
+        ImportXmlNamespace = 4,
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct ImportScope {
+        public BlobHandle ImportsBlob { get; }
+        public ImportScopeHandle Parent { get; }
+        public ImportDefinitionCollection GetImports();
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct ImportScopeCollection : IEnumerable, IEnumerable<ImportScopeHandle>, IReadOnlyCollection<ImportScopeHandle> {
+        public int Count { get; }
+        public ImportScopeCollection.Enumerator GetEnumerator();
+        IEnumerator<ImportScopeHandle> System.Collections.Generic.IEnumerable<System.Reflection.Metadata.ImportScopeHandle>.GetEnumerator();
+        IEnumerator System.Collections.IEnumerable.GetEnumerator();
+        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+        public struct Enumerator : IDisposable, IEnumerator, IEnumerator<ImportScopeHandle> {
+            public ImportScopeHandle Current { get; }
+            object System.Collections.IEnumerator.Current { get; }
+            public bool MoveNext();
+            void System.Collections.IEnumerator.Reset();
+            void System.IDisposable.Dispose();
+        }
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct ImportScopeHandle : IEquatable<ImportScopeHandle> {
+        public bool IsNil { get; }
+        public override bool Equals(object obj);
+        public bool Equals(ImportScopeHandle other);
+        public override int GetHashCode();
+        public static bool operator ==(ImportScopeHandle left, ImportScopeHandle right);
+        public static explicit operator ImportScopeHandle (EntityHandle handle);
+        public static explicit operator ImportScopeHandle (Handle handle);
+        public static implicit operator Handle (ImportScopeHandle handle);
+        public static implicit operator EntityHandle (ImportScopeHandle handle);
+        public static bool operator !=(ImportScopeHandle left, ImportScopeHandle right);
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct InterfaceImplementation {
+        public EntityHandle Interface { get; }
+        public CustomAttributeHandleCollection GetCustomAttributes();
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct InterfaceImplementationHandle : IEquatable<InterfaceImplementationHandle> {
+        public bool IsNil { get; }
+        public override bool Equals(object obj);
+        public bool Equals(InterfaceImplementationHandle other);
+        public override int GetHashCode();
+        public static bool operator ==(InterfaceImplementationHandle left, InterfaceImplementationHandle right);
+        public static explicit operator InterfaceImplementationHandle (EntityHandle handle);
+        public static explicit operator InterfaceImplementationHandle (Handle handle);
+        public static implicit operator Handle (InterfaceImplementationHandle handle);
+        public static implicit operator EntityHandle (InterfaceImplementationHandle handle);
+        public static bool operator !=(InterfaceImplementationHandle left, InterfaceImplementationHandle right);
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct InterfaceImplementationHandleCollection : IEnumerable, IEnumerable<InterfaceImplementationHandle>, IReadOnlyCollection<InterfaceImplementationHandle> {
+        public int Count { get; }
+        public InterfaceImplementationHandleCollection.Enumerator GetEnumerator();
+        IEnumerator<InterfaceImplementationHandle> System.Collections.Generic.IEnumerable<System.Reflection.Metadata.InterfaceImplementationHandle>.GetEnumerator();
+        IEnumerator System.Collections.IEnumerable.GetEnumerator();
+        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+        public struct Enumerator : IDisposable, IEnumerator, IEnumerator<InterfaceImplementationHandle> {
+            public InterfaceImplementationHandle Current { get; }
+            object System.Collections.IEnumerator.Current { get; }
+            public bool MoveNext();
+            void System.Collections.IEnumerator.Reset();
+            void System.IDisposable.Dispose();
+        }
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct LocalConstant {
+        public StringHandle Name { get; }
+        public BlobHandle Signature { get; }
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct LocalConstantHandle : IEquatable<LocalConstantHandle> {
+        public bool IsNil { get; }
+        public override bool Equals(object obj);
+        public bool Equals(LocalConstantHandle other);
+        public override int GetHashCode();
+        public static bool operator ==(LocalConstantHandle left, LocalConstantHandle right);
+        public static explicit operator LocalConstantHandle (EntityHandle handle);
+        public static explicit operator LocalConstantHandle (Handle handle);
+        public static implicit operator Handle (LocalConstantHandle handle);
+        public static implicit operator EntityHandle (LocalConstantHandle handle);
+        public static bool operator !=(LocalConstantHandle left, LocalConstantHandle right);
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct LocalConstantHandleCollection : IEnumerable, IEnumerable<LocalConstantHandle>, IReadOnlyCollection<LocalConstantHandle> {
+        public int Count { get; }
+        public LocalConstantHandleCollection.Enumerator GetEnumerator();
+        IEnumerator<LocalConstantHandle> System.Collections.Generic.IEnumerable<System.Reflection.Metadata.LocalConstantHandle>.GetEnumerator();
+        IEnumerator System.Collections.IEnumerable.GetEnumerator();
+        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+        public struct Enumerator : IDisposable, IEnumerator, IEnumerator<LocalConstantHandle> {
+            public LocalConstantHandle Current { get; }
+            object System.Collections.IEnumerator.Current { get; }
+            public bool MoveNext();
+            void System.Collections.IEnumerator.Reset();
+            void System.IDisposable.Dispose();
+        }
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct LocalScope {
+        public int EndOffset { get; }
+        public ImportScopeHandle ImportScope { get; }
+        public int Length { get; }
+        public MethodDefinitionHandle Method { get; }
+        public int StartOffset { get; }
+        public LocalScopeHandleCollection.ChildrenEnumerator GetChildren();
+        public LocalConstantHandleCollection GetLocalConstants();
+        public LocalVariableHandleCollection GetLocalVariables();
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct LocalScopeHandle : IEquatable<LocalScopeHandle> {
+        public bool IsNil { get; }
+        public override bool Equals(object obj);
+        public bool Equals(LocalScopeHandle other);
+        public override int GetHashCode();
+        public static bool operator ==(LocalScopeHandle left, LocalScopeHandle right);
+        public static explicit operator LocalScopeHandle (EntityHandle handle);
+        public static explicit operator LocalScopeHandle (Handle handle);
+        public static implicit operator Handle (LocalScopeHandle handle);
+        public static implicit operator EntityHandle (LocalScopeHandle handle);
+        public static bool operator !=(LocalScopeHandle left, LocalScopeHandle right);
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct LocalScopeHandleCollection : IEnumerable, IEnumerable<LocalScopeHandle>, IReadOnlyCollection<LocalScopeHandle> {
+        public int Count { get; }
+        public LocalScopeHandleCollection.Enumerator GetEnumerator();
+        IEnumerator<LocalScopeHandle> System.Collections.Generic.IEnumerable<System.Reflection.Metadata.LocalScopeHandle>.GetEnumerator();
+        IEnumerator System.Collections.IEnumerable.GetEnumerator();
+        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+        public struct ChildrenEnumerator : IDisposable, IEnumerator, IEnumerator<LocalScopeHandle> {
+            public LocalScopeHandle Current { get; }
+            object System.Collections.IEnumerator.Current { get; }
+            public bool MoveNext();
+            void System.Collections.IEnumerator.Reset();
+            void System.IDisposable.Dispose();
+        }
+        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+        public struct Enumerator : IDisposable, IEnumerator, IEnumerator<LocalScopeHandle> {
+            public LocalScopeHandle Current { get; }
+            object System.Collections.IEnumerator.Current { get; }
+            public bool MoveNext();
+            void System.Collections.IEnumerator.Reset();
+            void System.IDisposable.Dispose();
+        }
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct LocalVariable {
+        public LocalVariableAttributes Attributes { get; }
+        public int Index { get; }
+        public StringHandle Name { get; }
+    }
+    public enum LocalVariableAttributes {
+        DebuggerHidden = 1,
+        None = 0,
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct LocalVariableHandle : IEquatable<LocalVariableHandle> {
+        public bool IsNil { get; }
+        public override bool Equals(object obj);
+        public bool Equals(LocalVariableHandle other);
+        public override int GetHashCode();
+        public static bool operator ==(LocalVariableHandle left, LocalVariableHandle right);
+        public static explicit operator LocalVariableHandle (EntityHandle handle);
+        public static explicit operator LocalVariableHandle (Handle handle);
+        public static implicit operator Handle (LocalVariableHandle handle);
+        public static implicit operator EntityHandle (LocalVariableHandle handle);
+        public static bool operator !=(LocalVariableHandle left, LocalVariableHandle right);
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct LocalVariableHandleCollection : IEnumerable, IEnumerable<LocalVariableHandle>, IReadOnlyCollection<LocalVariableHandle> {
+        public int Count { get; }
+        public LocalVariableHandleCollection.Enumerator GetEnumerator();
+        IEnumerator<LocalVariableHandle> System.Collections.Generic.IEnumerable<System.Reflection.Metadata.LocalVariableHandle>.GetEnumerator();
+        IEnumerator System.Collections.IEnumerable.GetEnumerator();
+        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+        public struct Enumerator : IDisposable, IEnumerator, IEnumerator<LocalVariableHandle> {
+            public LocalVariableHandle Current { get; }
+            object System.Collections.IEnumerator.Current { get; }
+            public bool MoveNext();
+            void System.Collections.IEnumerator.Reset();
+            void System.IDisposable.Dispose();
+        }
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct ManifestResource {
+        public ManifestResourceAttributes Attributes { get; }
+        public EntityHandle Implementation { get; }
+        public StringHandle Name { get; }
+        public long Offset { get; }
+        public CustomAttributeHandleCollection GetCustomAttributes();
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct ManifestResourceHandle : IEquatable<ManifestResourceHandle> {
+        public bool IsNil { get; }
+        public override bool Equals(object obj);
+        public bool Equals(ManifestResourceHandle other);
+        public override int GetHashCode();
+        public static bool operator ==(ManifestResourceHandle left, ManifestResourceHandle right);
+        public static explicit operator ManifestResourceHandle (EntityHandle handle);
+        public static explicit operator ManifestResourceHandle (Handle handle);
+        public static implicit operator Handle (ManifestResourceHandle handle);
+        public static implicit operator EntityHandle (ManifestResourceHandle handle);
+        public static bool operator !=(ManifestResourceHandle left, ManifestResourceHandle right);
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct ManifestResourceHandleCollection : IEnumerable, IEnumerable<ManifestResourceHandle>, IReadOnlyCollection<ManifestResourceHandle> {
+        public int Count { get; }
+        public ManifestResourceHandleCollection.Enumerator GetEnumerator();
+        IEnumerator<ManifestResourceHandle> System.Collections.Generic.IEnumerable<System.Reflection.Metadata.ManifestResourceHandle>.GetEnumerator();
+        IEnumerator System.Collections.IEnumerable.GetEnumerator();
+        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+        public struct Enumerator : IDisposable, IEnumerator, IEnumerator<ManifestResourceHandle> {
+            public ManifestResourceHandle Current { get; }
+            object System.Collections.IEnumerator.Current { get; }
+            public bool MoveNext();
+            void System.Collections.IEnumerator.Reset();
+            void System.IDisposable.Dispose();
+        }
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct MemberReference {
+        public StringHandle Name { get; }
+        public EntityHandle Parent { get; }
+        public BlobHandle Signature { get; }
+        public CustomAttributeHandleCollection GetCustomAttributes();
+        public MemberReferenceKind GetKind();
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct MemberReferenceHandle : IEquatable<MemberReferenceHandle> {
+        public bool IsNil { get; }
+        public override bool Equals(object obj);
+        public bool Equals(MemberReferenceHandle other);
+        public override int GetHashCode();
+        public static bool operator ==(MemberReferenceHandle left, MemberReferenceHandle right);
+        public static explicit operator MemberReferenceHandle (EntityHandle handle);
+        public static explicit operator MemberReferenceHandle (Handle handle);
+        public static implicit operator Handle (MemberReferenceHandle handle);
+        public static implicit operator EntityHandle (MemberReferenceHandle handle);
+        public static bool operator !=(MemberReferenceHandle left, MemberReferenceHandle right);
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct MemberReferenceHandleCollection : IEnumerable, IEnumerable<MemberReferenceHandle>, IReadOnlyCollection<MemberReferenceHandle> {
+        public int Count { get; }
+        public MemberReferenceHandleCollection.Enumerator GetEnumerator();
+        IEnumerator<MemberReferenceHandle> System.Collections.Generic.IEnumerable<System.Reflection.Metadata.MemberReferenceHandle>.GetEnumerator();
+        IEnumerator System.Collections.IEnumerable.GetEnumerator();
+        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+        public struct Enumerator : IDisposable, IEnumerator, IEnumerator<MemberReferenceHandle> {
+            public MemberReferenceHandle Current { get; }
+            object System.Collections.IEnumerator.Current { get; }
+            public bool MoveNext();
+            void System.Collections.IEnumerator.Reset();
+            void System.IDisposable.Dispose();
+        }
+    }
+    public enum MemberReferenceKind {
+        Field = 1,
+        Method = 0,
+    }
+    public enum MetadataKind {
+        Ecma335 = 0,
+        ManagedWindowsMetadata = 2,
+        WindowsMetadata = 1,
+    }
+    public sealed class MetadataReader {
+        public unsafe MetadataReader(byte* metadata, int length);
+        public unsafe MetadataReader(byte* metadata, int length, MetadataReaderOptions options);
+        public unsafe MetadataReader(byte* metadata, int length, MetadataReaderOptions options, MetadataStringDecoder utf8Decoder);
+        public AssemblyFileHandleCollection AssemblyFiles { get; }
+        public AssemblyReferenceHandleCollection AssemblyReferences { get; }
+        public CustomAttributeHandleCollection CustomAttributes { get; }
+        public CustomDebugInformationHandleCollection CustomDebugInformation { get; }
+        public DebugMetadataHeader DebugMetadataHeader { get; }
+        public DeclarativeSecurityAttributeHandleCollection DeclarativeSecurityAttributes { get; }
+        public DocumentHandleCollection Documents { get; }
+        public EventDefinitionHandleCollection EventDefinitions { get; }
+        public ExportedTypeHandleCollection ExportedTypes { get; }
+        public FieldDefinitionHandleCollection FieldDefinitions { get; }
+        public ImportScopeCollection ImportScopes { get; }
+        public bool IsAssembly { get; }
+        public LocalConstantHandleCollection LocalConstants { get; }
+        public LocalScopeHandleCollection LocalScopes { get; }
+        public LocalVariableHandleCollection LocalVariables { get; }
+        public ManifestResourceHandleCollection ManifestResources { get; }
+        public MemberReferenceHandleCollection MemberReferences { get; }
+        public MetadataKind MetadataKind { get; }
+        public string MetadataVersion { get; }
+        public MethodDebugInformationHandleCollection MethodDebugInformation { get; }
+        public MethodDefinitionHandleCollection MethodDefinitions { get; }
+        public MetadataReaderOptions Options { get; }
+        public PropertyDefinitionHandleCollection PropertyDefinitions { get; }
+        public MetadataStringComparer StringComparer { get; }
+        public TypeDefinitionHandleCollection TypeDefinitions { get; }
+        public TypeReferenceHandleCollection TypeReferences { get; }
+        public AssemblyDefinition GetAssemblyDefinition();
+        public AssemblyFile GetAssemblyFile(AssemblyFileHandle handle);
+        public AssemblyReference GetAssemblyReference(AssemblyReferenceHandle handle);
+        public byte[] GetBlobBytes(BlobHandle handle);
+        public ImmutableArray<byte> GetBlobContent(BlobHandle handle);
+        public BlobReader GetBlobReader(BlobHandle handle);
+        public Constant GetConstant(ConstantHandle handle);
+        public CustomAttribute GetCustomAttribute(CustomAttributeHandle handle);
+        public CustomAttributeHandleCollection GetCustomAttributes(EntityHandle handle);
+        public CustomDebugInformation GetCustomDebugInformation(CustomDebugInformationHandle handle);
+        public CustomDebugInformationHandleCollection GetCustomDebugInformation(EntityHandle handle);
+        public DeclarativeSecurityAttribute GetDeclarativeSecurityAttribute(DeclarativeSecurityAttributeHandle handle);
+        public Document GetDocument(DocumentHandle handle);
+        public EventDefinition GetEventDefinition(EventDefinitionHandle handle);
+        public ExportedType GetExportedType(ExportedTypeHandle handle);
+        public FieldDefinition GetFieldDefinition(FieldDefinitionHandle handle);
+        public GenericParameter GetGenericParameter(GenericParameterHandle handle);
+        public GenericParameterConstraint GetGenericParameterConstraint(GenericParameterConstraintHandle handle);
+        public Guid GetGuid(GuidHandle handle);
+        public ImportScope GetImportScope(ImportScopeHandle handle);
+        public InterfaceImplementation GetInterfaceImplementation(InterfaceImplementationHandle handle);
+        public LocalConstant GetLocalConstant(LocalConstantHandle handle);
+        public LocalScope GetLocalScope(LocalScopeHandle handle);
+        public LocalScopeHandleCollection GetLocalScopes(MethodDebugInformationHandle handle);
+        public LocalScopeHandleCollection GetLocalScopes(MethodDefinitionHandle handle);
+        public LocalVariable GetLocalVariable(LocalVariableHandle handle);
+        public ManifestResource GetManifestResource(ManifestResourceHandle handle);
+        public MemberReference GetMemberReference(MemberReferenceHandle handle);
+        public MethodDebugInformation GetMethodDebugInformation(MethodDebugInformationHandle handle);
+        public MethodDebugInformation GetMethodDebugInformation(MethodDefinitionHandle handle);
+        public MethodDefinition GetMethodDefinition(MethodDefinitionHandle handle);
+        public MethodImplementation GetMethodImplementation(MethodImplementationHandle handle);
+        public MethodSpecification GetMethodSpecification(MethodSpecificationHandle handle);
+        public ModuleDefinition GetModuleDefinition();
+        public ModuleReference GetModuleReference(ModuleReferenceHandle handle);
+        public NamespaceDefinition GetNamespaceDefinition(NamespaceDefinitionHandle handle);
+        public NamespaceDefinition GetNamespaceDefinitionRoot();
+        public Parameter GetParameter(ParameterHandle handle);
+        public PropertyDefinition GetPropertyDefinition(PropertyDefinitionHandle handle);
+        public StandaloneSignature GetStandaloneSignature(StandaloneSignatureHandle handle);
+        public string GetString(DocumentNameBlobHandle handle);
+        public string GetString(NamespaceDefinitionHandle handle);
+        public string GetString(StringHandle handle);
+        public TypeDefinition GetTypeDefinition(TypeDefinitionHandle handle);
+        public TypeReference GetTypeReference(TypeReferenceHandle handle);
+        public TypeSpecification GetTypeSpecification(TypeSpecificationHandle handle);
+        public string GetUserString(UserStringHandle handle);
+    }
+    public enum MetadataReaderOptions {
+        ApplyWindowsRuntimeProjections = 1,
+        Default = 1,
+        None = 0,
+    }
+    public sealed class MetadataReaderProvider : IDisposable {
+        public void Dispose();
+        public unsafe static MetadataReaderProvider FromMetadataImage(byte* start, int size);
+        public static MetadataReaderProvider FromMetadataImage(ImmutableArray<byte> image);
+        public static MetadataReaderProvider FromMetadataStream(Stream stream, MetadataStreamOptions options=(MetadataStreamOptions)(0), int size=0);
+        public unsafe static MetadataReaderProvider FromPortablePdbImage(byte* start, int size);
+        public static MetadataReaderProvider FromPortablePdbImage(ImmutableArray<byte> image);
+        public static MetadataReaderProvider FromPortablePdbStream(Stream stream, MetadataStreamOptions options=(MetadataStreamOptions)(0), int size=0);
+        public MetadataReader GetMetadataReader(MetadataReaderOptions options=(MetadataReaderOptions)(1), MetadataStringDecoder utf8Decoder=null);
+    }
+    public enum MetadataStreamOptions {
+        Default = 0,
+        LeaveOpen = 1,
+        PrefetchMetadata = 2,
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct MetadataStringComparer {
+        public bool Equals(DocumentNameBlobHandle handle, string value);
+        public bool Equals(DocumentNameBlobHandle handle, string value, bool ignoreCase);
+        public bool Equals(NamespaceDefinitionHandle handle, string value);
+        public bool Equals(NamespaceDefinitionHandle handle, string value, bool ignoreCase);
+        public bool Equals(StringHandle handle, string value);
+        public bool Equals(StringHandle handle, string value, bool ignoreCase);
+        public bool StartsWith(StringHandle handle, string value);
+        public bool StartsWith(StringHandle handle, string value, bool ignoreCase);
+    }
+    public class MetadataStringDecoder {
+        public MetadataStringDecoder(Encoding encoding);
+        public static MetadataStringDecoder DefaultUTF8 { get; }
+        public Encoding Encoding { get; }
+        public unsafe virtual string GetString(byte* bytes, int byteCount);
+    }
+    public sealed class MethodBodyBlock {
+        public ImmutableArray<ExceptionRegion> ExceptionRegions { get; }
+        public StandaloneSignatureHandle LocalSignature { get; }
+        public bool LocalVariablesInitialized { get; }
+        public int MaxStack { get; }
+        public int Size { get; }
+        public static MethodBodyBlock Create(BlobReader reader);
+        public byte[] GetILBytes();
+        public ImmutableArray<byte> GetILContent();
+        public BlobReader GetILReader();
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct MethodDebugInformation {
+        public DocumentHandle Document { get; }
+        public StandaloneSignatureHandle LocalSignature { get; }
+        public BlobHandle SequencePointsBlob { get; }
+        public SequencePointCollection GetSequencePoints();
+        public MethodDefinitionHandle GetStateMachineKickoffMethod();
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct MethodDebugInformationHandle : IEquatable<MethodDebugInformationHandle> {
+        public bool IsNil { get; }
+        public override bool Equals(object obj);
+        public bool Equals(MethodDebugInformationHandle other);
+        public override int GetHashCode();
+        public static bool operator ==(MethodDebugInformationHandle left, MethodDebugInformationHandle right);
+        public static explicit operator MethodDebugInformationHandle (EntityHandle handle);
+        public static explicit operator MethodDebugInformationHandle (Handle handle);
+        public static implicit operator Handle (MethodDebugInformationHandle handle);
+        public static implicit operator EntityHandle (MethodDebugInformationHandle handle);
+        public static bool operator !=(MethodDebugInformationHandle left, MethodDebugInformationHandle right);
+        public MethodDefinitionHandle ToDefinitionHandle();
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct MethodDebugInformationHandleCollection : IEnumerable, IEnumerable<MethodDebugInformationHandle>, IReadOnlyCollection<MethodDebugInformationHandle> {
+        public int Count { get; }
+        public MethodDebugInformationHandleCollection.Enumerator GetEnumerator();
+        IEnumerator<MethodDebugInformationHandle> System.Collections.Generic.IEnumerable<System.Reflection.Metadata.MethodDebugInformationHandle>.GetEnumerator();
+        IEnumerator System.Collections.IEnumerable.GetEnumerator();
+        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+        public struct Enumerator : IDisposable, IEnumerator, IEnumerator<MethodDebugInformationHandle> {
+            public MethodDebugInformationHandle Current { get; }
+            object System.Collections.IEnumerator.Current { get; }
+            public bool MoveNext();
+            void System.Collections.IEnumerator.Reset();
+            void System.IDisposable.Dispose();
+        }
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct MethodDefinition {
+        public MethodAttributes Attributes { get; }
+        public MethodImplAttributes ImplAttributes { get; }
+        public StringHandle Name { get; }
+        public int RelativeVirtualAddress { get; }
+        public BlobHandle Signature { get; }
+        public CustomAttributeHandleCollection GetCustomAttributes();
+        public DeclarativeSecurityAttributeHandleCollection GetDeclarativeSecurityAttributes();
+        public TypeDefinitionHandle GetDeclaringType();
+        public GenericParameterHandleCollection GetGenericParameters();
+        public MethodImport GetImport();
+        public ParameterHandleCollection GetParameters();
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct MethodDefinitionHandle : IEquatable<MethodDefinitionHandle> {
+        public bool IsNil { get; }
+        public override bool Equals(object obj);
+        public bool Equals(MethodDefinitionHandle other);
+        public override int GetHashCode();
+        public static bool operator ==(MethodDefinitionHandle left, MethodDefinitionHandle right);
+        public static explicit operator MethodDefinitionHandle (EntityHandle handle);
+        public static explicit operator MethodDefinitionHandle (Handle handle);
+        public static implicit operator Handle (MethodDefinitionHandle handle);
+        public static implicit operator EntityHandle (MethodDefinitionHandle handle);
+        public static bool operator !=(MethodDefinitionHandle left, MethodDefinitionHandle right);
+        public MethodDebugInformationHandle ToDebugInformationHandle();
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct MethodDefinitionHandleCollection : IEnumerable, IEnumerable<MethodDefinitionHandle>, IReadOnlyCollection<MethodDefinitionHandle> {
+        public int Count { get; }
+        public MethodDefinitionHandleCollection.Enumerator GetEnumerator();
+        IEnumerator<MethodDefinitionHandle> System.Collections.Generic.IEnumerable<System.Reflection.Metadata.MethodDefinitionHandle>.GetEnumerator();
+        IEnumerator System.Collections.IEnumerable.GetEnumerator();
+        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+        public struct Enumerator : IDisposable, IEnumerator, IEnumerator<MethodDefinitionHandle> {
+            public MethodDefinitionHandle Current { get; }
+            object System.Collections.IEnumerator.Current { get; }
+            public bool MoveNext();
+            void System.Collections.IEnumerator.Reset();
+            void System.IDisposable.Dispose();
+        }
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct MethodImplementation {
+        public EntityHandle MethodBody { get; }
+        public EntityHandle MethodDeclaration { get; }
+        public TypeDefinitionHandle Type { get; }
+        public CustomAttributeHandleCollection GetCustomAttributes();
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct MethodImplementationHandle : IEquatable<MethodImplementationHandle> {
+        public bool IsNil { get; }
+        public override bool Equals(object obj);
+        public bool Equals(MethodImplementationHandle other);
+        public override int GetHashCode();
+        public static bool operator ==(MethodImplementationHandle left, MethodImplementationHandle right);
+        public static explicit operator MethodImplementationHandle (EntityHandle handle);
+        public static explicit operator MethodImplementationHandle (Handle handle);
+        public static implicit operator Handle (MethodImplementationHandle handle);
+        public static implicit operator EntityHandle (MethodImplementationHandle handle);
+        public static bool operator !=(MethodImplementationHandle left, MethodImplementationHandle right);
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct MethodImplementationHandleCollection : IEnumerable, IEnumerable<MethodImplementationHandle>, IReadOnlyCollection<MethodImplementationHandle> {
+        public int Count { get; }
+        public MethodImplementationHandleCollection.Enumerator GetEnumerator();
+        IEnumerator<MethodImplementationHandle> System.Collections.Generic.IEnumerable<System.Reflection.Metadata.MethodImplementationHandle>.GetEnumerator();
+        IEnumerator System.Collections.IEnumerable.GetEnumerator();
+        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+        public struct Enumerator : IDisposable, IEnumerator, IEnumerator<MethodImplementationHandle> {
+            public MethodImplementationHandle Current { get; }
+            object System.Collections.IEnumerator.Current { get; }
+            public bool MoveNext();
+            void System.Collections.IEnumerator.Reset();
+            void System.IDisposable.Dispose();
+        }
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct MethodImport {
+        public MethodImportAttributes Attributes { get; }
+        public ModuleReferenceHandle Module { get; }
+        public StringHandle Name { get; }
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct MethodSpecification {
+        public EntityHandle Method { get; }
+        public BlobHandle Signature { get; }
+        public CustomAttributeHandleCollection GetCustomAttributes();
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct MethodSpecificationHandle : IEquatable<MethodSpecificationHandle> {
+        public bool IsNil { get; }
+        public override bool Equals(object obj);
+        public bool Equals(MethodSpecificationHandle other);
+        public override int GetHashCode();
+        public static bool operator ==(MethodSpecificationHandle left, MethodSpecificationHandle right);
+        public static explicit operator MethodSpecificationHandle (EntityHandle handle);
+        public static explicit operator MethodSpecificationHandle (Handle handle);
+        public static implicit operator Handle (MethodSpecificationHandle handle);
+        public static implicit operator EntityHandle (MethodSpecificationHandle handle);
+        public static bool operator !=(MethodSpecificationHandle left, MethodSpecificationHandle right);
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct ModuleDefinition {
+        public GuidHandle BaseGenerationId { get; }
+        public int Generation { get; }
+        public GuidHandle GenerationId { get; }
+        public GuidHandle Mvid { get; }
+        public StringHandle Name { get; }
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct ModuleDefinitionHandle : IEquatable<ModuleDefinitionHandle> {
+        public bool IsNil { get; }
+        public override bool Equals(object obj);
+        public bool Equals(ModuleDefinitionHandle other);
+        public override int GetHashCode();
+        public static bool operator ==(ModuleDefinitionHandle left, ModuleDefinitionHandle right);
+        public static explicit operator ModuleDefinitionHandle (EntityHandle handle);
+        public static explicit operator ModuleDefinitionHandle (Handle handle);
+        public static implicit operator Handle (ModuleDefinitionHandle handle);
+        public static implicit operator EntityHandle (ModuleDefinitionHandle handle);
+        public static bool operator !=(ModuleDefinitionHandle left, ModuleDefinitionHandle right);
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct ModuleReference {
+        public StringHandle Name { get; }
+        public CustomAttributeHandleCollection GetCustomAttributes();
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct ModuleReferenceHandle : IEquatable<ModuleReferenceHandle> {
+        public bool IsNil { get; }
+        public override bool Equals(object obj);
+        public bool Equals(ModuleReferenceHandle other);
+        public override int GetHashCode();
+        public static bool operator ==(ModuleReferenceHandle left, ModuleReferenceHandle right);
+        public static explicit operator ModuleReferenceHandle (EntityHandle handle);
+        public static explicit operator ModuleReferenceHandle (Handle handle);
+        public static implicit operator Handle (ModuleReferenceHandle handle);
+        public static implicit operator EntityHandle (ModuleReferenceHandle handle);
+        public static bool operator !=(ModuleReferenceHandle left, ModuleReferenceHandle right);
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct NamespaceDefinition {
+        public ImmutableArray<ExportedTypeHandle> ExportedTypes { get; }
+        public StringHandle Name { get; }
+        public ImmutableArray<NamespaceDefinitionHandle> NamespaceDefinitions { get; }
+        public NamespaceDefinitionHandle Parent { get; }
+        public ImmutableArray<TypeDefinitionHandle> TypeDefinitions { get; }
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct NamespaceDefinitionHandle : IEquatable<NamespaceDefinitionHandle> {
+        public bool IsNil { get; }
+        public override bool Equals(object obj);
+        public bool Equals(NamespaceDefinitionHandle other);
+        public override int GetHashCode();
+        public static bool operator ==(NamespaceDefinitionHandle left, NamespaceDefinitionHandle right);
+        public static explicit operator NamespaceDefinitionHandle (Handle handle);
+        public static implicit operator Handle (NamespaceDefinitionHandle handle);
+        public static bool operator !=(NamespaceDefinitionHandle left, NamespaceDefinitionHandle right);
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct Parameter {
+        public ParameterAttributes Attributes { get; }
+        public StringHandle Name { get; }
+        public int SequenceNumber { get; }
+        public CustomAttributeHandleCollection GetCustomAttributes();
+        public ConstantHandle GetDefaultValue();
+        public BlobHandle GetMarshallingDescriptor();
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct ParameterHandle : IEquatable<ParameterHandle> {
+        public bool IsNil { get; }
+        public override bool Equals(object obj);
+        public bool Equals(ParameterHandle other);
+        public override int GetHashCode();
+        public static bool operator ==(ParameterHandle left, ParameterHandle right);
+        public static explicit operator ParameterHandle (EntityHandle handle);
+        public static explicit operator ParameterHandle (Handle handle);
+        public static implicit operator Handle (ParameterHandle handle);
+        public static implicit operator EntityHandle (ParameterHandle handle);
+        public static bool operator !=(ParameterHandle left, ParameterHandle right);
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct ParameterHandleCollection : IEnumerable, IEnumerable<ParameterHandle>, IReadOnlyCollection<ParameterHandle> {
+        public int Count { get; }
+        public ParameterHandleCollection.Enumerator GetEnumerator();
+        IEnumerator<ParameterHandle> System.Collections.Generic.IEnumerable<System.Reflection.Metadata.ParameterHandle>.GetEnumerator();
+        IEnumerator System.Collections.IEnumerable.GetEnumerator();
+        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+        public struct Enumerator : IDisposable, IEnumerator, IEnumerator<ParameterHandle> {
+            public ParameterHandle Current { get; }
+            object System.Collections.IEnumerator.Current { get; }
+            public bool MoveNext();
+            void System.Collections.IEnumerator.Reset();
+            void System.IDisposable.Dispose();
+        }
+    }
+    public static class PEReaderExtensions {
+        public static MetadataReader GetMetadataReader(this PEReader peReader);
+        public static MetadataReader GetMetadataReader(this PEReader peReader, MetadataReaderOptions options);
+        public static MetadataReader GetMetadataReader(this PEReader peReader, MetadataReaderOptions options, MetadataStringDecoder utf8Decoder);
+        public static MethodBodyBlock GetMethodBody(this PEReader peReader, int relativeVirtualAddress);
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct PropertyAccessors {
+        public MethodDefinitionHandle Getter { get; }
+        public MethodDefinitionHandle Setter { get; }
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct PropertyDefinition {
+        public PropertyAttributes Attributes { get; }
+        public StringHandle Name { get; }
+        public BlobHandle Signature { get; }
+        public PropertyAccessors GetAccessors();
+        public CustomAttributeHandleCollection GetCustomAttributes();
+        public ConstantHandle GetDefaultValue();
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct PropertyDefinitionHandle : IEquatable<PropertyDefinitionHandle> {
+        public bool IsNil { get; }
+        public override bool Equals(object obj);
+        public bool Equals(PropertyDefinitionHandle other);
+        public override int GetHashCode();
+        public static bool operator ==(PropertyDefinitionHandle left, PropertyDefinitionHandle right);
+        public static explicit operator PropertyDefinitionHandle (EntityHandle handle);
+        public static explicit operator PropertyDefinitionHandle (Handle handle);
+        public static implicit operator Handle (PropertyDefinitionHandle handle);
+        public static implicit operator EntityHandle (PropertyDefinitionHandle handle);
+        public static bool operator !=(PropertyDefinitionHandle left, PropertyDefinitionHandle right);
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct PropertyDefinitionHandleCollection : IEnumerable, IEnumerable<PropertyDefinitionHandle>, IReadOnlyCollection<PropertyDefinitionHandle> {
+        public int Count { get; }
+        public PropertyDefinitionHandleCollection.Enumerator GetEnumerator();
+        IEnumerator<PropertyDefinitionHandle> System.Collections.Generic.IEnumerable<System.Reflection.Metadata.PropertyDefinitionHandle>.GetEnumerator();
+        IEnumerator System.Collections.IEnumerable.GetEnumerator();
+        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+        public struct Enumerator : IDisposable, IEnumerator, IEnumerator<PropertyDefinitionHandle> {
+            public PropertyDefinitionHandle Current { get; }
+            object System.Collections.IEnumerator.Current { get; }
+            public bool MoveNext();
+            void System.Collections.IEnumerator.Reset();
+            void System.IDisposable.Dispose();
+        }
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct SequencePoint : IEquatable<SequencePoint> {
+        public const int HiddenLine = 16707566;
+        public DocumentHandle Document { get; }
+        public int EndColumn { get; }
+        public int EndLine { get; }
+        public bool IsHidden { get; }
+        public int Offset { get; }
+        public int StartColumn { get; }
+        public int StartLine { get; }
+        public override bool Equals(object obj);
+        public bool Equals(SequencePoint other);
+        public override int GetHashCode();
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct SequencePointCollection : IEnumerable, IEnumerable<SequencePoint> {
+        public SequencePointCollection.Enumerator GetEnumerator();
+        IEnumerator<SequencePoint> System.Collections.Generic.IEnumerable<System.Reflection.Metadata.SequencePoint>.GetEnumerator();
+        IEnumerator System.Collections.IEnumerable.GetEnumerator();
+        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+        public struct Enumerator : IDisposable, IEnumerator, IEnumerator<SequencePoint> {
+            public SequencePoint Current { get; }
+            object System.Collections.IEnumerator.Current { get; }
+            public bool MoveNext();
+            public void Reset();
+            void System.IDisposable.Dispose();
+        }
+    }
+    public enum SerializationTypeCode : byte {
+        Boolean = (byte)2,
+        Byte = (byte)5,
+        Char = (byte)3,
+        Double = (byte)13,
+        Enum = (byte)85,
+        Int16 = (byte)6,
+        Int32 = (byte)8,
+        Int64 = (byte)10,
+        Invalid = (byte)0,
+        SByte = (byte)4,
+        Single = (byte)12,
+        String = (byte)14,
+        SZArray = (byte)29,
+        TaggedObject = (byte)81,
+        Type = (byte)80,
+        UInt16 = (byte)7,
+        UInt32 = (byte)9,
+        UInt64 = (byte)11,
+    }
+    public enum SignatureAttributes : byte {
+        ExplicitThis = (byte)64,
+        Generic = (byte)16,
+        Instance = (byte)32,
+        None = (byte)0,
+    }
+    public enum SignatureCallingConvention : byte {
+        CDecl = (byte)1,
+        Default = (byte)0,
+        FastCall = (byte)4,
+        StdCall = (byte)2,
+        ThisCall = (byte)3,
+        VarArgs = (byte)5,
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct SignatureHeader : IEquatable<SignatureHeader> {
+        public const byte CallingConventionOrKindMask = (byte)15;
+        public SignatureHeader(byte rawValue);
+        public SignatureHeader(SignatureKind kind, SignatureCallingConvention convention, SignatureAttributes attributes);
+        public SignatureAttributes Attributes { get; }
+        public SignatureCallingConvention CallingConvention { get; }
+        public bool HasExplicitThis { get; }
+        public bool IsGeneric { get; }
+        public bool IsInstance { get; }
+        public SignatureKind Kind { get; }
+        public byte RawValue { get; }
+        public override bool Equals(object obj);
+        public bool Equals(SignatureHeader other);
+        public override int GetHashCode();
+        public static bool operator ==(SignatureHeader left, SignatureHeader right);
+        public static bool operator !=(SignatureHeader left, SignatureHeader right);
+        public override string ToString();
+    }
+    public enum SignatureKind : byte {
+        Field = (byte)6,
+        LocalVariables = (byte)7,
+        Method = (byte)0,
+        MethodSpecification = (byte)10,
+        Property = (byte)8,
+    }
+    public enum SignatureTypeCode : byte {
+        Array = (byte)20,
+        Boolean = (byte)2,
+        ByReference = (byte)16,
+        Byte = (byte)5,
+        Char = (byte)3,
+        Double = (byte)13,
+        FunctionPointer = (byte)27,
+        GenericMethodParameter = (byte)30,
+        GenericTypeInstance = (byte)21,
+        GenericTypeParameter = (byte)19,
+        Int16 = (byte)6,
+        Int32 = (byte)8,
+        Int64 = (byte)10,
+        IntPtr = (byte)24,
+        Invalid = (byte)0,
+        Object = (byte)28,
+        OptionalModifier = (byte)32,
+        Pinned = (byte)69,
+        Pointer = (byte)15,
+        RequiredModifier = (byte)31,
+        SByte = (byte)4,
+        Sentinel = (byte)65,
+        Single = (byte)12,
+        String = (byte)14,
+        SZArray = (byte)29,
+        TypedReference = (byte)22,
+        TypeHandle = (byte)64,
+        UInt16 = (byte)7,
+        UInt32 = (byte)9,
+        UInt64 = (byte)11,
+        UIntPtr = (byte)25,
+        Void = (byte)1,
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct StandaloneSignature {
+        public BlobHandle Signature { get; }
+        public CustomAttributeHandleCollection GetCustomAttributes();
+        public StandaloneSignatureKind GetKind();
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct StandaloneSignatureHandle : IEquatable<StandaloneSignatureHandle> {
+        public bool IsNil { get; }
+        public override bool Equals(object obj);
+        public bool Equals(StandaloneSignatureHandle other);
+        public override int GetHashCode();
+        public static bool operator ==(StandaloneSignatureHandle left, StandaloneSignatureHandle right);
+        public static explicit operator StandaloneSignatureHandle (EntityHandle handle);
+        public static explicit operator StandaloneSignatureHandle (Handle handle);
+        public static implicit operator Handle (StandaloneSignatureHandle handle);
+        public static implicit operator EntityHandle (StandaloneSignatureHandle handle);
+        public static bool operator !=(StandaloneSignatureHandle left, StandaloneSignatureHandle right);
+    }
+    public enum StandaloneSignatureKind {
+        LocalVariables = 1,
+        Method = 0,
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct StringHandle : IEquatable<StringHandle> {
+        public bool IsNil { get; }
+        public override bool Equals(object obj);
+        public bool Equals(StringHandle other);
+        public override int GetHashCode();
+        public static bool operator ==(StringHandle left, StringHandle right);
+        public static explicit operator StringHandle (Handle handle);
+        public static implicit operator Handle (StringHandle handle);
+        public static bool operator !=(StringHandle left, StringHandle right);
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct TypeDefinition {
+        public TypeAttributes Attributes { get; }
+        public EntityHandle BaseType { get; }
+        public StringHandle Name { get; }
+        public StringHandle Namespace { get; }
+        public NamespaceDefinitionHandle NamespaceDefinition { get; }
+        public CustomAttributeHandleCollection GetCustomAttributes();
+        public DeclarativeSecurityAttributeHandleCollection GetDeclarativeSecurityAttributes();
+        public TypeDefinitionHandle GetDeclaringType();
+        public EventDefinitionHandleCollection GetEvents();
+        public FieldDefinitionHandleCollection GetFields();
+        public GenericParameterHandleCollection GetGenericParameters();
+        public InterfaceImplementationHandleCollection GetInterfaceImplementations();
+        public TypeLayout GetLayout();
+        public MethodImplementationHandleCollection GetMethodImplementations();
+        public MethodDefinitionHandleCollection GetMethods();
+        public ImmutableArray<TypeDefinitionHandle> GetNestedTypes();
+        public PropertyDefinitionHandleCollection GetProperties();
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct TypeDefinitionHandle : IEquatable<TypeDefinitionHandle> {
+        public bool IsNil { get; }
+        public override bool Equals(object obj);
+        public bool Equals(TypeDefinitionHandle other);
+        public override int GetHashCode();
+        public static bool operator ==(TypeDefinitionHandle left, TypeDefinitionHandle right);
+        public static explicit operator TypeDefinitionHandle (EntityHandle handle);
+        public static explicit operator TypeDefinitionHandle (Handle handle);
+        public static implicit operator Handle (TypeDefinitionHandle handle);
+        public static implicit operator EntityHandle (TypeDefinitionHandle handle);
+        public static bool operator !=(TypeDefinitionHandle left, TypeDefinitionHandle right);
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct TypeDefinitionHandleCollection : IEnumerable, IEnumerable<TypeDefinitionHandle>, IReadOnlyCollection<TypeDefinitionHandle> {
+        public int Count { get; }
+        public TypeDefinitionHandleCollection.Enumerator GetEnumerator();
+        IEnumerator<TypeDefinitionHandle> System.Collections.Generic.IEnumerable<System.Reflection.Metadata.TypeDefinitionHandle>.GetEnumerator();
+        IEnumerator System.Collections.IEnumerable.GetEnumerator();
+        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+        public struct Enumerator : IDisposable, IEnumerator, IEnumerator<TypeDefinitionHandle> {
+            public TypeDefinitionHandle Current { get; }
+            object System.Collections.IEnumerator.Current { get; }
+            public bool MoveNext();
+            void System.Collections.IEnumerator.Reset();
+            void System.IDisposable.Dispose();
+        }
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct TypeLayout {
+        public TypeLayout(int size, int packingSize);
+        public bool IsDefault { get; }
+        public int PackingSize { get; }
+        public int Size { get; }
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct TypeReference {
+        public StringHandle Name { get; }
+        public StringHandle Namespace { get; }
+        public EntityHandle ResolutionScope { get; }
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct TypeReferenceHandle : IEquatable<TypeReferenceHandle> {
+        public bool IsNil { get; }
+        public override bool Equals(object obj);
+        public bool Equals(TypeReferenceHandle other);
+        public override int GetHashCode();
+        public static bool operator ==(TypeReferenceHandle left, TypeReferenceHandle right);
+        public static explicit operator TypeReferenceHandle (EntityHandle handle);
+        public static explicit operator TypeReferenceHandle (Handle handle);
+        public static implicit operator Handle (TypeReferenceHandle handle);
+        public static implicit operator EntityHandle (TypeReferenceHandle handle);
+        public static bool operator !=(TypeReferenceHandle left, TypeReferenceHandle right);
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct TypeReferenceHandleCollection : IEnumerable, IEnumerable<TypeReferenceHandle>, IReadOnlyCollection<TypeReferenceHandle> {
+        public int Count { get; }
+        public TypeReferenceHandleCollection.Enumerator GetEnumerator();
+        IEnumerator<TypeReferenceHandle> System.Collections.Generic.IEnumerable<System.Reflection.Metadata.TypeReferenceHandle>.GetEnumerator();
+        IEnumerator System.Collections.IEnumerable.GetEnumerator();
+        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+        public struct Enumerator : IDisposable, IEnumerator, IEnumerator<TypeReferenceHandle> {
+            public TypeReferenceHandle Current { get; }
+            object System.Collections.IEnumerator.Current { get; }
+            public bool MoveNext();
+            void System.Collections.IEnumerator.Reset();
+            void System.IDisposable.Dispose();
+        }
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct TypeSpecification {
+        public BlobHandle Signature { get; }
+        public CustomAttributeHandleCollection GetCustomAttributes();
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct TypeSpecificationHandle : IEquatable<TypeSpecificationHandle> {
+        public bool IsNil { get; }
+        public override bool Equals(object obj);
+        public bool Equals(TypeSpecificationHandle other);
+        public override int GetHashCode();
+        public static bool operator ==(TypeSpecificationHandle left, TypeSpecificationHandle right);
+        public static explicit operator TypeSpecificationHandle (EntityHandle handle);
+        public static explicit operator TypeSpecificationHandle (Handle handle);
+        public static implicit operator Handle (TypeSpecificationHandle handle);
+        public static implicit operator EntityHandle (TypeSpecificationHandle handle);
+        public static bool operator !=(TypeSpecificationHandle left, TypeSpecificationHandle right);
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct UserStringHandle : IEquatable<UserStringHandle> {
+        public bool IsNil { get; }
+        public override bool Equals(object obj);
+        public bool Equals(UserStringHandle other);
+        public override int GetHashCode();
+        public static bool operator ==(UserStringHandle left, UserStringHandle right);
+        public static explicit operator UserStringHandle (Handle handle);
+        public static implicit operator Handle (UserStringHandle handle);
+        public static bool operator !=(UserStringHandle left, UserStringHandle right);
+    }
+}
```

## System.Reflection.Metadata.Ecma335

```c#
+namespace System.Reflection.Metadata.Ecma335 {
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct EditAndContinueLogEntry : IEquatable<EditAndContinueLogEntry> {
+        public EditAndContinueLogEntry(EntityHandle handle, EditAndContinueOperation operation);
+        public EntityHandle Handle { get; }
+        public EditAndContinueOperation Operation { get; }
+        public override bool Equals(object obj);
+        public bool Equals(EditAndContinueLogEntry other);
+        public override int GetHashCode();
+    }
+    public enum EditAndContinueOperation {
+        AddEvent = 5,
+        AddField = 2,
+        AddMethod = 1,
+        AddParameter = 3,
+        AddProperty = 4,
+        Default = 0,
+    }
+    public static class ExportedTypeExtensions {
+        public static int GetTypeDefinitionId(this ExportedType exportedType);
+    }
+    public enum HeapIndex {
+        Blob = 2,
+        Guid = 3,
+        String = 1,
+        UserString = 0,
+    }
+    public sealed class MetadataAggregator {
+        public MetadataAggregator(IReadOnlyList<int> baseTableRowCounts, IReadOnlyList<int> baseHeapSizes, IReadOnlyList<MetadataReader> deltaReaders);
+        public MetadataAggregator(MetadataReader baseReader, IReadOnlyList<MetadataReader> deltaReaders);
+        public Handle GetGenerationHandle(Handle handle, out int generation);
+    }
+    public static class MetadataReaderExtensions {
+        public static IEnumerable<EditAndContinueLogEntry> GetEditAndContinueLogEntries(this MetadataReader reader);
+        public static IEnumerable<EntityHandle> GetEditAndContinueMapEntries(this MetadataReader reader);
+        public static int GetHeapMetadataOffset(this MetadataReader reader, HeapIndex heapIndex);
+        public static int GetHeapSize(this MetadataReader reader, HeapIndex heapIndex);
+        public static BlobHandle GetNextHandle(this MetadataReader reader, BlobHandle handle);
+        public static StringHandle GetNextHandle(this MetadataReader reader, StringHandle handle);
+        public static UserStringHandle GetNextHandle(this MetadataReader reader, UserStringHandle handle);
+        public static int GetTableMetadataOffset(this MetadataReader reader, TableIndex tableIndex);
+        public static int GetTableRowCount(this MetadataReader reader, TableIndex tableIndex);
+        public static int GetTableRowSize(this MetadataReader reader, TableIndex tableIndex);
+        public static IEnumerable<TypeDefinitionHandle> GetTypesWithEvents(this MetadataReader reader);
+        public static IEnumerable<TypeDefinitionHandle> GetTypesWithProperties(this MetadataReader reader);
+    }
+    public static class MetadataTokens {
+        public static readonly int HeapCount;
+        public static readonly int TableCount;
+        public static AssemblyFileHandle AssemblyFileHandle(int rowNumber);
+        public static AssemblyReferenceHandle AssemblyReferenceHandle(int rowNumber);
+        public static BlobHandle BlobHandle(int offset);
+        public static ConstantHandle ConstantHandle(int rowNumber);
+        public static CustomAttributeHandle CustomAttributeHandle(int rowNumber);
+        public static CustomDebugInformationHandle CustomDebugInformationHandle(int rowNumber);
+        public static DeclarativeSecurityAttributeHandle DeclarativeSecurityAttributeHandle(int rowNumber);
+        public static DocumentHandle DocumentHandle(int rowNumber);
+        public static DocumentNameBlobHandle DocumentNameBlobHandle(int offset);
+        public static EntityHandle EntityHandle(int token);
+        public static EntityHandle EntityHandle(TableIndex tableIndex, int rowNumber);
+        public static EventDefinitionHandle EventDefinitionHandle(int rowNumber);
+        public static ExportedTypeHandle ExportedTypeHandle(int rowNumber);
+        public static FieldDefinitionHandle FieldDefinitionHandle(int rowNumber);
+        public static GenericParameterConstraintHandle GenericParameterConstraintHandle(int rowNumber);
+        public static GenericParameterHandle GenericParameterHandle(int rowNumber);
+        public static int GetHeapOffset(Handle handle);
+        public static int GetHeapOffset(this MetadataReader reader, Handle handle);
+        public static int GetRowNumber(EntityHandle handle);
+        public static int GetRowNumber(this MetadataReader reader, EntityHandle handle);
+        public static int GetToken(EntityHandle handle);
+        public static int GetToken(Handle handle);
+        public static int GetToken(this MetadataReader reader, EntityHandle handle);
+        public static int GetToken(this MetadataReader reader, Handle handle);
+        public static GuidHandle GuidHandle(int offset);
+        public static Handle Handle(int token);
+        public static EntityHandle Handle(TableIndex tableIndex, int rowNumber);
+        public static ImportScopeHandle ImportScopeHandle(int rowNumber);
+        public static InterfaceImplementationHandle InterfaceImplementationHandle(int rowNumber);
+        public static LocalConstantHandle LocalConstantHandle(int rowNumber);
+        public static LocalScopeHandle LocalScopeHandle(int rowNumber);
+        public static LocalVariableHandle LocalVariableHandle(int rowNumber);
+        public static ManifestResourceHandle ManifestResourceHandle(int rowNumber);
+        public static MemberReferenceHandle MemberReferenceHandle(int rowNumber);
+        public static MethodDebugInformationHandle MethodDebugInformationHandle(int rowNumber);
+        public static MethodDefinitionHandle MethodDefinitionHandle(int rowNumber);
+        public static MethodImplementationHandle MethodImplementationHandle(int rowNumber);
+        public static MethodSpecificationHandle MethodSpecificationHandle(int rowNumber);
+        public static ModuleReferenceHandle ModuleReferenceHandle(int rowNumber);
+        public static ParameterHandle ParameterHandle(int rowNumber);
+        public static PropertyDefinitionHandle PropertyDefinitionHandle(int rowNumber);
+        public static StandaloneSignatureHandle StandaloneSignatureHandle(int rowNumber);
+        public static StringHandle StringHandle(int offset);
+        public static bool TryGetHeapIndex(HandleKind type, out HeapIndex index);
+        public static bool TryGetTableIndex(HandleKind type, out TableIndex index);
+        public static TypeDefinitionHandle TypeDefinitionHandle(int rowNumber);
+        public static TypeReferenceHandle TypeReferenceHandle(int rowNumber);
+        public static TypeSpecificationHandle TypeSpecificationHandle(int rowNumber);
+        public static UserStringHandle UserStringHandle(int offset);
+    }
+    public enum TableIndex : byte {
+        Assembly = (byte)32,
+        AssemblyOS = (byte)34,
+        AssemblyProcessor = (byte)33,
+        AssemblyRef = (byte)35,
+        AssemblyRefOS = (byte)37,
+        AssemblyRefProcessor = (byte)36,
+        ClassLayout = (byte)15,
+        Constant = (byte)11,
+        CustomAttribute = (byte)12,
+        CustomDebugInformation = (byte)55,
+        DeclSecurity = (byte)14,
+        Document = (byte)48,
+        EncLog = (byte)30,
+        EncMap = (byte)31,
+        Event = (byte)20,
+        EventMap = (byte)18,
+        EventPtr = (byte)19,
+        ExportedType = (byte)39,
+        Field = (byte)4,
+        FieldLayout = (byte)16,
+        FieldMarshal = (byte)13,
+        FieldPtr = (byte)3,
+        FieldRva = (byte)29,
+        File = (byte)38,
+        GenericParam = (byte)42,
+        GenericParamConstraint = (byte)44,
+        ImplMap = (byte)28,
+        ImportScope = (byte)53,
+        InterfaceImpl = (byte)9,
+        LocalConstant = (byte)52,
+        LocalScope = (byte)50,
+        LocalVariable = (byte)51,
+        ManifestResource = (byte)40,
+        MemberRef = (byte)10,
+        MethodDebugInformation = (byte)49,
+        MethodDef = (byte)6,
+        MethodImpl = (byte)25,
+        MethodPtr = (byte)5,
+        MethodSemantics = (byte)24,
+        MethodSpec = (byte)43,
+        Module = (byte)0,
+        ModuleRef = (byte)26,
+        NestedClass = (byte)41,
+        Param = (byte)8,
+        ParamPtr = (byte)7,
+        Property = (byte)23,
+        PropertyMap = (byte)21,
+        PropertyPtr = (byte)22,
+        StandAloneSig = (byte)17,
+        StateMachineMethod = (byte)54,
+        TypeDef = (byte)2,
+        TypeRef = (byte)1,
+        TypeSpec = (byte)27,
+    }
+}
```

## System.Reflection.PortableExecutable

```c#
+namespace System.Reflection.PortableExecutable {
+    public enum Characteristics : ushort {
+        AggressiveWSTrim = (ushort)16,
+        Bit32Machine = (ushort)256,
+        BytesReversedHi = (ushort)32768,
+        BytesReversedLo = (ushort)128,
+        DebugStripped = (ushort)512,
+        Dll = (ushort)8192,
+        ExecutableImage = (ushort)2,
+        LargeAddressAware = (ushort)32,
+        LineNumsStripped = (ushort)4,
+        LocalSymsStripped = (ushort)8,
+        NetRunFromSwap = (ushort)2048,
+        RelocsStripped = (ushort)1,
+        RemovableRunFromSwap = (ushort)1024,
+        System = (ushort)4096,
+        UpSystemOnly = (ushort)16384,
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct CodeViewDebugDirectoryData {
+        public int Age { get; }
+        public Guid Guid { get; }
+        public string Path { get; }
+    }
+    public sealed class CoffHeader {
+        public Characteristics Characteristics { get; }
+        public Machine Machine { get; }
+        public short NumberOfSections { get; }
+        public int NumberOfSymbols { get; }
+        public int PointerToSymbolTable { get; }
+        public short SizeOfOptionalHeader { get; }
+        public int TimeDateStamp { get; }
+    }
+    public enum CorFlags {
+        ILLibrary = 4,
+        ILOnly = 1,
+        NativeEntryPoint = 16,
+        Prefers32Bit = 131072,
+        Requires32Bit = 2,
+        StrongNameSigned = 8,
+        TrackDebugData = 65536,
+    }
+    public sealed class CorHeader {
+        public DirectoryEntry CodeManagerTableDirectory { get; }
+        public int EntryPointTokenOrRelativeVirtualAddress { get; }
+        public DirectoryEntry ExportAddressTableJumpsDirectory { get; }
+        public CorFlags Flags { get; }
+        public ushort MajorRuntimeVersion { get; }
+        public DirectoryEntry ManagedNativeHeaderDirectory { get; }
+        public DirectoryEntry MetadataDirectory { get; }
+        public ushort MinorRuntimeVersion { get; }
+        public DirectoryEntry ResourcesDirectory { get; }
+        public DirectoryEntry StrongNameSignatureDirectory { get; }
+        public DirectoryEntry VtableFixupsDirectory { get; }
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct DebugDirectoryEntry {
+        public DebugDirectoryEntry(uint stamp, ushort majorVersion, ushort minorVersion, DebugDirectoryEntryType type, int dataSize, int dataRelativeVirtualAddress, int dataPointer);
+        public int DataPointer { get; }
+        public int DataRelativeVirtualAddress { get; }
+        public int DataSize { get; }
+        public ushort MajorVersion { get; }
+        public ushort MinorVersion { get; }
+        public uint Stamp { get; }
+        public DebugDirectoryEntryType Type { get; }
+    }
+    public enum DebugDirectoryEntryType {
+        CodeView = 2,
+        Coff = 1,
+        Reproducible = 16,
+        Unknown = 0,
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct DirectoryEntry {
+        public readonly int RelativeVirtualAddress;
+        public readonly int Size;
+        public DirectoryEntry(int relativeVirtualAddress, int size);
+    }
+    public enum DllCharacteristics : ushort {
+        AppContainer = (ushort)4096,
+        DynamicBase = (ushort)64,
+        HighEntropyVirtualAddressSpace = (ushort)32,
+        NoBind = (ushort)2048,
+        NoIsolation = (ushort)512,
+        NoSeh = (ushort)1024,
+        NxCompatible = (ushort)256,
+        ProcessInit = (ushort)1,
+        ProcessTerm = (ushort)2,
+        TerminalServerAware = (ushort)32768,
+        ThreadInit = (ushort)4,
+        ThreadTerm = (ushort)8,
+        WdmDriver = (ushort)8192,
+    }
+    public enum Machine : ushort {
+        Alpha = (ushort)388,
+        Alpha64 = (ushort)644,
+        AM33 = (ushort)467,
+        Amd64 = (ushort)34404,
+        Arm = (ushort)448,
+        ArmThumb2 = (ushort)452,
+        Ebc = (ushort)3772,
+        I386 = (ushort)332,
+        IA64 = (ushort)512,
+        M32R = (ushort)36929,
+        MIPS16 = (ushort)614,
+        MipsFpu = (ushort)870,
+        MipsFpu16 = (ushort)1126,
+        PowerPC = (ushort)496,
+        PowerPCFP = (ushort)497,
+        SH3 = (ushort)418,
+        SH3Dsp = (ushort)419,
+        SH3E = (ushort)420,
+        SH4 = (ushort)422,
+        SH5 = (ushort)424,
+        Thumb = (ushort)450,
+        Tricore = (ushort)1312,
+        Unknown = (ushort)0,
+        WceMipsV2 = (ushort)361,
+    }
+    public sealed class PEHeader {
+        public int AddressOfEntryPoint { get; }
+        public int BaseOfCode { get; }
+        public int BaseOfData { get; }
+        public DirectoryEntry BaseRelocationTableDirectory { get; }
+        public DirectoryEntry BoundImportTableDirectory { get; }
+        public DirectoryEntry CertificateTableDirectory { get; }
+        public uint CheckSum { get; }
+        public DirectoryEntry CopyrightTableDirectory { get; }
+        public DirectoryEntry CorHeaderTableDirectory { get; }
+        public DirectoryEntry DebugTableDirectory { get; }
+        public DirectoryEntry DelayImportTableDirectory { get; }
+        public DllCharacteristics DllCharacteristics { get; }
+        public DirectoryEntry ExceptionTableDirectory { get; }
+        public DirectoryEntry ExportTableDirectory { get; }
+        public int FileAlignment { get; }
+        public DirectoryEntry GlobalPointerTableDirectory { get; }
+        public ulong ImageBase { get; }
+        public DirectoryEntry ImportAddressTableDirectory { get; }
+        public DirectoryEntry ImportTableDirectory { get; }
+        public DirectoryEntry LoadConfigTableDirectory { get; }
+        public PEMagic Magic { get; }
+        public ushort MajorImageVersion { get; }
+        public byte MajorLinkerVersion { get; }
+        public ushort MajorOperatingSystemVersion { get; }
+        public ushort MajorSubsystemVersion { get; }
+        public ushort MinorImageVersion { get; }
+        public byte MinorLinkerVersion { get; }
+        public ushort MinorOperatingSystemVersion { get; }
+        public ushort MinorSubsystemVersion { get; }
+        public int NumberOfRvaAndSizes { get; }
+        public DirectoryEntry ResourceTableDirectory { get; }
+        public int SectionAlignment { get; }
+        public int SizeOfCode { get; }
+        public int SizeOfHeaders { get; }
+        public ulong SizeOfHeapCommit { get; }
+        public ulong SizeOfHeapReserve { get; }
+        public int SizeOfImage { get; }
+        public int SizeOfInitializedData { get; }
+        public ulong SizeOfStackCommit { get; }
+        public ulong SizeOfStackReserve { get; }
+        public int SizeOfUninitializedData { get; }
+        public Subsystem Subsystem { get; }
+        public DirectoryEntry ThreadLocalStorageTableDirectory { get; }
+    }
+    public sealed class PEHeaders {
+        public PEHeaders(Stream peStream);
+        public PEHeaders(Stream peStream, int size);
+        public CoffHeader CoffHeader { get; }
+        public int CoffHeaderStartOffset { get; }
+        public CorHeader CorHeader { get; }
+        public int CorHeaderStartOffset { get; }
+        public bool IsCoffOnly { get; }
+        public bool IsConsoleApplication { get; }
+        public bool IsDll { get; }
+        public bool IsExe { get; }
+        public int MetadataSize { get; }
+        public int MetadataStartOffset { get; }
+        public PEHeader PEHeader { get; }
+        public int PEHeaderStartOffset { get; }
+        public ImmutableArray<SectionHeader> SectionHeaders { get; }
+        public int GetContainingSectionIndex(int relativeVirtualAddress);
+        public bool TryGetDirectoryOffset(DirectoryEntry directory, out int offset);
+    }
+    public enum PEMagic : ushort {
+        PE32 = (ushort)267,
+        PE32Plus = (ushort)523,
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct PEMemoryBlock {
+        public int Length { get; }
+        public unsafe byte* Pointer { get; }
+        public ImmutableArray<byte> GetContent();
+    }
+    public sealed class PEReader : IDisposable {
+        public unsafe PEReader(byte* peImage, int size);
+        public PEReader(ImmutableArray<byte> peImage);
+        public PEReader(Stream peStream);
+        public PEReader(Stream peStream, PEStreamOptions options);
+        public PEReader(Stream peStream, PEStreamOptions options, int size);
+        public bool HasMetadata { get; }
+        public bool IsEntireImageAvailable { get; }
+        public PEHeaders PEHeaders { get; }
+        public void Dispose();
+        public PEMemoryBlock GetEntireImage();
+        public PEMemoryBlock GetMetadata();
+        public PEMemoryBlock GetSectionData(int relativeVirtualAddress);
+        public CodeViewDebugDirectoryData ReadCodeViewDebugDirectoryData(DebugDirectoryEntry entry);
+        public ImmutableArray<DebugDirectoryEntry> ReadDebugDirectory();
+    }
+    public enum PEStreamOptions {
+        Default = 0,
+        LeaveOpen = 1,
+        PrefetchEntireImage = 4,
+        PrefetchMetadata = 2,
+    }
+    public enum SectionCharacteristics : uint {
+        Align1024Bytes = (uint)11534336,
+        Align128Bytes = (uint)8388608,
+        Align16Bytes = (uint)5242880,
+        Align1Bytes = (uint)1048576,
+        Align2048Bytes = (uint)12582912,
+        Align256Bytes = (uint)9437184,
+        Align2Bytes = (uint)2097152,
+        Align32Bytes = (uint)6291456,
+        Align4096Bytes = (uint)13631488,
+        Align4Bytes = (uint)3145728,
+        Align512Bytes = (uint)10485760,
+        Align64Bytes = (uint)7340032,
+        Align8192Bytes = (uint)14680064,
+        Align8Bytes = (uint)4194304,
+        AlignMask = (uint)15728640,
+        ContainsCode = (uint)32,
+        ContainsInitializedData = (uint)64,
+        ContainsUninitializedData = (uint)128,
+        GPRel = (uint)32768,
+        LinkerComdat = (uint)4096,
+        LinkerInfo = (uint)512,
+        LinkerNRelocOvfl = (uint)16777216,
+        LinkerOther = (uint)256,
+        LinkerRemove = (uint)2048,
+        Mem16Bit = (uint)131072,
+        MemDiscardable = (uint)33554432,
+        MemExecute = (uint)536870912,
+        MemFardata = (uint)32768,
+        MemLocked = (uint)262144,
+        MemNotCached = (uint)67108864,
+        MemNotPaged = (uint)134217728,
+        MemPreload = (uint)524288,
+        MemProtected = (uint)16384,
+        MemPurgeable = (uint)131072,
+        MemRead = (uint)1073741824,
+        MemShared = (uint)268435456,
+        MemSysheap = (uint)65536,
+        MemWrite = (uint)2147483648,
+        NoDeferSpecExc = (uint)16384,
+        TypeCopy = (uint)16,
+        TypeDSect = (uint)1,
+        TypeGroup = (uint)4,
+        TypeNoLoad = (uint)2,
+        TypeNoPad = (uint)8,
+        TypeOver = (uint)1024,
+        TypeReg = (uint)0,
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct SectionHeader {
+        public string Name { get; }
+        public ushort NumberOfLineNumbers { get; }
+        public ushort NumberOfRelocations { get; }
+        public int PointerToLineNumbers { get; }
+        public int PointerToRawData { get; }
+        public int PointerToRelocations { get; }
+        public SectionCharacteristics SectionCharacteristics { get; }
+        public int SizeOfRawData { get; }
+        public int VirtualAddress { get; }
+        public int VirtualSize { get; }
+    }
+    public enum Subsystem : ushort {
+        EfiApplication = (ushort)10,
+        EfiBootServiceDriver = (ushort)11,
+        EfiRom = (ushort)13,
+        EfiRuntimeDriver = (ushort)12,
+        Native = (ushort)1,
+        NativeWindows = (ushort)8,
+        OS2Cui = (ushort)5,
+        PosixCui = (ushort)7,
+        Unknown = (ushort)0,
+        WindowsCEGui = (ushort)9,
+        WindowsCui = (ushort)3,
+        WindowsGui = (ushort)2,
+        Xbox = (ushort)14,
+    }
+}
```

## System.Resources

```c#
+namespace System.Resources {
+    public interface IResourceReader : IDisposable, IEnumerable {
+        new IDictionaryEnumerator GetEnumerator();
+    }
+    public class MissingManifestResourceException : Exception {
+        public MissingManifestResourceException();
+        public MissingManifestResourceException(string message);
+        public MissingManifestResourceException(string message, Exception inner);
+    }
+    public sealed class NeutralResourcesLanguageAttribute : Attribute {
+        public NeutralResourcesLanguageAttribute(string cultureName);
+        public NeutralResourcesLanguageAttribute(string cultureName, UltimateResourceFallbackLocation location);
+        public string CultureName { get; }
+        public UltimateResourceFallbackLocation Location { get; }
+    }
+    public class ResourceManager {
+        public static readonly int HeaderVersionNumber;
+        public static readonly int MagicNumber;
+        protected Assembly MainAssembly;
+        protected string BaseNameField;
+        protected ResourceManager();
+        public ResourceManager(string baseName, Assembly assembly);
+        [MethodImpl(NoInlining)]public ResourceManager(string baseName, Assembly assembly, Type usingResourceSet);
+        public ResourceManager(Type resourceSource);
+        public virtual string BaseName { get; }
+        public virtual bool IgnoreCase { get; set; }
+        public virtual Type ResourceSetType { get; }
+        protected static CultureInfo GetNeutralResourcesLanguage(Assembly a);
+        public virtual object GetObject(string name);
+        public virtual object GetObject(string name, CultureInfo culture);
+        protected virtual string GetResourceFileName(CultureInfo culture);
+        [MethodImpl(NoInlining)]public virtual ResourceSet GetResourceSet(CultureInfo culture, bool createIfNotExists, bool tryParents);
+        protected static Version GetSatelliteContractVersion(Assembly a);
+        public UnmanagedMemoryStream GetStream(string name);
+        public UnmanagedMemoryStream GetStream(string name, CultureInfo culture);
+        public string GetString(string name);
+        public virtual string GetString(string name, CultureInfo culture);
+        [MethodImpl(NoInlining)]protected virtual ResourceSet InternalGetResourceSet(CultureInfo culture, bool createIfNotExists, bool tryParents);
+        public virtual void ReleaseAllResources();
+    }
+    public sealed class ResourceReader : IDisposable {
+        public ResourceReader(Stream stream);
+        public void Dispose();
+        public IDictionaryEnumerator GetEnumerator();
+    }
+    public class ResourceSet : IDisposable, IEnumerable {
+        protected IResourceReader Reader;
+        protected ResourceSet();
+        public ResourceSet(Stream stream);
+        public ResourceSet(string fileName);
+        public virtual void Close();
+        public void Dispose();
+        protected virtual void Dispose(bool disposing);
+        public virtual Type GetDefaultReader();
+        public virtual IDictionaryEnumerator GetEnumerator();
+        public virtual object GetObject(string name);
+        public virtual object GetObject(string name, bool ignoreCase);
+        public virtual string GetString(string name);
+        public virtual string GetString(string name, bool ignoreCase);
+        protected virtual void ReadResources();
+        IEnumerator System.Collections.IEnumerable.GetEnumerator();
+    }
+    public sealed class ResourceWriter : IDisposable {
+        public ResourceWriter(Stream stream);
+        public void AddResource(string name, string value);
+        public void Dispose();
+        public void Generate();
+    }
+    public sealed class SatelliteContractVersionAttribute : Attribute {
+        public SatelliteContractVersionAttribute(string version);
+        public string Version { get; }
+    }
+    public enum UltimateResourceFallbackLocation {
+        MainAssembly = 0,
+        Satellite = 1,
+    }
+}
```

## System.Runtime

```c#
+namespace System.Runtime {
+    public enum AsyncCompletionResult {
+        Completed = 1,
+        Queued = 0,
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Size=1)]
+    public struct DefaultTaskSchedulerAwaiter : INotifyCompletion {
+        public static DefaultTaskSchedulerAwaiter Singleton;
+        public bool IsCompleted { get; }
+        public DefaultTaskSchedulerAwaiter GetAwaiter();
+        public void GetResult();
+        public void OnCompleted(Action continuation);
+    }
+    public static class Fx {
+        public static Fx.ExceptionHandler AsynchronousThreadExceptionHandler { get; set; }
+        public static byte[] AllocateByteArray(int size);
+        public static char[] AllocateCharArray(int size);
+        public static void Assert(bool condition, string description);
+        public static void Assert(string description);
+        public static void AssertAndFailFast(bool condition, string description);
+        [MethodImpl(NoInlining)]public static Exception AssertAndFailFast(string description);
+        public static void AssertAndThrow(bool condition, string description);
+        [MethodImpl(NoInlining)]public static Exception AssertAndThrow(string description);
+        public static void AssertAndThrowFatal(bool condition, string description);
+        [MethodImpl(NoInlining)]public static Exception AssertAndThrowFatal(string description);
+        public static Guid CreateGuid(string guidString);
+        public static bool IsFatal(Exception exception);
+        public static AsyncCallback ThunkCallback(AsyncCallback callback);
+        public static bool TryCreateGuid(string guidString, out Guid result);
+        public abstract class ExceptionHandler {
+            protected ExceptionHandler();
+            public abstract bool HandleException(Exception exception);
+        }
+        public static class Tag {
+            public sealed class BlockingAttribute : Attribute {
+                public BlockingAttribute();
+                public Type CancelDeclaringType { get; set; }
+                public string CancelMethod { get; set; }
+                public string Conditional { get; set; }
+            }
+            public enum BlocksUsing {
+                AsyncResult = 4,
+                AutoResetEvent = 3,
+                IAsyncResult = 5,
+                InputQueue = 7,
+                ManualResetEvent = 2,
+                MonitorEnter = 0,
+                MonitorWait = 1,
+                NonBlocking = 14,
+                Other = 13,
+                OtherFrameworkPrimitive = 11,
+                OtherInternalPrimitive = 10,
+                OtherInterop = 12,
+                PInvoke = 6,
+                PrivatePrimitive = 9,
+                ThreadNeutralSemaphore = 8,
+            }
+            public sealed class CacheAttribute : Attribute {
+                public CacheAttribute(Type elementType, Fx.Tag.CacheAttrition cacheAttrition);
+                public Fx.Tag.CacheAttrition CacheAttrition { get; }
+                public Type ElementType { get; }
+                public string Scope { get; set; }
+                public string SizeLimit { get; set; }
+                public string Timeout { get; set; }
+            }
+            public enum CacheAttrition {
+                ElementOnCallback = 3,
+                ElementOnGC = 2,
+                ElementOnTimer = 1,
+                FullPurgeOnEachAccess = 5,
+                FullPurgeOnTimer = 4,
+                None = 0,
+                PartialPurgeOnEachAccess = 7,
+                PartialPurgeOnTimer = 6,
+            }
+            public sealed class ExternalResourceAttribute : Attribute {
+                public ExternalResourceAttribute(Fx.Tag.Location location, string description);
+                public string Description { get; }
+                public Fx.Tag.Location Location { get; }
+            }
+            public sealed class FriendAccessAllowedAttribute : Attribute {
+                public FriendAccessAllowedAttribute(string assemblyName);
+                public string AssemblyName { get; set; }
+            }
+            public sealed class GuaranteeNonBlockingAttribute : Attribute {
+                public GuaranteeNonBlockingAttribute();
+            }
+            public sealed class InheritThrowsAttribute : Attribute {
+                public InheritThrowsAttribute();
+                public string From { get; set; }
+                public Type FromDeclaringType { get; set; }
+            }
+            public sealed class KnownXamlExternalAttribute : Attribute {
+                public KnownXamlExternalAttribute();
+            }
+            public enum Location {
+                InProcess = 0,
+                LocalOrRemoteSystem = 3,
+                LocalSystem = 2,
+                OutOfProcess = 1,
+                RemoteSystem = 4,
+            }
+            public sealed class NonThrowingAttribute : Attribute {
+                public NonThrowingAttribute();
+            }
+            public sealed class QueueAttribute : Attribute {
+                public QueueAttribute(Type elementType);
+                public Type ElementType { get; }
+                public bool EnqueueThrowsIfFull { get; set; }
+                public string Scope { get; set; }
+                public string SizeLimit { get; set; }
+                public bool StaleElementsRemovedImmediately { get; set; }
+            }
+            public sealed class SecurityNoteAttribute : Attribute {
+                public SecurityNoteAttribute();
+                public string Critical { get; set; }
+                public string Miscellaneous { get; set; }
+                public string Safe { get; set; }
+            }
+            public static class Strings
+            public enum SynchronizationKind {
+                FromFieldType = 5,
+                InterlockedNoSpin = 3,
+                InterlockedWithSpin = 4,
+                LockStatement = 0,
+                MonitorExplicit = 2,
+                MonitorWait = 1,
+            }
+            public sealed class SynchronizationObjectAttribute : Attribute {
+                public SynchronizationObjectAttribute();
+                public bool Blocking { get; set; }
+                public Fx.Tag.SynchronizationKind Kind { get; set; }
+                public string Scope { get; set; }
+            }
+            public sealed class SynchronizationPrimitiveAttribute : Attribute {
+                public SynchronizationPrimitiveAttribute(Fx.Tag.BlocksUsing blocksUsing);
+                public Fx.Tag.BlocksUsing BlocksUsing { get; }
+                public string ReleaseMethod { get; set; }
+                public bool Spins { get; set; }
+                public bool SupportsAsync { get; set; }
+            }
+            public enum ThrottleAction {
+                Pause = 1,
+                Reject = 0,
+            }
+            public sealed class ThrottleAttribute : Attribute {
+                public ThrottleAttribute(Fx.Tag.ThrottleAction throttleAction, Fx.Tag.ThrottleMetric throttleMetric, string limit);
+                public string Limit { get; }
+                public string Scope { get; set; }
+                public Fx.Tag.ThrottleAction ThrottleAction { get; }
+                public Fx.Tag.ThrottleMetric ThrottleMetric { get; }
+            }
+            public enum ThrottleMetric {
+                Count = 0,
+                Other = 2,
+                Rate = 1,
+            }
+            public static class Throws {
+                public sealed class TimeoutAttribute : Fx.Tag.ThrowsAttribute {
+                    public TimeoutAttribute();
+                    public TimeoutAttribute(string diagnosis);
+                }
+            }
+            public class ThrowsAttribute : Attribute {
+                public ThrowsAttribute(Type exceptionType, string diagnosis);
+                public string Diagnosis { get; }
+                public Type ExceptionType { get; }
+            }
+            public sealed class XamlVisibleAttribute : Attribute {
+                public XamlVisibleAttribute();
+                public XamlVisibleAttribute(bool visible);
+                public bool Visible { get; private set; }
+            }
+        }
+    }
+    public enum GCLargeObjectHeapCompactionMode {
+        CompactOnce = 2,
+        Default = 1,
+    }
+    public enum GCLatencyMode {
+        Batch = 0,
+        Interactive = 1,
+        LowLatency = 2,
+        NoGCRegion = 4,
+        SustainedLowLatency = 3,
+    }
+    public static class GCSettings {
+        public static bool IsServerGC { get; }
+        public static GCLargeObjectHeapCompactionMode LargeObjectHeapCompactionMode { get; set; }
+        public static GCLatencyMode LatencyMode { get; set; }
+    }
+    public class MruCache<TKey, TValue> where TKey : class where TValue : class {
+        public MruCache(int watermark);
+        public MruCache(int lowWatermark, int highWatermark);
+        public MruCache(int lowWatermark, int highWatermark, IEqualityComparer<TKey> comparer);
+        public int Count { get; }
+        public void Add(TKey key, TValue value);
+        public void Clear();
+        protected virtual void OnItemAgedOutOfCache(TValue item);
+        protected virtual void OnSingleItemRemoved(TValue item);
+        public bool Remove(TKey key);
+        public bool TryGetValue(TKey key, out TValue value);
+    }
+    public class OutWrapper<T> {
+        public OutWrapper();
+        public T Value { get; set; }
+        public static implicit operator T (OutWrapper<T> wrapper);
+    }
+    public static class TaskHelpers {
+        public static Action<object> OnAsyncCompletionCallback;
+        public static Task AsyncWait<TException>(this Task task);
+        public static Task<bool> AwaitWithTimeout(this Task task, TimeSpan timeout);
+        public static Task CompletedTask();
+        public static DefaultTaskSchedulerAwaiter EnsureDefaultTaskScheduler();
+        public static Task ToApm(this Task task, AsyncCallback callback, object state);
+        public static Task<TResult> ToApm<TResult>(this Task<TResult> task, AsyncCallback callback, object state);
+        public static void ToApmEnd(this IAsyncResult iar);
+        public static TResult ToApmEnd<TResult>(this IAsyncResult iar);
+        public static void Wait(this Task task, TimeSpan timeout, Action<Exception, TimeSpan, string> exceptionConverter, string operationType);
+        public static void WaitForCompletion(this Task task);
+        public static TResult WaitForCompletion<TResult>(this Task<TResult> task);
+        public static void WaitForCompletionNoSpin(this Task task);
+        public static bool WaitForCompletionNoSpin(this Task task, TimeSpan timeout);
+        public static TResult WaitForCompletionNoSpin<TResult>(this Task<TResult> task);
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct TimeoutHelper {
+        public static readonly TimeSpan MaxWait;
+        public TimeoutHelper(TimeSpan timeout);
+        public TimeSpan OriginalTimeout { get; }
+        public static DateTime Add(DateTime time, TimeSpan timeout);
+        public static TimeSpan Add(TimeSpan timeout1, TimeSpan timeout2);
+        public static TimeSpan Divide(TimeSpan timeout, int factor);
+        public TimeSpan ElapsedTime();
+        public static TimeSpan FromMilliseconds(int milliseconds);
+        public CancellationToken GetCancellationToken();
+        public Task<CancellationToken> GetCancellationTokenAsync();
+        public static bool IsTooLarge(TimeSpan timeout);
+        public static TimeSpan Min(TimeSpan val1, TimeSpan val2);
+        public TimeSpan RemainingTime();
+        public static DateTime Subtract(DateTime time, TimeSpan timeout);
+        public static void ThrowIfNegativeArgument(TimeSpan timeout);
+        public static void ThrowIfNegativeArgument(TimeSpan timeout, string argumentName);
+        public static void ThrowIfNonPositiveArgument(TimeSpan timeout);
+        public static void ThrowIfNonPositiveArgument(TimeSpan timeout, string argumentName);
+        public static int ToMilliseconds(TimeSpan timeout);
+        public static bool WaitOne(WaitHandle waitHandle, TimeSpan timeout);
+    }
+}
```

## System.Runtime.CompilerServices

```c#
+namespace System.Runtime.CompilerServices {
+    public sealed class AccessedThroughPropertyAttribute : Attribute {
+        public AccessedThroughPropertyAttribute(string propertyName);
+        public string PropertyName { get; }
+    }
+    public sealed class AsyncStateMachineAttribute : StateMachineAttribute {
+        public AsyncStateMachineAttribute(Type stateMachineType);
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct AsyncTaskMethodBuilder {
+        public Task Task { get; }
+        public void AwaitOnCompleted<TAwaiter, TStateMachine>(ref TAwaiter awaiter, ref TStateMachine stateMachine) where TAwaiter : INotifyCompletion where TStateMachine : IAsyncStateMachine;
+        public void AwaitUnsafeOnCompleted<TAwaiter, TStateMachine>(ref TAwaiter awaiter, ref TStateMachine stateMachine) where TAwaiter : ICriticalNotifyCompletion where TStateMachine : IAsyncStateMachine;
+        public static AsyncTaskMethodBuilder Create();
+        public void SetException(Exception exception);
+        public void SetResult();
+        public void SetStateMachine(IAsyncStateMachine stateMachine);
+        public void Start<TStateMachine>(ref TStateMachine stateMachine) where TStateMachine : IAsyncStateMachine;
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct AsyncTaskMethodBuilder<TResult> {
+        public Task<TResult> Task { get; }
+        public void AwaitOnCompleted<TAwaiter, TStateMachine>(ref TAwaiter awaiter, ref TStateMachine stateMachine) where TAwaiter : INotifyCompletion where TStateMachine : IAsyncStateMachine;
+        public void AwaitUnsafeOnCompleted<TAwaiter, TStateMachine>(ref TAwaiter awaiter, ref TStateMachine stateMachine) where TAwaiter : ICriticalNotifyCompletion where TStateMachine : IAsyncStateMachine;
+        public static AsyncTaskMethodBuilder<TResult> Create();
+        public void SetException(Exception exception);
+        public void SetResult(TResult result);
+        public void SetStateMachine(IAsyncStateMachine stateMachine);
+        public void Start<TStateMachine>(ref TStateMachine stateMachine) where TStateMachine : IAsyncStateMachine;
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct AsyncVoidMethodBuilder {
+        public void AwaitOnCompleted<TAwaiter, TStateMachine>(ref TAwaiter awaiter, ref TStateMachine stateMachine) where TAwaiter : INotifyCompletion where TStateMachine : IAsyncStateMachine;
+        public void AwaitUnsafeOnCompleted<TAwaiter, TStateMachine>(ref TAwaiter awaiter, ref TStateMachine stateMachine) where TAwaiter : ICriticalNotifyCompletion where TStateMachine : IAsyncStateMachine;
+        public static AsyncVoidMethodBuilder Create();
+        public void SetException(Exception exception);
+        public void SetResult();
+        public void SetStateMachine(IAsyncStateMachine stateMachine);
+        public void Start<TStateMachine>(ref TStateMachine stateMachine) where TStateMachine : IAsyncStateMachine;
+    }
+    public class CallConvCdecl
+    public class CallConvFastcall
+    public class CallConvStdcall
+    public class CallConvThiscall
+    public sealed class CallerFilePathAttribute : Attribute {
+        public CallerFilePathAttribute();
+    }
+    public sealed class CallerLineNumberAttribute : Attribute {
+        public CallerLineNumberAttribute();
+    }
+    public sealed class CallerMemberNameAttribute : Attribute {
+        public CallerMemberNameAttribute();
+    }
+    public class CallSite {
+        public CallSiteBinder Binder { get; }
+        public static CallSite Create(Type delegateType, CallSiteBinder binder);
+    }
+    public class CallSite<T> : CallSite where T : class {
+        public T Target;
+        public T Update { get; }
+        public static CallSite<T> Create(CallSiteBinder binder);
+    }
+    public abstract class CallSiteBinder {
+        protected CallSiteBinder();
+        public static LabelTarget UpdateLabel { get; }
+        public abstract Expression Bind(object[] args, ReadOnlyCollection<ParameterExpression> parameters, LabelTarget returnLabel);
+        public virtual T BindDelegate<T>(CallSite<T> site, object[] args) where T : class;
+        protected void CacheTarget<T>(T target) where T : class;
+    }
+    public static class CallSiteHelpers {
+        public static bool IsInternalFrame(MethodBase mb);
+    }
+    public enum CompilationRelaxations {
+        NoStringInterning = 8,
+    }
+    public class CompilationRelaxationsAttribute : Attribute {
+        public CompilationRelaxationsAttribute(int relaxations);
+        public CompilationRelaxationsAttribute(CompilationRelaxations relaxations);
+        public int CompilationRelaxations { get; }
+    }
+    public sealed class CompilerGeneratedAttribute : Attribute {
+        public CompilerGeneratedAttribute();
+    }
+    public static class CompilerMarshalOverride
+    public sealed class ConditionalWeakTable<TKey, TValue> where TKey : class where TValue : class {
+        public ConditionalWeakTable();
+        public void Add(TKey key, TValue value);
+        ~ConditionalWeakTable();
+        public TValue GetOrCreateValue(TKey key);
+        public TValue GetValue(TKey key, ConditionalWeakTable<TKey, TValue>.CreateValueCallback createValueCallback);
+        public bool Remove(TKey key);
+        public bool TryGetValue(TKey key, out TValue value);
+        public delegate TValue CreateValueCallback(TKey key);
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct ConfiguredTaskAwaitable {
+        public ConfiguredTaskAwaitable.ConfiguredTaskAwaiter GetAwaiter();
+        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+        public struct ConfiguredTaskAwaiter : ICriticalNotifyCompletion, INotifyCompletion {
+            public bool IsCompleted { get; }
+            public void GetResult();
+            public void OnCompleted(Action continuation);
+            public void UnsafeOnCompleted(Action continuation);
+        }
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct ConfiguredTaskAwaitable<TResult> {
+        public ConfiguredTaskAwaitable<TResult>.ConfiguredTaskAwaiter GetAwaiter();
+        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+        public struct ConfiguredTaskAwaiter : ICriticalNotifyCompletion, INotifyCompletion {
+            public bool IsCompleted { get; }
+            public TResult GetResult();
+            public void OnCompleted(Action continuation);
+            public void UnsafeOnCompleted(Action continuation);
+        }
+    }
+    public struct ConfiguredValueTaskAwaitable<TResult> {
+        public ConfiguredValueTaskAwaitable<TResult>.ConfiguredValueTaskAwaiter GetAwaiter();
+        public struct ConfiguredValueTaskAwaiter : ICriticalNotifyCompletion, INotifyCompletion {
+            public bool IsCompleted { get; }
+            public TResult GetResult();
+            public void OnCompleted(Action continuation);
+            public void UnsafeOnCompleted(Action continuation);
+        }
+    }
+    public static class ContractHelper {
+        public static string RaiseContractFailedEvent(ContractFailureKind failureKind, string userMessage, string conditionText, Exception innerException);
+        public static void TriggerFailure(ContractFailureKind kind, string displayMessage, string userMessage, string conditionText, Exception innerException);
+    }
+    public abstract class CustomConstantAttribute : Attribute {
+        protected CustomConstantAttribute();
+        public abstract object Value { get; }
+    }
+    public sealed class DateTimeConstantAttribute : CustomConstantAttribute {
+        public DateTimeConstantAttribute(long ticks);
+        public override object Value { get; }
+    }
+    public sealed class DecimalConstantAttribute : Attribute {
+        public DecimalConstantAttribute(byte scale, byte sign, int hi, int mid, int low);
+        public DecimalConstantAttribute(byte scale, byte sign, uint hi, uint mid, uint low);
+        public Decimal Value { get; }
+    }
+    public sealed class DisablePrivateReflectionAttribute : Attribute {
+        public DisablePrivateReflectionAttribute();
+    }
+    public sealed class DynamicAttribute : Attribute {
+        public DynamicAttribute();
+        public DynamicAttribute(bool[] transformFlags);
+        public IList<bool> TransformFlags { get; }
+    }
+    public sealed class ExtensionAttribute : Attribute {
+        public ExtensionAttribute();
+    }
+    public sealed class FixedAddressValueTypeAttribute : Attribute {
+        public FixedAddressValueTypeAttribute();
+    }
+    public sealed class FixedBufferAttribute : Attribute {
+        public FixedBufferAttribute(Type elementType, int length);
+        public Type ElementType { get; }
+        public int Length { get; }
+    }
+    public static class FormattableStringFactory {
+        public static FormattableString Create(string format, params object[] arguments);
+    }
+    public interface IAsyncStateMachine {
+        void MoveNext();
+        void SetStateMachine(IAsyncStateMachine stateMachine);
+    }
+    public interface ICastable {
+        RuntimeTypeHandle GetImplType(RuntimeTypeHandle interfaceType);
+        bool IsInstanceOfInterface(RuntimeTypeHandle interfaceType, out Exception castError);
+    }
+    public interface ICriticalNotifyCompletion : INotifyCompletion {
+        void UnsafeOnCompleted(Action continuation);
+    }
+    public sealed class IndexerNameAttribute : Attribute {
+        public IndexerNameAttribute(string indexerName);
+    }
+    public interface INotifyCompletion {
+        void OnCompleted(Action continuation);
+    }
+    public sealed class InternalsVisibleToAttribute : Attribute {
+        public InternalsVisibleToAttribute(string assemblyName);
+        public bool AllInternalsVisible { get; set; }
+        public string AssemblyName { get; }
+    }
+    public static class IsBoxed
+    public static class IsByValue
+    public static class IsConst
+    public static class IsCopyConstructed
+    public static class IsExplicitlyDereferenced
+    public static class IsImplicitlyDereferenced
+    public static class IsJitIntrinsic
+    public static class IsLong
+    public static class IsSignUnspecifiedByte
+    public interface IStrongBox {
+        object Value { get; set; }
+    }
+    public static class IsUdtReturn
+    public static class IsVolatile
+    public sealed class IteratorStateMachineAttribute : StateMachineAttribute {
+        public IteratorStateMachineAttribute(Type stateMachineType);
+    }
+    public enum MethodCodeType {
+        IL = 0,
+        Native = 1,
+        OPTIL = 2,
+        Runtime = 3,
+    }
+    public sealed class MethodImplAttribute : Attribute {
+        public MethodCodeType MethodCodeType;
+        public MethodImplAttribute();
+        public MethodImplAttribute(short value);
+        public MethodImplAttribute(MethodImplOptions methodImplOptions);
+        public MethodImplOptions Value { get; }
+    }
+    public enum MethodImplOptions {
+        AggressiveInlining = 256,
+        ForwardRef = 16,
+        InternalCall = 4096,
+        NoInlining = 8,
+        NoOptimization = 64,
+        PreserveSig = 128,
+        Synchronized = 32,
+        Unmanaged = 4,
+    }
+    public sealed class NativeCppClassAttribute : Attribute {
+        public NativeCppClassAttribute();
+    }
+    public sealed class ReferenceAssemblyAttribute : Attribute {
+        public ReferenceAssemblyAttribute();
+        public ReferenceAssemblyAttribute(string description);
+        public string Description { get; }
+    }
+    public sealed class RequiredAttributeAttribute : Attribute {
+        public RequiredAttributeAttribute(Type requiredContract);
+        public Type RequiredContract { get; }
+    }
+    public sealed class RuntimeCompatibilityAttribute : Attribute {
+        public RuntimeCompatibilityAttribute();
+        public bool WrapNonExceptionThrows { get; set; }
+    }
+    public static class RuntimeHelpers {
+        public static int OffsetToStringData { get; }
+        public static void EnsureSufficientExecutionStack();
+        public static int GetHashCode(object o);
+        public static object GetObjectValue(object obj);
+        public static object GetUninitializedObject(Type type);
+        public static void InitializeArray(Array array, RuntimeFieldHandle fldHandle);
+        public static void RunClassConstructor(RuntimeTypeHandle type);
+    }
+    public sealed class SpecialNameAttribute : Attribute {
+        public SpecialNameAttribute();
+    }
+    public class StateMachineAttribute : Attribute {
+        public StateMachineAttribute(Type stateMachineType);
+        public Type StateMachineType { get; }
+    }
+    public class StrongBox<T> : IStrongBox {
+        public T Value;
+        public StrongBox();
+        public StrongBox(T value);
+        object System.Runtime.CompilerServices.IStrongBox.Value { get; set; }
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct TaskAwaiter : ICriticalNotifyCompletion, INotifyCompletion {
+        public bool IsCompleted { get; }
+        public void GetResult();
+        public void OnCompleted(Action continuation);
+        public void UnsafeOnCompleted(Action continuation);
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct TaskAwaiter<TResult> : ICriticalNotifyCompletion, INotifyCompletion {
+        public bool IsCompleted { get; }
+        public TResult GetResult();
+        public void OnCompleted(Action continuation);
+        public void UnsafeOnCompleted(Action continuation);
+    }
+    public sealed class TypeForwardedFromAttribute : Attribute {
+        public TypeForwardedFromAttribute(string assemblyFullName);
+        public string AssemblyFullName { get; }
+    }
+    public sealed class TypeForwardedToAttribute : Attribute {
+        public TypeForwardedToAttribute(Type destination);
+        public Type Destination { get; }
+    }
+    public static class Unsafe {
+        [MethodImpl(AggressiveInlining)]public static T As<T>(object o) where T : class;
+        [MethodImpl(AggressiveInlining)]public unsafe static void* AsPointer<T>(ref T value);
+        [MethodImpl(AggressiveInlining)]public unsafe static T AsRef<T>(void* source);
+        [MethodImpl(AggressiveInlining)]public unsafe static void Copy<T>(void* destination, ref T source);
+        [MethodImpl(AggressiveInlining)]public unsafe static void Copy<T>(ref T destination, void* source);
+        [MethodImpl(AggressiveInlining)]public unsafe static void CopyBlock(void* destination, void* source, uint byteCount);
+        [MethodImpl(AggressiveInlining)]public unsafe static void InitBlock(void* startAddress, byte value, uint byteCount);
+        [MethodImpl(AggressiveInlining)]public unsafe static T Read<T>(void* source);
+        [MethodImpl(AggressiveInlining)]public static int SizeOf<T>();
+        [MethodImpl(AggressiveInlining)]public unsafe static void Write<T>(void* destination, T value);
+    }
+    public sealed class UnsafeValueTypeAttribute : Attribute {
+        public UnsafeValueTypeAttribute();
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct ValueTaskAwaiter<TResult> : ICriticalNotifyCompletion, INotifyCompletion {
+        public bool IsCompleted { get; }
+        public TResult GetResult();
+        public void OnCompleted(Action continuation);
+        public void UnsafeOnCompleted(Action continuation);
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Size=1)]
+    public struct YieldAwaitable {
+        public YieldAwaitable.YieldAwaiter GetAwaiter();
+        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Size=1)]
+        public struct YieldAwaiter : ICriticalNotifyCompletion, INotifyCompletion {
+            public bool IsCompleted { get; }
+            public void GetResult();
+            public void OnCompleted(Action continuation);
+            public void UnsafeOnCompleted(Action continuation);
+        }
+    }
+}
```

## System.Runtime.ConstrainedExecution

```c#
+namespace System.Runtime.ConstrainedExecution {
+    public abstract class CriticalFinalizerObject {
+        protected CriticalFinalizerObject();
+        ~CriticalFinalizerObject();
+    }
+}
```

## System.Runtime.Diagnostics

```c#
+namespace System.Runtime.Diagnostics {
+    public class EventTraceActivity {
+        public Guid ActivityId;
+        public EventTraceActivity(bool setOnThread=false);
+        public EventTraceActivity(Guid guid, bool setOnThread=false);
+        public static EventTraceActivity Empty { get; }
+        public static string Name { get; }
+        public static Guid GetActivityIdFromThread();
+        public static EventTraceActivity GetFromThreadOrCreate(bool clearIdOnThread=false);
+        public void SetActivityId(Guid guid);
+    }
+    public class TraceRecord {
+        protected const string EventIdBase = "http://schemas.microsoft.com/2006/08/ServiceModel/";
+        protected const string NamespaceSuffix = "TraceRecord";
+        public TraceRecord();
+        protected string BuildEventId(string eventId);
+        protected string XmlEncode(string text);
+    }
+}
```

## System.Runtime.ExceptionServices

```c#
+namespace System.Runtime.ExceptionServices {
+    public sealed class ExceptionDispatchInfo {
+        public Exception SourceException { get; }
+        public static ExceptionDispatchInfo Capture(Exception source);
+        public void Throw();
+    }
+    public sealed class HandleProcessCorruptedStateExceptionsAttribute : Attribute {
+        public HandleProcessCorruptedStateExceptionsAttribute();
+    }
+}
```

## System.Runtime.InteropServices

```c#
+namespace System.Runtime.InteropServices {
+    public sealed class AllowReversePInvokeCallsAttribute : Attribute {
+        public AllowReversePInvokeCallsAttribute();
+    }
+    public enum Architecture {
+        Arm = 2,
+        Arm64 = 3,
+        X64 = 1,
+        X86 = 0,
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct ArrayWithOffset {
+        public ArrayWithOffset(object array, int offset);
+        public override bool Equals(object obj);
+        public bool Equals(ArrayWithOffset obj);
+        public object GetArray();
+        public override int GetHashCode();
+        public int GetOffset();
+        public static bool operator ==(ArrayWithOffset a, ArrayWithOffset b);
+        public static bool operator !=(ArrayWithOffset a, ArrayWithOffset b);
+    }
+    public sealed class BestFitMappingAttribute : Attribute {
+        public bool ThrowOnUnmappableChar;
+        public BestFitMappingAttribute(bool BestFitMapping);
+        public bool BestFitMapping { get; }
+    }
+    public sealed class BStrWrapper {
+        public BStrWrapper(object value);
+        public BStrWrapper(string value);
+        public string WrappedObject { get; }
+    }
+    public enum CallingConvention {
+        Cdecl = 2,
+        FastCall = 5,
+        StdCall = 3,
+        ThisCall = 4,
+        Winapi = 1,
+    }
+    public enum CharSet {
+        Ansi = 2,
+        Auto = 4,
+        None = 1,
+        Unicode = 3,
+    }
+    public sealed class ClassInterfaceAttribute : Attribute {
+        public ClassInterfaceAttribute(short classInterfaceType);
+        public ClassInterfaceAttribute(ClassInterfaceType classInterfaceType);
+        public ClassInterfaceType Value { get; }
+    }
+    public enum ClassInterfaceType {
+        AutoDispatch = 1,
+        AutoDual = 2,
+        None = 0,
+    }
+    public sealed class CoClassAttribute : Attribute {
+        public CoClassAttribute(Type coClass);
+        public Type CoClass { get; }
+    }
+    public class ComAwareEventInfo : EventInfo {
+        public ComAwareEventInfo(Type type, string eventName);
+        public override EventAttributes Attributes { get; }
+        public override Type DeclaringType { get; }
+        public override string Name { get; }
+        public override void AddEventHandler(object target, Delegate handler);
+        public override void RemoveEventHandler(object target, Delegate handler);
+    }
+    public sealed class ComDefaultInterfaceAttribute : Attribute {
+        public ComDefaultInterfaceAttribute(Type defaultInterface);
+        public Type Value { get; }
+    }
+    public sealed class ComEventInterfaceAttribute : Attribute {
+        public ComEventInterfaceAttribute(Type SourceInterface, Type EventProvider);
+        public Type EventProvider { get; }
+        public Type SourceInterface { get; }
+    }
+    public static class ComEventsHelper {
+        public static void Combine(object rcw, Guid iid, int dispid, Delegate d);
+        public static Delegate Remove(object rcw, Guid iid, int dispid, Delegate d);
+    }
+    public class COMException : Exception {
+        public COMException();
+        public COMException(string message);
+        public COMException(string message, Exception inner);
+        public COMException(string message, int errorCode);
+        public override string ToString();
+    }
+    public sealed class ComImportAttribute : Attribute {
+        public ComImportAttribute();
+    }
+    public enum ComInterfaceType {
+        InterfaceIsDual = 0,
+        InterfaceIsIDispatch = 2,
+        InterfaceIsIInspectable = 3,
+        InterfaceIsIUnknown = 1,
+    }
+    public enum ComMemberType {
+        Method = 0,
+        PropGet = 1,
+        PropSet = 2,
+    }
+    public sealed class ComSourceInterfacesAttribute : Attribute {
+        public ComSourceInterfacesAttribute(string sourceInterfaces);
+        public ComSourceInterfacesAttribute(Type sourceInterface);
+        public ComSourceInterfacesAttribute(Type sourceInterface1, Type sourceInterface2);
+        public ComSourceInterfacesAttribute(Type sourceInterface1, Type sourceInterface2, Type sourceInterface3);
+        public ComSourceInterfacesAttribute(Type sourceInterface1, Type sourceInterface2, Type sourceInterface3, Type sourceInterface4);
+        public string Value { get; }
+    }
+    public sealed class ComVisibleAttribute : Attribute {
+        public ComVisibleAttribute(bool visibility);
+        public bool Value { get; }
+    }
+    public abstract class CriticalHandle : IDisposable {
+        protected IntPtr handle;
+        protected CriticalHandle(IntPtr invalidHandleValue);
+        public bool IsClosed { get; }
+        public abstract bool IsInvalid { get; }
+        public void Close();
+        public void Dispose();
+        protected virtual void Dispose(bool disposing);
+        ~CriticalHandle();
+        protected abstract bool ReleaseHandle();
+        protected void SetHandle(IntPtr handle);
+        public void SetHandleAsInvalid();
+    }
+    public sealed class CurrencyWrapper {
+        public CurrencyWrapper(Decimal obj);
+        public CurrencyWrapper(object obj);
+        public Decimal WrappedObject { get; }
+    }
+    public enum CustomQueryInterfaceMode {
+        Allow = 1,
+        Ignore = 0,
+    }
+    public enum CustomQueryInterfaceResult {
+        Failed = 2,
+        Handled = 0,
+        NotHandled = 1,
+    }
+    public sealed class DefaultCharSetAttribute : Attribute {
+        public DefaultCharSetAttribute(CharSet charSet);
+        public CharSet CharSet { get; }
+    }
+    public sealed class DefaultDllImportSearchPathsAttribute : Attribute {
+        public DefaultDllImportSearchPathsAttribute(DllImportSearchPath paths);
+        public DllImportSearchPath Paths { get; }
+    }
+    public sealed class DefaultParameterValueAttribute : Attribute {
+        public DefaultParameterValueAttribute(object value);
+        public object Value { get; }
+    }
+    public sealed class DispatchWrapper {
+        public DispatchWrapper(object obj);
+        public object WrappedObject { get; }
+    }
+    public sealed class DispIdAttribute : Attribute {
+        public DispIdAttribute(int dispId);
+        public int Value { get; }
+    }
+    public sealed class DllImportAttribute : Attribute {
+        public bool BestFitMapping;
+        public bool ExactSpelling;
+        public bool PreserveSig;
+        public bool SetLastError;
+        public bool ThrowOnUnmappableChar;
+        public CallingConvention CallingConvention;
+        public CharSet CharSet;
+        public string EntryPoint;
+        public DllImportAttribute(string dllName);
+        public string Value { get; }
+    }
+    public enum DllImportSearchPath {
+        ApplicationDirectory = 512,
+        AssemblyDirectory = 2,
+        LegacyBehavior = 0,
+        SafeDirectories = 4096,
+        System32 = 2048,
+        UseDllDirectoryForDependencies = 256,
+        UserDirectories = 1024,
+    }
+    public sealed class ErrorWrapper {
+        public ErrorWrapper(Exception e);
+        public ErrorWrapper(int errorCode);
+        public ErrorWrapper(object errorCode);
+        public int ErrorCode { get; }
+    }
+    public class ExternalException : SystemException {
+        public ExternalException();
+        public ExternalException(string message);
+        public ExternalException(string message, Exception inner);
+        public virtual int ErrorCode { get; }
+    }
+    public sealed class FieldOffsetAttribute : Attribute {
+        public FieldOffsetAttribute(int offset);
+        public int Value { get; }
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct GCHandle {
+        public bool IsAllocated { get; }
+        public object Target { get; set; }
+        public IntPtr AddrOfPinnedObject();
+        public static GCHandle Alloc(object value);
+        public static GCHandle Alloc(object value, GCHandleType type);
+        public override bool Equals(object o);
+        public void Free();
+        public static GCHandle FromIntPtr(IntPtr value);
+        public override int GetHashCode();
+        public static bool operator ==(GCHandle a, GCHandle b);
+        public static explicit operator GCHandle (IntPtr value);
+        public static explicit operator IntPtr (GCHandle value);
+        public static bool operator !=(GCHandle a, GCHandle b);
+        public static IntPtr ToIntPtr(GCHandle value);
+    }
+    public enum GCHandleType {
+        Normal = 2,
+        Pinned = 3,
+        Weak = 0,
+        WeakTrackResurrection = 1,
+    }
+    public sealed class GuidAttribute : Attribute {
+        public GuidAttribute(string guid);
+        public string Value { get; }
+    }
+    public sealed class HandleCollector {
+        public HandleCollector(string name, int initialThreshold);
+        public HandleCollector(string name, int initialThreshold, int maximumThreshold);
+        public int Count { get; }
+        public int InitialThreshold { get; }
+        public int MaximumThreshold { get; }
+        public string Name { get; }
+        public void Add();
+        public void Remove();
+    }
+    public interface ICustomAdapter {
+        object GetUnderlyingObject();
+    }
+    public interface ICustomQueryInterface {
+        CustomQueryInterfaceResult GetInterface(ref Guid iid, out IntPtr ppv);
+    }
+    public sealed class InAttribute : Attribute {
+        public InAttribute();
+    }
+    public sealed class InterfaceTypeAttribute : Attribute {
+        public InterfaceTypeAttribute(short interfaceType);
+        public InterfaceTypeAttribute(ComInterfaceType interfaceType);
+        public ComInterfaceType Value { get; }
+    }
+    public class InvalidComObjectException : Exception {
+        public InvalidComObjectException();
+        public InvalidComObjectException(string message);
+        public InvalidComObjectException(string message, Exception inner);
+    }
+    public class InvalidOleVariantTypeException : Exception {
+        public InvalidOleVariantTypeException();
+        public InvalidOleVariantTypeException(string message);
+        public InvalidOleVariantTypeException(string message, Exception inner);
+    }
+    public enum LayoutKind {
+        Auto = 3,
+        Explicit = 2,
+        Sequential = 0,
+    }
+    public static class Marshal {
+        public static readonly int SystemDefaultCharSize;
+        public static readonly int SystemMaxDBCSCharSize;
+        public static int AddRef(IntPtr pUnk);
+        public static IntPtr AllocCoTaskMem(int cb);
+        public static IntPtr AllocHGlobal(int cb);
+        public static IntPtr AllocHGlobal(IntPtr cb);
+        public static bool AreComObjectsAvailableForCleanup();
+        public static void Copy(byte[] source, int startIndex, IntPtr destination, int length);
+        public static void Copy(char[] source, int startIndex, IntPtr destination, int length);
+        public static void Copy(double[] source, int startIndex, IntPtr destination, int length);
+        public static void Copy(short[] source, int startIndex, IntPtr destination, int length);
+        public static void Copy(int[] source, int startIndex, IntPtr destination, int length);
+        public static void Copy(long[] source, int startIndex, IntPtr destination, int length);
+        public static void Copy(IntPtr source, byte[] destination, int startIndex, int length);
+        public static void Copy(IntPtr source, char[] destination, int startIndex, int length);
+        public static void Copy(IntPtr source, double[] destination, int startIndex, int length);
+        public static void Copy(IntPtr source, short[] destination, int startIndex, int length);
+        public static void Copy(IntPtr source, int[] destination, int startIndex, int length);
+        public static void Copy(IntPtr source, long[] destination, int startIndex, int length);
+        public static void Copy(IntPtr source, IntPtr[] destination, int startIndex, int length);
+        public static void Copy(IntPtr source, float[] destination, int startIndex, int length);
+        public static void Copy(IntPtr[] source, int startIndex, IntPtr destination, int length);
+        public static void Copy(float[] source, int startIndex, IntPtr destination, int length);
+        public static IntPtr CreateAggregatedObject(IntPtr pOuter, object o);
+        public static IntPtr CreateAggregatedObject<T>(IntPtr pOuter, T o);
+        public static object CreateWrapperOfType(object o, Type t);
+        public static TWrapper CreateWrapperOfType<T, TWrapper>(T o);
+        public static void DestroyStructure(IntPtr ptr, Type structuretype);
+        public static void DestroyStructure<T>(IntPtr ptr);
+        public static int FinalReleaseComObject(object o);
+        public static void FreeBSTR(IntPtr ptr);
+        public static void FreeCoTaskMem(IntPtr ptr);
+        public static void FreeHGlobal(IntPtr hglobal);
+        public static IntPtr GetComInterfaceForObject(object o, Type T);
+        public static IntPtr GetComInterfaceForObject(object o, Type T, CustomQueryInterfaceMode mode);
+        public static IntPtr GetComInterfaceForObject<T, TInterface>(T o);
+        public static Delegate GetDelegateForFunctionPointer(IntPtr ptr, Type t);
+        public static TDelegate GetDelegateForFunctionPointer<TDelegate>(IntPtr ptr);
+        public static int GetExceptionCode();
+        public static Exception GetExceptionForHR(int errorCode);
+        public static Exception GetExceptionForHR(int errorCode, IntPtr errorInfo);
+        public static IntPtr GetFunctionPointerForDelegate(Delegate d);
+        public static IntPtr GetFunctionPointerForDelegate<TDelegate>(TDelegate d);
+        public static int GetHRForException(Exception e);
+        public static int GetHRForLastWin32Error();
+        public static IntPtr GetIUnknownForObject(object o);
+        public static int GetLastWin32Error();
+        public static void GetNativeVariantForObject(object obj, IntPtr pDstNativeVariant);
+        public static void GetNativeVariantForObject<T>(T obj, IntPtr pDstNativeVariant);
+        public static object GetObjectForIUnknown(IntPtr pUnk);
+        public static object GetObjectForNativeVariant(IntPtr pSrcNativeVariant);
+        public static T GetObjectForNativeVariant<T>(IntPtr pSrcNativeVariant);
+        public static object[] GetObjectsForNativeVariants(IntPtr aSrcNativeVariant, int cVars);
+        public static T[] GetObjectsForNativeVariants<T>(IntPtr aSrcNativeVariant, int cVars);
+        public static int GetStartComSlot(Type t);
+        public static Type GetTypeFromCLSID(Guid clsid);
+        public static string GetTypeInfoName(ITypeInfo typeInfo);
+        public static object GetUniqueObjectForIUnknown(IntPtr unknown);
+        public static bool IsComObject(object o);
+        public static IntPtr OffsetOf(Type t, string fieldName);
+        public static IntPtr OffsetOf<T>(string fieldName);
+        public static void Prelink(MethodInfo m);
+        public static void PrelinkAll(Type c);
+        public static string PtrToStringAnsi(IntPtr ptr);
+        public static string PtrToStringAnsi(IntPtr ptr, int len);
+        public static string PtrToStringBSTR(IntPtr ptr);
+        public static string PtrToStringUni(IntPtr ptr);
+        public static string PtrToStringUni(IntPtr ptr, int len);
+        public static string PtrToStringUTF8(IntPtr ptr);
+        public static string PtrToStringUTF8(IntPtr ptr, int byteLen);
+        public static void PtrToStructure(IntPtr ptr, object structure);
+        public static object PtrToStructure(IntPtr ptr, Type structureType);
+        public static T PtrToStructure<T>(IntPtr ptr);
+        public static void PtrToStructure<T>(IntPtr ptr, T structure);
+        public static int QueryInterface(IntPtr pUnk, ref Guid iid, out IntPtr ppv);
+        public static byte ReadByte(IntPtr ptr);
+        public static byte ReadByte(IntPtr ptr, int ofs);
+        public static byte ReadByte(object ptr, int ofs);
+        public static short ReadInt16(IntPtr ptr);
+        public static short ReadInt16(IntPtr ptr, int ofs);
+        public static short ReadInt16(object ptr, int ofs);
+        public static int ReadInt32(IntPtr ptr);
+        public static int ReadInt32(IntPtr ptr, int ofs);
+        public static int ReadInt32(object ptr, int ofs);
+        public static long ReadInt64(IntPtr ptr);
+        public static long ReadInt64(IntPtr ptr, int ofs);
+        public static long ReadInt64(object ptr, int ofs);
+        public static IntPtr ReadIntPtr(IntPtr ptr);
+        public static IntPtr ReadIntPtr(IntPtr ptr, int ofs);
+        public static IntPtr ReadIntPtr(object ptr, int ofs);
+        public static IntPtr ReAllocCoTaskMem(IntPtr pv, int cb);
+        public static IntPtr ReAllocHGlobal(IntPtr pv, IntPtr cb);
+        public static int Release(IntPtr pUnk);
+        public static int ReleaseComObject(object o);
+        public static int SizeOf(object structure);
+        public static int SizeOf(Type t);
+        public static int SizeOf<T>();
+        public static int SizeOf<T>(T structure);
+        public static IntPtr StringToBSTR(string s);
+        public static IntPtr StringToCoTaskMemAnsi(string s);
+        public static IntPtr StringToCoTaskMemUni(string s);
+        public static IntPtr StringToCoTaskMemUTF8(string s);
+        public static IntPtr StringToHGlobalAnsi(string s);
+        public static IntPtr StringToHGlobalUni(string s);
+        public static void StructureToPtr(object structure, IntPtr ptr, bool fDeleteOld);
+        public static void StructureToPtr<T>(T structure, IntPtr ptr, bool fDeleteOld);
+        public static void ThrowExceptionForHR(int errorCode);
+        public static void ThrowExceptionForHR(int errorCode, IntPtr errorInfo);
+        public static IntPtr UnsafeAddrOfPinnedArrayElement(Array arr, int index);
+        public static IntPtr UnsafeAddrOfPinnedArrayElement<T>(T[] arr, int index);
+        public static void WriteByte(IntPtr ptr, byte val);
+        public static void WriteByte(IntPtr ptr, int ofs, byte val);
+        public static void WriteByte(object ptr, int ofs, byte val);
+        public static void WriteInt16(IntPtr ptr, char val);
+        public static void WriteInt16(IntPtr ptr, short val);
+        public static void WriteInt16(IntPtr ptr, int ofs, char val);
+        public static void WriteInt16(IntPtr ptr, int ofs, short val);
+        public static void WriteInt16(object ptr, int ofs, char val);
+        public static void WriteInt16(object ptr, int ofs, short val);
+        public static void WriteInt32(IntPtr ptr, int val);
+        public static void WriteInt32(IntPtr ptr, int ofs, int val);
+        public static void WriteInt32(object ptr, int ofs, int val);
+        public static void WriteInt64(IntPtr ptr, int ofs, long val);
+        public static void WriteInt64(IntPtr ptr, long val);
+        public static void WriteInt64(object ptr, int ofs, long val);
+        public static void WriteIntPtr(IntPtr ptr, int ofs, IntPtr val);
+        public static void WriteIntPtr(IntPtr ptr, IntPtr val);
+        public static void WriteIntPtr(object ptr, int ofs, IntPtr val);
+        public static void ZeroFreeBSTR(IntPtr s);
+        public static void ZeroFreeCoTaskMemAnsi(IntPtr s);
+        public static void ZeroFreeCoTaskMemUnicode(IntPtr s);
+        public static void ZeroFreeCoTaskMemUTF8(IntPtr s);
+        public static void ZeroFreeGlobalAllocAnsi(IntPtr s);
+        public static void ZeroFreeGlobalAllocUnicode(IntPtr s);
+    }
+    public sealed class MarshalAsAttribute : Attribute {
+        public short SizeParamIndex;
+        public int IidParameterIndex;
+        public int SizeConst;
+        public UnmanagedType ArraySubType;
+        public VarEnum SafeArraySubType;
+        public string MarshalCookie;
+        public string MarshalType;
+        public Type MarshalTypeRef;
+        public Type SafeArrayUserDefinedSubType;
+        public MarshalAsAttribute(short unmanagedType);
+        public MarshalAsAttribute(UnmanagedType unmanagedType);
+        public UnmanagedType Value { get; }
+    }
+    public class MarshalDirectiveException : Exception {
+        public MarshalDirectiveException();
+        public MarshalDirectiveException(string message);
+        public MarshalDirectiveException(string message, Exception inner);
+    }
+    public sealed class NativeCallableAttribute : Attribute {
+        public CallingConvention CallingConvention;
+        public string EntryPoint;
+        public NativeCallableAttribute();
+    }
+    public sealed class OptionalAttribute : Attribute {
+        public OptionalAttribute();
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct OSPlatform : IEquatable<OSPlatform> {
+        public static OSPlatform Linux { get; }
+        public static OSPlatform OSX { get; }
+        public static OSPlatform Windows { get; }
+        public static OSPlatform Create(string osPlatform);
+        public override bool Equals(object obj);
+        public bool Equals(OSPlatform other);
+        public override int GetHashCode();
+        public static bool operator ==(OSPlatform left, OSPlatform right);
+        public static bool operator !=(OSPlatform left, OSPlatform right);
+        public override string ToString();
+    }
+    public sealed class OutAttribute : Attribute {
+        public OutAttribute();
+    }
+    public sealed class PreserveSigAttribute : Attribute {
+        public PreserveSigAttribute();
+    }
+    public static class RuntimeEnvironment {
+        public static string GetRuntimeDirectory();
+    }
+    public static class RuntimeInformation {
+        public static string FrameworkDescription { get; }
+        public static Architecture OSArchitecture { get; }
+        public static string OSDescription { get; }
+        public static Architecture ProcessArchitecture { get; }
+        public static bool IsOSPlatform(OSPlatform osPlatform);
+    }
+    public class SafeArrayRankMismatchException : Exception {
+        public SafeArrayRankMismatchException();
+        public SafeArrayRankMismatchException(string message);
+        public SafeArrayRankMismatchException(string message, Exception inner);
+    }
+    public class SafeArrayTypeMismatchException : Exception {
+        public SafeArrayTypeMismatchException();
+        public SafeArrayTypeMismatchException(string message);
+        public SafeArrayTypeMismatchException(string message, Exception inner);
+    }
+    public abstract class SafeBuffer : SafeHandle {
+        protected SafeBuffer(bool ownsHandle);
+        public ulong ByteLength { get; }
+        public override bool IsInvalid { get; }
+        public unsafe void AcquirePointer(ref byte* pointer);
+        public void Initialize(uint numElements, uint sizeOfEachElement);
+        public void Initialize(ulong numBytes);
+        public void Initialize<T>(uint numElements) where T : struct, ValueType;
+        public T Read<T>(ulong byteOffset) where T : struct, ValueType;
+        public void ReadArray<T>(ulong byteOffset, T[] array, int index, int count) where T : struct, ValueType;
+        public void ReleasePointer();
+        public void Write<T>(ulong byteOffset, T value) where T : struct, ValueType;
+        public void WriteArray<T>(ulong byteOffset, T[] array, int index, int count) where T : struct, ValueType;
+    }
+    public abstract class SafeHandle : IDisposable {
+        protected IntPtr handle;
+        protected SafeHandle();
+        protected SafeHandle(IntPtr invalidHandleValue, bool ownsHandle);
+        public bool IsClosed { get; }
+        public abstract bool IsInvalid { get; }
+        public void Close();
+        public void DangerousAddRef(ref bool success);
+        public IntPtr DangerousGetHandle();
+        public void DangerousRelease();
+        public void Dispose();
+        protected virtual void Dispose(bool disposing);
+        ~SafeHandle();
+        protected abstract bool ReleaseHandle();
+        protected void SetHandle(IntPtr handle);
+        public void SetHandleAsInvalid();
+    }
+    public class SEHException : Exception {
+        public SEHException();
+        public SEHException(string message);
+        public SEHException(string message, Exception inner);
+        public virtual bool CanResume();
+    }
+    public sealed class StructLayoutAttribute : Attribute {
+        public int Pack;
+        public int Size;
+        public CharSet CharSet;
+        public StructLayoutAttribute(LayoutKind layoutKind);
+        public LayoutKind Value { get; }
+    }
+    public sealed class TypeIdentifierAttribute : Attribute {
+        public TypeIdentifierAttribute();
+        public TypeIdentifierAttribute(string scope, string identifier);
+        public string Identifier { get; }
+        public string Scope { get; }
+    }
+    public sealed class UnknownWrapper {
+        public UnknownWrapper(object obj);
+        public object WrappedObject { get; }
+    }
+    public sealed class UnmanagedFunctionPointerAttribute : Attribute {
+        public bool BestFitMapping;
+        public bool SetLastError;
+        public bool ThrowOnUnmappableChar;
+        public CharSet CharSet;
+        public UnmanagedFunctionPointerAttribute(CallingConvention callingConvention);
+        public CallingConvention CallingConvention { get; }
+    }
+    public enum UnmanagedType {
+        AnsiBStr = 35,
+        AsAny = 40,
+        Bool = 2,
+        BStr = 19,
+        ByValArray = 30,
+        ByValTStr = 23,
+        Currency = 15,
+        CustomMarshaler = 44,
+        Error = 45,
+        FunctionPtr = 38,
+        HString = 47,
+        I1 = 3,
+        I2 = 5,
+        I4 = 7,
+        I8 = 9,
+        IDispatch = 26,
+        IInspectable = 46,
+        Interface = 28,
+        IUnknown = 25,
+        LPArray = 42,
+        LPStr = 20,
+        LPStruct = 43,
+        LPTStr = 22,
+        LPUTF8Str = 48,
+        LPWStr = 21,
+        R4 = 11,
+        R8 = 12,
+        SafeArray = 29,
+        Struct = 27,
+        SysInt = 31,
+        SysUInt = 32,
+        TBStr = 36,
+        U1 = 4,
+        U2 = 6,
+        U4 = 8,
+        U8 = 10,
+        VariantBool = 37,
+        VBByRefStr = 34,
+    }
+    public enum VarEnum {
+        VT_ARRAY = 8192,
+        VT_BLOB = 65,
+        VT_BLOB_OBJECT = 70,
+        VT_BOOL = 11,
+        VT_BSTR = 8,
+        VT_BYREF = 16384,
+        VT_CARRAY = 28,
+        VT_CF = 71,
+        VT_CLSID = 72,
+        VT_CY = 6,
+        VT_DATE = 7,
+        VT_DECIMAL = 14,
+        VT_DISPATCH = 9,
+        VT_EMPTY = 0,
+        VT_ERROR = 10,
+        VT_FILETIME = 64,
+        VT_HRESULT = 25,
+        VT_I1 = 16,
+        VT_I2 = 2,
+        VT_I4 = 3,
+        VT_I8 = 20,
+        VT_INT = 22,
+        VT_LPSTR = 30,
+        VT_LPWSTR = 31,
+        VT_NULL = 1,
+        VT_PTR = 26,
+        VT_R4 = 4,
+        VT_R8 = 5,
+        VT_RECORD = 36,
+        VT_SAFEARRAY = 27,
+        VT_STORAGE = 67,
+        VT_STORED_OBJECT = 69,
+        VT_STREAM = 66,
+        VT_STREAMED_OBJECT = 68,
+        VT_UI1 = 17,
+        VT_UI2 = 18,
+        VT_UI4 = 19,
+        VT_UI8 = 21,
+        VT_UINT = 23,
+        VT_UNKNOWN = 13,
+        VT_USERDEFINED = 29,
+        VT_VARIANT = 12,
+        VT_VECTOR = 4096,
+        VT_VOID = 24,
+    }
+    public sealed class VariantWrapper {
+        public VariantWrapper(object obj);
+        public object WrappedObject { get; }
+    }
+}
```

## System.Runtime.InteropServices.ComTypes

```c#
+namespace System.Runtime.InteropServices.ComTypes {
+    public enum ADVF {
+        ADVF_DATAONSTOP = 64,
+        ADVF_NODATA = 1,
+        ADVF_ONLYONCE = 4,
+        ADVF_PRIMEFIRST = 2,
+        ADVFCACHE_FORCEBUILTIN = 16,
+        ADVFCACHE_NOHANDLER = 8,
+        ADVFCACHE_ONSAVE = 32,
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct BIND_OPTS {
+        public int cbStruct;
+        public int dwTickCountDeadline;
+        public int grfFlags;
+        public int grfMode;
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Explicit)]
+    public struct BINDPTR {
+        [System.Runtime.InteropServices.FieldOffsetAttribute(0)]
+        public IntPtr lpfuncdesc;
+        [System.Runtime.InteropServices.FieldOffsetAttribute(0)]
+        public IntPtr lptcomp;
+        [System.Runtime.InteropServices.FieldOffsetAttribute(0)]
+        public IntPtr lpvardesc;
+    }
+    public enum CALLCONV {
+        CC_CDECL = 1,
+        CC_MACPASCAL = 3,
+        CC_MAX = 9,
+        CC_MPWCDECL = 7,
+        CC_MPWPASCAL = 8,
+        CC_MSCPASCAL = 2,
+        CC_PASCAL = 2,
+        CC_RESERVED = 5,
+        CC_STDCALL = 4,
+        CC_SYSCALL = 6,
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct CONNECTDATA {
+        public int dwCookie;
+        public object pUnk;
+    }
+    public enum DATADIR {
+        DATADIR_GET = 1,
+        DATADIR_SET = 2,
+    }
+    public enum DESCKIND {
+        DESCKIND_FUNCDESC = 1,
+        DESCKIND_IMPLICITAPPOBJ = 4,
+        DESCKIND_MAX = 5,
+        DESCKIND_NONE = 0,
+        DESCKIND_TYPECOMP = 3,
+        DESCKIND_VARDESC = 2,
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct DISPPARAMS {
+        public int cArgs;
+        public int cNamedArgs;
+        public IntPtr rgdispidNamedArgs;
+        public IntPtr rgvarg;
+    }
+    public enum DVASPECT {
+        DVASPECT_CONTENT = 1,
+        DVASPECT_DOCPRINT = 8,
+        DVASPECT_ICON = 4,
+        DVASPECT_THUMBNAIL = 2,
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct ELEMDESC {
+        public ELEMDESC.DESCUNION desc;
+        public TYPEDESC tdesc;
+        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Explicit)]
+        public struct DESCUNION {
+            [System.Runtime.InteropServices.FieldOffsetAttribute(0)]
+            public IDLDESC idldesc;
+            [System.Runtime.InteropServices.FieldOffsetAttribute(0)]
+            public PARAMDESC paramdesc;
+        }
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct EXCEPINFO {
+        public short wCode;
+        public short wReserved;
+        public int dwHelpContext;
+        public int scode;
+        public IntPtr pfnDeferredFillIn;
+        public IntPtr pvReserved;
+        public string bstrDescription;
+        public string bstrHelpFile;
+        public string bstrSource;
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct FILETIME {
+        public int dwHighDateTime;
+        public int dwLowDateTime;
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct FORMATETC {
+        public short cfFormat;
+        public int lindex;
+        public IntPtr ptd;
+        public DVASPECT dwAspect;
+        public TYMED tymed;
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct FUNCDESC {
+        public short cParams;
+        public short cParamsOpt;
+        public short cScodes;
+        public short oVft;
+        public short wFuncFlags;
+        public int memid;
+        public IntPtr lprgelemdescParam;
+        public IntPtr lprgscode;
+        public CALLCONV callconv;
+        public ELEMDESC elemdescFunc;
+        public FUNCKIND funckind;
+        public INVOKEKIND invkind;
+    }
+    public enum FUNCFLAGS : short {
+        FUNCFLAG_FBINDABLE = (short)4,
+        FUNCFLAG_FDEFAULTBIND = (short)32,
+        FUNCFLAG_FDEFAULTCOLLELEM = (short)256,
+        FUNCFLAG_FDISPLAYBIND = (short)16,
+        FUNCFLAG_FHIDDEN = (short)64,
+        FUNCFLAG_FIMMEDIATEBIND = (short)4096,
+        FUNCFLAG_FNONBROWSABLE = (short)1024,
+        FUNCFLAG_FREPLACEABLE = (short)2048,
+        FUNCFLAG_FREQUESTEDIT = (short)8,
+        FUNCFLAG_FRESTRICTED = (short)1,
+        FUNCFLAG_FSOURCE = (short)2,
+        FUNCFLAG_FUIDEFAULT = (short)512,
+        FUNCFLAG_FUSESGETLASTERROR = (short)128,
+    }
+    public enum FUNCKIND {
+        FUNC_DISPATCH = 4,
+        FUNC_NONVIRTUAL = 2,
+        FUNC_PUREVIRTUAL = 1,
+        FUNC_STATIC = 3,
+        FUNC_VIRTUAL = 0,
+    }
+    public interface IAdviseSink {
+        void OnClose();
+        void OnDataChange(ref FORMATETC format, ref STGMEDIUM stgmedium);
+        void OnRename(IMoniker moniker);
+        void OnSave();
+        void OnViewChange(int aspect, int index);
+    }
+    public interface IBindCtx {
+        void EnumObjectParam(out IEnumString ppenum);
+        void GetBindOptions(ref BIND_OPTS pbindopts);
+        void GetObjectParam(string pszKey, out object ppunk);
+        void GetRunningObjectTable(out IRunningObjectTable pprot);
+        void RegisterObjectBound(object punk);
+        void RegisterObjectParam(string pszKey, object punk);
+        void ReleaseBoundObjects();
+        void RevokeObjectBound(object punk);
+        int RevokeObjectParam(string pszKey);
+        void SetBindOptions(ref BIND_OPTS pbindopts);
+    }
+    public interface IConnectionPoint {
+        void Advise(object pUnkSink, out int pdwCookie);
+        void EnumConnections(out IEnumConnections ppEnum);
+        void GetConnectionInterface(out Guid pIID);
+        void GetConnectionPointContainer(out IConnectionPointContainer ppCPC);
+        void Unadvise(int dwCookie);
+    }
+    public interface IConnectionPointContainer {
+        void EnumConnectionPoints(out IEnumConnectionPoints ppEnum);
+        void FindConnectionPoint(ref Guid riid, out IConnectionPoint ppCP);
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct IDLDESC {
+        public IntPtr dwReserved;
+        public IDLFLAG wIDLFlags;
+    }
+    public enum IDLFLAG : short {
+        IDLFLAG_FIN = (short)1,
+        IDLFLAG_FLCID = (short)4,
+        IDLFLAG_FOUT = (short)2,
+        IDLFLAG_FRETVAL = (short)8,
+        IDLFLAG_NONE = (short)0,
+    }
+    public interface IEnumConnectionPoints {
+        void Clone(out IEnumConnectionPoints ppenum);
+        int Next(int celt, IConnectionPoint[] rgelt, IntPtr pceltFetched);
+        void Reset();
+        int Skip(int celt);
+    }
+    public interface IEnumConnections {
+        void Clone(out IEnumConnections ppenum);
+        int Next(int celt, CONNECTDATA[] rgelt, IntPtr pceltFetched);
+        void Reset();
+        int Skip(int celt);
+    }
+    public interface IEnumFORMATETC {
+        void Clone(out IEnumFORMATETC newEnum);
+        int Next(int celt, FORMATETC[] rgelt, int[] pceltFetched);
+        int Reset();
+        int Skip(int celt);
+    }
+    public interface IEnumMoniker {
+        void Clone(out IEnumMoniker ppenum);
+        int Next(int celt, IMoniker[] rgelt, IntPtr pceltFetched);
+        void Reset();
+        int Skip(int celt);
+    }
+    public interface IEnumString {
+        void Clone(out IEnumString ppenum);
+        int Next(int celt, string[] rgelt, IntPtr pceltFetched);
+        void Reset();
+        int Skip(int celt);
+    }
+    public interface IEnumVARIANT {
+        IEnumVARIANT Clone();
+        int Next(int celt, object[] rgVar, IntPtr pceltFetched);
+        int Reset();
+        int Skip(int celt);
+    }
+    public interface IMoniker {
+        void BindToObject(IBindCtx pbc, IMoniker pmkToLeft, ref Guid riidResult, out object ppvResult);
+        void BindToStorage(IBindCtx pbc, IMoniker pmkToLeft, ref Guid riid, out object ppvObj);
+        void CommonPrefixWith(IMoniker pmkOther, out IMoniker ppmkPrefix);
+        void ComposeWith(IMoniker pmkRight, bool fOnlyIfNotGeneric, out IMoniker ppmkComposite);
+        void Enum(bool fForward, out IEnumMoniker ppenumMoniker);
+        void GetClassID(out Guid pClassID);
+        void GetDisplayName(IBindCtx pbc, IMoniker pmkToLeft, out string ppszDisplayName);
+        void GetSizeMax(out long pcbSize);
+        void GetTimeOfLastChange(IBindCtx pbc, IMoniker pmkToLeft, out FILETIME pFileTime);
+        void Hash(out int pdwHash);
+        void Inverse(out IMoniker ppmk);
+        int IsDirty();
+        int IsEqual(IMoniker pmkOtherMoniker);
+        int IsRunning(IBindCtx pbc, IMoniker pmkToLeft, IMoniker pmkNewlyRunning);
+        int IsSystemMoniker(out int pdwMksys);
+        void Load(IStream pStm);
+        void ParseDisplayName(IBindCtx pbc, IMoniker pmkToLeft, string pszDisplayName, out int pchEaten, out IMoniker ppmkOut);
+        void Reduce(IBindCtx pbc, int dwReduceHowFar, ref IMoniker ppmkToLeft, out IMoniker ppmkReduced);
+        void RelativePathTo(IMoniker pmkOther, out IMoniker ppmkRelPath);
+        void Save(IStream pStm, bool fClearDirty);
+    }
+    public enum IMPLTYPEFLAGS {
+        IMPLTYPEFLAG_FDEFAULT = 1,
+        IMPLTYPEFLAG_FDEFAULTVTABLE = 8,
+        IMPLTYPEFLAG_FRESTRICTED = 4,
+        IMPLTYPEFLAG_FSOURCE = 2,
+    }
+    public enum INVOKEKIND {
+        INVOKE_FUNC = 1,
+        INVOKE_PROPERTYGET = 2,
+        INVOKE_PROPERTYPUT = 4,
+        INVOKE_PROPERTYPUTREF = 8,
+    }
+    public interface IPersistFile {
+        void GetClassID(out Guid pClassID);
+        void GetCurFile(out string ppszFileName);
+        int IsDirty();
+        void Load(string pszFileName, int dwMode);
+        void Save(string pszFileName, bool fRemember);
+        void SaveCompleted(string pszFileName);
+    }
+    public interface IRunningObjectTable {
+        void EnumRunning(out IEnumMoniker ppenumMoniker);
+        int GetObject(IMoniker pmkObjectName, out object ppunkObject);
+        int GetTimeOfLastChange(IMoniker pmkObjectName, out FILETIME pfiletime);
+        int IsRunning(IMoniker pmkObjectName);
+        void NoteChangeTime(int dwRegister, ref FILETIME pfiletime);
+        int Register(int grfFlags, object punkObject, IMoniker pmkObjectName);
+        void Revoke(int dwRegister);
+    }
+    public interface IStream {
+        void Clone(out IStream ppstm);
+        void Commit(int grfCommitFlags);
+        void CopyTo(IStream pstm, long cb, IntPtr pcbRead, IntPtr pcbWritten);
+        void LockRegion(long libOffset, long cb, int dwLockType);
+        void Read(byte[] pv, int cb, IntPtr pcbRead);
+        void Revert();
+        void Seek(long dlibMove, int dwOrigin, IntPtr plibNewPosition);
+        void SetSize(long libNewSize);
+        void Stat(out STATSTG pstatstg, int grfStatFlag);
+        void UnlockRegion(long libOffset, long cb, int dwLockType);
+        void Write(byte[] pv, int cb, IntPtr pcbWritten);
+    }
+    public interface ITypeComp {
+        void Bind(string szName, int lHashVal, short wFlags, out ITypeInfo ppTInfo, out DESCKIND pDescKind, out BINDPTR pBindPtr);
+        void BindType(string szName, int lHashVal, out ITypeInfo ppTInfo, out ITypeComp ppTComp);
+    }
+    public interface ITypeInfo {
+        void AddressOfMember(int memid, INVOKEKIND invKind, out IntPtr ppv);
+        void CreateInstance(object pUnkOuter, ref Guid riid, out object ppvObj);
+        void GetContainingTypeLib(out ITypeLib ppTLB, out int pIndex);
+        void GetDllEntry(int memid, INVOKEKIND invKind, IntPtr pBstrDllName, IntPtr pBstrName, IntPtr pwOrdinal);
+        void GetDocumentation(int index, out string strName, out string strDocString, out int dwHelpContext, out string strHelpFile);
+        void GetFuncDesc(int index, out IntPtr ppFuncDesc);
+        void GetIDsOfNames(string[] rgszNames, int cNames, int[] pMemId);
+        void GetImplTypeFlags(int index, out IMPLTYPEFLAGS pImplTypeFlags);
+        void GetMops(int memid, out string pBstrMops);
+        void GetNames(int memid, string[] rgBstrNames, int cMaxNames, out int pcNames);
+        void GetRefTypeInfo(int hRef, out ITypeInfo ppTI);
+        void GetRefTypeOfImplType(int index, out int href);
+        void GetTypeAttr(out IntPtr ppTypeAttr);
+        void GetTypeComp(out ITypeComp ppTComp);
+        void GetVarDesc(int index, out IntPtr ppVarDesc);
+        void Invoke(object pvInstance, int memid, short wFlags, ref DISPPARAMS pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, out int puArgErr);
+        void ReleaseFuncDesc(IntPtr pFuncDesc);
+        void ReleaseTypeAttr(IntPtr pTypeAttr);
+        void ReleaseVarDesc(IntPtr pVarDesc);
+    }
+    public interface ITypeInfo2 : ITypeInfo {
+        new void AddressOfMember(int memid, INVOKEKIND invKind, out IntPtr ppv);
+        new void CreateInstance(object pUnkOuter, ref Guid riid, out object ppvObj);
+        void GetAllCustData(IntPtr pCustData);
+        void GetAllFuncCustData(int index, IntPtr pCustData);
+        void GetAllImplTypeCustData(int index, IntPtr pCustData);
+        void GetAllParamCustData(int indexFunc, int indexParam, IntPtr pCustData);
+        void GetAllVarCustData(int index, IntPtr pCustData);
+        new void GetContainingTypeLib(out ITypeLib ppTLB, out int pIndex);
+        void GetCustData(ref Guid guid, out object pVarVal);
+        new void GetDllEntry(int memid, INVOKEKIND invKind, IntPtr pBstrDllName, IntPtr pBstrName, IntPtr pwOrdinal);
+        new void GetDocumentation(int index, out string strName, out string strDocString, out int dwHelpContext, out string strHelpFile);
+        void GetDocumentation2(int memid, out string pbstrHelpString, out int pdwHelpStringContext, out string pbstrHelpStringDll);
+        void GetFuncCustData(int index, ref Guid guid, out object pVarVal);
+        new void GetFuncDesc(int index, out IntPtr ppFuncDesc);
+        void GetFuncIndexOfMemId(int memid, INVOKEKIND invKind, out int pFuncIndex);
+        new void GetIDsOfNames(string[] rgszNames, int cNames, int[] pMemId);
+        void GetImplTypeCustData(int index, ref Guid guid, out object pVarVal);
+        new void GetImplTypeFlags(int index, out IMPLTYPEFLAGS pImplTypeFlags);
+        new void GetMops(int memid, out string pBstrMops);
+        new void GetNames(int memid, string[] rgBstrNames, int cMaxNames, out int pcNames);
+        void GetParamCustData(int indexFunc, int indexParam, ref Guid guid, out object pVarVal);
+        new void GetRefTypeInfo(int hRef, out ITypeInfo ppTI);
+        new void GetRefTypeOfImplType(int index, out int href);
+        new void GetTypeAttr(out IntPtr ppTypeAttr);
+        new void GetTypeComp(out ITypeComp ppTComp);
+        void GetTypeFlags(out int pTypeFlags);
+        void GetTypeKind(out TYPEKIND pTypeKind);
+        void GetVarCustData(int index, ref Guid guid, out object pVarVal);
+        new void GetVarDesc(int index, out IntPtr ppVarDesc);
+        void GetVarIndexOfMemId(int memid, out int pVarIndex);
+        new void Invoke(object pvInstance, int memid, short wFlags, ref DISPPARAMS pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, out int puArgErr);
+        new void ReleaseFuncDesc(IntPtr pFuncDesc);
+        new void ReleaseTypeAttr(IntPtr pTypeAttr);
+        new void ReleaseVarDesc(IntPtr pVarDesc);
+    }
+    public interface ITypeLib {
+        void FindName(string szNameBuf, int lHashVal, ITypeInfo[] ppTInfo, int[] rgMemId, ref short pcFound);
+        void GetDocumentation(int index, out string strName, out string strDocString, out int dwHelpContext, out string strHelpFile);
+        void GetLibAttr(out IntPtr ppTLibAttr);
+        void GetTypeComp(out ITypeComp ppTComp);
+        void GetTypeInfo(int index, out ITypeInfo ppTI);
+        int GetTypeInfoCount();
+        void GetTypeInfoOfGuid(ref Guid guid, out ITypeInfo ppTInfo);
+        void GetTypeInfoType(int index, out TYPEKIND pTKind);
+        bool IsName(string szNameBuf, int lHashVal);
+        void ReleaseTLibAttr(IntPtr pTLibAttr);
+    }
+    public interface ITypeLib2 : ITypeLib {
+        new void FindName(string szNameBuf, int lHashVal, ITypeInfo[] ppTInfo, int[] rgMemId, ref short pcFound);
+        void GetAllCustData(IntPtr pCustData);
+        void GetCustData(ref Guid guid, out object pVarVal);
+        new void GetDocumentation(int index, out string strName, out string strDocString, out int dwHelpContext, out string strHelpFile);
+        void GetDocumentation2(int index, out string pbstrHelpString, out int pdwHelpStringContext, out string pbstrHelpStringDll);
+        new void GetLibAttr(out IntPtr ppTLibAttr);
+        void GetLibStatistics(IntPtr pcUniqueNames, out int pcchUniqueNames);
+        new void GetTypeComp(out ITypeComp ppTComp);
+        new void GetTypeInfo(int index, out ITypeInfo ppTI);
+        new int GetTypeInfoCount();
+        new void GetTypeInfoOfGuid(ref Guid guid, out ITypeInfo ppTInfo);
+        new void GetTypeInfoType(int index, out TYPEKIND pTKind);
+        new bool IsName(string szNameBuf, int lHashVal);
+        new void ReleaseTLibAttr(IntPtr pTLibAttr);
+    }
+    public enum LIBFLAGS : short {
+        LIBFLAG_FCONTROL = (short)2,
+        LIBFLAG_FHASDISKIMAGE = (short)8,
+        LIBFLAG_FHIDDEN = (short)4,
+        LIBFLAG_FRESTRICTED = (short)1,
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct PARAMDESC {
+        public IntPtr lpVarValue;
+        public PARAMFLAG wParamFlags;
+    }
+    public enum PARAMFLAG : short {
+        PARAMFLAG_FHASCUSTDATA = (short)64,
+        PARAMFLAG_FHASDEFAULT = (short)32,
+        PARAMFLAG_FIN = (short)1,
+        PARAMFLAG_FLCID = (short)4,
+        PARAMFLAG_FOPT = (short)16,
+        PARAMFLAG_FOUT = (short)2,
+        PARAMFLAG_FRETVAL = (short)8,
+        PARAMFLAG_NONE = (short)0,
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct STATDATA {
+        public int connection;
+        public ADVF advf;
+        public FORMATETC formatetc;
+        public IAdviseSink advSink;
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct STATSTG {
+        public Guid clsid;
+        public int grfLocksSupported;
+        public int grfMode;
+        public int grfStateBits;
+        public int reserved;
+        public int type;
+        public long cbSize;
+        public FILETIME atime;
+        public FILETIME ctime;
+        public FILETIME mtime;
+        public string pwcsName;
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct STGMEDIUM {
+        public IntPtr unionmember;
+        public object pUnkForRelease;
+        public TYMED tymed;
+    }
+    public enum SYSKIND {
+        SYS_MAC = 2,
+        SYS_WIN16 = 0,
+        SYS_WIN32 = 1,
+        SYS_WIN64 = 3,
+    }
+    public enum TYMED {
+        TYMED_ENHMF = 64,
+        TYMED_FILE = 2,
+        TYMED_GDI = 16,
+        TYMED_HGLOBAL = 1,
+        TYMED_ISTORAGE = 8,
+        TYMED_ISTREAM = 4,
+        TYMED_MFPICT = 32,
+        TYMED_NULL = 0,
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct TYPEATTR {
+        public Guid guid;
+        public short cbAlignment;
+        public short cbSizeVft;
+        public short cFuncs;
+        public short cImplTypes;
+        public short cVars;
+        public short wMajorVerNum;
+        public short wMinorVerNum;
+        public int cbSizeInstance;
+        public int dwReserved;
+        public int lcid;
+        public const int MEMBER_ID_NIL = -1;
+        public int memidConstructor;
+        public int memidDestructor;
+        public IntPtr lpstrSchema;
+        public IDLDESC idldescType;
+        public TYPEDESC tdescAlias;
+        public TYPEFLAGS wTypeFlags;
+        public TYPEKIND typekind;
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct TYPEDESC {
+        public short vt;
+        public IntPtr lpValue;
+    }
+    public enum TYPEFLAGS : short {
+        TYPEFLAG_FAGGREGATABLE = (short)1024,
+        TYPEFLAG_FAPPOBJECT = (short)1,
+        TYPEFLAG_FCANCREATE = (short)2,
+        TYPEFLAG_FCONTROL = (short)32,
+        TYPEFLAG_FDISPATCHABLE = (short)4096,
+        TYPEFLAG_FDUAL = (short)64,
+        TYPEFLAG_FHIDDEN = (short)16,
+        TYPEFLAG_FLICENSED = (short)4,
+        TYPEFLAG_FNONEXTENSIBLE = (short)128,
+        TYPEFLAG_FOLEAUTOMATION = (short)256,
+        TYPEFLAG_FPREDECLID = (short)8,
+        TYPEFLAG_FPROXY = (short)16384,
+        TYPEFLAG_FREPLACEABLE = (short)2048,
+        TYPEFLAG_FRESTRICTED = (short)512,
+        TYPEFLAG_FREVERSEBIND = (short)8192,
+    }
+    public enum TYPEKIND {
+        TKIND_ALIAS = 6,
+        TKIND_COCLASS = 5,
+        TKIND_DISPATCH = 4,
+        TKIND_ENUM = 0,
+        TKIND_INTERFACE = 3,
+        TKIND_MAX = 8,
+        TKIND_MODULE = 2,
+        TKIND_RECORD = 1,
+        TKIND_UNION = 7,
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct TYPELIBATTR {
+        public Guid guid;
+        public short wMajorVerNum;
+        public short wMinorVerNum;
+        public int lcid;
+        public LIBFLAGS wLibFlags;
+        public SYSKIND syskind;
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct VARDESC {
+        public VARDESC.DESCUNION desc;
+        public short wVarFlags;
+        public int memid;
+        public ELEMDESC elemdescVar;
+        public VARKIND varkind;
+        public string lpstrSchema;
+        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Explicit)]
+        public struct DESCUNION {
+            [System.Runtime.InteropServices.FieldOffsetAttribute(0)]
+            public int oInst;
+            [System.Runtime.InteropServices.FieldOffsetAttribute(0)]
+            public IntPtr lpvarValue;
+        }
+    }
+    public enum VARFLAGS : short {
+        VARFLAG_FBINDABLE = (short)4,
+        VARFLAG_FDEFAULTBIND = (short)32,
+        VARFLAG_FDEFAULTCOLLELEM = (short)256,
+        VARFLAG_FDISPLAYBIND = (short)16,
+        VARFLAG_FHIDDEN = (short)64,
+        VARFLAG_FIMMEDIATEBIND = (short)4096,
+        VARFLAG_FNONBROWSABLE = (short)1024,
+        VARFLAG_FREADONLY = (short)1,
+        VARFLAG_FREPLACEABLE = (short)2048,
+        VARFLAG_FREQUESTEDIT = (short)8,
+        VARFLAG_FRESTRICTED = (short)128,
+        VARFLAG_FSOURCE = (short)2,
+        VARFLAG_FUIDEFAULT = (short)512,
+    }
+    public enum VARKIND {
+        VAR_CONST = 2,
+        VAR_DISPATCH = 3,
+        VAR_PERINSTANCE = 0,
+        VAR_STATIC = 1,
+    }
+}
```

## System.Runtime.InteropServices.WindowsRuntime

```c#
+namespace System.Runtime.InteropServices.WindowsRuntime {
+    public sealed class DefaultInterfaceAttribute : Attribute {
+        public DefaultInterfaceAttribute(Type defaultInterface);
+        public Type DefaultInterface { get; }
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct EventRegistrationToken {
+        public override bool Equals(object obj);
+        public override int GetHashCode();
+        public static bool operator ==(EventRegistrationToken left, EventRegistrationToken right);
+        public static bool operator !=(EventRegistrationToken left, EventRegistrationToken right);
+    }
+    public sealed class EventRegistrationTokenTable<T> where T : class {
+        public EventRegistrationTokenTable();
+        public T InvocationList { get; set; }
+        public EventRegistrationToken AddEventHandler(T handler);
+        public static EventRegistrationTokenTable<T> GetOrCreateEventRegistrationTokenTable(ref EventRegistrationTokenTable<T> refEventTable);
+        public void RemoveEventHandler(EventRegistrationToken token);
+        public void RemoveEventHandler(T handler);
+    }
+    public interface IActivationFactory {
+        object ActivateInstance();
+    }
+    public sealed class InterfaceImplementedInVersionAttribute : Attribute {
+        public InterfaceImplementedInVersionAttribute(Type interfaceType, byte majorVersion, byte minorVersion, byte buildVersion, byte revisionVersion);
+        public byte BuildVersion { get; }
+        public Type InterfaceType { get; }
+        public byte MajorVersion { get; }
+        public byte MinorVersion { get; }
+        public byte RevisionVersion { get; }
+    }
+    public sealed class ReadOnlyArrayAttribute : Attribute {
+        public ReadOnlyArrayAttribute();
+    }
+    public sealed class ReturnValueNameAttribute : Attribute {
+        public ReturnValueNameAttribute(string name);
+        public string Name { get; }
+    }
+    public static class WindowsRuntimeMarshal {
+        public static void AddEventHandler<T>(Func<T, EventRegistrationToken> addMethod, Action<EventRegistrationToken> removeMethod, T handler);
+        public static void FreeHString(IntPtr ptr);
+        public static IActivationFactory GetActivationFactory(Type type);
+        public static string PtrToStringHString(IntPtr ptr);
+        public static void RemoveAllEventHandlers(Action<EventRegistrationToken> removeMethod);
+        public static void RemoveEventHandler<T>(Action<EventRegistrationToken> removeMethod, T handler);
+        public static IntPtr StringToHString(string s);
+    }
+    public sealed class WriteOnlyArrayAttribute : Attribute {
+        public WriteOnlyArrayAttribute();
+    }
+}
```

## System.Runtime.Loader

```c#
+namespace System.Runtime.Loader {
+    public abstract class AssemblyLoadContext {
+        protected AssemblyLoadContext();
+        public static AssemblyLoadContext Default { get; }
+        public event Func<AssemblyLoadContext, AssemblyName, Assembly> Resolving;
+        public event Action<AssemblyLoadContext> Unloading;
+        public static AssemblyName GetAssemblyName(string assemblyPath);
+        public static AssemblyLoadContext GetLoadContext(Assembly assembly);
+        protected abstract Assembly Load(AssemblyName assemblyName);
+        public Assembly LoadFromAssemblyName(AssemblyName assemblyName);
+        public Assembly LoadFromAssemblyPath(string assemblyPath);
+        public Assembly LoadFromNativeImagePath(string nativeImagePath, string assemblyPath);
+        public Assembly LoadFromStream(Stream assembly);
+        public Assembly LoadFromStream(Stream assembly, Stream assemblySymbols);
+        protected virtual IntPtr LoadUnmanagedDll(string unmanagedDllName);
+        protected IntPtr LoadUnmanagedDllFromPath(string unmanagedDllPath);
+        public void SetProfileOptimizationRoot(string directoryPath);
+        public void StartProfileOptimization(string profile);
+    }
+}
```

## System.Runtime.Serialization

```c#
+namespace System.Runtime.Serialization {
+    public sealed class CollectionDataContractAttribute : Attribute {
+        public CollectionDataContractAttribute();
+        public bool IsItemNameSetExplicitly { get; }
+        public bool IsKeyNameSetExplicitly { get; }
+        public bool IsNameSetExplicitly { get; }
+        public bool IsNamespaceSetExplicitly { get; }
+        public bool IsReference { get; set; }
+        public bool IsReferenceSetExplicitly { get; }
+        public bool IsValueNameSetExplicitly { get; }
+        public string ItemName { get; set; }
+        public string KeyName { get; set; }
+        public string Name { get; set; }
+        public string Namespace { get; set; }
+        public string ValueName { get; set; }
+    }
+    public sealed class ContractNamespaceAttribute : Attribute {
+        public ContractNamespaceAttribute(string contractNamespace);
+        public string ClrNamespace { get; set; }
+        public string ContractNamespace { get; }
+    }
+    public sealed class DataContractAttribute : Attribute {
+        public DataContractAttribute();
+        public bool IsNameSetExplicitly { get; }
+        public bool IsNamespaceSetExplicitly { get; }
+        public bool IsReference { get; set; }
+        public bool IsReferenceSetExplicitly { get; }
+        public string Name { get; set; }
+        public string Namespace { get; set; }
+    }
+    public abstract class DataContractResolver {
+        protected DataContractResolver();
+        public abstract Type ResolveName(string typeName, string typeNamespace, Type declaredType, DataContractResolver knownTypeResolver);
+        public abstract bool TryResolveType(Type type, Type declaredType, DataContractResolver knownTypeResolver, out XmlDictionaryString typeName, out XmlDictionaryString typeNamespace);
+    }
+    public sealed class DataContractSerializer : XmlObjectSerializer {
+        public DataContractSerializer(Type type);
+        public DataContractSerializer(Type type, IEnumerable<Type> knownTypes);
+        public DataContractSerializer(Type type, DataContractSerializerSettings settings);
+        public DataContractSerializer(Type type, string rootName, string rootNamespace);
+        public DataContractSerializer(Type type, string rootName, string rootNamespace, IEnumerable<Type> knownTypes);
+        public DataContractSerializer(Type type, XmlDictionaryString rootName, XmlDictionaryString rootNamespace);
+        public DataContractSerializer(Type type, XmlDictionaryString rootName, XmlDictionaryString rootNamespace, IEnumerable<Type> knownTypes);
+        public DataContractSerializer(Type type, XmlDictionaryString rootName, XmlDictionaryString rootNamespace, IEnumerable<Type> knownTypes, int maxItemsInObjectGraph, bool ignoreExtensionDataObject, bool preserveObjectReferences, DataContractResolver dataContractResolver);
+        public DataContractResolver DataContractResolver { get; }
+        public bool IgnoreExtensionDataObject { get; }
+        public ReadOnlyCollection<Type> KnownTypes { get; }
+        public int MaxItemsInObjectGraph { get; }
+        public bool PreserveObjectReferences { get; }
+        public bool SerializeReadOnlyTypes { get; }
+        public override bool IsStartObject(XmlDictionaryReader reader);
+        public override bool IsStartObject(XmlReader reader);
+        public override object ReadObject(XmlDictionaryReader reader, bool verifyObjectName);
+        public override object ReadObject(XmlReader reader);
+        public override object ReadObject(XmlReader reader, bool verifyObjectName);
+        public override void WriteEndObject(XmlDictionaryWriter writer);
+        public override void WriteEndObject(XmlWriter writer);
+        public override void WriteObject(XmlWriter writer, object graph);
+        public override void WriteObjectContent(XmlDictionaryWriter writer, object graph);
+        public override void WriteObjectContent(XmlWriter writer, object graph);
+        public override void WriteStartObject(XmlDictionaryWriter writer, object graph);
+        public override void WriteStartObject(XmlWriter writer, object graph);
+    }
+    public static class DataContractSerializerExtensions {
+        public static ISerializationSurrogateProvider GetSerializationSurrogateProvider(this DataContractSerializer serializer);
+        public static void SetSerializationSurrogateProvider(this DataContractSerializer serializer, ISerializationSurrogateProvider provider);
+    }
+    public class DataContractSerializerSettings {
+        public DataContractSerializerSettings();
+        public DataContractResolver DataContractResolver { get; set; }
+        public IEnumerable<Type> KnownTypes { get; set; }
+        public int MaxItemsInObjectGraph { get; set; }
+        public bool PreserveObjectReferences { get; set; }
+        public XmlDictionaryString RootName { get; set; }
+        public XmlDictionaryString RootNamespace { get; set; }
+        public bool SerializeReadOnlyTypes { get; set; }
+    }
+    public sealed class DataMemberAttribute : Attribute {
+        public DataMemberAttribute();
+        public bool EmitDefaultValue { get; set; }
+        public bool IsNameSetExplicitly { get; }
+        public bool IsRequired { get; set; }
+        public string Name { get; set; }
+        public int Order { get; set; }
+    }
+    public class DateTimeFormat {
+        public DateTimeFormat(string formatString);
+        public DateTimeFormat(string formatString, IFormatProvider formatProvider);
+        public DateTimeStyles DateTimeStyles { get; set; }
+        public IFormatProvider FormatProvider { get; }
+        public string FormatString { get; }
+    }
+    public enum EmitTypeInformation {
+        Always = 1,
+        AsNeeded = 0,
+        Never = 2,
+    }
+    public sealed class EnumMemberAttribute : Attribute {
+        public EnumMemberAttribute();
+        public bool IsValueSetExplicitly { get; }
+        public string Value { get; set; }
+    }
+    public static class FormatterServices {
+        public static object GetUninitializedObject(Type type);
+    }
+    public class GeneratedXmlSerializers {
+        public GeneratedXmlSerializers();
+        public static bool IsInitialized { get; }
+        public static Dictionary<string, Type> GetGeneratedSerializers();
+    }
+    public sealed class IgnoreDataMemberAttribute : Attribute {
+        public IgnoreDataMemberAttribute();
+    }
+    public class InvalidDataContractException : Exception {
+        public InvalidDataContractException();
+        public InvalidDataContractException(string message);
+        public InvalidDataContractException(string message, Exception innerException);
+    }
+    public interface ISerializationSurrogateProvider {
+        object GetDeserializedObject(object obj, Type targetType);
+        object GetObjectToSerialize(object obj, Type targetType);
+        Type GetSurrogateType(Type type);
+    }
+    public static class JsonFormatGeneratorStatics {
+        public static PropertyInfo CollectionItemNameProperty { get; }
+        public static MethodInfo GetCurrentMethod { get; }
+        public static MethodInfo GetItemContractMethod { get; }
+        public static MethodInfo GetJsonDataContractMethod { get; }
+        public static MethodInfo GetJsonMemberIndexMethod { get; }
+        public static MethodInfo GetJsonMemberNameMethod { get; }
+        public static MethodInfo GetRevisedItemContractMethod { get; }
+        public static MethodInfo GetUninitializedObjectMethod { get; }
+        public static MethodInfo IsStartElementMethod0 { get; }
+        public static MethodInfo IsStartElementMethod2 { get; }
+        public static PropertyInfo LocalNameProperty { get; }
+        public static MethodInfo MoveNextMethod { get; }
+        public static MethodInfo MoveToContentMethod { get; }
+        public static PropertyInfo NamespaceProperty { get; }
+        public static PropertyInfo NodeTypeProperty { get; }
+        public static MethodInfo ParseEnumMethod { get; }
+        public static MethodInfo ReadJsonValueMethod { get; }
+        public static ConstructorInfo SerializationExceptionCtor { get; }
+        public static MethodInfo ThrowDuplicateMemberExceptionMethod { get; }
+        public static MethodInfo ThrowMissingRequiredMembersMethod { get; }
+        public static PropertyInfo TypeHandleProperty { get; }
+        public static PropertyInfo UseSimpleDictionaryFormatReadProperty { get; }
+        public static PropertyInfo UseSimpleDictionaryFormatWriteProperty { get; }
+        public static MethodInfo WriteAttributeStringMethod { get; }
+        public static MethodInfo WriteEndElementMethod { get; }
+        public static MethodInfo WriteJsonISerializableMethod { get; }
+        public static MethodInfo WriteJsonNameWithMappingMethod { get; }
+        public static MethodInfo WriteJsonValueMethod { get; }
+        public static MethodInfo WriteStartElementMethod { get; }
+        public static MethodInfo WriteStartElementStringMethod { get; }
+    }
+    public sealed class KnownTypeAttribute : Attribute {
+        public KnownTypeAttribute(string methodName);
+        public KnownTypeAttribute(Type type);
+        public string MethodName { get; }
+        public Type Type { get; }
+    }
+    public sealed class OnDeserializedAttribute : Attribute {
+        public OnDeserializedAttribute();
+    }
+    public sealed class OnDeserializingAttribute : Attribute {
+        public OnDeserializingAttribute();
+    }
+    public sealed class OnSerializedAttribute : Attribute {
+        public OnSerializedAttribute();
+    }
+    public sealed class OnSerializingAttribute : Attribute {
+        public OnSerializingAttribute();
+    }
+    public class SerializationException : Exception {
+        public SerializationException();
+        public SerializationException(string message);
+        public SerializationException(string message, Exception innerException);
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct StreamingContext {
+        public StreamingContext(StreamingContextStates state);
+        public StreamingContext(StreamingContextStates state, object additional);
+        public object Context { get; }
+        public StreamingContextStates State { get; }
+        public override bool Equals(object obj);
+        public override int GetHashCode();
+    }
+    public enum StreamingContextStates {
+        All = 255,
+        Clone = 64,
+        CrossAppDomain = 128,
+        CrossMachine = 2,
+        CrossProcess = 1,
+        File = 4,
+        Other = 32,
+        Persistence = 8,
+        Remoting = 16,
+    }
+    public abstract class XmlObjectSerializer {
+        protected XmlObjectSerializer();
+        public abstract bool IsStartObject(XmlDictionaryReader reader);
+        public virtual bool IsStartObject(XmlReader reader);
+        public virtual object ReadObject(Stream stream);
+        public virtual object ReadObject(XmlDictionaryReader reader);
+        public abstract object ReadObject(XmlDictionaryReader reader, bool verifyObjectName);
+        public virtual object ReadObject(XmlReader reader);
+        public virtual object ReadObject(XmlReader reader, bool verifyObjectName);
+        public abstract void WriteEndObject(XmlDictionaryWriter writer);
+        public virtual void WriteEndObject(XmlWriter writer);
+        public virtual void WriteObject(Stream stream, object graph);
+        public virtual void WriteObject(XmlDictionaryWriter writer, object graph);
+        public virtual void WriteObject(XmlWriter writer, object graph);
+        public abstract void WriteObjectContent(XmlDictionaryWriter writer, object graph);
+        public virtual void WriteObjectContent(XmlWriter writer, object graph);
+        public abstract void WriteStartObject(XmlDictionaryWriter writer, object graph);
+        public virtual void WriteStartObject(XmlWriter writer, object graph);
+    }
+    public static class XmlSerializableServices {
+        public static XmlNode[] ReadNodes(XmlReader xmlReader);
+        public static void WriteNodes(XmlWriter xmlWriter, XmlNode[] nodes);
+    }
+}
```

## System.Runtime.Serialization.Json

```c#
+namespace System.Runtime.Serialization.Json {
+    public sealed class DataContractJsonSerializer {
+        public DataContractJsonSerializer(Type type);
+        public DataContractJsonSerializer(Type type, IEnumerable<Type> knownTypes);
+        public DataContractJsonSerializer(Type type, DataContractJsonSerializerSettings settings);
+        public DateTimeFormat DateTimeFormat { get; }
+        public EmitTypeInformation EmitTypeInformation { get; }
+        public ReadOnlyCollection<Type> KnownTypes { get; }
+        public int MaxItemsInObjectGraph { get; }
+        public bool SerializeReadOnlyTypes { get; }
+        public bool UseSimpleDictionaryFormat { get; }
+        public object ReadObject(Stream stream);
+        public void WriteObject(Stream stream, object graph);
+    }
+    public class DataContractJsonSerializerSettings {
+        public DataContractJsonSerializerSettings();
+        public DateTimeFormat DateTimeFormat { get; set; }
+        public EmitTypeInformation EmitTypeInformation { get; set; }
+        public bool IgnoreExtensionDataObject { get; set; }
+        public IEnumerable<Type> KnownTypes { get; set; }
+        public int MaxItemsInObjectGraph { get; set; }
+        public string RootName { get; set; }
+        public bool SerializeReadOnlyTypes { get; set; }
+        public bool UseSimpleDictionaryFormat { get; set; }
+    }
+}
```

## System.Runtime.Versioning

```c#
+namespace System.Runtime.Versioning {
+    public sealed class ComponentGuaranteesAttribute : Attribute {
+        public ComponentGuaranteesAttribute(ComponentGuaranteesOptions guarantees);
+        public ComponentGuaranteesOptions Guarantees { get; }
+    }
+    public enum ComponentGuaranteesOptions {
+        Exchange = 1,
+        None = 0,
+        SideBySide = 4,
+        Stable = 2,
+    }
+    public sealed class FrameworkName : IEquatable<FrameworkName> {
+        public FrameworkName(string frameworkName);
+        public FrameworkName(string identifier, Version version);
+        public FrameworkName(string identifier, Version version, string profile);
+        public string FullName { get; }
+        public string Identifier { get; }
+        public string Profile { get; }
+        public Version Version { get; }
+        public override bool Equals(object obj);
+        public bool Equals(FrameworkName other);
+        public override int GetHashCode();
+        public static bool operator ==(FrameworkName left, FrameworkName right);
+        public static bool operator !=(FrameworkName left, FrameworkName right);
+        public override string ToString();
+    }
+    public sealed class ResourceExposureAttribute : Attribute {
+        public ResourceExposureAttribute(ResourceScope exposureLevel);
+        public ResourceScope ResourceExposureLevel { get; }
+    }
+    public enum ResourceScope {
+        AppDomain = 4,
+        Assembly = 32,
+        Library = 8,
+        Machine = 1,
+        None = 0,
+        Private = 16,
+        Process = 2,
+    }
+    public sealed class TargetFrameworkAttribute : Attribute {
+        public TargetFrameworkAttribute(string frameworkName);
+        public string FrameworkDisplayName { get; set; }
+        public string FrameworkName { get; }
+    }
+    public static class VersioningHelper {
+        public static string MakeVersionSafeName(string name, ResourceScope from, ResourceScope to);
+        public static string MakeVersionSafeName(string name, ResourceScope from, ResourceScope to, Type type);
+    }
+}
```

## System.Security

```c#
+namespace System.Security {
+    public sealed class AllowPartiallyTrustedCallersAttribute : Attribute {
+        public AllowPartiallyTrustedCallersAttribute();
+    }
+    public sealed class SecureString : IDisposable {
+        public SecureString();
+        public unsafe SecureString(char* value, int length);
+        public int Length { get; }
+        public void AppendChar(char c);
+        public void Clear();
+        public SecureString Copy();
+        public void Dispose();
+        public void InsertAt(int index, char c);
+        public bool IsReadOnly();
+        public void MakeReadOnly();
+        public void RemoveAt(int index);
+        public void SetAt(int index, char c);
+    }
+    public static class SecureStringMarshal {
+        public static IntPtr SecureStringToCoTaskMemAnsi(SecureString s);
+        public static IntPtr SecureStringToCoTaskMemUnicode(SecureString s);
+        public static IntPtr SecureStringToGlobalAllocAnsi(SecureString s);
+        public static IntPtr SecureStringToGlobalAllocUnicode(SecureString s);
+    }
+    public sealed class SecurityCriticalAttribute : Attribute {
+        public SecurityCriticalAttribute();
+    }
+    public class SecurityException : Exception {
+        public SecurityException();
+        public SecurityException(string message);
+        public SecurityException(string message, Exception inner);
+        public override string ToString();
+    }
+    public sealed class SecuritySafeCriticalAttribute : Attribute {
+        public SecuritySafeCriticalAttribute();
+    }
+    public abstract class SecurityState {
+        protected SecurityState();
+        public abstract void EnsureState();
+        public bool IsStateAvailable();
+    }
+    public sealed class SecurityTransparentAttribute : Attribute {
+        public SecurityTransparentAttribute();
+    }
+    public sealed class UnverifiableCodeAttribute : Attribute {
+        public UnverifiableCodeAttribute();
+    }
+    public class VerificationException : Exception {
+        public VerificationException();
+        public VerificationException(string message);
+        public VerificationException(string message, Exception innerException);
+    }
+}
```

## System.Security.AccessControl

```c#
+namespace System.Security.AccessControl {
+    public enum AccessControlActions {
+        Change = 2,
+        None = 0,
+        View = 1,
+    }
+    public enum AccessControlModification {
+        Add = 0,
+        Remove = 3,
+        RemoveAll = 4,
+        RemoveSpecific = 5,
+        Reset = 2,
+        Set = 1,
+    }
+    public enum AccessControlSections {
+        Access = 2,
+        All = 15,
+        Audit = 1,
+        Group = 8,
+        None = 0,
+        Owner = 4,
+    }
+    public enum AccessControlType {
+        Allow = 0,
+        Deny = 1,
+    }
+    public abstract class AccessRule : AuthorizationRule {
+        protected AccessRule(IdentityReference identity, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AccessControlType type);
+        public AccessControlType AccessControlType { get; }
+    }
+    public class AccessRule<T> : AccessRule where T : struct, ValueType {
+        public AccessRule(IdentityReference identity, T rights, AccessControlType type);
+        public AccessRule(IdentityReference identity, T rights, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AccessControlType type);
+        public AccessRule(string identity, T rights, AccessControlType type);
+        public AccessRule(string identity, T rights, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AccessControlType type);
+        public T Rights { get; }
+    }
+    public sealed class AceEnumerator : IEnumerator {
+        public GenericAce Current { get; }
+        object System.Collections.IEnumerator.Current { get; }
+        public bool MoveNext();
+        public void Reset();
+    }
+    public enum AceFlags : byte {
+        AuditFlags = (byte)192,
+        ContainerInherit = (byte)2,
+        FailedAccess = (byte)128,
+        InheritanceFlags = (byte)15,
+        Inherited = (byte)16,
+        InheritOnly = (byte)8,
+        None = (byte)0,
+        NoPropagateInherit = (byte)4,
+        ObjectInherit = (byte)1,
+        SuccessfulAccess = (byte)64,
+    }
+    public enum AceQualifier {
+        AccessAllowed = 0,
+        AccessDenied = 1,
+        SystemAlarm = 3,
+        SystemAudit = 2,
+    }
+    public enum AceType : byte {
+        AccessAllowed = (byte)0,
+        AccessAllowedCallback = (byte)9,
+        AccessAllowedCallbackObject = (byte)11,
+        AccessAllowedCompound = (byte)4,
+        AccessAllowedObject = (byte)5,
+        AccessDenied = (byte)1,
+        AccessDeniedCallback = (byte)10,
+        AccessDeniedCallbackObject = (byte)12,
+        AccessDeniedObject = (byte)6,
+        MaxDefinedAceType = (byte)16,
+        SystemAlarm = (byte)3,
+        SystemAlarmCallback = (byte)14,
+        SystemAlarmCallbackObject = (byte)16,
+        SystemAlarmObject = (byte)8,
+        SystemAudit = (byte)2,
+        SystemAuditCallback = (byte)13,
+        SystemAuditCallbackObject = (byte)15,
+        SystemAuditObject = (byte)7,
+    }
+    public enum AuditFlags {
+        Failure = 2,
+        None = 0,
+        Success = 1,
+    }
+    public abstract class AuditRule : AuthorizationRule {
+        protected AuditRule(IdentityReference identity, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AuditFlags auditFlags);
+        public AuditFlags AuditFlags { get; }
+    }
+    public class AuditRule<T> : AuditRule where T : struct, ValueType {
+        public AuditRule(IdentityReference identity, T rights, AuditFlags flags);
+        public AuditRule(IdentityReference identity, T rights, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AuditFlags flags);
+        public AuditRule(string identity, T rights, AuditFlags flags);
+        public AuditRule(string identity, T rights, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AuditFlags flags);
+        public T Rights { get; }
+    }
+    public abstract class AuthorizationRule {
+        protected internal AuthorizationRule(IdentityReference identity, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags);
+        protected internal int AccessMask { get; }
+        public IdentityReference IdentityReference { get; }
+        public InheritanceFlags InheritanceFlags { get; }
+        public bool IsInherited { get; }
+        public PropagationFlags PropagationFlags { get; }
+    }
+    public sealed class AuthorizationRuleCollection : ICollection, IEnumerable {
+        public AuthorizationRuleCollection();
+        public int Count { get; }
+        bool System.Collections.ICollection.IsSynchronized { get; }
+        object System.Collections.ICollection.SyncRoot { get; }
+        public AuthorizationRule this[int index] { get; }
+        public void AddRule(AuthorizationRule rule);
+        public void CopyTo(AuthorizationRule[] rules, int index);
+        void System.Collections.ICollection.CopyTo(Array array, int index);
+        IEnumerator System.Collections.IEnumerable.GetEnumerator();
+    }
+    public sealed class CommonAce : QualifiedAce {
+        public CommonAce(AceFlags flags, AceQualifier qualifier, int accessMask, SecurityIdentifier sid, bool isCallback, byte[] opaque);
+        public override int BinaryLength { get; }
+        public override void GetBinaryForm(byte[] binaryForm, int offset);
+        public static int MaxOpaqueLength(bool isCallback);
+    }
+    public abstract class CommonAcl : GenericAcl {
+        public sealed override int BinaryLength { get; }
+        public sealed override int Count { get; }
+        public bool IsCanonical { get; }
+        public bool IsContainer { get; }
+        public bool IsDS { get; }
+        public sealed override byte Revision { get; }
+        public sealed override GenericAce this[int index] { get; set; }
+        public sealed override void GetBinaryForm(byte[] binaryForm, int offset);
+        public void Purge(SecurityIdentifier sid);
+        public void RemoveInheritedAces();
+    }
+    public abstract class CommonObjectSecurity : ObjectSecurity {
+        protected CommonObjectSecurity(bool isContainer);
+        protected void AddAccessRule(AccessRule rule);
+        protected void AddAuditRule(AuditRule rule);
+        public AuthorizationRuleCollection GetAccessRules(bool includeExplicit, bool includeInherited, Type targetType);
+        public AuthorizationRuleCollection GetAuditRules(bool includeExplicit, bool includeInherited, Type targetType);
+        protected override bool ModifyAccess(AccessControlModification modification, AccessRule rule, out bool modified);
+        protected override bool ModifyAudit(AccessControlModification modification, AuditRule rule, out bool modified);
+        protected bool RemoveAccessRule(AccessRule rule);
+        protected void RemoveAccessRuleAll(AccessRule rule);
+        protected void RemoveAccessRuleSpecific(AccessRule rule);
+        protected bool RemoveAuditRule(AuditRule rule);
+        protected void RemoveAuditRuleAll(AuditRule rule);
+        protected void RemoveAuditRuleSpecific(AuditRule rule);
+        protected void ResetAccessRule(AccessRule rule);
+        protected void SetAccessRule(AccessRule rule);
+        protected void SetAuditRule(AuditRule rule);
+    }
+    public sealed class CommonSecurityDescriptor : GenericSecurityDescriptor {
+        public CommonSecurityDescriptor(bool isContainer, bool isDS, byte[] binaryForm, int offset);
+        public CommonSecurityDescriptor(bool isContainer, bool isDS, ControlFlags flags, SecurityIdentifier owner, SecurityIdentifier group, SystemAcl systemAcl, DiscretionaryAcl discretionaryAcl);
+        public CommonSecurityDescriptor(bool isContainer, bool isDS, RawSecurityDescriptor rawSecurityDescriptor);
+        public CommonSecurityDescriptor(bool isContainer, bool isDS, string sddlForm);
+        public override ControlFlags ControlFlags { get; }
+        public DiscretionaryAcl DiscretionaryAcl { get; set; }
+        public override SecurityIdentifier Group { get; set; }
+        public bool IsContainer { get; }
+        public bool IsDiscretionaryAclCanonical { get; }
+        public bool IsDS { get; }
+        public bool IsSystemAclCanonical { get; }
+        public override SecurityIdentifier Owner { get; set; }
+        public SystemAcl SystemAcl { get; set; }
+        public void AddDiscretionaryAcl(byte revision, int trusted);
+        public void AddSystemAcl(byte revision, int trusted);
+        public void PurgeAccessControl(SecurityIdentifier sid);
+        public void PurgeAudit(SecurityIdentifier sid);
+        public void SetDiscretionaryAclProtection(bool isProtected, bool preserveInheritance);
+        public void SetSystemAclProtection(bool isProtected, bool preserveInheritance);
+    }
+    public sealed class CompoundAce : KnownAce {
+        public CompoundAce(AceFlags flags, int accessMask, CompoundAceType compoundAceType, SecurityIdentifier sid);
+        public override int BinaryLength { get; }
+        public CompoundAceType CompoundAceType { get; set; }
+        public override void GetBinaryForm(byte[] binaryForm, int offset);
+    }
+    public enum CompoundAceType {
+        Impersonation = 1,
+    }
+    public enum ControlFlags {
+        DiscretionaryAclAutoInherited = 1024,
+        DiscretionaryAclAutoInheritRequired = 256,
+        DiscretionaryAclDefaulted = 8,
+        DiscretionaryAclPresent = 4,
+        DiscretionaryAclProtected = 4096,
+        DiscretionaryAclUntrusted = 64,
+        GroupDefaulted = 2,
+        None = 0,
+        OwnerDefaulted = 1,
+        RMControlValid = 16384,
+        SelfRelative = 32768,
+        ServerSecurity = 128,
+        SystemAclAutoInherited = 2048,
+        SystemAclAutoInheritRequired = 512,
+        SystemAclDefaulted = 32,
+        SystemAclPresent = 16,
+        SystemAclProtected = 8192,
+    }
+    public sealed class CustomAce : GenericAce {
+        public static readonly int MaxOpaqueLength;
+        public CustomAce(AceType type, AceFlags flags, byte[] opaque);
+        public override int BinaryLength { get; }
+        public int OpaqueLength { get; }
+        public override void GetBinaryForm(byte[] binaryForm, int offset);
+        public byte[] GetOpaque();
+        public void SetOpaque(byte[] opaque);
+    }
+    public abstract class DirectoryObjectSecurity : ObjectSecurity {
+        protected DirectoryObjectSecurity();
+        protected DirectoryObjectSecurity(CommonSecurityDescriptor securityDescriptor);
+        public virtual AccessRule AccessRuleFactory(IdentityReference identityReference, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AccessControlType type, Guid objectType, Guid inheritedObjectType);
+        protected void AddAccessRule(ObjectAccessRule rule);
+        protected void AddAuditRule(ObjectAuditRule rule);
+        public virtual AuditRule AuditRuleFactory(IdentityReference identityReference, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AuditFlags flags, Guid objectType, Guid inheritedObjectType);
+        public AuthorizationRuleCollection GetAccessRules(bool includeExplicit, bool includeInherited, Type targetType);
+        public AuthorizationRuleCollection GetAuditRules(bool includeExplicit, bool includeInherited, Type targetType);
+        protected override bool ModifyAccess(AccessControlModification modification, AccessRule rule, out bool modified);
+        protected override bool ModifyAudit(AccessControlModification modification, AuditRule rule, out bool modified);
+        protected bool RemoveAccessRule(ObjectAccessRule rule);
+        protected void RemoveAccessRuleAll(ObjectAccessRule rule);
+        protected void RemoveAccessRuleSpecific(ObjectAccessRule rule);
+        protected bool RemoveAuditRule(ObjectAuditRule rule);
+        protected void RemoveAuditRuleAll(ObjectAuditRule rule);
+        protected void RemoveAuditRuleSpecific(ObjectAuditRule rule);
+        protected void ResetAccessRule(ObjectAccessRule rule);
+        protected void SetAccessRule(ObjectAccessRule rule);
+        protected void SetAuditRule(ObjectAuditRule rule);
+    }
+    public sealed class DirectorySecurity : FileSystemSecurity {
+        public DirectorySecurity();
+        public DirectorySecurity(string name, AccessControlSections includeSections);
+    }
+    public sealed class DiscretionaryAcl : CommonAcl {
+        public DiscretionaryAcl(bool isContainer, bool isDS, byte revision, int capacity);
+        public DiscretionaryAcl(bool isContainer, bool isDS, int capacity);
+        public DiscretionaryAcl(bool isContainer, bool isDS, RawAcl rawAcl);
+        public void AddAccess(AccessControlType accessType, SecurityIdentifier sid, int accessMask, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags);
+        public void AddAccess(AccessControlType accessType, SecurityIdentifier sid, int accessMask, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, ObjectAceFlags objectFlags, Guid objectType, Guid inheritedObjectType);
+        public void AddAccess(AccessControlType accessType, SecurityIdentifier sid, ObjectAccessRule rule);
+        public bool RemoveAccess(AccessControlType accessType, SecurityIdentifier sid, int accessMask, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags);
+        public bool RemoveAccess(AccessControlType accessType, SecurityIdentifier sid, int accessMask, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, ObjectAceFlags objectFlags, Guid objectType, Guid inheritedObjectType);
+        public bool RemoveAccess(AccessControlType accessType, SecurityIdentifier sid, ObjectAccessRule rule);
+        public void RemoveAccessSpecific(AccessControlType accessType, SecurityIdentifier sid, int accessMask, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags);
+        public void RemoveAccessSpecific(AccessControlType accessType, SecurityIdentifier sid, int accessMask, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, ObjectAceFlags objectFlags, Guid objectType, Guid inheritedObjectType);
+        public void RemoveAccessSpecific(AccessControlType accessType, SecurityIdentifier sid, ObjectAccessRule rule);
+        public void SetAccess(AccessControlType accessType, SecurityIdentifier sid, int accessMask, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags);
+        public void SetAccess(AccessControlType accessType, SecurityIdentifier sid, int accessMask, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, ObjectAceFlags objectFlags, Guid objectType, Guid inheritedObjectType);
+        public void SetAccess(AccessControlType accessType, SecurityIdentifier sid, ObjectAccessRule rule);
+    }
+    public sealed class EventWaitHandleAccessRule : AccessRule {
+        public EventWaitHandleAccessRule(IdentityReference identity, EventWaitHandleRights eventRights, AccessControlType type);
+        public EventWaitHandleAccessRule(string identity, EventWaitHandleRights eventRights, AccessControlType type);
+        public EventWaitHandleRights EventWaitHandleRights { get; }
+    }
+    public sealed class EventWaitHandleAuditRule : AuditRule {
+        public EventWaitHandleAuditRule(IdentityReference identity, EventWaitHandleRights eventRights, AuditFlags flags);
+        public EventWaitHandleRights EventWaitHandleRights { get; }
+    }
+    public enum EventWaitHandleRights {
+        ChangePermissions = 262144,
+        Delete = 65536,
+        FullControl = 2031619,
+        Modify = 2,
+        ReadPermissions = 131072,
+        Synchronize = 1048576,
+        TakeOwnership = 524288,
+    }
+    public sealed class EventWaitHandleSecurity : NativeObjectSecurity {
+        public EventWaitHandleSecurity();
+        public override Type AccessRightType { get; }
+        public override Type AccessRuleType { get; }
+        public override Type AuditRuleType { get; }
+        public override AccessRule AccessRuleFactory(IdentityReference identityReference, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AccessControlType type);
+        public void AddAccessRule(EventWaitHandleAccessRule rule);
+        public void AddAuditRule(EventWaitHandleAuditRule rule);
+        public override AuditRule AuditRuleFactory(IdentityReference identityReference, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AuditFlags flags);
+        public bool RemoveAccessRule(EventWaitHandleAccessRule rule);
+        public void RemoveAccessRuleAll(EventWaitHandleAccessRule rule);
+        public void RemoveAccessRuleSpecific(EventWaitHandleAccessRule rule);
+        public bool RemoveAuditRule(EventWaitHandleAuditRule rule);
+        public void RemoveAuditRuleAll(EventWaitHandleAuditRule rule);
+        public void RemoveAuditRuleSpecific(EventWaitHandleAuditRule rule);
+        public void ResetAccessRule(EventWaitHandleAccessRule rule);
+        public void SetAccessRule(EventWaitHandleAccessRule rule);
+        public void SetAuditRule(EventWaitHandleAuditRule rule);
+    }
+    public sealed class FileSecurity : FileSystemSecurity {
+        public FileSecurity();
+        public FileSecurity(string fileName, AccessControlSections includeSections);
+    }
+    public sealed class FileSystemAccessRule : AccessRule {
+        public FileSystemAccessRule(IdentityReference identity, FileSystemRights fileSystemRights, AccessControlType type);
+        public FileSystemAccessRule(IdentityReference identity, FileSystemRights fileSystemRights, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AccessControlType type);
+        public FileSystemAccessRule(string identity, FileSystemRights fileSystemRights, AccessControlType type);
+        public FileSystemAccessRule(string identity, FileSystemRights fileSystemRights, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AccessControlType type);
+        public FileSystemRights FileSystemRights { get; }
+    }
+    public sealed class FileSystemAuditRule : AuditRule {
+        public FileSystemAuditRule(IdentityReference identity, FileSystemRights fileSystemRights, AuditFlags flags);
+        public FileSystemAuditRule(IdentityReference identity, FileSystemRights fileSystemRights, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AuditFlags flags);
+        public FileSystemAuditRule(string identity, FileSystemRights fileSystemRights, AuditFlags flags);
+        public FileSystemAuditRule(string identity, FileSystemRights fileSystemRights, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AuditFlags flags);
+        public FileSystemRights FileSystemRights { get; }
+    }
+    public enum FileSystemRights {
+        AppendData = 4,
+        ChangePermissions = 262144,
+        CreateDirectories = 4,
+        CreateFiles = 2,
+        Delete = 65536,
+        DeleteSubdirectoriesAndFiles = 64,
+        ExecuteFile = 32,
+        FullControl = 2032127,
+        ListDirectory = 1,
+        Modify = 197055,
+        Read = 131209,
+        ReadAndExecute = 131241,
+        ReadAttributes = 128,
+        ReadData = 1,
+        ReadExtendedAttributes = 8,
+        ReadPermissions = 131072,
+        Synchronize = 1048576,
+        TakeOwnership = 524288,
+        Traverse = 32,
+        Write = 278,
+        WriteAttributes = 256,
+        WriteData = 2,
+        WriteExtendedAttributes = 16,
+    }
+    public abstract class FileSystemSecurity : NativeObjectSecurity {
+        public override Type AccessRightType { get; }
+        public override Type AccessRuleType { get; }
+        public override Type AuditRuleType { get; }
+        public sealed override AccessRule AccessRuleFactory(IdentityReference identityReference, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AccessControlType type);
+        public void AddAccessRule(FileSystemAccessRule rule);
+        public void AddAuditRule(FileSystemAuditRule rule);
+        public sealed override AuditRule AuditRuleFactory(IdentityReference identityReference, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AuditFlags flags);
+        public bool RemoveAccessRule(FileSystemAccessRule rule);
+        public void RemoveAccessRuleAll(FileSystemAccessRule rule);
+        public void RemoveAccessRuleSpecific(FileSystemAccessRule rule);
+        public bool RemoveAuditRule(FileSystemAuditRule rule);
+        public void RemoveAuditRuleAll(FileSystemAuditRule rule);
+        public void RemoveAuditRuleSpecific(FileSystemAuditRule rule);
+        public void ResetAccessRule(FileSystemAccessRule rule);
+        public void SetAccessRule(FileSystemAccessRule rule);
+        public void SetAuditRule(FileSystemAuditRule rule);
+    }
+    public abstract class GenericAce {
+        public AceFlags AceFlags { get; set; }
+        public AceType AceType { get; }
+        public AuditFlags AuditFlags { get; }
+        public abstract int BinaryLength { get; }
+        public InheritanceFlags InheritanceFlags { get; }
+        public bool IsInherited { get; }
+        public PropagationFlags PropagationFlags { get; }
+        public GenericAce Copy();
+        public static GenericAce CreateFromBinaryForm(byte[] binaryForm, int offset);
+        public sealed override bool Equals(object o);
+        public abstract void GetBinaryForm(byte[] binaryForm, int offset);
+        public sealed override int GetHashCode();
+        public static bool operator ==(GenericAce left, GenericAce right);
+        public static bool operator !=(GenericAce left, GenericAce right);
+    }
+    public abstract class GenericAcl : ICollection, IEnumerable {
+        public static readonly byte AclRevision;
+        public static readonly byte AclRevisionDS;
+        public static readonly int MaxBinaryLength;
+        protected GenericAcl();
+        public abstract int BinaryLength { get; }
+        public abstract int Count { get; }
+        public bool IsSynchronized { get; }
+        public abstract byte Revision { get; }
+        public virtual object SyncRoot { get; }
+        public abstract GenericAce this[int index] { get; set; }
+        public void CopyTo(GenericAce[] array, int index);
+        public abstract void GetBinaryForm(byte[] binaryForm, int offset);
+        public AceEnumerator GetEnumerator();
+        void System.Collections.ICollection.CopyTo(Array array, int index);
+        IEnumerator System.Collections.IEnumerable.GetEnumerator();
+    }
+    public abstract class GenericSecurityDescriptor {
+        protected GenericSecurityDescriptor();
+        public int BinaryLength { get; }
+        public abstract ControlFlags ControlFlags { get; }
+        public abstract SecurityIdentifier Group { get; set; }
+        public abstract SecurityIdentifier Owner { get; set; }
+        public static byte Revision { get; }
+        public void GetBinaryForm(byte[] binaryForm, int offset);
+        public string GetSddlForm(AccessControlSections includeSections);
+        public static bool IsSddlConversionSupported();
+    }
+    public enum InheritanceFlags {
+        ContainerInherit = 1,
+        None = 0,
+        ObjectInherit = 2,
+    }
+    public abstract class KnownAce : GenericAce {
+        public int AccessMask { get; set; }
+        public SecurityIdentifier SecurityIdentifier { get; set; }
+    }
+    public sealed class MutexAccessRule : AccessRule {
+        public MutexAccessRule(IdentityReference identity, MutexRights eventRights, AccessControlType type);
+        public MutexAccessRule(string identity, MutexRights eventRights, AccessControlType type);
+        public MutexRights MutexRights { get; }
+    }
+    public sealed class MutexAuditRule : AuditRule {
+        public MutexAuditRule(IdentityReference identity, MutexRights eventRights, AuditFlags flags);
+        public MutexRights MutexRights { get; }
+    }
+    public enum MutexRights {
+        ChangePermissions = 262144,
+        Delete = 65536,
+        FullControl = 2031617,
+        Modify = 1,
+        ReadPermissions = 131072,
+        Synchronize = 1048576,
+        TakeOwnership = 524288,
+    }
+    public sealed class MutexSecurity : NativeObjectSecurity {
+        public MutexSecurity();
+        public MutexSecurity(string name, AccessControlSections includeSections);
+        public override Type AccessRightType { get; }
+        public override Type AccessRuleType { get; }
+        public override Type AuditRuleType { get; }
+        public override AccessRule AccessRuleFactory(IdentityReference identityReference, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AccessControlType type);
+        public void AddAccessRule(MutexAccessRule rule);
+        public void AddAuditRule(MutexAuditRule rule);
+        public override AuditRule AuditRuleFactory(IdentityReference identityReference, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AuditFlags flags);
+        public bool RemoveAccessRule(MutexAccessRule rule);
+        public void RemoveAccessRuleAll(MutexAccessRule rule);
+        public void RemoveAccessRuleSpecific(MutexAccessRule rule);
+        public bool RemoveAuditRule(MutexAuditRule rule);
+        public void RemoveAuditRuleAll(MutexAuditRule rule);
+        public void RemoveAuditRuleSpecific(MutexAuditRule rule);
+        public void ResetAccessRule(MutexAccessRule rule);
+        public void SetAccessRule(MutexAccessRule rule);
+        public void SetAuditRule(MutexAuditRule rule);
+    }
+    public abstract class NativeObjectSecurity : CommonObjectSecurity {
+        protected NativeObjectSecurity(bool isContainer, ResourceType resourceType);
+        protected NativeObjectSecurity(bool isContainer, ResourceType resourceType, NativeObjectSecurity.ExceptionFromErrorCode exceptionFromErrorCode, object exceptionContext);
+        protected NativeObjectSecurity(bool isContainer, ResourceType resourceType, SafeHandle handle, AccessControlSections includeSections);
+        protected NativeObjectSecurity(bool isContainer, ResourceType resourceType, SafeHandle handle, AccessControlSections includeSections, NativeObjectSecurity.ExceptionFromErrorCode exceptionFromErrorCode, object exceptionContext);
+        protected NativeObjectSecurity(bool isContainer, ResourceType resourceType, string name, AccessControlSections includeSections);
+        protected NativeObjectSecurity(bool isContainer, ResourceType resourceType, string name, AccessControlSections includeSections, NativeObjectSecurity.ExceptionFromErrorCode exceptionFromErrorCode, object exceptionContext);
+        protected sealed override void Persist(SafeHandle handle, AccessControlSections includeSections);
+        protected void Persist(SafeHandle handle, AccessControlSections includeSections, object exceptionContext);
+        protected sealed override void Persist(string name, AccessControlSections includeSections);
+        protected void Persist(string name, AccessControlSections includeSections, object exceptionContext);
+        protected internal delegate Exception ExceptionFromErrorCode(int errorCode, string name, SafeHandle handle, object context);
+    }
+    public abstract class ObjectAccessRule : AccessRule {
+        protected ObjectAccessRule(IdentityReference identity, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, Guid objectType, Guid inheritedObjectType, AccessControlType type);
+        public Guid InheritedObjectType { get; }
+        public ObjectAceFlags ObjectFlags { get; }
+        public Guid ObjectType { get; }
+    }
+    public sealed class ObjectAce : QualifiedAce {
+        public ObjectAce(AceFlags aceFlags, AceQualifier qualifier, int accessMask, SecurityIdentifier sid, ObjectAceFlags flags, Guid type, Guid inheritedType, bool isCallback, byte[] opaque);
+        public override int BinaryLength { get; }
+        public Guid InheritedObjectAceType { get; set; }
+        public ObjectAceFlags ObjectAceFlags { get; set; }
+        public Guid ObjectAceType { get; set; }
+        public override void GetBinaryForm(byte[] binaryForm, int offset);
+        public static int MaxOpaqueLength(bool isCallback);
+    }
+    public enum ObjectAceFlags {
+        InheritedObjectAceTypePresent = 2,
+        None = 0,
+        ObjectAceTypePresent = 1,
+    }
+    public abstract class ObjectAuditRule : AuditRule {
+        protected ObjectAuditRule(IdentityReference identity, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, Guid objectType, Guid inheritedObjectType, AuditFlags auditFlags);
+        public Guid InheritedObjectType { get; }
+        public ObjectAceFlags ObjectFlags { get; }
+        public Guid ObjectType { get; }
+    }
+    public abstract class ObjectSecurity {
+        protected ObjectSecurity();
+        protected ObjectSecurity(bool isContainer, bool isDS);
+        protected ObjectSecurity(CommonSecurityDescriptor securityDescriptor);
+        public abstract Type AccessRightType { get; }
+        protected bool AccessRulesModified { get; set; }
+        public abstract Type AccessRuleType { get; }
+        public bool AreAccessRulesCanonical { get; }
+        public bool AreAccessRulesProtected { get; }
+        public bool AreAuditRulesCanonical { get; }
+        public bool AreAuditRulesProtected { get; }
+        protected bool AuditRulesModified { get; set; }
+        public abstract Type AuditRuleType { get; }
+        protected bool GroupModified { get; set; }
+        protected bool IsContainer { get; }
+        protected bool IsDS { get; }
+        protected bool OwnerModified { get; set; }
+        public abstract AccessRule AccessRuleFactory(IdentityReference identityReference, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AccessControlType type);
+        public abstract AuditRule AuditRuleFactory(IdentityReference identityReference, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AuditFlags flags);
+        public IdentityReference GetGroup(Type targetType);
+        public IdentityReference GetOwner(Type targetType);
+        public byte[] GetSecurityDescriptorBinaryForm();
+        public string GetSecurityDescriptorSddlForm(AccessControlSections includeSections);
+        public static bool IsSddlConversionSupported();
+        protected abstract bool ModifyAccess(AccessControlModification modification, AccessRule rule, out bool modified);
+        public virtual bool ModifyAccessRule(AccessControlModification modification, AccessRule rule, out bool modified);
+        protected abstract bool ModifyAudit(AccessControlModification modification, AuditRule rule, out bool modified);
+        public virtual bool ModifyAuditRule(AccessControlModification modification, AuditRule rule, out bool modified);
+        protected virtual void Persist(bool enableOwnershipPrivilege, string name, AccessControlSections includeSections);
+        protected virtual void Persist(SafeHandle handle, AccessControlSections includeSections);
+        protected virtual void Persist(string name, AccessControlSections includeSections);
+        public virtual void PurgeAccessRules(IdentityReference identity);
+        public virtual void PurgeAuditRules(IdentityReference identity);
+        protected void ReadLock();
+        protected void ReadUnlock();
+        public void SetAccessRuleProtection(bool isProtected, bool preserveInheritance);
+        public void SetAuditRuleProtection(bool isProtected, bool preserveInheritance);
+        public void SetGroup(IdentityReference identity);
+        public void SetOwner(IdentityReference identity);
+        public void SetSecurityDescriptorBinaryForm(byte[] binaryForm);
+        public void SetSecurityDescriptorBinaryForm(byte[] binaryForm, AccessControlSections includeSections);
+        public void SetSecurityDescriptorSddlForm(string sddlForm);
+        public void SetSecurityDescriptorSddlForm(string sddlForm, AccessControlSections includeSections);
+        protected void WriteLock();
+        protected void WriteUnlock();
+    }
+    public abstract class ObjectSecurity<T> : NativeObjectSecurity where T : struct, ValueType {
+        protected ObjectSecurity(bool isContainer, ResourceType resourceType);
+        protected ObjectSecurity(bool isContainer, ResourceType resourceType, SafeHandle safeHandle, AccessControlSections includeSections);
+        protected ObjectSecurity(bool isContainer, ResourceType resourceType, SafeHandle safeHandle, AccessControlSections includeSections, NativeObjectSecurity.ExceptionFromErrorCode exceptionFromErrorCode, object exceptionContext);
+        protected ObjectSecurity(bool isContainer, ResourceType resourceType, string name, AccessControlSections includeSections);
+        protected ObjectSecurity(bool isContainer, ResourceType resourceType, string name, AccessControlSections includeSections, NativeObjectSecurity.ExceptionFromErrorCode exceptionFromErrorCode, object exceptionContext);
+        public override Type AccessRightType { get; }
+        public override Type AccessRuleType { get; }
+        public override Type AuditRuleType { get; }
+        public override AccessRule AccessRuleFactory(IdentityReference identityReference, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AccessControlType type);
+        public virtual void AddAccessRule(AccessRule<T> rule);
+        public virtual void AddAuditRule(AuditRule<T> rule);
+        public override AuditRule AuditRuleFactory(IdentityReference identityReference, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AuditFlags flags);
+        protected internal void Persist(SafeHandle handle);
+        protected internal void Persist(string name);
+        public virtual bool RemoveAccessRule(AccessRule<T> rule);
+        public virtual void RemoveAccessRuleAll(AccessRule<T> rule);
+        public virtual void RemoveAccessRuleSpecific(AccessRule<T> rule);
+        public virtual bool RemoveAuditRule(AuditRule<T> rule);
+        public virtual void RemoveAuditRuleAll(AuditRule<T> rule);
+        public virtual void RemoveAuditRuleSpecific(AuditRule<T> rule);
+        public virtual void ResetAccessRule(AccessRule<T> rule);
+        public virtual void SetAccessRule(AccessRule<T> rule);
+        public virtual void SetAuditRule(AuditRule<T> rule);
+    }
+    public sealed class PrivilegeNotHeldException : UnauthorizedAccessException {
+        public PrivilegeNotHeldException();
+        public PrivilegeNotHeldException(string privilege);
+        public PrivilegeNotHeldException(string privilege, Exception inner);
+        public string PrivilegeName { get; }
+    }
+    public enum PropagationFlags {
+        InheritOnly = 2,
+        None = 0,
+        NoPropagateInherit = 1,
+    }
+    public abstract class QualifiedAce : KnownAce {
+        public AceQualifier AceQualifier { get; }
+        public bool IsCallback { get; }
+        public int OpaqueLength { get; }
+        public byte[] GetOpaque();
+        public void SetOpaque(byte[] opaque);
+    }
+    public sealed class RawAcl : GenericAcl {
+        public RawAcl(byte revision, int capacity);
+        public RawAcl(byte[] binaryForm, int offset);
+        public override int BinaryLength { get; }
+        public override int Count { get; }
+        public override byte Revision { get; }
+        public override GenericAce this[int index] { get; set; }
+        public override void GetBinaryForm(byte[] binaryForm, int offset);
+        public void InsertAce(int index, GenericAce ace);
+        public void RemoveAce(int index);
+    }
+    public sealed class RawSecurityDescriptor : GenericSecurityDescriptor {
+        public RawSecurityDescriptor(byte[] binaryForm, int offset);
+        public RawSecurityDescriptor(ControlFlags flags, SecurityIdentifier owner, SecurityIdentifier group, RawAcl systemAcl, RawAcl discretionaryAcl);
+        public RawSecurityDescriptor(string sddlForm);
+        public override ControlFlags ControlFlags { get; }
+        public RawAcl DiscretionaryAcl { get; set; }
+        public override SecurityIdentifier Group { get; set; }
+        public override SecurityIdentifier Owner { get; set; }
+        public byte ResourceManagerControl { get; set; }
+        public RawAcl SystemAcl { get; set; }
+        public void SetFlags(ControlFlags flags);
+    }
+    public sealed class RegistryAccessRule : AccessRule {
+        public RegistryAccessRule(IdentityReference identity, RegistryRights registryRights, AccessControlType type);
+        public RegistryAccessRule(IdentityReference identity, RegistryRights registryRights, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AccessControlType type);
+        public RegistryAccessRule(string identity, RegistryRights registryRights, AccessControlType type);
+        public RegistryAccessRule(string identity, RegistryRights registryRights, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AccessControlType type);
+        public RegistryRights RegistryRights { get; }
+    }
+    public sealed class RegistryAuditRule : AuditRule {
+        public RegistryAuditRule(IdentityReference identity, RegistryRights registryRights, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AuditFlags flags);
+        public RegistryAuditRule(string identity, RegistryRights registryRights, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AuditFlags flags);
+        public RegistryRights RegistryRights { get; }
+    }
+    public enum RegistryRights {
+        ChangePermissions = 262144,
+        CreateLink = 32,
+        CreateSubKey = 4,
+        Delete = 65536,
+        EnumerateSubKeys = 8,
+        ExecuteKey = 131097,
+        FullControl = 983103,
+        Notify = 16,
+        QueryValues = 1,
+        ReadKey = 131097,
+        ReadPermissions = 131072,
+        SetValue = 2,
+        TakeOwnership = 524288,
+        WriteKey = 131078,
+    }
+    public sealed class RegistrySecurity : NativeObjectSecurity {
+        public RegistrySecurity();
+        public override Type AccessRightType { get; }
+        public override Type AccessRuleType { get; }
+        public override Type AuditRuleType { get; }
+        public override AccessRule AccessRuleFactory(IdentityReference identityReference, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AccessControlType type);
+        public void AddAccessRule(RegistryAccessRule rule);
+        public void AddAuditRule(RegistryAuditRule rule);
+        public override AuditRule AuditRuleFactory(IdentityReference identityReference, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AuditFlags flags);
+        public bool RemoveAccessRule(RegistryAccessRule rule);
+        public void RemoveAccessRuleAll(RegistryAccessRule rule);
+        public void RemoveAccessRuleSpecific(RegistryAccessRule rule);
+        public bool RemoveAuditRule(RegistryAuditRule rule);
+        public void RemoveAuditRuleAll(RegistryAuditRule rule);
+        public void RemoveAuditRuleSpecific(RegistryAuditRule rule);
+        public void ResetAccessRule(RegistryAccessRule rule);
+        public void SetAccessRule(RegistryAccessRule rule);
+        public void SetAuditRule(RegistryAuditRule rule);
+    }
+    public enum ResourceType {
+        DSObject = 8,
+        DSObjectAll = 9,
+        FileObject = 1,
+        KernelObject = 6,
+        LMShare = 5,
+        Printer = 3,
+        ProviderDefined = 10,
+        RegistryKey = 4,
+        RegistryWow6432Key = 12,
+        Service = 2,
+        Unknown = 0,
+        WindowObject = 7,
+        WmiGuidObject = 11,
+    }
+    public enum SecurityInfos {
+        DiscretionaryAcl = 4,
+        Group = 2,
+        Owner = 1,
+        SystemAcl = 8,
+    }
+    public sealed class SemaphoreAccessRule : AccessRule {
+        public SemaphoreAccessRule(IdentityReference identity, SemaphoreRights eventRights, AccessControlType type);
+        public SemaphoreAccessRule(string identity, SemaphoreRights eventRights, AccessControlType type);
+        public SemaphoreRights SemaphoreRights { get; }
+    }
+    public sealed class SemaphoreAuditRule : AuditRule {
+        public SemaphoreAuditRule(IdentityReference identity, SemaphoreRights eventRights, AuditFlags flags);
+        public SemaphoreRights SemaphoreRights { get; }
+    }
+    public enum SemaphoreRights {
+        ChangePermissions = 262144,
+        Delete = 65536,
+        FullControl = 2031619,
+        Modify = 2,
+        ReadPermissions = 131072,
+        Synchronize = 1048576,
+        TakeOwnership = 524288,
+    }
+    public sealed class SemaphoreSecurity : NativeObjectSecurity {
+        public SemaphoreSecurity();
+        public SemaphoreSecurity(string name, AccessControlSections includeSections);
+        public override Type AccessRightType { get; }
+        public override Type AccessRuleType { get; }
+        public override Type AuditRuleType { get; }
+        public override AccessRule AccessRuleFactory(IdentityReference identityReference, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AccessControlType type);
+        public void AddAccessRule(SemaphoreAccessRule rule);
+        public void AddAuditRule(SemaphoreAuditRule rule);
+        public override AuditRule AuditRuleFactory(IdentityReference identityReference, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AuditFlags flags);
+        public bool RemoveAccessRule(SemaphoreAccessRule rule);
+        public void RemoveAccessRuleAll(SemaphoreAccessRule rule);
+        public void RemoveAccessRuleSpecific(SemaphoreAccessRule rule);
+        public bool RemoveAuditRule(SemaphoreAuditRule rule);
+        public void RemoveAuditRuleAll(SemaphoreAuditRule rule);
+        public void RemoveAuditRuleSpecific(SemaphoreAuditRule rule);
+        public void ResetAccessRule(SemaphoreAccessRule rule);
+        public void SetAccessRule(SemaphoreAccessRule rule);
+        public void SetAuditRule(SemaphoreAuditRule rule);
+    }
+    public sealed class SystemAcl : CommonAcl {
+        public SystemAcl(bool isContainer, bool isDS, byte revision, int capacity);
+        public SystemAcl(bool isContainer, bool isDS, int capacity);
+        public SystemAcl(bool isContainer, bool isDS, RawAcl rawAcl);
+        public void AddAudit(AuditFlags auditFlags, SecurityIdentifier sid, int accessMask, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags);
+        public void AddAudit(AuditFlags auditFlags, SecurityIdentifier sid, int accessMask, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, ObjectAceFlags objectFlags, Guid objectType, Guid inheritedObjectType);
+        public void AddAudit(SecurityIdentifier sid, ObjectAuditRule rule);
+        public bool RemoveAudit(AuditFlags auditFlags, SecurityIdentifier sid, int accessMask, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags);
+        public bool RemoveAudit(AuditFlags auditFlags, SecurityIdentifier sid, int accessMask, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, ObjectAceFlags objectFlags, Guid objectType, Guid inheritedObjectType);
+        public bool RemoveAudit(SecurityIdentifier sid, ObjectAuditRule rule);
+        public void RemoveAuditSpecific(AuditFlags auditFlags, SecurityIdentifier sid, int accessMask, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags);
+        public void RemoveAuditSpecific(AuditFlags auditFlags, SecurityIdentifier sid, int accessMask, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, ObjectAceFlags objectFlags, Guid objectType, Guid inheritedObjectType);
+        public void RemoveAuditSpecific(SecurityIdentifier sid, ObjectAuditRule rule);
+        public void SetAudit(AuditFlags auditFlags, SecurityIdentifier sid, int accessMask, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags);
+        public void SetAudit(AuditFlags auditFlags, SecurityIdentifier sid, int accessMask, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, ObjectAceFlags objectFlags, Guid objectType, Guid inheritedObjectType);
+        public void SetAudit(SecurityIdentifier sid, ObjectAuditRule rule);
+    }
+}
```

## System.Security.Authentication

```c#
+namespace System.Security.Authentication {
+    public class AuthenticationException : Exception {
+        public AuthenticationException();
+        public AuthenticationException(string message);
+        public AuthenticationException(string message, Exception innerException);
+    }
+    public enum CipherAlgorithmType {
+        Aes = 26129,
+        Aes128 = 26126,
+        Aes192 = 26127,
+        Aes256 = 26128,
+        Des = 26113,
+        None = 0,
+        Null = 24576,
+        Rc2 = 26114,
+        Rc4 = 26625,
+        TripleDes = 26115,
+    }
+    public enum ExchangeAlgorithmType {
+        DiffieHellman = 43522,
+        None = 0,
+        RsaKeyX = 41984,
+        RsaSign = 9216,
+    }
+    public enum HashAlgorithmType {
+        Md5 = 32771,
+        None = 0,
+        Sha1 = 32772,
+    }
+    public class InvalidCredentialException : AuthenticationException {
+        public InvalidCredentialException();
+        public InvalidCredentialException(string message);
+        public InvalidCredentialException(string message, Exception innerException);
+    }
+    public enum SslProtocols {
+        None = 0,
+        Ssl2 = 12,
+        Ssl3 = 48,
+        Tls = 192,
+        Tls11 = 768,
+        Tls12 = 3072,
+    }
+}
```

## System.Security.Authentication.ExtendedProtection

```c#
+namespace System.Security.Authentication.ExtendedProtection {
+    public abstract class ChannelBinding : SafeHandle {
+        protected ChannelBinding();
+        protected ChannelBinding(bool ownsHandle);
+        public abstract int Size { get; }
+    }
+    public enum ChannelBindingKind {
+        Endpoint = 26,
+        Unique = 25,
+        Unknown = 0,
+    }
+    public class ExtendedProtectionPolicy {
+        public ExtendedProtectionPolicy(PolicyEnforcement policyEnforcement);
+        public ExtendedProtectionPolicy(PolicyEnforcement policyEnforcement, ChannelBinding customChannelBinding);
+        public ExtendedProtectionPolicy(PolicyEnforcement policyEnforcement, ProtectionScenario protectionScenario, ICollection customServiceNames);
+        public ExtendedProtectionPolicy(PolicyEnforcement policyEnforcement, ProtectionScenario protectionScenario, ServiceNameCollection customServiceNames);
+        public ChannelBinding CustomChannelBinding { get; }
+        public ServiceNameCollection CustomServiceNames { get; }
+        public static bool OSSupportsExtendedProtection { get; }
+        public PolicyEnforcement PolicyEnforcement { get; }
+        public ProtectionScenario ProtectionScenario { get; }
+        public override string ToString();
+    }
+    public enum PolicyEnforcement {
+        Always = 2,
+        Never = 0,
+        WhenSupported = 1,
+    }
+    public enum ProtectionScenario {
+        TransportSelected = 0,
+        TrustedProxy = 1,
+    }
+    public class ServiceNameCollection : ICollection, IEnumerable {
+        public ServiceNameCollection(ICollection items);
+        public int Count { get; }
+        bool System.Collections.ICollection.IsSynchronized { get; }
+        object System.Collections.ICollection.SyncRoot { get; }
+        public bool Contains(string searchServiceName);
+        public IEnumerator GetEnumerator();
+        public ServiceNameCollection Merge(IEnumerable serviceNames);
+        public ServiceNameCollection Merge(string serviceName);
+        void System.Collections.ICollection.CopyTo(Array array, int index);
+    }
+}
```

## System.Security.Claims

```c#
+namespace System.Security.Claims {
+    public class Claim {
+        public Claim(BinaryReader reader);
+        public Claim(BinaryReader reader, ClaimsIdentity subject);
+        protected Claim(Claim other);
+        protected Claim(Claim other, ClaimsIdentity subject);
+        public Claim(string type, string value);
+        public Claim(string type, string value, string valueType);
+        public Claim(string type, string value, string valueType, string issuer);
+        public Claim(string type, string value, string valueType, string issuer, string originalIssuer);
+        public Claim(string type, string value, string valueType, string issuer, string originalIssuer, ClaimsIdentity subject);
+        protected virtual byte[] CustomSerializationData { get; }
+        public string Issuer { get; }
+        public string OriginalIssuer { get; }
+        public IDictionary<string, string> Properties { get; }
+        public ClaimsIdentity Subject { get; }
+        public string Type { get; }
+        public string Value { get; }
+        public string ValueType { get; }
+        public virtual Claim Clone();
+        public virtual Claim Clone(ClaimsIdentity identity);
+        public override string ToString();
+        public virtual void WriteTo(BinaryWriter writer);
+        protected virtual void WriteTo(BinaryWriter writer, byte[] userData);
+    }
+    public class ClaimsIdentity : IIdentity {
+        public const string DefaultIssuer = "LOCAL AUTHORITY";
+        public const string DefaultNameClaimType = "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/name";
+        public const string DefaultRoleClaimType = "http://schemas.microsoft.com/ws/2008/06/identity/claims/role";
+        public ClaimsIdentity();
+        public ClaimsIdentity(IEnumerable<Claim> claims);
+        public ClaimsIdentity(IEnumerable<Claim> claims, string authenticationType);
+        public ClaimsIdentity(IEnumerable<Claim> claims, string authenticationType, string nameType, string roleType);
+        public ClaimsIdentity(BinaryReader reader);
+        protected ClaimsIdentity(ClaimsIdentity other);
+        public ClaimsIdentity(IIdentity identity);
+        public ClaimsIdentity(IIdentity identity, IEnumerable<Claim> claims);
+        public ClaimsIdentity(IIdentity identity, IEnumerable<Claim> claims, string authenticationType, string nameType, string roleType);
+        public ClaimsIdentity(string authenticationType);
+        public ClaimsIdentity(string authenticationType, string nameType, string roleType);
+        public ClaimsIdentity Actor { get; set; }
+        public virtual string AuthenticationType { get; }
+        public object BootstrapContext { get; set; }
+        public virtual IEnumerable<Claim> Claims { get; }
+        protected virtual byte[] CustomSerializationData { get; }
+        public virtual bool IsAuthenticated { get; }
+        public string Label { get; set; }
+        public virtual string Name { get; }
+        public string NameClaimType { get; }
+        public string RoleClaimType { get; }
+        public virtual void AddClaim(Claim claim);
+        public virtual void AddClaims(IEnumerable<Claim> claims);
+        public virtual ClaimsIdentity Clone();
+        protected virtual Claim CreateClaim(BinaryReader reader);
+        public virtual IEnumerable<Claim> FindAll(Predicate<Claim> match);
+        public virtual IEnumerable<Claim> FindAll(string type);
+        public virtual Claim FindFirst(Predicate<Claim> match);
+        public virtual Claim FindFirst(string type);
+        public virtual bool HasClaim(Predicate<Claim> match);
+        public virtual bool HasClaim(string type, string value);
+        public virtual void RemoveClaim(Claim claim);
+        public virtual bool TryRemoveClaim(Claim claim);
+        public virtual void WriteTo(BinaryWriter writer);
+        protected virtual void WriteTo(BinaryWriter writer, byte[] userData);
+    }
+    public class ClaimsPrincipal : IPrincipal {
+        public ClaimsPrincipal();
+        public ClaimsPrincipal(IEnumerable<ClaimsIdentity> identities);
+        public ClaimsPrincipal(BinaryReader reader);
+        public ClaimsPrincipal(IIdentity identity);
+        public ClaimsPrincipal(IPrincipal principal);
+        public virtual IEnumerable<Claim> Claims { get; }
+        public static Func<ClaimsPrincipal> ClaimsPrincipalSelector { get; set; }
+        public static ClaimsPrincipal Current { get; }
+        protected virtual byte[] CustomSerializationData { get; }
+        public virtual IEnumerable<ClaimsIdentity> Identities { get; }
+        public virtual IIdentity Identity { get; }
+        public static Func<IEnumerable<ClaimsIdentity>, ClaimsIdentity> PrimaryIdentitySelector { get; set; }
+        public virtual void AddIdentities(IEnumerable<ClaimsIdentity> identities);
+        public virtual void AddIdentity(ClaimsIdentity identity);
+        public virtual ClaimsPrincipal Clone();
+        protected virtual ClaimsIdentity CreateClaimsIdentity(BinaryReader reader);
+        public virtual IEnumerable<Claim> FindAll(Predicate<Claim> match);
+        public virtual IEnumerable<Claim> FindAll(string type);
+        public virtual Claim FindFirst(Predicate<Claim> match);
+        public virtual Claim FindFirst(string type);
+        public virtual bool HasClaim(Predicate<Claim> match);
+        public virtual bool HasClaim(string type, string value);
+        public virtual bool IsInRole(string role);
+        public virtual void WriteTo(BinaryWriter writer);
+        protected virtual void WriteTo(BinaryWriter writer, byte[] userData);
+    }
+    public static class ClaimTypes {
+        public const string Actor = "http://schemas.xmlsoap.org/ws/2009/09/identity/claims/actor";
+        public const string Anonymous = "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/anonymous";
+        public const string Authentication = "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/authentication";
+        public const string AuthenticationInstant = "http://schemas.microsoft.com/ws/2008/06/identity/claims/authenticationinstant";
+        public const string AuthenticationMethod = "http://schemas.microsoft.com/ws/2008/06/identity/claims/authenticationmethod";
+        public const string AuthorizationDecision = "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/authorizationdecision";
+        public const string CookiePath = "http://schemas.microsoft.com/ws/2008/06/identity/claims/cookiepath";
+        public const string Country = "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/country";
+        public const string DateOfBirth = "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/dateofbirth";
+        public const string DenyOnlyPrimaryGroupSid = "http://schemas.microsoft.com/ws/2008/06/identity/claims/denyonlyprimarygroupsid";
+        public const string DenyOnlyPrimarySid = "http://schemas.microsoft.com/ws/2008/06/identity/claims/denyonlyprimarysid";
+        public const string DenyOnlySid = "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/denyonlysid";
+        public const string DenyOnlyWindowsDeviceGroup = "http://schemas.microsoft.com/ws/2008/06/identity/claims/denyonlywindowsdevicegroup";
+        public const string Dns = "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/dns";
+        public const string Dsa = "http://schemas.microsoft.com/ws/2008/06/identity/claims/dsa";
+        public const string Email = "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/emailaddress";
+        public const string Expiration = "http://schemas.microsoft.com/ws/2008/06/identity/claims/expiration";
+        public const string Expired = "http://schemas.microsoft.com/ws/2008/06/identity/claims/expired";
+        public const string Gender = "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/gender";
+        public const string GivenName = "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/givenname";
+        public const string GroupSid = "http://schemas.microsoft.com/ws/2008/06/identity/claims/groupsid";
+        public const string Hash = "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/hash";
+        public const string HomePhone = "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/homephone";
+        public const string IsPersistent = "http://schemas.microsoft.com/ws/2008/06/identity/claims/ispersistent";
+        public const string Locality = "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/locality";
+        public const string MobilePhone = "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/mobilephone";
+        public const string Name = "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/name";
+        public const string NameIdentifier = "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/nameidentifier";
+        public const string OtherPhone = "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/otherphone";
+        public const string PostalCode = "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/postalcode";
+        public const string PrimaryGroupSid = "http://schemas.microsoft.com/ws/2008/06/identity/claims/primarygroupsid";
+        public const string PrimarySid = "http://schemas.microsoft.com/ws/2008/06/identity/claims/primarysid";
+        public const string Role = "http://schemas.microsoft.com/ws/2008/06/identity/claims/role";
+        public const string Rsa = "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/rsa";
+        public const string SerialNumber = "http://schemas.microsoft.com/ws/2008/06/identity/claims/serialnumber";
+        public const string Sid = "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/sid";
+        public const string Spn = "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/spn";
+        public const string StateOrProvince = "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/stateorprovince";
+        public const string StreetAddress = "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/streetaddress";
+        public const string Surname = "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/surname";
+        public const string System = "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/system";
+        public const string Thumbprint = "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/thumbprint";
+        public const string Upn = "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/upn";
+        public const string Uri = "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/uri";
+        public const string UserData = "http://schemas.microsoft.com/ws/2008/06/identity/claims/userdata";
+        public const string Version = "http://schemas.microsoft.com/ws/2008/06/identity/claims/version";
+        public const string Webpage = "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/webpage";
+        public const string WindowsAccountName = "http://schemas.microsoft.com/ws/2008/06/identity/claims/windowsaccountname";
+        public const string WindowsDeviceClaim = "http://schemas.microsoft.com/ws/2008/06/identity/claims/windowsdeviceclaim";
+        public const string WindowsDeviceGroup = "http://schemas.microsoft.com/ws/2008/06/identity/claims/windowsdevicegroup";
+        public const string WindowsFqbnVersion = "http://schemas.microsoft.com/ws/2008/06/identity/claims/windowsfqbnversion";
+        public const string WindowsSubAuthority = "http://schemas.microsoft.com/ws/2008/06/identity/claims/windowssubauthority";
+        public const string WindowsUserClaim = "http://schemas.microsoft.com/ws/2008/06/identity/claims/windowsuserclaim";
+        public const string X500DistinguishedName = "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/x500distinguishedname";
+    }
+    public static class ClaimValueTypes {
+        public const string Base64Binary = "http://www.w3.org/2001/XMLSchema#base64Binary";
+        public const string Base64Octet = "http://www.w3.org/2001/XMLSchema#base64Octet";
+        public const string Boolean = "http://www.w3.org/2001/XMLSchema#boolean";
+        public const string Date = "http://www.w3.org/2001/XMLSchema#date";
+        public const string DateTime = "http://www.w3.org/2001/XMLSchema#dateTime";
+        public const string DaytimeDuration = "http://www.w3.org/TR/2002/WD-xquery-operators-20020816#dayTimeDuration";
+        public const string DnsName = "http://schemas.xmlsoap.org/claims/dns";
+        public const string Double = "http://www.w3.org/2001/XMLSchema#double";
+        public const string DsaKeyValue = "http://www.w3.org/2000/09/xmldsig#DSAKeyValue";
+        public const string Email = "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/emailaddress";
+        public const string Fqbn = "http://www.w3.org/2001/XMLSchema#fqbn";
+        public const string HexBinary = "http://www.w3.org/2001/XMLSchema#hexBinary";
+        public const string Integer = "http://www.w3.org/2001/XMLSchema#integer";
+        public const string Integer32 = "http://www.w3.org/2001/XMLSchema#integer32";
+        public const string Integer64 = "http://www.w3.org/2001/XMLSchema#integer64";
+        public const string KeyInfo = "http://www.w3.org/2000/09/xmldsig#KeyInfo";
+        public const string Rfc822Name = "urn:oasis:names:tc:xacml:1.0:data-type:rfc822Name";
+        public const string Rsa = "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/rsa";
+        public const string RsaKeyValue = "http://www.w3.org/2000/09/xmldsig#RSAKeyValue";
+        public const string Sid = "http://www.w3.org/2001/XMLSchema#sid";
+        public const string String = "http://www.w3.org/2001/XMLSchema#string";
+        public const string Time = "http://www.w3.org/2001/XMLSchema#time";
+        public const string UInteger32 = "http://www.w3.org/2001/XMLSchema#uinteger32";
+        public const string UInteger64 = "http://www.w3.org/2001/XMLSchema#uinteger64";
+        public const string UpnName = "http://schemas.xmlsoap.org/claims/UPN";
+        public const string X500Name = "urn:oasis:names:tc:xacml:1.0:data-type:x500Name";
+        public const string YearMonthDuration = "http://www.w3.org/TR/2002/WD-xquery-operators-20020816#yearMonthDuration";
+    }
+}
```

## System.Security.Cryptography

```c#
+namespace System.Security.Cryptography {
+    public abstract class Aes : SymmetricAlgorithm {
+        protected Aes();
+        public override KeySizes[] LegalBlockSizes { get; }
+        public override KeySizes[] LegalKeySizes { get; }
+        public static Aes Create();
+    }
+    public sealed class AesCng : Aes {
+        public AesCng();
+        public AesCng(string keyName);
+        public AesCng(string keyName, CngProvider provider);
+        public AesCng(string keyName, CngProvider provider, CngKeyOpenOptions openOptions);
+        public override byte[] Key { get; set; }
+        public override int KeySize { get; set; }
+        public override ICryptoTransform CreateDecryptor();
+        public override ICryptoTransform CreateDecryptor(byte[] rgbKey, byte[] rgbIV);
+        public override ICryptoTransform CreateEncryptor();
+        public override ICryptoTransform CreateEncryptor(byte[] rgbKey, byte[] rgbIV);
+        protected override void Dispose(bool disposing);
+        public override void GenerateIV();
+        public override void GenerateKey();
+    }
+    public class AsnEncodedData {
+        protected AsnEncodedData();
+        public AsnEncodedData(byte[] rawData);
+        public AsnEncodedData(AsnEncodedData asnEncodedData);
+        public AsnEncodedData(Oid oid, byte[] rawData);
+        public AsnEncodedData(string oid, byte[] rawData);
+        public Oid Oid { get; set; }
+        public byte[] RawData { get; set; }
+        public virtual void CopyFrom(AsnEncodedData asnEncodedData);
+        public virtual string Format(bool multiLine);
+    }
+    public sealed class AsnEncodedDataCollection : ICollection, IEnumerable {
+        public AsnEncodedDataCollection();
+        public AsnEncodedDataCollection(AsnEncodedData asnEncodedData);
+        public int Count { get; }
+        bool System.Collections.ICollection.IsSynchronized { get; }
+        object System.Collections.ICollection.SyncRoot { get; }
+        public AsnEncodedData this[int index] { get; }
+        public int Add(AsnEncodedData asnEncodedData);
+        public void CopyTo(AsnEncodedData[] array, int index);
+        public AsnEncodedDataEnumerator GetEnumerator();
+        public void Remove(AsnEncodedData asnEncodedData);
+        void System.Collections.ICollection.CopyTo(Array array, int index);
+        IEnumerator System.Collections.IEnumerable.GetEnumerator();
+    }
+    public sealed class AsnEncodedDataEnumerator : IEnumerator {
+        public AsnEncodedData Current { get; }
+        object System.Collections.IEnumerator.Current { get; }
+        public bool MoveNext();
+        public void Reset();
+    }
+    public abstract class AsymmetricAlgorithm : IDisposable {
+        protected int KeySizeValue;
+        protected KeySizes[] LegalKeySizesValue;
+        protected AsymmetricAlgorithm();
+        public virtual int KeySize { get; set; }
+        public virtual KeySizes[] LegalKeySizes { get; }
+        public void Dispose();
+        protected virtual void Dispose(bool disposing);
+    }
+    public enum CipherMode {
+        CBC = 1,
+        CTS = 5,
+        ECB = 2,
+    }
+    public sealed class CngAlgorithm : IEquatable<CngAlgorithm> {
+        public CngAlgorithm(string algorithm);
+        public string Algorithm { get; }
+        public static CngAlgorithm ECDiffieHellman { get; }
+        public static CngAlgorithm ECDiffieHellmanP256 { get; }
+        public static CngAlgorithm ECDiffieHellmanP384 { get; }
+        public static CngAlgorithm ECDiffieHellmanP521 { get; }
+        public static CngAlgorithm ECDsa { get; }
+        public static CngAlgorithm ECDsaP256 { get; }
+        public static CngAlgorithm ECDsaP384 { get; }
+        public static CngAlgorithm ECDsaP521 { get; }
+        public static CngAlgorithm MD5 { get; }
+        public static CngAlgorithm Rsa { get; }
+        public static CngAlgorithm Sha1 { get; }
+        public static CngAlgorithm Sha256 { get; }
+        public static CngAlgorithm Sha384 { get; }
+        public static CngAlgorithm Sha512 { get; }
+        public override bool Equals(object obj);
+        public bool Equals(CngAlgorithm other);
+        public override int GetHashCode();
+        public static bool operator ==(CngAlgorithm left, CngAlgorithm right);
+        public static bool operator !=(CngAlgorithm left, CngAlgorithm right);
+        public override string ToString();
+    }
+    public sealed class CngAlgorithmGroup : IEquatable<CngAlgorithmGroup> {
+        public CngAlgorithmGroup(string algorithmGroup);
+        public string AlgorithmGroup { get; }
+        public static CngAlgorithmGroup DiffieHellman { get; }
+        public static CngAlgorithmGroup Dsa { get; }
+        public static CngAlgorithmGroup ECDiffieHellman { get; }
+        public static CngAlgorithmGroup ECDsa { get; }
+        public static CngAlgorithmGroup Rsa { get; }
+        public override bool Equals(object obj);
+        public bool Equals(CngAlgorithmGroup other);
+        public override int GetHashCode();
+        public static bool operator ==(CngAlgorithmGroup left, CngAlgorithmGroup right);
+        public static bool operator !=(CngAlgorithmGroup left, CngAlgorithmGroup right);
+        public override string ToString();
+    }
+    public enum CngExportPolicies {
+        AllowArchiving = 4,
+        AllowExport = 1,
+        AllowPlaintextArchiving = 8,
+        AllowPlaintextExport = 2,
+        None = 0,
+    }
+    public sealed class CngKey : IDisposable {
+        public CngAlgorithm Algorithm { get; }
+        public CngAlgorithmGroup AlgorithmGroup { get; }
+        public CngExportPolicies ExportPolicy { get; }
+        public SafeNCryptKeyHandle Handle { get; }
+        public bool IsEphemeral { get; }
+        public bool IsMachineKey { get; }
+        public string KeyName { get; }
+        public int KeySize { get; }
+        public CngKeyUsages KeyUsage { get; }
+        public IntPtr ParentWindowHandle { get; set; }
+        public CngProvider Provider { get; }
+        public SafeNCryptProviderHandle ProviderHandle { get; }
+        public CngUIPolicy UIPolicy { get; }
+        public string UniqueName { get; }
+        public static CngKey Create(CngAlgorithm algorithm);
+        public static CngKey Create(CngAlgorithm algorithm, string keyName);
+        public static CngKey Create(CngAlgorithm algorithm, string keyName, CngKeyCreationParameters creationParameters);
+        public void Delete();
+        public void Dispose();
+        public static bool Exists(string keyName);
+        public static bool Exists(string keyName, CngProvider provider);
+        public static bool Exists(string keyName, CngProvider provider, CngKeyOpenOptions options);
+        public byte[] Export(CngKeyBlobFormat format);
+        public CngProperty GetProperty(string name, CngPropertyOptions options);
+        public bool HasProperty(string name, CngPropertyOptions options);
+        public static CngKey Import(byte[] keyBlob, CngKeyBlobFormat format);
+        public static CngKey Import(byte[] keyBlob, CngKeyBlobFormat format, CngProvider provider);
+        public static CngKey Open(SafeNCryptKeyHandle keyHandle, CngKeyHandleOpenOptions keyHandleOpenOptions);
+        public static CngKey Open(string keyName);
+        public static CngKey Open(string keyName, CngProvider provider);
+        public static CngKey Open(string keyName, CngProvider provider, CngKeyOpenOptions openOptions);
+        public void SetProperty(CngProperty property);
+    }
+    public sealed class CngKeyBlobFormat : IEquatable<CngKeyBlobFormat> {
+        public CngKeyBlobFormat(string format);
+        public static CngKeyBlobFormat EccFullPrivateBlob { get; }
+        public static CngKeyBlobFormat EccFullPublicBlob { get; }
+        public static CngKeyBlobFormat EccPrivateBlob { get; }
+        public static CngKeyBlobFormat EccPublicBlob { get; }
+        public string Format { get; }
+        public static CngKeyBlobFormat GenericPrivateBlob { get; }
+        public static CngKeyBlobFormat GenericPublicBlob { get; }
+        public static CngKeyBlobFormat OpaqueTransportBlob { get; }
+        public static CngKeyBlobFormat Pkcs8PrivateBlob { get; }
+        public override bool Equals(object obj);
+        public bool Equals(CngKeyBlobFormat other);
+        public override int GetHashCode();
+        public static bool operator ==(CngKeyBlobFormat left, CngKeyBlobFormat right);
+        public static bool operator !=(CngKeyBlobFormat left, CngKeyBlobFormat right);
+        public override string ToString();
+    }
+    public enum CngKeyCreationOptions {
+        MachineKey = 32,
+        None = 0,
+        OverwriteExistingKey = 128,
+    }
+    public sealed class CngKeyCreationParameters {
+        public CngKeyCreationParameters();
+        public Nullable<CngExportPolicies> ExportPolicy { get; set; }
+        public CngKeyCreationOptions KeyCreationOptions { get; set; }
+        public Nullable<CngKeyUsages> KeyUsage { get; set; }
+        public CngPropertyCollection Parameters { get; }
+        public IntPtr ParentWindowHandle { get; set; }
+        public CngProvider Provider { get; set; }
+        public CngUIPolicy UIPolicy { get; set; }
+    }
+    public enum CngKeyHandleOpenOptions {
+        EphemeralKey = 1,
+        None = 0,
+    }
+    public enum CngKeyOpenOptions {
+        MachineKey = 32,
+        None = 0,
+        Silent = 64,
+        UserKey = 0,
+    }
+    public enum CngKeyUsages {
+        AllUsages = 16777215,
+        Decryption = 1,
+        KeyAgreement = 4,
+        None = 0,
+        Signing = 2,
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct CngProperty : IEquatable<CngProperty> {
+        public CngProperty(string name, byte[] value, CngPropertyOptions options);
+        public string Name { get; }
+        public CngPropertyOptions Options { get; }
+        public override bool Equals(object obj);
+        public bool Equals(CngProperty other);
+        public override int GetHashCode();
+        public byte[] GetValue();
+        public static bool operator ==(CngProperty left, CngProperty right);
+        public static bool operator !=(CngProperty left, CngProperty right);
+    }
+    public sealed class CngPropertyCollection : Collection<CngProperty> {
+        public CngPropertyCollection();
+    }
+    public enum CngPropertyOptions {
+        CustomProperty = 1073741824,
+        None = 0,
+        Persist = -2147483648,
+    }
+    public sealed class CngProvider : IEquatable<CngProvider> {
+        public CngProvider(string provider);
+        public static CngProvider MicrosoftSmartCardKeyStorageProvider { get; }
+        public static CngProvider MicrosoftSoftwareKeyStorageProvider { get; }
+        public string Provider { get; }
+        public override bool Equals(object obj);
+        public bool Equals(CngProvider other);
+        public override int GetHashCode();
+        public static bool operator ==(CngProvider left, CngProvider right);
+        public static bool operator !=(CngProvider left, CngProvider right);
+        public override string ToString();
+    }
+    public sealed class CngUIPolicy {
+        public CngUIPolicy(CngUIProtectionLevels protectionLevel);
+        public CngUIPolicy(CngUIProtectionLevels protectionLevel, string friendlyName);
+        public CngUIPolicy(CngUIProtectionLevels protectionLevel, string friendlyName, string description);
+        public CngUIPolicy(CngUIProtectionLevels protectionLevel, string friendlyName, string description, string useContext);
+        public CngUIPolicy(CngUIProtectionLevels protectionLevel, string friendlyName, string description, string useContext, string creationTitle);
+        public string CreationTitle { get; }
+        public string Description { get; }
+        public string FriendlyName { get; }
+        public CngUIProtectionLevels ProtectionLevel { get; }
+        public string UseContext { get; }
+    }
+    public enum CngUIProtectionLevels {
+        ForceHighProtection = 2,
+        None = 0,
+        ProtectKey = 1,
+    }
+    public sealed class CryptographicAttributeObject {
+        public CryptographicAttributeObject(Oid oid);
+        public CryptographicAttributeObject(Oid oid, AsnEncodedDataCollection values);
+        public Oid Oid { get; }
+        public AsnEncodedDataCollection Values { get; }
+    }
+    public sealed class CryptographicAttributeObjectCollection : ICollection, IEnumerable {
+        public CryptographicAttributeObjectCollection();
+        public CryptographicAttributeObjectCollection(CryptographicAttributeObject attribute);
+        public int Count { get; }
+        bool System.Collections.ICollection.IsSynchronized { get; }
+        object System.Collections.ICollection.SyncRoot { get; }
+        public CryptographicAttributeObject this[int index] { get; }
+        public int Add(AsnEncodedData asnEncodedData);
+        public int Add(CryptographicAttributeObject attribute);
+        public void CopyTo(CryptographicAttributeObject[] array, int index);
+        public CryptographicAttributeObjectEnumerator GetEnumerator();
+        public void Remove(CryptographicAttributeObject attribute);
+        void System.Collections.ICollection.CopyTo(Array array, int index);
+        IEnumerator System.Collections.IEnumerable.GetEnumerator();
+    }
+    public sealed class CryptographicAttributeObjectEnumerator : IEnumerator {
+        public CryptographicAttributeObject Current { get; }
+        object System.Collections.IEnumerator.Current { get; }
+        public bool MoveNext();
+        public void Reset();
+    }
+    public class CryptographicException : Exception {
+        public CryptographicException();
+        public CryptographicException(int hr);
+        public CryptographicException(string message);
+        public CryptographicException(string message, Exception inner);
+        public CryptographicException(string format, string insert);
+    }
+    public class CryptoStream : Stream, IDisposable {
+        public CryptoStream(Stream stream, ICryptoTransform transform, CryptoStreamMode mode);
+        public override bool CanRead { get; }
+        public override bool CanSeek { get; }
+        public override bool CanWrite { get; }
+        public bool HasFlushedFinalBlock { get; }
+        public override long Length { get; }
+        public override long Position { get; set; }
+        protected override void Dispose(bool disposing);
+        public override void Flush();
+        public override Task FlushAsync(CancellationToken cancellationToken);
+        public void FlushFinalBlock();
+        public override int Read(byte[] buffer, int offset, int count);
+        public override Task<int> ReadAsync(byte[] buffer, int offset, int count, CancellationToken cancellationToken);
+        public override long Seek(long offset, SeekOrigin origin);
+        public override void SetLength(long value);
+        public override void Write(byte[] buffer, int offset, int count);
+        public override Task WriteAsync(byte[] buffer, int offset, int count, CancellationToken cancellationToken);
+    }
+    public enum CryptoStreamMode {
+        Read = 0,
+        Write = 1,
+    }
+    public sealed class CspKeyContainerInfo {
+        public CspKeyContainerInfo(CspParameters parameters);
+        public bool Accessible { get; }
+        public bool Exportable { get; }
+        public bool HardwareDevice { get; }
+        public string KeyContainerName { get; }
+        public KeyNumber KeyNumber { get; }
+        public bool MachineKeyStore { get; }
+        public bool Protected { get; }
+        public string ProviderName { get; }
+        public int ProviderType { get; }
+        public bool RandomlyGenerated { get; }
+        public bool Removable { get; }
+        public string UniqueKeyContainerName { get; }
+    }
+    public sealed class CspParameters {
+        public int KeyNumber;
+        public int ProviderType;
+        public string KeyContainerName;
+        public string ProviderName;
+        public CspParameters();
+        public CspParameters(int dwTypeIn);
+        public CspParameters(int dwTypeIn, string strProviderNameIn);
+        public CspParameters(int dwTypeIn, string strProviderNameIn, string strContainerNameIn);
+        public CspProviderFlags Flags { get; set; }
+        public IntPtr ParentWindowHandle { get; set; }
+    }
+    public enum CspProviderFlags {
+        CreateEphemeralKey = 128,
+        NoFlags = 0,
+        NoPrompt = 64,
+        UseArchivableKey = 16,
+        UseDefaultKeyContainer = 2,
+        UseExistingKey = 8,
+        UseMachineKeyStore = 1,
+        UseNonExportableKey = 4,
+        UseUserProtectedKey = 32,
+    }
+    public enum DataProtectionScope {
+        CurrentUser = 0,
+        LocalMachine = 1,
+    }
+    public abstract class DeriveBytes : IDisposable {
+        protected DeriveBytes();
+        public void Dispose();
+        protected virtual void Dispose(bool disposing);
+        public abstract byte[] GetBytes(int cb);
+        public abstract void Reset();
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct ECCurve {
+        public ECCurve.ECCurveType CurveType;
+        public byte[] A;
+        public byte[] B;
+        public byte[] Cofactor;
+        public byte[] Order;
+        public byte[] Polynomial;
+        public byte[] Prime;
+        public byte[] Seed;
+        public Nullable<HashAlgorithmName> Hash;
+        public ECPoint G;
+        public bool IsCharacteristic2 { get; }
+        public bool IsExplicit { get; }
+        public bool IsNamed { get; }
+        public bool IsPrime { get; }
+        public Oid Oid { get; }
+        public static ECCurve CreateFromFriendlyName(string oidFriendlyName);
+        public static ECCurve CreateFromOid(Oid curveOid);
+        public static ECCurve CreateFromValue(string oidValue);
+        public void Validate();
+        public enum ECCurveType {
+            Characteristic2 = 4,
+            Implicit = 0,
+            Named = 5,
+            PrimeMontgomery = 3,
+            PrimeShortWeierstrass = 1,
+            PrimeTwistedEdwards = 2,
+        }
+        public static class NamedCurves {
+            public static ECCurve brainpoolP160r1 { get; }
+            public static ECCurve brainpoolP160t1 { get; }
+            public static ECCurve brainpoolP192r1 { get; }
+            public static ECCurve brainpoolP192t1 { get; }
+            public static ECCurve brainpoolP224r1 { get; }
+            public static ECCurve brainpoolP224t1 { get; }
+            public static ECCurve brainpoolP256r1 { get; }
+            public static ECCurve brainpoolP256t1 { get; }
+            public static ECCurve brainpoolP320r1 { get; }
+            public static ECCurve brainpoolP320t1 { get; }
+            public static ECCurve brainpoolP384r1 { get; }
+            public static ECCurve brainpoolP384t1 { get; }
+            public static ECCurve brainpoolP512r1 { get; }
+            public static ECCurve brainpoolP512t1 { get; }
+            public static ECCurve nistP256 { get; }
+            public static ECCurve nistP384 { get; }
+            public static ECCurve nistP521 { get; }
+        }
+    }
+    public abstract class ECDsa : AsymmetricAlgorithm {
+        protected ECDsa();
+        public static ECDsa Create();
+        public static ECDsa Create(ECCurve curve);
+        public static ECDsa Create(ECParameters parameters);
+        public virtual ECParameters ExportExplicitParameters(bool includePrivateParameters);
+        public virtual ECParameters ExportParameters(bool includePrivateParameters);
+        public virtual void GenerateKey(ECCurve curve);
+        protected abstract byte[] HashData(byte[] data, int offset, int count, HashAlgorithmName hashAlgorithm);
+        protected abstract byte[] HashData(Stream data, HashAlgorithmName hashAlgorithm);
+        public virtual void ImportParameters(ECParameters parameters);
+        public virtual byte[] SignData(byte[] data, int offset, int count, HashAlgorithmName hashAlgorithm);
+        public virtual byte[] SignData(byte[] data, HashAlgorithmName hashAlgorithm);
+        public virtual byte[] SignData(Stream data, HashAlgorithmName hashAlgorithm);
+        public abstract byte[] SignHash(byte[] hash);
+        public bool VerifyData(byte[] data, byte[] signature, HashAlgorithmName hashAlgorithm);
+        public virtual bool VerifyData(byte[] data, int offset, int count, byte[] signature, HashAlgorithmName hashAlgorithm);
+        public bool VerifyData(Stream data, byte[] signature, HashAlgorithmName hashAlgorithm);
+        public abstract bool VerifyHash(byte[] hash, byte[] signature);
+    }
+    public sealed class ECDsaCng : ECDsa {
+        public ECDsaCng();
+        public ECDsaCng(int keySize);
+        public ECDsaCng(CngKey key);
+        public ECDsaCng(ECCurve curve);
+        public CngKey Key { get; }
+        public override int KeySize { get; set; }
+        public override KeySizes[] LegalKeySizes { get; }
+        protected override void Dispose(bool disposing);
+        public override ECParameters ExportExplicitParameters(bool includePrivateParameters);
+        public override ECParameters ExportParameters(bool includePrivateParameters);
+        public override void GenerateKey(ECCurve curve);
+        protected override byte[] HashData(byte[] data, int offset, int count, HashAlgorithmName hashAlgorithm);
+        protected override byte[] HashData(Stream data, HashAlgorithmName hashAlgorithm);
+        public override void ImportParameters(ECParameters parameters);
+        public override byte[] SignHash(byte[] hash);
+        public override bool VerifyHash(byte[] hash, byte[] signature);
+    }
+    public sealed class ECDsaOpenSsl : ECDsa {
+        public ECDsaOpenSsl();
+        public ECDsaOpenSsl(int keySize);
+        public ECDsaOpenSsl(IntPtr handle);
+        public ECDsaOpenSsl(ECCurve curve);
+        public ECDsaOpenSsl(SafeEvpPKeyHandle pkeyHandle);
+        public override int KeySize { get; set; }
+        public override KeySizes[] LegalKeySizes { get; }
+        protected override void Dispose(bool disposing);
+        public SafeEvpPKeyHandle DuplicateKeyHandle();
+        public override ECParameters ExportExplicitParameters(bool includePrivateParameters);
+        public override ECParameters ExportParameters(bool includePrivateParameters);
+        public override void GenerateKey(ECCurve curve);
+        protected override byte[] HashData(byte[] data, int offset, int count, HashAlgorithmName hashAlgorithm);
+        protected override byte[] HashData(Stream data, HashAlgorithmName hashAlgorithm);
+        public override void ImportParameters(ECParameters parameters);
+        public override byte[] SignHash(byte[] hash);
+        public override bool VerifyHash(byte[] hash, byte[] signature);
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct ECParameters {
+        public byte[] D;
+        public ECCurve Curve;
+        public ECPoint Q;
+        public void Validate();
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct ECPoint {
+        public byte[] X;
+        public byte[] Y;
+    }
+    public abstract class HashAlgorithm : IDisposable {
+        protected HashAlgorithm();
+        public virtual int HashSize { get; }
+        public byte[] ComputeHash(byte[] buffer);
+        public byte[] ComputeHash(byte[] buffer, int offset, int count);
+        public byte[] ComputeHash(Stream inputStream);
+        public void Dispose();
+        protected virtual void Dispose(bool disposing);
+        protected abstract void HashCore(byte[] array, int ibStart, int cbSize);
+        protected abstract byte[] HashFinal();
+        public abstract void Initialize();
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct HashAlgorithmName : IEquatable<HashAlgorithmName> {
+        public HashAlgorithmName(string name);
+        public static HashAlgorithmName MD5 { get; }
+        public string Name { get; }
+        public static HashAlgorithmName SHA1 { get; }
+        public static HashAlgorithmName SHA256 { get; }
+        public static HashAlgorithmName SHA384 { get; }
+        public static HashAlgorithmName SHA512 { get; }
+        public override bool Equals(object obj);
+        public bool Equals(HashAlgorithmName other);
+        public override int GetHashCode();
+        public static bool operator ==(HashAlgorithmName left, HashAlgorithmName right);
+        public static bool operator !=(HashAlgorithmName left, HashAlgorithmName right);
+        public override string ToString();
+    }
+    public abstract class HMAC : KeyedHashAlgorithm {
+        protected HMAC();
+        public string HashName { get; set; }
+        public override byte[] Key { get; set; }
+        protected override void Dispose(bool disposing);
+        protected override void HashCore(byte[] rgb, int ib, int cb);
+        protected override byte[] HashFinal();
+        public override void Initialize();
+    }
+    public class HMACMD5 : HMAC {
+        public HMACMD5();
+        public HMACMD5(byte[] key);
+        public override int HashSize { get; }
+        public override byte[] Key { get; set; }
+        protected override void Dispose(bool disposing);
+        protected override void HashCore(byte[] rgb, int ib, int cb);
+        protected override byte[] HashFinal();
+        public override void Initialize();
+    }
+    public class HMACSHA1 : HMAC {
+        public HMACSHA1();
+        public HMACSHA1(byte[] key);
+        public override int HashSize { get; }
+        public override byte[] Key { get; set; }
+        protected override void Dispose(bool disposing);
+        protected override void HashCore(byte[] rgb, int ib, int cb);
+        protected override byte[] HashFinal();
+        public override void Initialize();
+    }
+    public class HMACSHA256 : HMAC {
+        public HMACSHA256();
+        public HMACSHA256(byte[] key);
+        public override int HashSize { get; }
+        public override byte[] Key { get; set; }
+        protected override void Dispose(bool disposing);
+        protected override void HashCore(byte[] rgb, int ib, int cb);
+        protected override byte[] HashFinal();
+        public override void Initialize();
+    }
+    public class HMACSHA384 : HMAC {
+        public HMACSHA384();
+        public HMACSHA384(byte[] key);
+        public override int HashSize { get; }
+        public override byte[] Key { get; set; }
+        protected override void Dispose(bool disposing);
+        protected override void HashCore(byte[] rgb, int ib, int cb);
+        protected override byte[] HashFinal();
+        public override void Initialize();
+    }
+    public class HMACSHA512 : HMAC {
+        public HMACSHA512();
+        public HMACSHA512(byte[] key);
+        public override int HashSize { get; }
+        public override byte[] Key { get; set; }
+        protected override void Dispose(bool disposing);
+        protected override void HashCore(byte[] rgb, int ib, int cb);
+        protected override byte[] HashFinal();
+        public override void Initialize();
+    }
+    public interface ICryptoTransform : IDisposable {
+        bool CanReuseTransform { get; }
+        bool CanTransformMultipleBlocks { get; }
+        int InputBlockSize { get; }
+        int OutputBlockSize { get; }
+        int TransformBlock(byte[] inputBuffer, int inputOffset, int inputCount, byte[] outputBuffer, int outputOffset);
+        byte[] TransformFinalBlock(byte[] inputBuffer, int inputOffset, int inputCount);
+    }
+    public interface ICspAsymmetricAlgorithm {
+        CspKeyContainerInfo CspKeyContainerInfo { get; }
+        byte[] ExportCspBlob(bool includePrivateParameters);
+        void ImportCspBlob(byte[] rawData);
+    }
+    public sealed class IncrementalHash : IDisposable {
+        public HashAlgorithmName AlgorithmName { get; }
+        public void AppendData(byte[] data);
+        public void AppendData(byte[] data, int offset, int count);
+        public static IncrementalHash CreateHash(HashAlgorithmName hashAlgorithm);
+        public static IncrementalHash CreateHMAC(HashAlgorithmName hashAlgorithm, byte[] key);
+        public void Dispose();
+        public byte[] GetHashAndReset();
+    }
+    public abstract class KeyedHashAlgorithm : HashAlgorithm {
+        protected KeyedHashAlgorithm();
+        public virtual byte[] Key { get; set; }
+        protected override void Dispose(bool disposing);
+    }
+    public enum KeyNumber {
+        Exchange = 1,
+        Signature = 2,
+    }
+    public sealed class KeySizes {
+        public KeySizes(int minSize, int maxSize, int skipSize);
+        public int MaxSize { get; }
+        public int MinSize { get; }
+        public int SkipSize { get; }
+    }
+    public abstract class MD5 : HashAlgorithm {
+        protected MD5();
+        public static MD5 Create();
+    }
+    public sealed class Oid {
+        public Oid(Oid oid);
+        public Oid(string oid);
+        public Oid(string value, string friendlyName);
+        public string FriendlyName { get; set; }
+        public string Value { get; set; }
+        public static Oid FromFriendlyName(string friendlyName, OidGroup group);
+        public static Oid FromOidValue(string oidValue, OidGroup group);
+    }
+    public sealed class OidCollection : ICollection, IEnumerable {
+        public OidCollection();
+        public int Count { get; }
+        bool System.Collections.ICollection.IsSynchronized { get; }
+        object System.Collections.ICollection.SyncRoot { get; }
+        public Oid this[int index] { get; }
+        public Oid this[string oid] { get; }
+        public int Add(Oid oid);
+        public void CopyTo(Oid[] array, int index);
+        public OidEnumerator GetEnumerator();
+        void System.Collections.ICollection.CopyTo(Array array, int index);
+        IEnumerator System.Collections.IEnumerable.GetEnumerator();
+    }
+    public sealed class OidEnumerator : IEnumerator {
+        public Oid Current { get; }
+        object System.Collections.IEnumerator.Current { get; }
+        public bool MoveNext();
+        public void Reset();
+    }
+    public enum OidGroup {
+        All = 0,
+        Attribute = 5,
+        EncryptionAlgorithm = 2,
+        EnhancedKeyUsage = 7,
+        ExtensionOrAttribute = 6,
+        HashAlgorithm = 1,
+        KeyDerivationFunction = 10,
+        Policy = 8,
+        PublicKeyAlgorithm = 3,
+        SignatureAlgorithm = 4,
+        Template = 9,
+    }
+    public enum PaddingMode {
+        None = 1,
+        PKCS7 = 2,
+        Zeros = 3,
+    }
+    public static class ProtectedData {
+        public static byte[] Protect(byte[] userData, byte[] optionalEntropy, DataProtectionScope scope);
+        public static byte[] Unprotect(byte[] encryptedData, byte[] optionalEntropy, DataProtectionScope scope);
+    }
+    public abstract class RandomNumberGenerator : IDisposable {
+        protected RandomNumberGenerator();
+        public static RandomNumberGenerator Create();
+        public void Dispose();
+        protected virtual void Dispose(bool disposing);
+        public abstract void GetBytes(byte[] data);
+    }
+    public class Rfc2898DeriveBytes : DeriveBytes {
+        public Rfc2898DeriveBytes(byte[] password, byte[] salt, int iterations);
+        public Rfc2898DeriveBytes(string password, byte[] salt);
+        public Rfc2898DeriveBytes(string password, byte[] salt, int iterations);
+        public Rfc2898DeriveBytes(string password, int saltSize);
+        public Rfc2898DeriveBytes(string password, int saltSize, int iterations);
+        public int IterationCount { get; set; }
+        public byte[] Salt { get; set; }
+        protected override void Dispose(bool disposing);
+        public override byte[] GetBytes(int cb);
+        public override void Reset();
+    }
+    public abstract class RSA : AsymmetricAlgorithm {
+        protected RSA();
+        public static RSA Create();
+        public abstract byte[] Decrypt(byte[] data, RSAEncryptionPadding padding);
+        public abstract byte[] Encrypt(byte[] data, RSAEncryptionPadding padding);
+        public abstract RSAParameters ExportParameters(bool includePrivateParameters);
+        protected abstract byte[] HashData(byte[] data, int offset, int count, HashAlgorithmName hashAlgorithm);
+        protected abstract byte[] HashData(Stream data, HashAlgorithmName hashAlgorithm);
+        public abstract void ImportParameters(RSAParameters parameters);
+        public virtual byte[] SignData(byte[] data, int offset, int count, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding);
+        public byte[] SignData(byte[] data, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding);
+        public virtual byte[] SignData(Stream data, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding);
+        public abstract byte[] SignHash(byte[] hash, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding);
+        public bool VerifyData(byte[] data, byte[] signature, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding);
+        public virtual bool VerifyData(byte[] data, int offset, int count, byte[] signature, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding);
+        public bool VerifyData(Stream data, byte[] signature, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding);
+        public abstract bool VerifyHash(byte[] hash, byte[] signature, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding);
+    }
+    public sealed class RSACng : RSA {
+        public RSACng();
+        public RSACng(int keySize);
+        public RSACng(CngKey key);
+        public CngKey Key { get; }
+        public override KeySizes[] LegalKeySizes { get; }
+        public override byte[] Decrypt(byte[] data, RSAEncryptionPadding padding);
+        protected override void Dispose(bool disposing);
+        public override byte[] Encrypt(byte[] data, RSAEncryptionPadding padding);
+        public override RSAParameters ExportParameters(bool includePrivateParameters);
+        protected override byte[] HashData(byte[] data, int offset, int count, HashAlgorithmName hashAlgorithm);
+        protected override byte[] HashData(Stream data, HashAlgorithmName hashAlgorithm);
+        public override void ImportParameters(RSAParameters parameters);
+        public override byte[] SignHash(byte[] hash, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding);
+        public override bool VerifyHash(byte[] hash, byte[] signature, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding);
+    }
+    public sealed class RSACryptoServiceProvider : RSA, ICspAsymmetricAlgorithm {
+        public RSACryptoServiceProvider();
+        public RSACryptoServiceProvider(int dwKeySize);
+        public RSACryptoServiceProvider(int dwKeySize, CspParameters parameters);
+        public RSACryptoServiceProvider(CspParameters parameters);
+        public CspKeyContainerInfo CspKeyContainerInfo { get; }
+        public override int KeySize { get; }
+        public override KeySizes[] LegalKeySizes { get; }
+        public bool PersistKeyInCsp { get; set; }
+        public bool PublicOnly { get; }
+        public static bool UseMachineKeyStore { get; set; }
+        public byte[] Decrypt(byte[] rgb, bool fOAEP);
+        public override byte[] Decrypt(byte[] data, RSAEncryptionPadding padding);
+        protected override void Dispose(bool disposing);
+        public byte[] Encrypt(byte[] rgb, bool fOAEP);
+        public override byte[] Encrypt(byte[] data, RSAEncryptionPadding padding);
+        public byte[] ExportCspBlob(bool includePrivateParameters);
+        public override RSAParameters ExportParameters(bool includePrivateParameters);
+        protected override byte[] HashData(byte[] data, int offset, int count, HashAlgorithmName hashAlgorithm);
+        protected override byte[] HashData(Stream data, HashAlgorithmName hashAlgorithm);
+        public void ImportCspBlob(byte[] keyBlob);
+        public override void ImportParameters(RSAParameters parameters);
+        public byte[] SignData(byte[] buffer, int offset, int count, object halg);
+        public byte[] SignData(byte[] buffer, object halg);
+        public byte[] SignData(Stream inputStream, object halg);
+        public override byte[] SignHash(byte[] hash, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding);
+        public byte[] SignHash(byte[] rgbHash, string str);
+        public bool VerifyData(byte[] buffer, object halg, byte[] signature);
+        public override bool VerifyHash(byte[] hash, byte[] signature, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding);
+        public bool VerifyHash(byte[] rgbHash, string str, byte[] rgbSignature);
+    }
+    public sealed class RSAEncryptionPadding : IEquatable<RSAEncryptionPadding> {
+        public RSAEncryptionPaddingMode Mode { get; }
+        public HashAlgorithmName OaepHashAlgorithm { get; }
+        public static RSAEncryptionPadding OaepSHA1 { get; }
+        public static RSAEncryptionPadding OaepSHA256 { get; }
+        public static RSAEncryptionPadding OaepSHA384 { get; }
+        public static RSAEncryptionPadding OaepSHA512 { get; }
+        public static RSAEncryptionPadding Pkcs1 { get; }
+        public static RSAEncryptionPadding CreateOaep(HashAlgorithmName hashAlgorithm);
+        public override bool Equals(object obj);
+        public bool Equals(RSAEncryptionPadding other);
+        public override int GetHashCode();
+        public static bool operator ==(RSAEncryptionPadding left, RSAEncryptionPadding right);
+        public static bool operator !=(RSAEncryptionPadding left, RSAEncryptionPadding right);
+        public override string ToString();
+    }
+    public enum RSAEncryptionPaddingMode {
+        Oaep = 1,
+        Pkcs1 = 0,
+    }
+    public sealed class RSAOpenSsl : RSA {
+        public RSAOpenSsl();
+        public RSAOpenSsl(int keySize);
+        public RSAOpenSsl(IntPtr handle);
+        public RSAOpenSsl(RSAParameters parameters);
+        public RSAOpenSsl(SafeEvpPKeyHandle pkeyHandle);
+        public override int KeySize { set; }
+        public override KeySizes[] LegalKeySizes { get; }
+        public override byte[] Decrypt(byte[] data, RSAEncryptionPadding padding);
+        protected override void Dispose(bool disposing);
+        public SafeEvpPKeyHandle DuplicateKeyHandle();
+        public override byte[] Encrypt(byte[] data, RSAEncryptionPadding padding);
+        public override RSAParameters ExportParameters(bool includePrivateParameters);
+        protected override byte[] HashData(byte[] data, int offset, int count, HashAlgorithmName hashAlgorithm);
+        protected override byte[] HashData(Stream data, HashAlgorithmName hashAlgorithm);
+        public override void ImportParameters(RSAParameters parameters);
+        public override byte[] SignHash(byte[] hash, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding);
+        public override bool VerifyHash(byte[] hash, byte[] signature, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding);
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct RSAParameters {
+        public byte[] D;
+        public byte[] DP;
+        public byte[] DQ;
+        public byte[] Exponent;
+        public byte[] InverseQ;
+        public byte[] Modulus;
+        public byte[] P;
+        public byte[] Q;
+    }
+    public sealed class RSASignaturePadding : IEquatable<RSASignaturePadding> {
+        public RSASignaturePaddingMode Mode { get; }
+        public static RSASignaturePadding Pkcs1 { get; }
+        public static RSASignaturePadding Pss { get; }
+        public override bool Equals(object obj);
+        public bool Equals(RSASignaturePadding other);
+        public override int GetHashCode();
+        public static bool operator ==(RSASignaturePadding left, RSASignaturePadding right);
+        public static bool operator !=(RSASignaturePadding left, RSASignaturePadding right);
+        public override string ToString();
+    }
+    public enum RSASignaturePaddingMode {
+        Pkcs1 = 0,
+        Pss = 1,
+    }
+    public sealed class SafeEvpPKeyHandle : SafeHandle {
+        public SafeEvpPKeyHandle(IntPtr handle, bool ownsHandle);
+        public override bool IsInvalid { get; }
+        public SafeEvpPKeyHandle DuplicateHandle();
+        protected override bool ReleaseHandle();
+    }
+    public abstract class SHA1 : HashAlgorithm {
+        protected SHA1();
+        public static SHA1 Create();
+    }
+    public abstract class SHA256 : HashAlgorithm {
+        protected SHA256();
+        public static SHA256 Create();
+    }
+    public abstract class SHA384 : HashAlgorithm {
+        protected SHA384();
+        public static SHA384 Create();
+    }
+    public abstract class SHA512 : HashAlgorithm {
+        protected SHA512();
+        public static SHA512 Create();
+    }
+    public abstract class SymmetricAlgorithm : IDisposable {
+        protected byte[] IVValue;
+        protected byte[] KeyValue;
+        protected int BlockSizeValue;
+        protected int KeySizeValue;
+        protected CipherMode ModeValue;
+        protected KeySizes[] LegalBlockSizesValue;
+        protected KeySizes[] LegalKeySizesValue;
+        protected PaddingMode PaddingValue;
+        protected SymmetricAlgorithm();
+        public virtual int BlockSize { get; set; }
+        public virtual byte[] IV { get; set; }
+        public virtual byte[] Key { get; set; }
+        public virtual int KeySize { get; set; }
+        public virtual KeySizes[] LegalBlockSizes { get; }
+        public virtual KeySizes[] LegalKeySizes { get; }
+        public virtual CipherMode Mode { get; set; }
+        public virtual PaddingMode Padding { get; set; }
+        public virtual ICryptoTransform CreateDecryptor();
+        public abstract ICryptoTransform CreateDecryptor(byte[] rgbKey, byte[] rgbIV);
+        public virtual ICryptoTransform CreateEncryptor();
+        public abstract ICryptoTransform CreateEncryptor(byte[] rgbKey, byte[] rgbIV);
+        public void Dispose();
+        protected virtual void Dispose(bool disposing);
+        public abstract void GenerateIV();
+        public abstract void GenerateKey();
+    }
+    public abstract class TripleDES : SymmetricAlgorithm {
+        protected TripleDES();
+        public override byte[] Key { get; set; }
+        public override KeySizes[] LegalBlockSizes { get; }
+        public override KeySizes[] LegalKeySizes { get; }
+        public static TripleDES Create();
+        public static bool IsWeakKey(byte[] rgbKey);
+    }
+    public sealed class TripleDESCng : TripleDES {
+        public TripleDESCng();
+        public TripleDESCng(string keyName);
+        public TripleDESCng(string keyName, CngProvider provider);
+        public TripleDESCng(string keyName, CngProvider provider, CngKeyOpenOptions openOptions);
+        public override byte[] Key { get; set; }
+        public override int KeySize { get; set; }
+        public override KeySizes[] LegalKeySizes { get; }
+        public override ICryptoTransform CreateDecryptor();
+        public override ICryptoTransform CreateDecryptor(byte[] rgbKey, byte[] rgbIV);
+        public override ICryptoTransform CreateEncryptor();
+        public override ICryptoTransform CreateEncryptor(byte[] rgbKey, byte[] rgbIV);
+        protected override void Dispose(bool disposing);
+        public override void GenerateIV();
+        public override void GenerateKey();
+    }
+}
```

## System.Security.Cryptography.Pkcs

```c#
+namespace System.Security.Cryptography.Pkcs {
+    public sealed class AlgorithmIdentifier {
+        public AlgorithmIdentifier();
+        public AlgorithmIdentifier(Oid oid);
+        public AlgorithmIdentifier(Oid oid, int keyLength);
+        public int KeyLength { get; set; }
+        public Oid Oid { get; set; }
+    }
+    public sealed class CmsRecipient {
+        public CmsRecipient(SubjectIdentifierType recipientIdentifierType, X509Certificate2 certificate);
+        public CmsRecipient(X509Certificate2 certificate);
+        public X509Certificate2 Certificate { get; }
+        public SubjectIdentifierType RecipientIdentifierType { get; }
+    }
+    public sealed class CmsRecipientCollection : ICollection, IEnumerable {
+        public CmsRecipientCollection();
+        public CmsRecipientCollection(CmsRecipient recipient);
+        public CmsRecipientCollection(SubjectIdentifierType recipientIdentifierType, X509Certificate2Collection certificates);
+        public int Count { get; }
+        bool System.Collections.ICollection.IsSynchronized { get; }
+        object System.Collections.ICollection.SyncRoot { get; }
+        public CmsRecipient this[int index] { get; }
+        public int Add(CmsRecipient recipient);
+        public void CopyTo(Array array, int index);
+        public void CopyTo(CmsRecipient[] array, int index);
+        public CmsRecipientEnumerator GetEnumerator();
+        public void Remove(CmsRecipient recipient);
+        IEnumerator System.Collections.IEnumerable.GetEnumerator();
+    }
+    public sealed class CmsRecipientEnumerator : IEnumerator {
+        public CmsRecipient Current { get; }
+        object System.Collections.IEnumerator.Current { get; }
+        public bool MoveNext();
+        public void Reset();
+    }
+    public sealed class ContentInfo {
+        public ContentInfo(byte[] content);
+        public ContentInfo(Oid contentType, byte[] content);
+        public byte[] Content { get; }
+        public Oid ContentType { get; }
+        public static Oid GetContentType(byte[] encodedMessage);
+    }
+    public sealed class EnvelopedCms {
+        public EnvelopedCms();
+        public EnvelopedCms(ContentInfo contentInfo);
+        public EnvelopedCms(ContentInfo contentInfo, AlgorithmIdentifier encryptionAlgorithm);
+        public X509Certificate2Collection Certificates { get; }
+        public AlgorithmIdentifier ContentEncryptionAlgorithm { get; }
+        public ContentInfo ContentInfo { get; }
+        public RecipientInfoCollection RecipientInfos { get; }
+        public CryptographicAttributeObjectCollection UnprotectedAttributes { get; }
+        public int Version { get; }
+        public void Decode(byte[] encodedMessage);
+        public void Decrypt();
+        public void Decrypt(RecipientInfo recipientInfo);
+        public void Decrypt(RecipientInfo recipientInfo, X509Certificate2Collection extraStore);
+        public void Decrypt(X509Certificate2Collection extraStore);
+        public byte[] Encode();
+        public void Encrypt(CmsRecipient recipient);
+        public void Encrypt(CmsRecipientCollection recipients);
+    }
+    public sealed class KeyAgreeRecipientInfo : RecipientInfo {
+        public DateTime Date { get; }
+        public override byte[] EncryptedKey { get; }
+        public override AlgorithmIdentifier KeyEncryptionAlgorithm { get; }
+        public SubjectIdentifierOrKey OriginatorIdentifierOrKey { get; }
+        public CryptographicAttributeObject OtherKeyAttribute { get; }
+        public override SubjectIdentifier RecipientIdentifier { get; }
+        public override int Version { get; }
+    }
+    public sealed class KeyTransRecipientInfo : RecipientInfo {
+        public override byte[] EncryptedKey { get; }
+        public override AlgorithmIdentifier KeyEncryptionAlgorithm { get; }
+        public override SubjectIdentifier RecipientIdentifier { get; }
+        public override int Version { get; }
+    }
+    public class Pkcs9AttributeObject : AsnEncodedData {
+        public Pkcs9AttributeObject();
+        public Pkcs9AttributeObject(AsnEncodedData asnEncodedData);
+        public Pkcs9AttributeObject(Oid oid, byte[] encodedData);
+        public Pkcs9AttributeObject(string oid, byte[] encodedData);
+        public new Oid Oid { get; }
+        public override void CopyFrom(AsnEncodedData asnEncodedData);
+    }
+    public sealed class Pkcs9ContentType : Pkcs9AttributeObject {
+        public Pkcs9ContentType();
+        public Oid ContentType { get; }
+        public override void CopyFrom(AsnEncodedData asnEncodedData);
+    }
+    public sealed class Pkcs9DocumentDescription : Pkcs9AttributeObject {
+        public Pkcs9DocumentDescription();
+        public Pkcs9DocumentDescription(byte[] encodedDocumentDescription);
+        public Pkcs9DocumentDescription(string documentDescription);
+        public string DocumentDescription { get; }
+        public override void CopyFrom(AsnEncodedData asnEncodedData);
+    }
+    public sealed class Pkcs9DocumentName : Pkcs9AttributeObject {
+        public Pkcs9DocumentName();
+        public Pkcs9DocumentName(byte[] encodedDocumentName);
+        public Pkcs9DocumentName(string documentName);
+        public string DocumentName { get; }
+        public override void CopyFrom(AsnEncodedData asnEncodedData);
+    }
+    public sealed class Pkcs9MessageDigest : Pkcs9AttributeObject {
+        public Pkcs9MessageDigest();
+        public byte[] MessageDigest { get; }
+        public override void CopyFrom(AsnEncodedData asnEncodedData);
+    }
+    public sealed class Pkcs9SigningTime : Pkcs9AttributeObject {
+        public Pkcs9SigningTime();
+        public Pkcs9SigningTime(byte[] encodedSigningTime);
+        public Pkcs9SigningTime(DateTime signingTime);
+        public DateTime SigningTime { get; }
+        public override void CopyFrom(AsnEncodedData asnEncodedData);
+    }
+    public sealed class PublicKeyInfo {
+        public AlgorithmIdentifier Algorithm { get; }
+        public byte[] KeyValue { get; }
+    }
+    public abstract class RecipientInfo {
+        public abstract byte[] EncryptedKey { get; }
+        public abstract AlgorithmIdentifier KeyEncryptionAlgorithm { get; }
+        public abstract SubjectIdentifier RecipientIdentifier { get; }
+        public RecipientInfoType Type { get; }
+        public abstract int Version { get; }
+    }
+    public sealed class RecipientInfoCollection : ICollection, IEnumerable {
+        public int Count { get; }
+        bool System.Collections.ICollection.IsSynchronized { get; }
+        object System.Collections.ICollection.SyncRoot { get; }
+        public RecipientInfo this[int index] { get; }
+        public void CopyTo(Array array, int index);
+        public void CopyTo(RecipientInfo[] array, int index);
+        public RecipientInfoEnumerator GetEnumerator();
+        IEnumerator System.Collections.IEnumerable.GetEnumerator();
+    }
+    public sealed class RecipientInfoEnumerator : IEnumerator {
+        public RecipientInfo Current { get; }
+        object System.Collections.IEnumerator.Current { get; }
+        public bool MoveNext();
+        public void Reset();
+    }
+    public enum RecipientInfoType {
+        KeyAgreement = 2,
+        KeyTransport = 1,
+        Unknown = 0,
+    }
+    public sealed class SubjectIdentifier {
+        public SubjectIdentifierType Type { get; }
+        public object Value { get; }
+    }
+    public sealed class SubjectIdentifierOrKey {
+        public SubjectIdentifierOrKeyType Type { get; }
+        public object Value { get; }
+    }
+    public enum SubjectIdentifierOrKeyType {
+        IssuerAndSerialNumber = 1,
+        PublicKeyInfo = 3,
+        SubjectKeyIdentifier = 2,
+        Unknown = 0,
+    }
+    public enum SubjectIdentifierType {
+        IssuerAndSerialNumber = 1,
+        NoSignature = 3,
+        SubjectKeyIdentifier = 2,
+        Unknown = 0,
+    }
+}
```

## System.Security.Cryptography.X509Certificates

```c#
+namespace System.Security.Cryptography.X509Certificates {
+    public static class ECDsaCertificateExtensions {
+        public static ECDsa GetECDsaPrivateKey(this X509Certificate2 certificate);
+        public static ECDsa GetECDsaPublicKey(this X509Certificate2 certificate);
+    }
+    public enum OpenFlags {
+        IncludeArchived = 8,
+        MaxAllowed = 2,
+        OpenExistingOnly = 4,
+        ReadOnly = 0,
+        ReadWrite = 1,
+    }
+    public sealed class PublicKey {
+        public PublicKey(Oid oid, AsnEncodedData parameters, AsnEncodedData keyValue);
+        public AsnEncodedData EncodedKeyValue { get; }
+        public AsnEncodedData EncodedParameters { get; }
+        public Oid Oid { get; }
+    }
+    public static class RSACertificateExtensions {
+        public static RSA GetRSAPrivateKey(this X509Certificate2 certificate);
+        public static RSA GetRSAPublicKey(this X509Certificate2 certificate);
+    }
+    public enum StoreLocation {
+        CurrentUser = 1,
+        LocalMachine = 2,
+    }
+    public enum StoreName {
+        AddressBook = 1,
+        AuthRoot = 2,
+        CertificateAuthority = 3,
+        Disallowed = 4,
+        My = 5,
+        Root = 6,
+        TrustedPeople = 7,
+        TrustedPublisher = 8,
+    }
+    public sealed class X500DistinguishedName : AsnEncodedData {
+        public X500DistinguishedName(byte[] encodedDistinguishedName);
+        public X500DistinguishedName(AsnEncodedData encodedDistinguishedName);
+        public X500DistinguishedName(X500DistinguishedName distinguishedName);
+        public X500DistinguishedName(string distinguishedName);
+        public X500DistinguishedName(string distinguishedName, X500DistinguishedNameFlags flag);
+        public string Name { get; }
+        public string Decode(X500DistinguishedNameFlags flag);
+        public override string Format(bool multiLine);
+    }
+    public enum X500DistinguishedNameFlags {
+        DoNotUsePlusSign = 32,
+        DoNotUseQuotes = 64,
+        ForceUTF8Encoding = 16384,
+        None = 0,
+        Reversed = 1,
+        UseCommas = 128,
+        UseNewLines = 256,
+        UseSemicolons = 16,
+        UseT61Encoding = 8192,
+        UseUTF8Encoding = 4096,
+    }
+    public sealed class X509BasicConstraintsExtension : X509Extension {
+        public X509BasicConstraintsExtension();
+        public X509BasicConstraintsExtension(bool certificateAuthority, bool hasPathLengthConstraint, int pathLengthConstraint, bool critical);
+        public X509BasicConstraintsExtension(AsnEncodedData encodedBasicConstraints, bool critical);
+        public bool CertificateAuthority { get; }
+        public bool HasPathLengthConstraint { get; }
+        public int PathLengthConstraint { get; }
+        public override void CopyFrom(AsnEncodedData asnEncodedData);
+    }
+    public class X509Certificate : IDisposable {
+        public X509Certificate();
+        public X509Certificate(byte[] data);
+        public X509Certificate(byte[] rawData, string password);
+        public X509Certificate(byte[] rawData, string password, X509KeyStorageFlags keyStorageFlags);
+        public X509Certificate(IntPtr handle);
+        public X509Certificate(string fileName);
+        public X509Certificate(string fileName, string password);
+        public X509Certificate(string fileName, string password, X509KeyStorageFlags keyStorageFlags);
+        public IntPtr Handle { get; }
+        public string Issuer { get; }
+        public string Subject { get; }
+        public void Dispose();
+        protected virtual void Dispose(bool disposing);
+        public override bool Equals(object obj);
+        public virtual bool Equals(X509Certificate other);
+        public virtual byte[] Export(X509ContentType contentType);
+        public virtual byte[] Export(X509ContentType contentType, string password);
+        public virtual byte[] GetCertHash();
+        public virtual string GetFormat();
+        public override int GetHashCode();
+        public virtual string GetKeyAlgorithm();
+        public virtual byte[] GetKeyAlgorithmParameters();
+        public virtual string GetKeyAlgorithmParametersString();
+        public virtual byte[] GetPublicKey();
+        public virtual byte[] GetSerialNumber();
+        public override string ToString();
+        public virtual string ToString(bool fVerbose);
+    }
+    public class X509Certificate2 : X509Certificate {
+        public X509Certificate2();
+        public X509Certificate2(byte[] rawData);
+        public X509Certificate2(byte[] rawData, string password);
+        public X509Certificate2(byte[] rawData, string password, X509KeyStorageFlags keyStorageFlags);
+        public X509Certificate2(IntPtr handle);
+        public X509Certificate2(string fileName);
+        public X509Certificate2(string fileName, string password);
+        public X509Certificate2(string fileName, string password, X509KeyStorageFlags keyStorageFlags);
+        public bool Archived { get; set; }
+        public X509ExtensionCollection Extensions { get; }
+        public string FriendlyName { get; set; }
+        public bool HasPrivateKey { get; }
+        public X500DistinguishedName IssuerName { get; }
+        public DateTime NotAfter { get; }
+        public DateTime NotBefore { get; }
+        public PublicKey PublicKey { get; }
+        public byte[] RawData { get; }
+        public string SerialNumber { get; }
+        public Oid SignatureAlgorithm { get; }
+        public X500DistinguishedName SubjectName { get; }
+        public string Thumbprint { get; }
+        public int Version { get; }
+        public static X509ContentType GetCertContentType(byte[] rawData);
+        public static X509ContentType GetCertContentType(string fileName);
+        public string GetNameInfo(X509NameType nameType, bool forIssuer);
+        public override string ToString();
+        public override string ToString(bool verbose);
+    }
+    public class X509Certificate2Collection : X509CertificateCollection {
+        public X509Certificate2Collection();
+        public X509Certificate2Collection(X509Certificate2 certificate);
+        public X509Certificate2Collection(X509Certificate2[] certificates);
+        public X509Certificate2Collection(X509Certificate2Collection certificates);
+        public new X509Certificate2 this[int index] { get; set; }
+        public int Add(X509Certificate2 certificate);
+        public void AddRange(X509Certificate2[] certificates);
+        public void AddRange(X509Certificate2Collection certificates);
+        public bool Contains(X509Certificate2 certificate);
+        public byte[] Export(X509ContentType contentType);
+        public byte[] Export(X509ContentType contentType, string password);
+        public X509Certificate2Collection Find(X509FindType findType, object findValue, bool validOnly);
+        public new X509Certificate2Enumerator GetEnumerator();
+        public void Import(byte[] rawData);
+        public void Import(byte[] rawData, string password, X509KeyStorageFlags keyStorageFlags);
+        public void Import(string fileName);
+        public void Import(string fileName, string password, X509KeyStorageFlags keyStorageFlags);
+        public void Insert(int index, X509Certificate2 certificate);
+        public void Remove(X509Certificate2 certificate);
+        public void RemoveRange(X509Certificate2[] certificates);
+        public void RemoveRange(X509Certificate2Collection certificates);
+    }
+    public sealed class X509Certificate2Enumerator : IEnumerator {
+        public X509Certificate2 Current { get; }
+        object System.Collections.IEnumerator.Current { get; }
+        public bool MoveNext();
+        public void Reset();
+        bool System.Collections.IEnumerator.MoveNext();
+        void System.Collections.IEnumerator.Reset();
+    }
+    public class X509CertificateCollection : ICollection, IEnumerable, IList {
+        public X509CertificateCollection();
+        public X509CertificateCollection(X509Certificate[] value);
+        public X509CertificateCollection(X509CertificateCollection value);
+        public int Count { get; }
+        bool System.Collections.ICollection.IsSynchronized { get; }
+        object System.Collections.ICollection.SyncRoot { get; }
+        bool System.Collections.IList.IsFixedSize { get; }
+        bool System.Collections.IList.IsReadOnly { get; }
+        object System.Collections.IList.this[int index] { get; set; }
+        public X509Certificate this[int index] { get; set; }
+        public int Add(X509Certificate value);
+        public void AddRange(X509Certificate[] value);
+        public void AddRange(X509CertificateCollection value);
+        public void Clear();
+        public bool Contains(X509Certificate value);
+        public void CopyTo(X509Certificate[] array, int index);
+        public X509CertificateCollection.X509CertificateEnumerator GetEnumerator();
+        public override int GetHashCode();
+        public int IndexOf(X509Certificate value);
+        public void Insert(int index, X509Certificate value);
+        public void Remove(X509Certificate value);
+        public void RemoveAt(int index);
+        void System.Collections.ICollection.CopyTo(Array array, int index);
+        IEnumerator System.Collections.IEnumerable.GetEnumerator();
+        int System.Collections.IList.Add(object value);
+        bool System.Collections.IList.Contains(object value);
+        int System.Collections.IList.IndexOf(object value);
+        void System.Collections.IList.Insert(int index, object value);
+        void System.Collections.IList.Remove(object value);
+        public class X509CertificateEnumerator : IEnumerator {
+            public X509CertificateEnumerator(X509CertificateCollection mappings);
+            public X509Certificate Current { get; }
+            object System.Collections.IEnumerator.Current { get; }
+            public bool MoveNext();
+            public void Reset();
+            bool System.Collections.IEnumerator.MoveNext();
+            void System.Collections.IEnumerator.Reset();
+        }
+    }
+    public class X509Chain : IDisposable {
+        public X509Chain();
+        public X509ChainElementCollection ChainElements { get; }
+        public X509ChainPolicy ChainPolicy { get; set; }
+        public X509ChainStatus[] ChainStatus { get; }
+        public SafeX509ChainHandle SafeHandle { get; }
+        public bool Build(X509Certificate2 certificate);
+        public void Dispose();
+        protected virtual void Dispose(bool disposing);
+    }
+    public class X509ChainElement {
+        public X509Certificate2 Certificate { get; }
+        public X509ChainStatus[] ChainElementStatus { get; }
+        public string Information { get; }
+    }
+    public sealed class X509ChainElementCollection : ICollection, IEnumerable {
+        public int Count { get; }
+        bool System.Collections.ICollection.IsSynchronized { get; }
+        object System.Collections.ICollection.SyncRoot { get; }
+        public X509ChainElement this[int index] { get; }
+        public void CopyTo(X509ChainElement[] array, int index);
+        public X509ChainElementEnumerator GetEnumerator();
+        void System.Collections.ICollection.CopyTo(Array array, int index);
+        IEnumerator System.Collections.IEnumerable.GetEnumerator();
+    }
+    public sealed class X509ChainElementEnumerator : IEnumerator {
+        public X509ChainElement Current { get; }
+        object System.Collections.IEnumerator.Current { get; }
+        public bool MoveNext();
+        public void Reset();
+    }
+    public sealed class X509ChainPolicy {
+        public X509ChainPolicy();
+        public OidCollection ApplicationPolicy { get; }
+        public OidCollection CertificatePolicy { get; }
+        public X509Certificate2Collection ExtraStore { get; }
+        public X509RevocationFlag RevocationFlag { get; set; }
+        public X509RevocationMode RevocationMode { get; set; }
+        public TimeSpan UrlRetrievalTimeout { get; set; }
+        public X509VerificationFlags VerificationFlags { get; set; }
+        public DateTime VerificationTime { get; set; }
+        public void Reset();
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct X509ChainStatus {
+        public X509ChainStatusFlags Status { get; set; }
+        public string StatusInformation { get; set; }
+    }
+    public enum X509ChainStatusFlags {
+        CtlNotSignatureValid = 262144,
+        CtlNotTimeValid = 131072,
+        CtlNotValidForUsage = 524288,
+        Cyclic = 128,
+        ExplicitDistrust = 67108864,
+        HasExcludedNameConstraint = 32768,
+        HasNotDefinedNameConstraint = 8192,
+        HasNotPermittedNameConstraint = 16384,
+        HasNotSupportedCriticalExtension = 134217728,
+        HasNotSupportedNameConstraint = 4096,
+        HasWeakSignature = 1048576,
+        InvalidBasicConstraints = 1024,
+        InvalidExtension = 256,
+        InvalidNameConstraints = 2048,
+        InvalidPolicyConstraints = 512,
+        NoError = 0,
+        NoIssuanceChainPolicy = 33554432,
+        NotSignatureValid = 8,
+        NotTimeNested = 2,
+        NotTimeValid = 1,
+        NotValidForUsage = 16,
+        OfflineRevocation = 16777216,
+        PartialChain = 65536,
+        RevocationStatusUnknown = 64,
+        Revoked = 4,
+        UntrustedRoot = 32,
+    }
+    public enum X509ContentType {
+        Authenticode = 6,
+        Cert = 1,
+        Pfx = 3,
+        Pkcs12 = 3,
+        Pkcs7 = 5,
+        SerializedCert = 2,
+        SerializedStore = 4,
+        Unknown = 0,
+    }
+    public sealed class X509EnhancedKeyUsageExtension : X509Extension {
+        public X509EnhancedKeyUsageExtension();
+        public X509EnhancedKeyUsageExtension(AsnEncodedData encodedEnhancedKeyUsages, bool critical);
+        public X509EnhancedKeyUsageExtension(OidCollection enhancedKeyUsages, bool critical);
+        public OidCollection EnhancedKeyUsages { get; }
+        public override void CopyFrom(AsnEncodedData asnEncodedData);
+    }
+    public class X509Extension : AsnEncodedData {
+        protected X509Extension();
+        public X509Extension(AsnEncodedData encodedExtension, bool critical);
+        public X509Extension(Oid oid, byte[] rawData, bool critical);
+        public X509Extension(string oid, byte[] rawData, bool critical);
+        public bool Critical { get; set; }
+        public override void CopyFrom(AsnEncodedData asnEncodedData);
+    }
+    public sealed class X509ExtensionCollection : ICollection, IEnumerable {
+        public X509ExtensionCollection();
+        public int Count { get; }
+        bool System.Collections.ICollection.IsSynchronized { get; }
+        object System.Collections.ICollection.SyncRoot { get; }
+        public X509Extension this[int index] { get; }
+        public X509Extension this[string oid] { get; }
+        public int Add(X509Extension extension);
+        public void CopyTo(X509Extension[] array, int index);
+        public X509ExtensionEnumerator GetEnumerator();
+        void System.Collections.ICollection.CopyTo(Array array, int index);
+        IEnumerator System.Collections.IEnumerable.GetEnumerator();
+    }
+    public sealed class X509ExtensionEnumerator : IEnumerator {
+        public X509Extension Current { get; }
+        object System.Collections.IEnumerator.Current { get; }
+        public bool MoveNext();
+        public void Reset();
+    }
+    public enum X509FindType {
+        FindByApplicationPolicy = 10,
+        FindByCertificatePolicy = 11,
+        FindByExtension = 12,
+        FindByIssuerDistinguishedName = 4,
+        FindByIssuerName = 3,
+        FindByKeyUsage = 13,
+        FindBySerialNumber = 5,
+        FindBySubjectDistinguishedName = 2,
+        FindBySubjectKeyIdentifier = 14,
+        FindBySubjectName = 1,
+        FindByTemplateName = 9,
+        FindByThumbprint = 0,
+        FindByTimeExpired = 8,
+        FindByTimeNotYetValid = 7,
+        FindByTimeValid = 6,
+    }
+    public enum X509KeyStorageFlags {
+        DefaultKeySet = 0,
+        Exportable = 4,
+        MachineKeySet = 2,
+        PersistKeySet = 16,
+        UserKeySet = 1,
+        UserProtected = 8,
+    }
+    public sealed class X509KeyUsageExtension : X509Extension {
+        public X509KeyUsageExtension();
+        public X509KeyUsageExtension(AsnEncodedData encodedKeyUsage, bool critical);
+        public X509KeyUsageExtension(X509KeyUsageFlags keyUsages, bool critical);
+        public X509KeyUsageFlags KeyUsages { get; }
+        public override void CopyFrom(AsnEncodedData asnEncodedData);
+    }
+    public enum X509KeyUsageFlags {
+        CrlSign = 2,
+        DataEncipherment = 16,
+        DecipherOnly = 32768,
+        DigitalSignature = 128,
+        EncipherOnly = 1,
+        KeyAgreement = 8,
+        KeyCertSign = 4,
+        KeyEncipherment = 32,
+        None = 0,
+        NonRepudiation = 64,
+    }
+    public enum X509NameType {
+        DnsFromAlternativeName = 4,
+        DnsName = 3,
+        EmailName = 1,
+        SimpleName = 0,
+        UpnName = 2,
+        UrlName = 5,
+    }
+    public enum X509RevocationFlag {
+        EndCertificateOnly = 0,
+        EntireChain = 1,
+        ExcludeRoot = 2,
+    }
+    public enum X509RevocationMode {
+        NoCheck = 0,
+        Offline = 2,
+        Online = 1,
+    }
+    public sealed class X509Store : IDisposable {
+        public X509Store();
+        public X509Store(StoreName storeName, StoreLocation storeLocation);
+        public X509Store(string storeName, StoreLocation storeLocation);
+        public X509Certificate2Collection Certificates { get; }
+        public StoreLocation Location { get; }
+        public string Name { get; }
+        public void Add(X509Certificate2 certificate);
+        public void Dispose();
+        public void Open(OpenFlags flags);
+        public void Remove(X509Certificate2 certificate);
+    }
+    public sealed class X509SubjectKeyIdentifierExtension : X509Extension {
+        public X509SubjectKeyIdentifierExtension();
+        public X509SubjectKeyIdentifierExtension(byte[] subjectKeyIdentifier, bool critical);
+        public X509SubjectKeyIdentifierExtension(AsnEncodedData encodedSubjectKeyIdentifier, bool critical);
+        public X509SubjectKeyIdentifierExtension(PublicKey key, bool critical);
+        public X509SubjectKeyIdentifierExtension(PublicKey key, X509SubjectKeyIdentifierHashAlgorithm algorithm, bool critical);
+        public X509SubjectKeyIdentifierExtension(string subjectKeyIdentifier, bool critical);
+        public string SubjectKeyIdentifier { get; }
+        public override void CopyFrom(AsnEncodedData asnEncodedData);
+    }
+    public enum X509SubjectKeyIdentifierHashAlgorithm {
+        CapiSha1 = 2,
+        Sha1 = 0,
+        ShortSha1 = 1,
+    }
+    public enum X509VerificationFlags {
+        AllFlags = 4095,
+        AllowUnknownCertificateAuthority = 16,
+        IgnoreCertificateAuthorityRevocationUnknown = 1024,
+        IgnoreCtlNotTimeValid = 2,
+        IgnoreCtlSignerRevocationUnknown = 512,
+        IgnoreEndRevocationUnknown = 256,
+        IgnoreInvalidBasicConstraints = 8,
+        IgnoreInvalidName = 64,
+        IgnoreInvalidPolicy = 128,
+        IgnoreNotTimeNested = 4,
+        IgnoreNotTimeValid = 1,
+        IgnoreRootRevocationUnknown = 2048,
+        IgnoreWrongUsage = 32,
+        NoFlag = 0,
+    }
+}
```

## System.Security.Cryptography.Xml

```c#
+namespace System.Security.Cryptography.Xml {
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct X509IssuerSerial {
+        public string IssuerName { get; set; }
+        public string SerialNumber { get; set; }
+    }
+}
```

## System.Security.Permissions

```c#
+namespace System.Security.Permissions {
+    public abstract class CodeAccessSecurityAttribute : SecurityAttribute {
+        protected CodeAccessSecurityAttribute(SecurityAction action);
+    }
+    public enum SecurityAction {
+        Assert = 3,
+        Demand = 2,
+        Deny = 4,
+        InheritanceDemand = 7,
+        LinkDemand = 6,
+        PermitOnly = 5,
+        RequestMinimum = 8,
+        RequestOptional = 9,
+        RequestRefuse = 10,
+    }
+    public abstract class SecurityAttribute : Attribute {
+        protected SecurityAttribute(SecurityAction action);
+        public SecurityAction Action { get; set; }
+        public bool Unrestricted { get; set; }
+    }
+    public sealed class SecurityPermissionAttribute : CodeAccessSecurityAttribute {
+        public SecurityPermissionAttribute(SecurityAction action);
+        public bool ControlAppDomain { get; set; }
+        public bool ControlDomainPolicy { get; set; }
+        public bool ControlEvidence { get; set; }
+        public bool ControlPolicy { get; set; }
+        public bool ControlThread { get; set; }
+        public SecurityPermissionFlag Flags { get; set; }
+        public bool SkipVerification { get; set; }
+        public bool UnmanagedCode { get; set; }
+    }
+    public enum SecurityPermissionFlag {
+        AllFlags = 16383,
+        Assertion = 1,
+        BindingRedirects = 8192,
+        ControlAppDomain = 1024,
+        ControlDomainPolicy = 256,
+        ControlEvidence = 32,
+        ControlPolicy = 64,
+        ControlPrincipal = 512,
+        ControlThread = 16,
+        Execution = 8,
+        Infrastructure = 4096,
+        NoFlags = 0,
+        RemotingConfiguration = 2048,
+        SerializationFormatter = 128,
+        SkipVerification = 4,
+        UnmanagedCode = 2,
+    }
+}
```

## System.Security.Principal

```c#
+namespace System.Security.Principal {
+    public class GenericIdentity : ClaimsIdentity {
+        protected GenericIdentity(GenericIdentity identity);
+        public GenericIdentity(string name);
+        public GenericIdentity(string name, string type);
+        public override string AuthenticationType { get; }
+        public override IEnumerable<Claim> Claims { get; }
+        public override bool IsAuthenticated { get; }
+        public override string Name { get; }
+        public override ClaimsIdentity Clone();
+    }
+    public class GenericPrincipal : ClaimsPrincipal {
+        public GenericPrincipal(IIdentity identity, string[] roles);
+        public override IIdentity Identity { get; }
+        public override bool IsInRole(string role);
+    }
+    public sealed class IdentityNotMappedException : Exception {
+        public IdentityNotMappedException();
+        public IdentityNotMappedException(string message);
+        public IdentityNotMappedException(string message, Exception inner);
+        public IdentityReferenceCollection UnmappedIdentities { get; }
+    }
+    public abstract class IdentityReference {
+        public abstract string Value { get; }
+        public abstract override bool Equals(object o);
+        public abstract override int GetHashCode();
+        public abstract bool IsValidTargetType(Type targetType);
+        public static bool operator ==(IdentityReference left, IdentityReference right);
+        public static bool operator !=(IdentityReference left, IdentityReference right);
+        public abstract override string ToString();
+        public abstract IdentityReference Translate(Type targetType);
+    }
+    public class IdentityReferenceCollection : ICollection<IdentityReference>, IEnumerable, IEnumerable<IdentityReference> {
+        public IdentityReferenceCollection();
+        public IdentityReferenceCollection(int capacity);
+        public int Count { get; }
+        bool System.Collections.Generic.ICollection<System.Security.Principal.IdentityReference>.IsReadOnly { get; }
+        public IdentityReference this[int index] { get; set; }
+        public void Add(IdentityReference identity);
+        public void Clear();
+        public bool Contains(IdentityReference identity);
+        public void CopyTo(IdentityReference[] array, int offset);
+        public IEnumerator<IdentityReference> GetEnumerator();
+        public bool Remove(IdentityReference identity);
+        IEnumerator System.Collections.IEnumerable.GetEnumerator();
+        public IdentityReferenceCollection Translate(Type targetType);
+        public IdentityReferenceCollection Translate(Type targetType, bool forceSuccess);
+    }
+    public interface IIdentity {
+        string AuthenticationType { get; }
+        bool IsAuthenticated { get; }
+        string Name { get; }
+    }
+    public interface IPrincipal {
+        IIdentity Identity { get; }
+        bool IsInRole(string role);
+    }
+    public sealed class NTAccount : IdentityReference {
+        public NTAccount(string name);
+        public NTAccount(string domainName, string accountName);
+        public override string Value { get; }
+        public override bool Equals(object o);
+        public override int GetHashCode();
+        public override bool IsValidTargetType(Type targetType);
+        public static bool operator ==(NTAccount left, NTAccount right);
+        public static bool operator !=(NTAccount left, NTAccount right);
+        public override string ToString();
+        public override IdentityReference Translate(Type targetType);
+    }
+    public sealed class SecurityIdentifier : IdentityReference, IComparable<SecurityIdentifier> {
+        public static readonly int MaxBinaryLength;
+        public static readonly int MinBinaryLength;
+        public SecurityIdentifier(byte[] binaryForm, int offset);
+        public SecurityIdentifier(IntPtr binaryForm);
+        public SecurityIdentifier(WellKnownSidType sidType, SecurityIdentifier domainSid);
+        public SecurityIdentifier(string sddlForm);
+        public SecurityIdentifier AccountDomainSid { get; }
+        public int BinaryLength { get; }
+        public override string Value { get; }
+        public int CompareTo(SecurityIdentifier sid);
+        public override bool Equals(object o);
+        public bool Equals(SecurityIdentifier sid);
+        public void GetBinaryForm(byte[] binaryForm, int offset);
+        public override int GetHashCode();
+        public bool IsAccountSid();
+        public bool IsEqualDomainSid(SecurityIdentifier sid);
+        public override bool IsValidTargetType(Type targetType);
+        public bool IsWellKnown(WellKnownSidType type);
+        public static bool operator ==(SecurityIdentifier left, SecurityIdentifier right);
+        public static bool operator !=(SecurityIdentifier left, SecurityIdentifier right);
+        public override string ToString();
+        public override IdentityReference Translate(Type targetType);
+    }
+    public enum TokenAccessLevels {
+        AdjustDefault = 128,
+        AdjustGroups = 64,
+        AdjustPrivileges = 32,
+        AdjustSessionId = 256,
+        AllAccess = 983551,
+        AssignPrimary = 1,
+        Duplicate = 2,
+        Impersonate = 4,
+        MaximumAllowed = 33554432,
+        Query = 8,
+        QuerySource = 16,
+        Read = 131080,
+        Write = 131296,
+    }
+    public enum TokenImpersonationLevel {
+        Anonymous = 1,
+        Delegation = 4,
+        Identification = 2,
+        Impersonation = 3,
+        None = 0,
+    }
+    public enum WellKnownSidType {
+        AccountAdministratorSid = 38,
+        AccountCertAdminsSid = 46,
+        AccountComputersSid = 44,
+        AccountControllersSid = 45,
+        AccountDomainAdminsSid = 41,
+        AccountDomainGuestsSid = 43,
+        AccountDomainUsersSid = 42,
+        AccountEnterpriseAdminsSid = 48,
+        AccountGuestSid = 39,
+        AccountKrbtgtSid = 40,
+        AccountPolicyAdminsSid = 49,
+        AccountRasAndIasServersSid = 50,
+        AccountSchemaAdminsSid = 47,
+        AnonymousSid = 13,
+        AuthenticatedUserSid = 17,
+        BatchSid = 10,
+        BuiltinAccountOperatorsSid = 30,
+        BuiltinAdministratorsSid = 26,
+        BuiltinAuthorizationAccessSid = 59,
+        BuiltinBackupOperatorsSid = 33,
+        BuiltinDomainSid = 25,
+        BuiltinGuestsSid = 28,
+        BuiltinIncomingForestTrustBuildersSid = 56,
+        BuiltinNetworkConfigurationOperatorsSid = 37,
+        BuiltinPerformanceLoggingUsersSid = 58,
+        BuiltinPerformanceMonitoringUsersSid = 57,
+        BuiltinPowerUsersSid = 29,
+        BuiltinPreWindows2000CompatibleAccessSid = 35,
+        BuiltinPrintOperatorsSid = 32,
+        BuiltinRemoteDesktopUsersSid = 36,
+        BuiltinReplicatorSid = 34,
+        BuiltinSystemOperatorsSid = 31,
+        BuiltinUsersSid = 27,
+        CreatorGroupServerSid = 6,
+        CreatorGroupSid = 4,
+        CreatorOwnerServerSid = 5,
+        CreatorOwnerSid = 3,
+        DialupSid = 8,
+        DigestAuthenticationSid = 52,
+        EnterpriseControllersSid = 15,
+        InteractiveSid = 11,
+        LocalServiceSid = 23,
+        LocalSid = 2,
+        LocalSystemSid = 22,
+        LogonIdsSid = 21,
+        MaxDefined = 60,
+        NetworkServiceSid = 24,
+        NetworkSid = 9,
+        NTAuthoritySid = 7,
+        NtlmAuthenticationSid = 51,
+        NullSid = 0,
+        OtherOrganizationSid = 55,
+        ProxySid = 14,
+        RemoteLogonIdSid = 20,
+        RestrictedCodeSid = 18,
+        SChannelAuthenticationSid = 53,
+        SelfSid = 16,
+        ServiceSid = 12,
+        TerminalServerSid = 19,
+        ThisOrganizationSid = 54,
+        WinBuiltinTerminalServerLicenseServersSid = 60,
+        WorldSid = 1,
+    }
+    public enum WindowsBuiltInRole {
+        AccountOperator = 548,
+        Administrator = 544,
+        BackupOperator = 551,
+        Guest = 546,
+        PowerUser = 547,
+        PrintOperator = 550,
+        Replicator = 552,
+        SystemOperator = 549,
+        User = 545,
+    }
+    public class WindowsIdentity : ClaimsIdentity, IDisposable {
+        public const string DefaultIssuer = "AD AUTHORITY";
+        public WindowsIdentity(IntPtr userToken);
+        public WindowsIdentity(IntPtr userToken, string type);
+        public WindowsIdentity(string sUserPrincipalName);
+        public SafeAccessTokenHandle AccessToken { get; }
+        public sealed override string AuthenticationType { get; }
+        public override IEnumerable<Claim> Claims { get; }
+        public IdentityReferenceCollection Groups { get; }
+        public TokenImpersonationLevel ImpersonationLevel { get; }
+        public virtual bool IsAnonymous { get; }
+        public override bool IsAuthenticated { get; }
+        public virtual bool IsGuest { get; }
+        public virtual bool IsSystem { get; }
+        public override string Name { get; }
+        public SecurityIdentifier Owner { get; }
+        public SecurityIdentifier User { get; }
+        public override ClaimsIdentity Clone();
+        public void Dispose();
+        protected virtual void Dispose(bool disposing);
+        public static WindowsIdentity GetAnonymous();
+        public static WindowsIdentity GetCurrent();
+        public static WindowsIdentity GetCurrent(bool ifImpersonating);
+        public static WindowsIdentity GetCurrent(TokenAccessLevels desiredAccess);
+        public static void RunImpersonated(SafeAccessTokenHandle safeAccessTokenHandle, Action action);
+        public static T RunImpersonated<T>(SafeAccessTokenHandle safeAccessTokenHandle, Func<T> func);
+    }
+    public class WindowsPrincipal : ClaimsPrincipal {
+        public WindowsPrincipal(WindowsIdentity ntIdentity);
+        public override IIdentity Identity { get; }
+        public virtual bool IsInRole(int rid);
+        public virtual bool IsInRole(SecurityIdentifier sid);
+        public virtual bool IsInRole(WindowsBuiltInRole role);
+        public override bool IsInRole(string role);
+    }
+}
```

## System.ServiceModel

```c#
+namespace System.ServiceModel {
+    public class ActionNotSupportedException : CommunicationException {
+        public ActionNotSupportedException();
+        public ActionNotSupportedException(string message);
+        public ActionNotSupportedException(string message, Exception innerException);
+    }
+    public enum AuditLevel {
+        Failure = 2,
+        None = 0,
+        Success = 1,
+        SuccessOrFailure = 3,
+    }
+    public enum AuditLogLocation {
+        Application = 1,
+        Default = 0,
+        Security = 2,
+    }
+    public class BasicHttpBinding : HttpBindingBase {
+        public BasicHttpBinding();
+        public BasicHttpBinding(BasicHttpSecurityMode securityMode);
+        public BasicHttpSecurity Security { get; set; }
+        public override IChannelFactory<TChannel> BuildChannelFactory<TChannel>(BindingParameterCollection parameters);
+        public override BindingElementCollection CreateBindingElements();
+    }
+    public enum BasicHttpMessageCredentialType {
+        Certificate = 1,
+        UserName = 0,
+    }
+    public class BasicHttpsBinding : HttpBindingBase {
+        public BasicHttpsBinding();
+        public BasicHttpsBinding(BasicHttpsSecurityMode securityMode);
+        public BasicHttpsSecurity Security { get; set; }
+        public override IChannelFactory<TChannel> BuildChannelFactory<TChannel>(BindingParameterCollection parameters);
+        public override BindingElementCollection CreateBindingElements();
+    }
+    public sealed class BasicHttpSecurity {
+        public BasicHttpSecurity();
+        public BasicHttpSecurityMode Mode { get; set; }
+        public HttpTransportSecurity Transport { get; set; }
+    }
+    public enum BasicHttpSecurityMode {
+        Message = 2,
+        None = 0,
+        Transport = 1,
+        TransportCredentialOnly = 4,
+        TransportWithMessageCredential = 3,
+    }
+    public sealed class BasicHttpsSecurity {
+        public BasicHttpsSecurity();
+        public BasicHttpsSecurityMode Mode { get; set; }
+        public HttpTransportSecurity Transport { get; set; }
+    }
+    public enum BasicHttpsSecurityMode {
+        Transport = 0,
+        TransportWithMessageCredential = 1,
+    }
+    public sealed class CallbackBehaviorAttribute : Attribute, IEndpointBehavior {
+        public CallbackBehaviorAttribute();
+        public bool AutomaticSessionShutdown { get; set; }
+        public bool UseSynchronizationContext { get; set; }
+        void System.ServiceModel.Description.IEndpointBehavior.AddBindingParameters(ServiceEndpoint serviceEndpoint, BindingParameterCollection parameters);
+        void System.ServiceModel.Description.IEndpointBehavior.ApplyClientBehavior(ServiceEndpoint serviceEndpoint, ClientRuntime clientRuntime);
+        void System.ServiceModel.Description.IEndpointBehavior.ApplyDispatchBehavior(ServiceEndpoint serviceEndpoint, EndpointDispatcher endpointDispatcher);
+        void System.ServiceModel.Description.IEndpointBehavior.Validate(ServiceEndpoint serviceEndpoint);
+    }
+    public abstract class ChannelFactory : CommunicationObject, IChannelFactory, ICommunicationObject, IDisposable {
+        protected ChannelFactory();
+        public ClientCredentials Credentials { get; }
+        protected override TimeSpan DefaultCloseTimeout { get; }
+        protected override TimeSpan DefaultOpenTimeout { get; }
+        public ServiceEndpoint Endpoint { get; }
+        protected virtual void ApplyConfiguration(string configurationName);
+        protected abstract ServiceEndpoint CreateDescription();
+        protected virtual IChannelFactory CreateFactory();
+        protected internal void EnsureOpened();
+        public T GetProperty<T>() where T : class;
+        protected void InitializeEndpoint(Binding binding, EndpointAddress address);
+        protected void InitializeEndpoint(ServiceEndpoint endpoint);
+        protected void InitializeEndpoint(string configurationName, EndpointAddress address);
+        protected override void OnAbort();
+        protected override IAsyncResult OnBeginClose(TimeSpan timeout, AsyncCallback callback, object state);
+        protected override IAsyncResult OnBeginOpen(TimeSpan timeout, AsyncCallback callback, object state);
+        protected override void OnClose(TimeSpan timeout);
+        protected internal override Task OnCloseAsync(TimeSpan timeout);
+        protected override void OnEndClose(IAsyncResult result);
+        protected override void OnEndOpen(IAsyncResult result);
+        protected override void OnOpen(TimeSpan timeout);
+        protected internal override Task OnOpenAsync(TimeSpan timeout);
+        protected override void OnOpened();
+        protected override void OnOpening();
+        void System.IDisposable.Dispose();
+    }
+    public class ChannelFactory<TChannel> : ChannelFactory, IChannelFactory, IChannelFactory<TChannel>, ICommunicationObject {
+        public ChannelFactory();
+        public ChannelFactory(Binding binding);
+        public ChannelFactory(Binding binding, EndpointAddress remoteAddress);
+        public ChannelFactory(Binding binding, string remoteAddress);
+        public ChannelFactory(ServiceEndpoint endpoint);
+        public ChannelFactory(string endpointConfigurationName);
+        public ChannelFactory(string endpointConfigurationName, EndpointAddress remoteAddress);
+        protected ChannelFactory(Type channelType);
+        public TChannel CreateChannel();
+        public static TChannel CreateChannel(Binding binding, EndpointAddress endpointAddress);
+        public static TChannel CreateChannel(Binding binding, EndpointAddress endpointAddress, Uri via);
+        public TChannel CreateChannel(EndpointAddress address);
+        public virtual TChannel CreateChannel(EndpointAddress address, Uri via);
+        protected static TChannel CreateChannel(string endpointConfigurationName);
+        protected override ServiceEndpoint CreateDescription();
+    }
+    public class ChannelTerminatedException : CommunicationException {
+        public ChannelTerminatedException();
+        public ChannelTerminatedException(string message);
+        public ChannelTerminatedException(string message, Exception innerException);
+    }
+    public abstract class ClientBase<TChannel> : ICommunicationObject where TChannel : class {
+        protected ClientBase();
+        protected ClientBase(Binding binding, EndpointAddress remoteAddress);
+        protected ClientBase(InstanceContext callbackInstance, Binding binding, EndpointAddress remoteAddress);
+        protected ClientBase(string endpointConfigurationName);
+        protected ClientBase(string endpointConfigurationName, EndpointAddress remoteAddress);
+        protected ClientBase(string endpointConfigurationName, string remoteAddress);
+        protected TChannel Channel { get; }
+        public ChannelFactory<TChannel> ChannelFactory { get; }
+        public ClientCredentials ClientCredentials { get; }
+        public ServiceEndpoint Endpoint { get; }
+        public IClientChannel InnerChannel { get; }
+        public CommunicationState State { get; }
+        event EventHandler System.ServiceModel.ICommunicationObject.Closed;
+        event EventHandler System.ServiceModel.ICommunicationObject.Closing;
+        event EventHandler System.ServiceModel.ICommunicationObject.Faulted;
+        event EventHandler System.ServiceModel.ICommunicationObject.Opened;
+        event EventHandler System.ServiceModel.ICommunicationObject.Opening;
+        public void Abort();
+        public void Close();
+        protected virtual TChannel CreateChannel();
+        protected T GetDefaultValueForInitialization<T>();
+        protected void InvokeAsync(ClientBase<TChannel>.BeginOperationDelegate beginOperationDelegate, object[] inValues, ClientBase<TChannel>.EndOperationDelegate endOperationDelegate, SendOrPostCallback operationCompletedCallback, object userState);
+        public void Open();
+        void System.IDisposable.Dispose();
+        IAsyncResult System.ServiceModel.ICommunicationObject.BeginClose(AsyncCallback callback, object state);
+        IAsyncResult System.ServiceModel.ICommunicationObject.BeginClose(TimeSpan timeout, AsyncCallback callback, object state);
+        IAsyncResult System.ServiceModel.ICommunicationObject.BeginOpen(AsyncCallback callback, object state);
+        IAsyncResult System.ServiceModel.ICommunicationObject.BeginOpen(TimeSpan timeout, AsyncCallback callback, object state);
+        void System.ServiceModel.ICommunicationObject.Close();
+        void System.ServiceModel.ICommunicationObject.Close(TimeSpan timeout);
+        void System.ServiceModel.ICommunicationObject.EndClose(IAsyncResult result);
+        void System.ServiceModel.ICommunicationObject.EndOpen(IAsyncResult result);
+        void System.ServiceModel.ICommunicationObject.Open();
+        void System.ServiceModel.ICommunicationObject.Open(TimeSpan timeout);
+        protected class AsyncOperationContext
+        protected delegate IAsyncResult BeginOperationDelegate(object[] inValues, AsyncCallback asyncCallback, object state);
+        protected class ChannelBase<T> : IChannel, IClientChannel, ICommunicationObject, IContextChannel, IDisposable, IExtensibleObject<IContextChannel>, IOutputChannel, IRequestChannel where T : class {
+            protected ChannelBase(ClientBase<T> client);
+            EndpointAddress System.ServiceModel.Channels.IOutputChannel.RemoteAddress { get; }
+            Uri System.ServiceModel.Channels.IOutputChannel.Via { get; }
+            EndpointAddress System.ServiceModel.Channels.IRequestChannel.RemoteAddress { get; }
+            Uri System.ServiceModel.Channels.IRequestChannel.Via { get; }
+            bool System.ServiceModel.IClientChannel.AllowInitializationUI { get; set; }
+            bool System.ServiceModel.IClientChannel.DidInteractiveInitialization { get; }
+            Uri System.ServiceModel.IClientChannel.Via { get; }
+            CommunicationState System.ServiceModel.ICommunicationObject.State { get; }
+            bool System.ServiceModel.IContextChannel.AllowOutputBatching { get; set; }
+            IInputSession System.ServiceModel.IContextChannel.InputSession { get; }
+            EndpointAddress System.ServiceModel.IContextChannel.LocalAddress { get; }
+            TimeSpan System.ServiceModel.IContextChannel.OperationTimeout { get; set; }
+            IOutputSession System.ServiceModel.IContextChannel.OutputSession { get; }
+            EndpointAddress System.ServiceModel.IContextChannel.RemoteAddress { get; }
+            string System.ServiceModel.IContextChannel.SessionId { get; }
+            IExtensionCollection<IContextChannel> System.ServiceModel.IExtensibleObject<System.ServiceModel.IContextChannel>.Extensions { get; }
+            event EventHandler<UnknownMessageReceivedEventArgs> System.ServiceModel.IClientChannel.UnknownMessageReceived;
+            event EventHandler System.ServiceModel.ICommunicationObject.Closed;
+            event EventHandler System.ServiceModel.ICommunicationObject.Closing;
+            event EventHandler System.ServiceModel.ICommunicationObject.Faulted;
+            event EventHandler System.ServiceModel.ICommunicationObject.Opened;
+            event EventHandler System.ServiceModel.ICommunicationObject.Opening;
+            protected IAsyncResult BeginInvoke(string methodName, object[] args, AsyncCallback callback, object state);
+            protected object EndInvoke(string methodName, object[] args, IAsyncResult result);
+            void System.IDisposable.Dispose();
+            TProperty System.ServiceModel.Channels.IChannel.GetProperty<TProperty>();
+            IAsyncResult System.ServiceModel.Channels.IOutputChannel.BeginSend(Message message, AsyncCallback callback, object state);
+            IAsyncResult System.ServiceModel.Channels.IOutputChannel.BeginSend(Message message, TimeSpan timeout, AsyncCallback callback, object state);
+            void System.ServiceModel.Channels.IOutputChannel.EndSend(IAsyncResult result);
+            void System.ServiceModel.Channels.IOutputChannel.Send(Message message);
+            void System.ServiceModel.Channels.IOutputChannel.Send(Message message, TimeSpan timeout);
+            IAsyncResult System.ServiceModel.Channels.IRequestChannel.BeginRequest(Message message, AsyncCallback callback, object state);
+            IAsyncResult System.ServiceModel.Channels.IRequestChannel.BeginRequest(Message message, TimeSpan timeout, AsyncCallback callback, object state);
+            Message System.ServiceModel.Channels.IRequestChannel.EndRequest(IAsyncResult result);
+            Message System.ServiceModel.Channels.IRequestChannel.Request(Message message);
+            Message System.ServiceModel.Channels.IRequestChannel.Request(Message message, TimeSpan timeout);
+            IAsyncResult System.ServiceModel.IClientChannel.BeginDisplayInitializationUI(AsyncCallback callback, object state);
+            void System.ServiceModel.IClientChannel.DisplayInitializationUI();
+            void System.ServiceModel.IClientChannel.EndDisplayInitializationUI(IAsyncResult result);
+            void System.ServiceModel.ICommunicationObject.Abort();
+            IAsyncResult System.ServiceModel.ICommunicationObject.BeginClose(AsyncCallback callback, object state);
+            IAsyncResult System.ServiceModel.ICommunicationObject.BeginClose(TimeSpan timeout, AsyncCallback callback, object state);
+            IAsyncResult System.ServiceModel.ICommunicationObject.BeginOpen(AsyncCallback callback, object state);
+            IAsyncResult System.ServiceModel.ICommunicationObject.BeginOpen(TimeSpan timeout, AsyncCallback callback, object state);
+            void System.ServiceModel.ICommunicationObject.Close();
+            void System.ServiceModel.ICommunicationObject.Close(TimeSpan timeout);
+            void System.ServiceModel.ICommunicationObject.EndClose(IAsyncResult result);
+            void System.ServiceModel.ICommunicationObject.EndOpen(IAsyncResult result);
+            void System.ServiceModel.ICommunicationObject.Open();
+            void System.ServiceModel.ICommunicationObject.Open(TimeSpan timeout);
+        }
+        protected delegate object[] EndOperationDelegate(IAsyncResult result);
+        protected class InvokeAsyncCompletedEventArgs : AsyncCompletedEventArgs {
+            public object[] Results { get; }
+        }
+    }
+    public class ClientCredentialsSecurityTokenManager : SecurityTokenManager {
+        public ClientCredentialsSecurityTokenManager(ClientCredentials clientCredentials);
+        public ClientCredentials ClientCredentials { get; }
+        public override SecurityTokenAuthenticator CreateSecurityTokenAuthenticator(SecurityTokenRequirement tokenRequirement, out SecurityTokenResolver outOfBandTokenResolver);
+        public override SecurityTokenProvider CreateSecurityTokenProvider(SecurityTokenRequirement tokenRequirement);
+        public override SecurityTokenSerializer CreateSecurityTokenSerializer(SecurityTokenVersion version);
+        protected internal bool IsIssuedSecurityTokenRequirement(SecurityTokenRequirement requirement);
+    }
+    public class CommunicationException : Exception {
+        public CommunicationException();
+        public CommunicationException(string message);
+        public CommunicationException(string message, Exception innerException);
+    }
+    public class CommunicationObjectAbortedException : CommunicationException {
+        public CommunicationObjectAbortedException();
+        public CommunicationObjectAbortedException(string message);
+        public CommunicationObjectAbortedException(string message, Exception innerException);
+    }
+    public class CommunicationObjectFaultedException : CommunicationException {
+        public CommunicationObjectFaultedException();
+        public CommunicationObjectFaultedException(string message);
+        public CommunicationObjectFaultedException(string message, Exception innerException);
+    }
+    public enum CommunicationState {
+        Closed = 4,
+        Closing = 3,
+        Created = 0,
+        Faulted = 5,
+        Opened = 2,
+        Opening = 1,
+    }
+    public enum ConcurrencyMode {
+        Multiple = 2,
+        Reentrant = 1,
+        Single = 0,
+    }
+    public static class ConcurrencyModeHelper {
+        public static bool IsDefined(ConcurrencyMode x);
+    }
+    public sealed class DataContractFormatAttribute : Attribute {
+        public DataContractFormatAttribute();
+        public OperationFormatStyle Style { get; set; }
+    }
+    public static class DiagnosticUtility {
+        public static ExceptionUtility ExceptionUtility { get; }
+    }
+    public class DnsEndpointIdentity : EndpointIdentity {
+        public DnsEndpointIdentity(Claim identity);
+        public DnsEndpointIdentity(string dnsName);
+    }
+    public class DuplexChannelFactory<TChannel> : ChannelFactory<TChannel> {
+        public DuplexChannelFactory(object callbackObject);
+        public DuplexChannelFactory(object callbackObject, Binding binding);
+        public DuplexChannelFactory(object callbackObject, Binding binding, EndpointAddress remoteAddress);
+        public DuplexChannelFactory(object callbackObject, Binding binding, string remoteAddress);
+        public DuplexChannelFactory(object callbackObject, ServiceEndpoint endpoint);
+        public DuplexChannelFactory(object callbackObject, string endpointConfigurationName);
+        public DuplexChannelFactory(object callbackObject, string endpointConfigurationName, EndpointAddress remoteAddress);
+        public DuplexChannelFactory(InstanceContext callbackInstance);
+        public DuplexChannelFactory(InstanceContext callbackInstance, Binding binding);
+        public DuplexChannelFactory(InstanceContext callbackInstance, Binding binding, EndpointAddress remoteAddress);
+        public DuplexChannelFactory(InstanceContext callbackInstance, Binding binding, string remoteAddress);
+        public DuplexChannelFactory(InstanceContext callbackInstance, ServiceEndpoint endpoint);
+        public DuplexChannelFactory(InstanceContext callbackInstance, string endpointConfigurationName);
+        public DuplexChannelFactory(InstanceContext callbackInstance, string endpointConfigurationName, EndpointAddress remoteAddress);
+        public DuplexChannelFactory(Type callbackInstanceType);
+        public DuplexChannelFactory(Type callbackInstanceType, Binding binding);
+        public DuplexChannelFactory(Type callbackInstanceType, Binding binding, EndpointAddress remoteAddress);
+        public DuplexChannelFactory(Type callbackInstanceType, Binding binding, string remoteAddress);
+        public DuplexChannelFactory(Type callbackInstanceType, ServiceEndpoint endpoint);
+        public DuplexChannelFactory(Type callbackInstanceType, string endpointConfigurationName);
+        public DuplexChannelFactory(Type callbackInstanceType, string endpointConfigurationName, EndpointAddress remoteAddress);
+        public static TChannel CreateChannel(object callbackObject, Binding binding, EndpointAddress endpointAddress);
+        public static TChannel CreateChannel(object callbackObject, Binding binding, EndpointAddress endpointAddress, Uri via);
+        public static TChannel CreateChannel(object callbackObject, string endpointConfigurationName);
+        public override TChannel CreateChannel(EndpointAddress address, Uri via);
+        public TChannel CreateChannel(InstanceContext callbackInstance);
+        public static TChannel CreateChannel(InstanceContext callbackInstance, Binding binding, EndpointAddress endpointAddress);
+        public static TChannel CreateChannel(InstanceContext callbackInstance, Binding binding, EndpointAddress endpointAddress, Uri via);
+        public TChannel CreateChannel(InstanceContext callbackInstance, EndpointAddress address);
+        public virtual TChannel CreateChannel(InstanceContext callbackInstance, EndpointAddress address, Uri via);
+        public static TChannel CreateChannel(InstanceContext callbackInstance, string endpointConfigurationName);
+    }
+    public abstract class DuplexClientBase<TChannel> : ClientBase<TChannel> where TChannel : class {
+        protected DuplexClientBase(InstanceContext callbackInstance);
+        protected DuplexClientBase(InstanceContext callbackInstance, Binding binding, EndpointAddress remoteAddress);
+        protected DuplexClientBase(InstanceContext callbackInstance, string endpointConfigurationName);
+        protected DuplexClientBase(InstanceContext callbackInstance, string endpointConfigurationName, EndpointAddress remoteAddress);
+        protected DuplexClientBase(InstanceContext callbackInstance, string endpointConfigurationName, string remoteAddress);
+        public IDuplexContextChannel InnerDuplexChannel { get; }
+    }
+    public class EndpointAddress {
+        public EndpointAddress(string uri);
+        public EndpointAddress(Uri uri, params AddressHeader[] addressHeaders);
+        public EndpointAddress(Uri uri, EndpointIdentity identity, params AddressHeader[] addressHeaders);
+        public static Uri AnonymousUri { get; }
+        public AddressHeaderCollection Headers { get; }
+        public EndpointIdentity Identity { get; }
+        public bool IsAnonymous { get; }
+        public bool IsNone { get; }
+        public static Uri NoneUri { get; }
+        public Uri Uri { get; }
+        public void ApplyTo(Message message);
+        public override bool Equals(object obj);
+        public override int GetHashCode();
+        public XmlDictionaryReader GetReaderAtExtensions();
+        public XmlDictionaryReader GetReaderAtMetadata();
+        public static bool operator ==(EndpointAddress address1, EndpointAddress address2);
+        public static bool operator !=(EndpointAddress address1, EndpointAddress address2);
+        public static EndpointAddress ReadFrom(AddressingVersion addressingVersion, XmlDictionaryReader reader);
+        public static EndpointAddress ReadFrom(XmlDictionaryReader reader);
+        public override string ToString();
+        public void WriteContentsTo(AddressingVersion addressingVersion, XmlDictionaryWriter writer);
+        public void WriteContentsTo(AddressingVersion addressingVersion, XmlWriter writer);
+        public void WriteTo(AddressingVersion addressingVersion, XmlDictionaryWriter writer);
+        public void WriteTo(AddressingVersion addressingVersion, XmlDictionaryWriter writer, XmlDictionaryString localName, XmlDictionaryString ns);
+        public void WriteTo(AddressingVersion addressingVersion, XmlWriter writer);
+        public void WriteTo(AddressingVersion addressingVersion, XmlWriter writer, string localName, string ns);
+    }
+    public class EndpointAddressBuilder {
+        public EndpointAddressBuilder();
+        public EndpointAddressBuilder(EndpointAddress address);
+        public Collection<AddressHeader> Headers { get; }
+        public EndpointIdentity Identity { get; set; }
+        public Uri Uri { get; set; }
+        public XmlDictionaryReader GetReaderAtExtensions();
+        public XmlDictionaryReader GetReaderAtMetadata();
+        public void SetExtensionReader(XmlDictionaryReader reader);
+        public void SetMetadataReader(XmlDictionaryReader reader);
+        public EndpointAddress ToEndpointAddress();
+    }
+    public abstract class EndpointIdentity {
+        protected EndpointIdentity();
+        public Claim IdentityClaim { get; }
+        public static EndpointIdentity CreateDnsIdentity(string dnsName);
+        public static EndpointIdentity CreateIdentity(Claim identity);
+        public static EndpointIdentity CreateSpnIdentity(string spnName);
+        public static EndpointIdentity CreateUpnIdentity(string upnName);
+        public override bool Equals(object obj);
+        public override int GetHashCode();
+        protected void Initialize(Claim identityClaim);
+        protected void Initialize(Claim identityClaim, IEqualityComparer<Claim> claimComparer);
+        public override string ToString();
+    }
+    public class EndpointNotFoundException : CommunicationException {
+        public EndpointNotFoundException();
+        public EndpointNotFoundException(string message);
+        public EndpointNotFoundException(string message, Exception innerException);
+    }
+    public sealed class EnvelopeVersion {
+        public string NextDestinationActorValue { get; }
+        public static EnvelopeVersion None { get; }
+        public static EnvelopeVersion Soap11 { get; }
+        public static EnvelopeVersion Soap12 { get; }
+        public string[] GetUltimateDestinationActorValues();
+        public override string ToString();
+    }
+    public class ExceptionDetail {
+        public ExceptionDetail(Exception exception);
+        public string HelpLink { get; set; }
+        public ExceptionDetail InnerException { get; set; }
+        public string Message { get; set; }
+        public string StackTrace { get; set; }
+        public string Type { get; set; }
+        public override string ToString();
+    }
+    public class ExceptionHelper {
+        public const string WinsdowsStreamSecurityNotSupported = "Windows Stream Security is not supported";
+        public ExceptionHelper();
+        public static Exception AsError(Exception exception);
+        public static Exception CreateMaxReceivedMessageSizeExceededException(long maxMessageSize);
+        public static PlatformNotSupportedException PlatformNotSupported();
+        public static PlatformNotSupportedException PlatformNotSupported(string message);
+    }
+    public sealed class ExtensionCollection<T> : SynchronizedCollection<IExtension<T>>, ICollection<IExtension<T>>, IEnumerable, IEnumerable<IExtension<T>>, IExtensionCollection<T> where T : IExtensibleObject<T> {
+        public ExtensionCollection(T owner);
+        public ExtensionCollection(T owner, object syncRoot);
+        bool System.Collections.Generic.ICollection<System.ServiceModel.IExtension<T>>.IsReadOnly { get; }
+        protected override void ClearItems();
+        public E Find<E>();
+        public Collection<E> FindAll<E>();
+        protected override void InsertItem(int index, IExtension<T> item);
+        protected override void RemoveItem(int index);
+        protected override void SetItem(int index, IExtension<T> item);
+    }
+    public class FaultCode {
+        public FaultCode(string name);
+        public FaultCode(string name, FaultCode subCode);
+        public FaultCode(string name, string ns);
+        public FaultCode(string name, string ns, FaultCode subCode);
+        public bool IsPredefinedFault { get; }
+        public bool IsReceiverFault { get; }
+        public bool IsSenderFault { get; }
+        public string Name { get; }
+        public string Namespace { get; }
+        public FaultCode SubCode { get; }
+        public static FaultCode CreateReceiverFaultCode(FaultCode subCode);
+        public static FaultCode CreateReceiverFaultCode(string name, string ns);
+        public static FaultCode CreateSenderFaultCode(FaultCode subCode);
+        public static FaultCode CreateSenderFaultCode(string name, string ns);
+    }
+    public sealed class FaultContractAttribute : Attribute {
+        public FaultContractAttribute(Type detailType);
+        public string Action { get; set; }
+        public Type DetailType { get; }
+        public bool HasProtectionLevel { get; }
+        public string Name { get; set; }
+        public string Namespace { get; set; }
+        public ProtectionLevel ProtectionLevel { get; set; }
+    }
+    public class FaultException : CommunicationException {
+        public FaultException();
+        public FaultException(MessageFault fault);
+        public FaultException(MessageFault fault, string action);
+        public FaultException(FaultReason reason);
+        public FaultException(FaultReason reason, FaultCode code);
+        public FaultException(FaultReason reason, FaultCode code, string action);
+        public FaultException(string reason);
+        public FaultException(string reason, FaultCode code);
+        public FaultException(string reason, FaultCode code, string action);
+        public string Action { get; }
+        public FaultCode Code { get; }
+        public override string Message { get; }
+        public FaultReason Reason { get; }
+        public static FaultException CreateFault(MessageFault messageFault, string action, params Type[] faultDetailTypes);
+        public static FaultException CreateFault(MessageFault messageFault, params Type[] faultDetailTypes);
+        public virtual MessageFault CreateMessageFault();
+    }
+    public class FaultException<TDetail> : FaultException {
+        public FaultException(TDetail detail);
+        public FaultException(TDetail detail, FaultReason reason);
+        public FaultException(TDetail detail, FaultReason reason, FaultCode code);
+        public FaultException(TDetail detail, FaultReason reason, FaultCode code, string action);
+        public FaultException(TDetail detail, string reason);
+        public FaultException(TDetail detail, string reason, FaultCode code);
+        public FaultException(TDetail detail, string reason, FaultCode code, string action);
+        public TDetail Detail { get; }
+        public override MessageFault CreateMessageFault();
+        public override string ToString();
+    }
+    public class FaultReason {
+        public FaultReason(IEnumerable<FaultReasonText> translations);
+        public FaultReason(FaultReasonText translation);
+        public FaultReason(string text);
+        public SynchronizedReadOnlyCollection<FaultReasonText> Translations { get; }
+        public FaultReasonText GetMatchingTranslation();
+        public FaultReasonText GetMatchingTranslation(CultureInfo cultureInfo);
+        public override string ToString();
+    }
+    public class FaultReasonText {
+        public FaultReasonText(string text);
+        public FaultReasonText(string text, CultureInfo cultureInfo);
+        public FaultReasonText(string text, string xmlLang);
+        public string Text { get; }
+        public string XmlLang { get; }
+        public bool Matches(CultureInfo cultureInfo);
+    }
+    public enum HostNameComparisonMode {
+        Exact = 1,
+        StrongWildcard = 0,
+        WeakWildcard = 2,
+    }
+    public static class HostNameComparisonModeHelper {
+        public static bool IsDefined(HostNameComparisonMode value);
+        public static void Validate(HostNameComparisonMode value);
+    }
+    public abstract class HttpBindingBase : Binding {
+        public bool AllowCookies { get; set; }
+        public EnvelopeVersion EnvelopeVersion { get; }
+        public HostNameComparisonMode HostNameComparisonMode { get; set; }
+        public long MaxBufferPoolSize { get; set; }
+        public int MaxBufferSize { get; set; }
+        public long MaxReceivedMessageSize { get; set; }
+        public XmlDictionaryReaderQuotas ReaderQuotas { get; set; }
+        public override string Scheme { get; }
+        bool System.ServiceModel.Channels.IBindingRuntimePreferences.ReceiveSynchronously { get; }
+        public Encoding TextEncoding { get; set; }
+        public TransferMode TransferMode { get; set; }
+        public bool UseDefaultWebProxy { get; }
+    }
+    public enum HttpClientCredentialType {
+        Basic = 1,
+        Certificate = 5,
+        Digest = 2,
+        InheritedFromHost = 6,
+        None = 0,
+        Ntlm = 3,
+        Windows = 4,
+    }
+    public sealed class HttpTransportSecurity {
+        public HttpTransportSecurity();
+        public HttpClientCredentialType ClientCredentialType { get; set; }
+        public string Realm { get; set; }
+    }
+    public interface IAsyncCommunicationObject : ICommunicationObject {
+        Task CloseAsync(TimeSpan timeout);
+        Task OpenAsync(TimeSpan timeout);
+    }
+    public interface IClientChannel : IChannel, ICommunicationObject, IContextChannel, IDisposable, IExtensibleObject<IContextChannel> {
+        bool AllowInitializationUI { get; set; }
+        bool DidInteractiveInitialization { get; }
+        Uri Via { get; }
+        event EventHandler<UnknownMessageReceivedEventArgs> UnknownMessageReceived;
+        IAsyncResult BeginDisplayInitializationUI(AsyncCallback callback, object state);
+        void DisplayInitializationUI();
+        void EndDisplayInitializationUI(IAsyncResult result);
+    }
+    public interface ICommunicationObject {
+        CommunicationState State { get; }
+        event EventHandler Closed;
+        event EventHandler Closing;
+        event EventHandler Faulted;
+        event EventHandler Opened;
+        event EventHandler Opening;
+        void Abort();
+        IAsyncResult BeginClose(AsyncCallback callback, object state);
+        IAsyncResult BeginClose(TimeSpan timeout, AsyncCallback callback, object state);
+        IAsyncResult BeginOpen(AsyncCallback callback, object state);
+        IAsyncResult BeginOpen(TimeSpan timeout, AsyncCallback callback, object state);
+        void Close();
+        void Close(TimeSpan timeout);
+        void EndClose(IAsyncResult result);
+        void EndOpen(IAsyncResult result);
+        void Open();
+        void Open(TimeSpan timeout);
+    }
+    public interface IContextChannel : IChannel, ICommunicationObject, IExtensibleObject<IContextChannel> {
+        bool AllowOutputBatching { get; set; }
+        IInputSession InputSession { get; }
+        EndpointAddress LocalAddress { get; }
+        TimeSpan OperationTimeout { get; set; }
+        IOutputSession OutputSession { get; }
+        EndpointAddress RemoteAddress { get; }
+        string SessionId { get; }
+    }
+    public interface IDefaultCommunicationTimeouts {
+        TimeSpan CloseTimeout { get; }
+        TimeSpan OpenTimeout { get; }
+        TimeSpan ReceiveTimeout { get; }
+        TimeSpan SendTimeout { get; }
+    }
+    public interface IDuplexContextChannel : IChannel, ICommunicationObject, IContextChannel, IExtensibleObject<IContextChannel> {
+        bool AutomaticInputSessionShutdown { get; set; }
+        InstanceContext CallbackInstance { get; set; }
+        IAsyncResult BeginCloseOutputSession(TimeSpan timeout, AsyncCallback callback, object state);
+        void CloseOutputSession(TimeSpan timeout);
+        void EndCloseOutputSession(IAsyncResult result);
+    }
+    public interface IExtensibleObject<T> where T : IExtensibleObject<T> {
+        IExtensionCollection<T> Extensions { get; }
+    }
+    public interface IExtension<T> where T : IExtensibleObject<T> {
+        void Attach(T owner);
+        void Detach(T owner);
+    }
+    public interface IExtensionCollection<T> : ICollection<IExtension<T>>, IEnumerable, IEnumerable<IExtension<T>> where T : IExtensibleObject<T> {
+        E Find<E>();
+        Collection<E> FindAll<E>();
+    }
+    public enum ImpersonationOption {
+        Allowed = 1,
+        NotAllowed = 0,
+        Required = 2,
+    }
+    public sealed class InstanceContext : CommunicationObject, IExtensibleObject<InstanceContext> {
+        public InstanceContext(object implementation);
+        protected override TimeSpan DefaultCloseTimeout { get; }
+        protected override TimeSpan DefaultOpenTimeout { get; }
+        public IExtensionCollection<InstanceContext> Extensions { get; }
+        public ICollection<IChannel> IncomingChannels { get; }
+        public ICollection<IChannel> OutgoingChannels { get; }
+        public SynchronizationContext SynchronizationContext { get; set; }
+        IExtensionCollection<InstanceContext> System.ServiceModel.IExtensibleObject<System.ServiceModel.InstanceContext>.Extensions { get; }
+        public object GetServiceInstance(Message message);
+        protected override void OnAbort();
+        protected override IAsyncResult OnBeginClose(TimeSpan timeout, AsyncCallback callback, object state);
+        protected override IAsyncResult OnBeginOpen(TimeSpan timeout, AsyncCallback callback, object state);
+        protected override void OnClose(TimeSpan timeout);
+        protected internal override Task OnCloseAsync(TimeSpan timeout);
+        protected override void OnClosed();
+        protected override void OnEndClose(IAsyncResult result);
+        protected override void OnEndOpen(IAsyncResult result);
+        protected override void OnFaulted();
+        protected override void OnOpen(TimeSpan timeout);
+        protected internal override Task OnOpenAsync(TimeSpan timeout);
+        protected override void OnOpened();
+        protected override void OnOpening();
+    }
+    public enum InstanceContextMode {
+        PerCall = 1,
+        PerSession = 0,
+        Single = 2,
+    }
+    public class InvalidMessageContractException : Exception {
+        public InvalidMessageContractException();
+        public InvalidMessageContractException(string message);
+        public InvalidMessageContractException(string message, Exception innerException);
+    }
+    public interface IServiceChannel : IChannel, ICommunicationObject, IContextChannel, IExtensibleObject<IContextChannel> {
+        Uri ListenUri { get; }
+    }
+    public class MessageBodyMemberAttribute : MessageContractMemberAttribute {
+        public MessageBodyMemberAttribute();
+        public int Order { get; set; }
+    }
+    public sealed class MessageContractAttribute : Attribute {
+        public MessageContractAttribute();
+        public bool HasProtectionLevel { get; }
+        public bool IsWrapped { get; set; }
+        public ProtectionLevel ProtectionLevel { get; set; }
+        public string WrapperName { get; set; }
+        public string WrapperNamespace { get; set; }
+    }
+    public abstract class MessageContractMemberAttribute : Attribute {
+        protected MessageContractMemberAttribute();
+        public bool HasProtectionLevel { get; }
+        public string Name { get; set; }
+        public string Namespace { get; set; }
+        public ProtectionLevel ProtectionLevel { get; set; }
+    }
+    public enum MessageCredentialType {
+        Certificate = 3,
+        IssuedToken = 4,
+        None = 0,
+        UserName = 2,
+        Windows = 1,
+    }
+    public class MessageHeader<T> {
+        public MessageHeader();
+        public MessageHeader(T content);
+        public MessageHeader(T content, bool mustUnderstand, string actor, bool relay);
+        public string Actor { get; set; }
+        public T Content { get; set; }
+        public bool MustUnderstand { get; set; }
+        public bool Relay { get; set; }
+        public MessageHeader GetUntypedHeader(string name, string ns);
+    }
+    public class MessageHeaderAttribute : MessageContractMemberAttribute {
+        public MessageHeaderAttribute();
+        public string Actor { get; set; }
+        public bool MustUnderstand { get; set; }
+        public bool Relay { get; set; }
+    }
+    public class MessageHeaderException : ProtocolException {
+        public MessageHeaderException();
+        public MessageHeaderException(string message);
+        public MessageHeaderException(string message, bool isDuplicate);
+        public MessageHeaderException(string message, Exception innerException);
+        public MessageHeaderException(string message, string headerName, string ns);
+        public MessageHeaderException(string message, string headerName, string ns, bool isDuplicate);
+        public MessageHeaderException(string message, string headerName, string ns, bool isDuplicate, Exception innerException);
+        public MessageHeaderException(string message, string headerName, string ns, Exception innerException);
+        public string HeaderName { get; }
+        public string HeaderNamespace { get; }
+        public bool IsDuplicate { get; }
+    }
+    public sealed class MessageParameterAttribute : Attribute {
+        public MessageParameterAttribute();
+        public string Name { get; set; }
+    }
+    public sealed class MessageSecurityOverTcp {
+        public MessageSecurityOverTcp();
+        public MessageCredentialType ClientCredentialType { get; set; }
+    }
+    public abstract class MessageSecurityVersion {
+        public abstract BasicSecurityProfileVersion BasicSecurityProfileVersion { get; }
+        public static MessageSecurityVersion Default { get; }
+        public SecureConversationVersion SecureConversationVersion { get; }
+        public abstract SecurityPolicyVersion SecurityPolicyVersion { get; }
+        public SecurityTokenVersion SecurityTokenVersion { get; }
+        public SecurityVersion SecurityVersion { get; }
+        public TrustVersion TrustVersion { get; }
+        public static MessageSecurityVersion WSSecurity10WSTrust13WSSecureConversation13WSSecurityPolicy12BasicSecurityProfile10 { get; }
+        public static MessageSecurityVersion WSSecurity10WSTrustFebruary2005WSSecureConversationFebruary2005WSSecurityPolicy11BasicSecurityProfile10 { get; }
+        public static MessageSecurityVersion WSSecurity11WSTrust13WSSecureConversation13WSSecurityPolicy12 { get; }
+        public static MessageSecurityVersion WSSecurity11WSTrust13WSSecureConversation13WSSecurityPolicy12BasicSecurityProfile10 { get; }
+        public static MessageSecurityVersion WSSecurity11WSTrustFebruary2005WSSecureConversationFebruary2005WSSecurityPolicy11 { get; }
+        public static MessageSecurityVersion WSSecurity11WSTrustFebruary2005WSSecureConversationFebruary2005WSSecurityPolicy11BasicSecurityProfile10 { get; }
+    }
+    public class NetHttpBinding : HttpBindingBase {
+        public NetHttpBinding();
+        public NetHttpBinding(BasicHttpSecurityMode securityMode);
+        public NetHttpBinding(string configurationName);
+        public NetHttpMessageEncoding MessageEncoding { get; set; }
+        public BasicHttpSecurity Security { get; set; }
+        public WebSocketTransportSettings WebSocketSettings { get; }
+        public override IChannelFactory<TChannel> BuildChannelFactory<TChannel>(BindingParameterCollection parameters);
+        public override BindingElementCollection CreateBindingElements();
+    }
+    public enum NetHttpMessageEncoding {
+        Binary = 0,
+        Mtom = 2,
+        Text = 1,
+    }
+    public class NetHttpsBinding : HttpBindingBase {
+        public NetHttpsBinding();
+        public NetHttpsBinding(BasicHttpsSecurityMode securityMode);
+        public NetHttpMessageEncoding MessageEncoding { get; set; }
+        public BasicHttpsSecurity Security { get; set; }
+        public WebSocketTransportSettings WebSocketSettings { get; }
+        public override IChannelFactory<TChannel> BuildChannelFactory<TChannel>(BindingParameterCollection parameters);
+        public override BindingElementCollection CreateBindingElements();
+    }
+    public class NetTcpBinding : Binding {
+        public NetTcpBinding();
+        public NetTcpBinding(SecurityMode securityMode);
+        public NetTcpBinding(string configurationName);
+        public EnvelopeVersion EnvelopeVersion { get; }
+        public long MaxBufferPoolSize { get; set; }
+        public int MaxBufferSize { get; set; }
+        public long MaxReceivedMessageSize { get; set; }
+        public XmlDictionaryReaderQuotas ReaderQuotas { get; set; }
+        public override string Scheme { get; }
+        public NetTcpSecurity Security { get; set; }
+        public TransferMode TransferMode { get; set; }
+        public override BindingElementCollection CreateBindingElements();
+    }
+    public sealed class NetTcpSecurity {
+        public NetTcpSecurity();
+        public MessageSecurityOverTcp Message { get; set; }
+        public SecurityMode Mode { get; set; }
+        public TcpTransportSecurity Transport { get; set; }
+    }
+    public sealed class OperationContext : IExtensibleObject<OperationContext> {
+        public OperationContext(IContextChannel channel);
+        public IContextChannel Channel { get; }
+        public ClaimsPrincipal ClaimsPrincipal { get; internal set; }
+        public static OperationContext Current { get; set; }
+        public EndpointDispatcher EndpointDispatcher { get; set; }
+        public IExtensionCollection<OperationContext> Extensions { get; }
+        public MessageHeaders IncomingMessageHeaders { get; }
+        public MessageProperties IncomingMessageProperties { get; }
+        public MessageVersion IncomingMessageVersion { get; }
+        public InstanceContext InstanceContext { get; }
+        public bool IsUserContext { get; }
+        public MessageHeaders OutgoingMessageHeaders { get; }
+        public MessageProperties OutgoingMessageProperties { get; }
+        public RequestContext RequestContext { get; set; }
+        public string SessionId { get; }
+        public event EventHandler OperationCompleted;
+        public T GetCallbackChannel<T>();
+    }
+    public sealed class OperationContextScope : IDisposable {
+        public OperationContextScope(IContextChannel channel);
+        public OperationContextScope(OperationContext context);
+        public void Dispose();
+    }
+    public sealed class OperationContractAttribute : Attribute {
+        public OperationContractAttribute();
+        public string Action { get; set; }
+        public bool AsyncPattern { get; set; }
+        public bool HasProtectionLevel { get; }
+        public bool IsInitiating { get; set; }
+        public bool IsOneWay { get; set; }
+        public string Name { get; set; }
+        public ProtectionLevel ProtectionLevel { get; set; }
+        public string ReplyAction { get; set; }
+    }
+    public enum OperationFormatStyle {
+        Document = 0,
+        Rpc = 1,
+    }
+    public class Pool<T> where T : class {
+        public Pool(int maxCount);
+        public int Count { get; }
+        public void Clear();
+        public bool Return(T item);
+        public T Take();
+    }
+    public class ProtocolException : CommunicationException {
+        public ProtocolException();
+        public ProtocolException(string message);
+        public ProtocolException(string message, Exception innerException);
+    }
+    public class QuotaExceededException : Exception {
+        public QuotaExceededException();
+        public QuotaExceededException(string message);
+        public QuotaExceededException(string message, Exception innerException);
+    }
+    public enum ReceiveErrorHandling {
+        Drop = 1,
+        Fault = 0,
+        Move = 3,
+        Reject = 2,
+    }
+    public enum SecurityMode {
+        Message = 2,
+        None = 0,
+        Transport = 1,
+        TransportWithMessageCredential = 3,
+    }
+    public static class SecurityModeHelper {
+        public static bool IsDefined(SecurityMode value);
+        public static SecurityMode ToSecurityMode(UnifiedSecurityMode value);
+    }
+    public class ServerTooBusyException : CommunicationException {
+        public ServerTooBusyException();
+        public ServerTooBusyException(string message);
+        public ServerTooBusyException(string message, Exception innerException);
+    }
+    public class ServiceActivationException : CommunicationException {
+        public ServiceActivationException();
+        public ServiceActivationException(string message);
+        public ServiceActivationException(string message, Exception innerException);
+    }
+    public sealed class ServiceContractAttribute : Attribute {
+        public ServiceContractAttribute();
+        public Type CallbackContract { get; set; }
+        public string ConfigurationName { get; set; }
+        public bool HasProtectionLevel { get; }
+        public string Name { get; set; }
+        public string Namespace { get; set; }
+        public ProtectionLevel ProtectionLevel { get; set; }
+        public SessionMode SessionMode { get; set; }
+    }
+    public static class ServiceDefaults {
+        public static TimeSpan CloseTimeout { get; }
+        public static TimeSpan OpenTimeout { get; }
+        public static TimeSpan ReceiveTimeout { get; }
+        public static TimeSpan SendTimeout { get; }
+    }
+    public sealed class ServiceKnownTypeAttribute : Attribute {
+        public ServiceKnownTypeAttribute(string methodName);
+        public ServiceKnownTypeAttribute(string methodName, Type declaringType);
+        public ServiceKnownTypeAttribute(Type type);
+        public Type DeclaringType { get; }
+        public string MethodName { get; }
+        public Type Type { get; }
+    }
+    public class ServiceSecurityContext {
+        public ServiceSecurityContext(ReadOnlyCollection<IAuthorizationPolicy> authorizationPolicies);
+        public ServiceSecurityContext(AuthorizationContext authorizationContext);
+        public ServiceSecurityContext(AuthorizationContext authorizationContext, ReadOnlyCollection<IAuthorizationPolicy> authorizationPolicies);
+        public static ServiceSecurityContext Anonymous { get; }
+        public AuthorizationContext AuthorizationContext { get; }
+        public ReadOnlyCollection<IAuthorizationPolicy> AuthorizationPolicies { get; set; }
+        public bool IsAnonymous { get; }
+        public IIdentity PrimaryIdentity { get; }
+    }
+    public enum SessionMode {
+        Allowed = 0,
+        NotAllowed = 2,
+        Required = 1,
+    }
+    public class SpnEndpointIdentity : EndpointIdentity {
+        public SpnEndpointIdentity(Claim identity);
+        public SpnEndpointIdentity(string spnName);
+        public static TimeSpan SpnLookupTime { get; set; }
+    }
+    public enum TcpClientCredentialType {
+        Certificate = 2,
+        None = 0,
+        Windows = 1,
+    }
+    public sealed class TcpTransportSecurity {
+        public TcpTransportSecurity();
+        public TcpClientCredentialType ClientCredentialType { get; set; }
+        public SslProtocols SslProtocols { get; set; }
+    }
+    public static class TimeSpanHelper {
+        public static TimeSpan FromMilliseconds(int ms, string text);
+        public static TimeSpan FromMinutes(int minutes, string text);
+        public static TimeSpan FromSeconds(int seconds, string text);
+    }
+    public enum TransferMode {
+        Buffered = 0,
+        Streamed = 1,
+        StreamedRequest = 2,
+        StreamedResponse = 3,
+    }
+    public static class TransferModeHelper {
+        public static bool IsDefined(TransferMode v);
+        public static bool IsRequestStreamed(TransferMode v);
+        public static bool IsResponseStreamed(TransferMode v);
+        public static void Validate(TransferMode value);
+    }
+    public enum UnifiedSecurityMode {
+        Both = 16,
+        Message = 8,
+        None = 1,
+        Transport = 4,
+        TransportCredentialOnly = 64,
+        TransportWithMessageCredential = 32,
+    }
+    public sealed class UnknownMessageReceivedEventArgs : EventArgs {
+        public Message Message { get; }
+    }
+    public class UpnEndpointIdentity : EndpointIdentity {
+        public UpnEndpointIdentity(Claim identity);
+        public UpnEndpointIdentity(string upnName);
+    }
+    public class UriSchemeKeyedCollection : SynchronizedKeyedCollection<string, Uri> {
+        public UriSchemeKeyedCollection(params Uri[] addresses);
+        protected override string GetKeyForItem(Uri item);
+        protected override void InsertItem(int index, Uri item);
+        protected override void SetItem(int index, Uri item);
+    }
+    public enum WSMessageEncoding {
+        Text = 0,
+    }
+    public class X509CertificateEndpointIdentity : EndpointIdentity {
+        public X509CertificateEndpointIdentity(X509Certificate2 certificate);
+        public X509CertificateEndpointIdentity(X509Certificate2 primaryCertificate, X509Certificate2Collection supportingCertificates);
+        public X509Certificate2Collection Certificates { get; }
+    }
+    public sealed class XmlSerializerFormatAttribute : Attribute {
+        public XmlSerializerFormatAttribute();
+        public OperationFormatStyle Style { get; set; }
+        public bool SupportFaults { get; set; }
+    }
+}
```

## System.ServiceModel.Channels

```c#
+namespace System.ServiceModel.Channels {
+    public abstract class AddressHeader {
+        protected AddressHeader();
+        public abstract string Name { get; }
+        public abstract string Namespace { get; }
+        public static AddressHeader CreateAddressHeader(object value);
+        public static AddressHeader CreateAddressHeader(object value, XmlObjectSerializer serializer);
+        public static AddressHeader CreateAddressHeader(string name, string ns, object value);
+        public static AddressHeader CreateAddressHeader(string name, string ns, object value, XmlObjectSerializer serializer);
+        public override bool Equals(object obj);
+        public virtual XmlDictionaryReader GetAddressHeaderReader();
+        public override int GetHashCode();
+        public T GetValue<T>();
+        public T GetValue<T>(XmlObjectSerializer serializer);
+        protected abstract void OnWriteAddressHeaderContents(XmlDictionaryWriter writer);
+        protected virtual void OnWriteStartAddressHeader(XmlDictionaryWriter writer);
+        public MessageHeader ToMessageHeader();
+        public void WriteAddressHeader(XmlDictionaryWriter writer);
+        public void WriteAddressHeader(XmlWriter writer);
+        public void WriteAddressHeaderContents(XmlDictionaryWriter writer);
+        public void WriteStartAddressHeader(XmlDictionaryWriter writer);
+    }
+    public sealed class AddressHeaderCollection : ReadOnlyCollection<AddressHeader> {
+        public AddressHeaderCollection();
+        public AddressHeaderCollection(IEnumerable<AddressHeader> addressHeaders);
+        public void AddHeadersTo(Message message);
+        public AddressHeader[] FindAll(string name, string ns);
+        public AddressHeader FindHeader(string name, string ns);
+    }
+    public sealed class AddressingVersion {
+        public static AddressingVersion None { get; }
+        public static AddressingVersion WSAddressing10 { get; }
+        public override string ToString();
+    }
+    public sealed class ApplicationContainerSettings {
+        public const int CurrentSession = -1;
+        public const int ServiceSession = 0;
+        public string PackageFullName { get; set; }
+        public int SessionId { get; set; }
+    }
+    public static class ApplicationContainerSettingsDefaults {
+        public const int CurrentSession = -1;
+        public const int ServiceSession = 0;
+        public const string CurrentUserSessionDefaultString = "CurrentSession";
+        public const string PackageFullNameDefaultString = null;
+        public const string Session0ServiceSessionString = "ServiceSession";
+    }
+    public static class BasicHttpBindingDefaults {
+        public const BasicHttpMessageCredentialType MessageSecurityClientCredentialType = 0;
+        public const TransferMode TransferMode = 0;
+        public const WSMessageEncoding MessageEncoding = 0;
+        public static Encoding TextEncoding { get; }
+    }
+    public static class BinaryEncoderDefaults {
+        public const int MaxSessionSize = 2048;
+        public static BinaryVersion BinaryVersion { get; }
+        public static EnvelopeVersion EnvelopeVersion { get; }
+    }
+    public sealed class BinaryMessageEncodingBindingElement : MessageEncodingBindingElement {
+        public BinaryMessageEncodingBindingElement();
+        public CompressionFormat CompressionFormat { get; set; }
+        public int MaxReadPoolSize { get; set; }
+        public int MaxSessionSize { get; set; }
+        public int MaxWritePoolSize { get; set; }
+        public override MessageVersion MessageVersion { get; set; }
+        public XmlDictionaryReaderQuotas ReaderQuotas { get; set; }
+        public override IChannelFactory<TChannel> BuildChannelFactory<TChannel>(BindingContext context);
+        public override BindingElement Clone();
+        public override MessageEncoderFactory CreateMessageEncoderFactory();
+        public override T GetProperty<T>(BindingContext context);
+        public bool ShouldSerializeMessageVersion();
+        public bool ShouldSerializeReaderQuotas();
+    }
+    public class BinaryVersion {
+        public static readonly BinaryVersion DeflateVersion1;
+        public static readonly BinaryVersion GZipVersion1;
+        public static readonly BinaryVersion Version1;
+        public string ContentType { get; }
+        public static BinaryVersion CurrentVersion { get; }
+        public IXmlDictionary Dictionary { get; }
+        public string SessionContentType { get; }
+    }
+    public abstract class Binding : IDefaultCommunicationTimeouts {
+        protected Binding();
+        protected Binding(string name, string ns);
+        public TimeSpan CloseTimeout { get; set; }
+        public MessageVersion MessageVersion { get; }
+        public string Name { get; set; }
+        public string Namespace { get; set; }
+        public TimeSpan OpenTimeout { get; set; }
+        public TimeSpan ReceiveTimeout { get; set; }
+        public abstract string Scheme { get; }
+        public TimeSpan SendTimeout { get; set; }
+        public IChannelFactory<TChannel> BuildChannelFactory<TChannel>(params object[] parameters);
+        public virtual IChannelFactory<TChannel> BuildChannelFactory<TChannel>(BindingParameterCollection parameters);
+        public bool CanBuildChannelFactory<TChannel>(params object[] parameters);
+        public virtual bool CanBuildChannelFactory<TChannel>(BindingParameterCollection parameters);
+        public abstract BindingElementCollection CreateBindingElements();
+        public T GetProperty<T>(BindingParameterCollection parameters) where T : class;
+    }
+    public class BindingContext {
+        public BindingContext(CustomBinding binding, BindingParameterCollection parameters);
+        public CustomBinding Binding { get; }
+        public BindingParameterCollection BindingParameters { get; }
+        public Uri ListenUriBaseAddress { get; set; }
+        public ListenUriMode ListenUriMode { get; set; }
+        public string ListenUriRelativeAddress { get; set; }
+        public BindingElementCollection RemainingBindingElements { get; }
+        public IChannelFactory<TChannel> BuildInnerChannelFactory<TChannel>();
+        public bool CanBuildInnerChannelFactory<TChannel>();
+        public BindingContext Clone();
+        public T GetInnerProperty<T>() where T : class;
+    }
+    public abstract class BindingElement {
+        protected BindingElement();
+        protected BindingElement(BindingElement elementToBeCloned);
+        public virtual IChannelFactory<TChannel> BuildChannelFactory<TChannel>(BindingContext context);
+        public virtual bool CanBuildChannelFactory<TChannel>(BindingContext context);
+        public abstract BindingElement Clone();
+        public abstract T GetProperty<T>(BindingContext context) where T : class;
+    }
+    public class BindingElementCollection : Collection<BindingElement> {
+        public BindingElementCollection();
+        public BindingElementCollection(IEnumerable<BindingElement> elements);
+        public BindingElementCollection(BindingElement[] elements);
+        public void AddRange(params BindingElement[] elements);
+        public BindingElementCollection Clone();
+        public bool Contains(Type bindingElementType);
+        public T Find<T>();
+        public Collection<T> FindAll<T>();
+        protected override void InsertItem(int index, BindingElement item);
+        public T Remove<T>();
+        public Collection<T> RemoveAll<T>();
+        protected override void SetItem(int index, BindingElement item);
+    }
+    public class BindingParameterCollection : KeyedCollection<Type, object> {
+        public BindingParameterCollection();
+        protected override Type GetKeyForItem(object item);
+        protected override void InsertItem(int index, object item);
+        protected override void SetItem(int index, object item);
+    }
+    public abstract class BodyWriter {
+        protected BodyWriter(bool isBuffered);
+        public bool IsBuffered { get; }
+        public IAsyncResult BeginWriteBodyContents(XmlDictionaryWriter writer, AsyncCallback callback, object state);
+        public BodyWriter CreateBufferedCopy(int maxBufferSize);
+        public void EndWriteBodyContents(IAsyncResult result);
+        protected virtual IAsyncResult OnBeginWriteBodyContents(XmlDictionaryWriter writer, AsyncCallback callback, object state);
+        protected virtual BodyWriter OnCreateBufferedCopy(int maxBufferSize);
+        protected virtual void OnEndWriteBodyContents(IAsyncResult result);
+        protected abstract void OnWriteBodyContents(XmlDictionaryWriter writer);
+        protected virtual Task OnWriteBodyContentsAsync(XmlDictionaryWriter writer);
+        public void WriteBodyContents(XmlDictionaryWriter writer);
+    }
+    public abstract class BufferManager {
+        protected BufferManager();
+        public abstract void Clear();
+        public static BufferManager CreateBufferManager(long maxBufferPoolSize, int maxBufferSize);
+        public abstract void ReturnBuffer(byte[] buffer);
+        public abstract byte[] TakeBuffer(int bufferSize);
+    }
+    public abstract class ChannelBase : CommunicationObject, IChannel, ICommunicationObject, IDefaultCommunicationTimeouts {
+        protected ChannelBase(ChannelManagerBase channelManager);
+        protected override TimeSpan DefaultCloseTimeout { get; }
+        protected override TimeSpan DefaultOpenTimeout { get; }
+        protected TimeSpan DefaultReceiveTimeout { get; }
+        protected TimeSpan DefaultSendTimeout { get; }
+        protected ChannelManagerBase Manager { get; }
+        TimeSpan System.ServiceModel.IDefaultCommunicationTimeouts.CloseTimeout { get; }
+        TimeSpan System.ServiceModel.IDefaultCommunicationTimeouts.OpenTimeout { get; }
+        TimeSpan System.ServiceModel.IDefaultCommunicationTimeouts.ReceiveTimeout { get; }
+        TimeSpan System.ServiceModel.IDefaultCommunicationTimeouts.SendTimeout { get; }
+        public virtual T GetProperty<T>() where T : class;
+        protected override void OnClosed();
+    }
+    public abstract class ChannelFactoryBase : ChannelManagerBase, IChannelFactory, ICommunicationObject {
+        protected ChannelFactoryBase();
+        protected ChannelFactoryBase(IDefaultCommunicationTimeouts timeouts);
+        protected override TimeSpan DefaultCloseTimeout { get; }
+        protected override TimeSpan DefaultOpenTimeout { get; }
+        protected override TimeSpan DefaultReceiveTimeout { get; }
+        protected override TimeSpan DefaultSendTimeout { get; }
+        public virtual T GetProperty<T>() where T : class;
+        protected override void OnAbort();
+        protected override IAsyncResult OnBeginClose(TimeSpan timeout, AsyncCallback callback, object state);
+        protected override void OnClose(TimeSpan timeout);
+        protected internal override Task OnCloseAsync(TimeSpan timeout);
+        protected override void OnEndClose(IAsyncResult result);
+    }
+    public abstract class ChannelFactoryBase<TChannel> : ChannelFactoryBase, IChannelFactory, IChannelFactory<TChannel>, ICommunicationObject {
+        protected ChannelFactoryBase();
+        protected ChannelFactoryBase(IDefaultCommunicationTimeouts timeouts);
+        public TChannel CreateChannel(EndpointAddress address);
+        public TChannel CreateChannel(EndpointAddress address, Uri via);
+        protected override void OnAbort();
+        protected override IAsyncResult OnBeginClose(TimeSpan timeout, AsyncCallback callback, object state);
+        protected override void OnClose(TimeSpan timeout);
+        protected internal override Task OnCloseAsync(TimeSpan timeout);
+        protected abstract TChannel OnCreateChannel(EndpointAddress address, Uri via);
+        protected override void OnEndClose(IAsyncResult result);
+        protected void ValidateCreateChannel();
+    }
+    public abstract class ChannelManagerBase : CommunicationObject, IDefaultCommunicationTimeouts {
+        protected ChannelManagerBase();
+        protected abstract TimeSpan DefaultReceiveTimeout { get; }
+        protected abstract TimeSpan DefaultSendTimeout { get; }
+        TimeSpan System.ServiceModel.IDefaultCommunicationTimeouts.CloseTimeout { get; }
+        TimeSpan System.ServiceModel.IDefaultCommunicationTimeouts.OpenTimeout { get; }
+        TimeSpan System.ServiceModel.IDefaultCommunicationTimeouts.ReceiveTimeout { get; }
+        TimeSpan System.ServiceModel.IDefaultCommunicationTimeouts.SendTimeout { get; }
+    }
+    public class ChannelParameterCollection : Collection<object> {
+        public ChannelParameterCollection();
+        public ChannelParameterCollection(IChannel channel);
+        protected virtual IChannel Channel { get; }
+        protected override void ClearItems();
+        protected override void InsertItem(int index, object item);
+        public void PropagateChannelParameters(IChannel innerChannel);
+        protected override void RemoveItem(int index);
+        protected override void SetItem(int index, object item);
+    }
+    public abstract class ClientWebSocketFactory {
+        protected ClientWebSocketFactory();
+        public abstract Task<WebSocket> CreateWebSocketAsync(Uri address, WebHeaderCollection headers, ICredentials credentials, WebSocketTransportSettings settings, TimeoutHelper timeoutHelper);
+        public static ClientWebSocketFactory GetFactory();
+    }
+    public abstract class CommunicationObject : ICommunicationObject {
+        protected CommunicationObject();
+        protected CommunicationObject(object mutex);
+        protected abstract TimeSpan DefaultCloseTimeout { get; }
+        protected abstract TimeSpan DefaultOpenTimeout { get; }
+        protected bool IsDisposed { get; }
+        public CommunicationState State { get; }
+        protected object ThisLock { get; }
+        public event EventHandler Closed;
+        public event EventHandler Closing;
+        public event EventHandler Faulted;
+        public event EventHandler Opened;
+        public event EventHandler Opening;
+        public void Abort();
+        public IAsyncResult BeginClose(AsyncCallback callback, object state);
+        public IAsyncResult BeginClose(TimeSpan timeout, AsyncCallback callback, object state);
+        public IAsyncResult BeginOpen(AsyncCallback callback, object state);
+        public IAsyncResult BeginOpen(TimeSpan timeout, AsyncCallback callback, object state);
+        public void Close();
+        public void Close(TimeSpan timeout);
+        public void EndClose(IAsyncResult result);
+        public void EndOpen(IAsyncResult result);
+        protected void Fault();
+        protected virtual Type GetCommunicationObjectType();
+        protected abstract void OnAbort();
+        protected abstract IAsyncResult OnBeginClose(TimeSpan timeout, AsyncCallback callback, object state);
+        protected abstract IAsyncResult OnBeginOpen(TimeSpan timeout, AsyncCallback callback, object state);
+        protected abstract void OnClose(TimeSpan timeout);
+        protected internal virtual Task OnCloseAsync(TimeSpan timeout);
+        protected virtual void OnClosed();
+        protected virtual void OnClosing();
+        protected abstract void OnEndClose(IAsyncResult result);
+        protected abstract void OnEndOpen(IAsyncResult result);
+        protected virtual void OnFaulted();
+        protected abstract void OnOpen(TimeSpan timeout);
+        protected internal virtual Task OnOpenAsync(TimeSpan timeout);
+        protected virtual void OnOpened();
+        protected virtual void OnOpening();
+        public void Open();
+        public void Open(TimeSpan timeout);
+        Task System.ServiceModel.IAsyncCommunicationObject.CloseAsync(TimeSpan timeout);
+        Task System.ServiceModel.IAsyncCommunicationObject.OpenAsync(TimeSpan timeout);
+        protected internal void ThrowIfDisposed();
+        protected internal void ThrowIfDisposedOrImmutable();
+        protected internal void ThrowIfDisposedOrNotOpen();
+    }
+    public static class CommunicationObjectInternal {
+        public static TimeSpan GetInternalCloseTimeout(this CommunicationObject communicationObject);
+        public static IAsyncResult OnBeginClose(CommunicationObject communicationObject, TimeSpan timeout, AsyncCallback callback, object state);
+        public static IAsyncResult OnBeginOpen(CommunicationObject communicationObject, TimeSpan timeout, AsyncCallback callback, object state);
+        public static void OnClose(CommunicationObject communicationObject, TimeSpan timeout);
+        public static Task OnCloseAsyncInternal(CommunicationObject communicationObject, TimeSpan timeout);
+        public static void OnEnd(IAsyncResult result);
+        public static void OnOpen(CommunicationObject communicationObject, TimeSpan timeout);
+        public static Task OnOpenAsyncInternal(CommunicationObject communicationObject, TimeSpan timeout);
+        public static void ThrowIfClosed(CommunicationObject communicationObject);
+        public static void ThrowIfClosedOrOpened(CommunicationObject communicationObject);
+        public static void ThrowIfDisposed(CommunicationObject communicationObject);
+        public static void ThrowIfDisposedOrNotOpen(CommunicationObject communicationObject);
+    }
+    public abstract class CommunicationPool<TKey, TItem> where TKey : class where TItem : class {
+        protected CommunicationPool(int maxCount);
+        public int MaxIdleConnectionPoolCount { get; }
+        protected object ThisLock { get; }
+        protected abstract void AbortItem(TItem item);
+        public void AddConnection(TKey key, TItem connection, TimeSpan timeout);
+        public bool Close(TimeSpan timeout);
+        protected abstract void CloseItem(TItem item, TimeSpan timeout);
+        protected abstract void CloseItemAsync(TItem item, TimeSpan timeout);
+        protected virtual CommunicationPool<TKey, TItem>.EndpointConnectionPool CreateEndpointConnectionPool(TKey key);
+        protected abstract TKey GetPoolKey(EndpointAddress address, Uri via);
+        protected virtual void OnClosed();
+        public void ReturnConnection(TKey key, TItem connection, bool connectionIsStillGood, TimeSpan timeout);
+        public TItem TakeConnection(EndpointAddress address, Uri via, TimeSpan timeout, out TKey key);
+        public bool TryOpen();
+        protected class EndpointConnectionPool {
+            public EndpointConnectionPool(CommunicationPool<TKey, TItem> parent, TKey key);
+            protected TKey Key { get; }
+            protected CommunicationPool<TKey, TItem> Parent { get; }
+            protected object ThisLock { get; }
+            public void Abort();
+            protected virtual void AbortItem(TItem item);
+            public void AddConnection(TItem connection, TimeSpan timeout);
+            public void Close(TimeSpan timeout);
+            public void CloseIdleConnection(TItem connection, TimeSpan timeout);
+            public bool CloseIfEmpty();
+            protected virtual void CloseItem(TItem item, TimeSpan timeout);
+            protected virtual void CloseItemAsync(TItem item, TimeSpan timeout);
+            protected virtual CommunicationPool<TKey, TItem>.IdleConnectionPool GetIdleConnectionPool();
+            protected virtual void OnConnectionAborted();
+            public virtual void Prune(List<TItem> itemsToClose);
+            public void ReturnConnection(TItem connection, bool connectionIsStillGood, TimeSpan timeout);
+            public TItem TakeConnection(TimeSpan timeout);
+            protected class PoolIdleConnectionPool : CommunicationPool<TKey, TItem>.IdleConnectionPool {
+                public PoolIdleConnectionPool(int maxCount);
+                public override int Count { get; }
+                public override bool Add(TItem connection);
+                public override bool Return(TItem connection);
+                public override TItem Take(out bool closeItem);
+            }
+        }
+        protected abstract class IdleConnectionPool {
+            protected IdleConnectionPool();
+            public abstract int Count { get; }
+            public abstract bool Add(TItem item);
+            public abstract bool Return(TItem item);
+            public abstract TItem Take(out bool closeItem);
+        }
+    }
+    public enum CompressionFormat {
+        Deflate = 2,
+        GZip = 1,
+        None = 0,
+    }
+    public abstract class ConnectionOrientedTransportBindingElement : TransportBindingElement {
+        public int ConnectionBufferSize { get; set; }
+        public int MaxBufferSize { get; set; }
+        public TransferMode TransferMode { get; set; }
+        public override bool CanBuildChannelFactory<TChannel>(BindingContext context);
+        public override T GetProperty<T>(BindingContext context);
+    }
+    public static class ConnectionOrientedTransportDefaults {
+        public const bool AllowNtlm = true;
+        public const int ConnectionBufferSize = 8192;
+        public const int MaxContentTypeSize = 256;
+        public const int MaxOutboundConnectionsPerEndpoint = 10;
+        public const int MaxPendingAcceptsConst = 0;
+        public const int MaxPendingConnectionsConst = 0;
+        public const int MaxViaSize = 2048;
+        public const ProtectionLevel ProtectionLevel = 2;
+        public const HostNameComparisonMode HostNameComparisonMode = 0;
+        public const TransferMode TransferMode = 0;
+        public const string ChannelInitializationTimeoutString = "00:00:30";
+        public const string ConnectionPoolGroupName = "default";
+        public const string IdleTimeoutString = "00:02:00";
+        public const string MaxOutputDelayString = "00:00:00.2";
+        public static TimeSpan ChannelInitializationTimeout { get; }
+        public static TimeSpan IdleTimeout { get; }
+        public static TimeSpan MaxOutputDelay { get; }
+        public static int GetMaxConnections();
+        public static int GetMaxPendingAccepts();
+        public static int GetMaxPendingConnections();
+    }
+    public abstract class ConnectionPool : IdlingCommunicationPool<string, IConnection> {
+        protected ConnectionPool(IConnectionOrientedTransportChannelFactorySettings settings, TimeSpan leaseTimeout);
+        public string Name { get; }
+        protected override void AbortItem(IConnection item);
+        protected override void CloseItem(IConnection item, TimeSpan timeout);
+        protected override void CloseItemAsync(IConnection item, TimeSpan timeout);
+        public virtual bool IsCompatible(IConnectionOrientedTransportChannelFactorySettings settings);
+    }
+    public abstract class ConnectionPoolRegistry {
+        protected ConnectionPoolRegistry();
+        protected abstract ConnectionPool CreatePool(IConnectionOrientedTransportChannelFactorySettings settings);
+        public ConnectionPool Lookup(IConnectionOrientedTransportChannelFactorySettings settings);
+        public void Release(ConnectionPool pool, TimeSpan timeout);
+    }
+    public class CustomBinding : Binding {
+        public CustomBinding();
+        public CustomBinding(IEnumerable<BindingElement> bindingElementsInTopDownChannelStackOrder);
+        public CustomBinding(Binding binding);
+        public CustomBinding(params BindingElement[] bindingElementsInTopDownChannelStackOrder);
+        public CustomBinding(string name, string ns, params BindingElement[] bindingElementsInTopDownChannelStackOrder);
+        public BindingElementCollection Elements { get; }
+        public override string Scheme { get; }
+        public override BindingElementCollection CreateBindingElements();
+    }
+    public abstract class DelegatingStream : Stream {
+        protected DelegatingStream(Stream stream);
+        protected Stream BaseStream { get; }
+        public override bool CanRead { get; }
+        public override bool CanSeek { get; }
+        public override bool CanTimeout { get; }
+        public override bool CanWrite { get; }
+        public override long Length { get; }
+        public override long Position { get; set; }
+        public override int ReadTimeout { get; set; }
+        public override int WriteTimeout { get; set; }
+        public override Task CopyToAsync(Stream destination, int bufferSize, CancellationToken cancellationToken);
+        protected override void Dispose(bool disposing);
+        public override void Flush();
+        public override Task FlushAsync(CancellationToken cancellationToken);
+        public override int Read(byte[] buffer, int offset, int count);
+        public override Task<int> ReadAsync(byte[] buffer, int offset, int count, CancellationToken cancellationToken);
+        public override int ReadByte();
+        public override long Seek(long offset, SeekOrigin origin);
+        public override void SetLength(long value);
+        public override void Write(byte[] buffer, int offset, int count);
+        public override Task WriteAsync(byte[] buffer, int offset, int count, CancellationToken cancellationToken);
+        public override void WriteByte(byte value);
+    }
+    public static class EncoderDefaults {
+        public const int BufferedReadDefaultMaxArrayLength = 2147483647;
+        public const int BufferedReadDefaultMaxBytesPerRead = 2147483647;
+        public const int BufferedReadDefaultMaxDepth = 128;
+        public const int BufferedReadDefaultMaxNameTableCharCount = 2147483647;
+        public const int BufferedReadDefaultMaxStringContentLength = 2147483647;
+        public const int MaxArrayLength = 16384;
+        public const int MaxBytesPerRead = 4096;
+        public const int MaxDepth = 32;
+        public const int MaxNameTableCharCount = 16384;
+        public const int MaxReadPoolSize = 64;
+        public const int MaxStringContentLength = 8192;
+        public const int MaxWritePoolSize = 16;
+        public const CompressionFormat DefaultCompressionFormat = 0;
+        public static readonly XmlDictionaryReaderQuotas ReaderQuotas;
+        public static bool IsDefaultReaderQuotas(XmlDictionaryReaderQuotas quotas);
+    }
+    public abstract class FaultConverter {
+        protected FaultConverter();
+        public static FaultConverter GetDefaultFaultConverter(MessageVersion version);
+        protected abstract bool OnTryCreateException(Message message, MessageFault fault, out Exception exception);
+        protected abstract bool OnTryCreateFaultMessage(Exception exception, out Message message);
+        public bool TryCreateException(Message message, MessageFault fault, out Exception exception);
+        public bool TryCreateFaultMessage(Exception exception, out Message message);
+    }
+    public class HttpMessageHandlerFactory {
+        [MethodImpl(NoInlining)]protected HttpMessageHandlerFactory();
+        [MethodImpl(NoInlining)]public HttpMessageHandlerFactory(Func<IEnumerable<DelegatingHandler>> handlers);
+        [MethodImpl(NoInlining)]public HttpMessageHandlerFactory(params Type[] handlers);
+        [MethodImpl(NoInlining)]public HttpMessageHandler Create(HttpMessageHandler innerChannel);
+        protected virtual HttpMessageHandler OnCreate(HttpMessageHandler innerChannel);
+    }
+    public static class HttpRequestMessageExtensionMethods {
+        public static bool CreateContentIfNull(this HttpRequestMessage httpRequestMessage);
+    }
+    public sealed class HttpRequestMessageProperty : IMessageProperty {
+        public HttpRequestMessageProperty();
+        public WebHeaderCollection Headers { get; }
+        public HttpRequestMessage HttpRequestMessage { get; }
+        public string Method { get; set; }
+        public static string Name { get; }
+        public string QueryString { get; set; }
+        public bool SuppressEntityBody { get; set; }
+        IMessageProperty System.ServiceModel.Channels.IMessageProperty.CreateCopy();
+    }
+    public sealed class HttpResponseMessageProperty : IMessageProperty {
+        public HttpResponseMessageProperty();
+        public WebHeaderCollection Headers { get; }
+        public HttpResponseMessage HttpResponseMessage { get; }
+        public static string Name { get; }
+        public HttpStatusCode StatusCode { get; set; }
+        public string StatusDescription { get; set; }
+        public bool SuppressEntityBody { get; set; }
+        public bool SuppressPreamble { get; set; }
+        IMessageProperty System.ServiceModel.Channels.IMessageProperty.CreateCopy();
+    }
+    public class HttpsTransportBindingElement : HttpTransportBindingElement {
+        public HttpsTransportBindingElement();
+        protected HttpsTransportBindingElement(HttpsTransportBindingElement elementToBeCloned);
+        public bool RequireClientCertificate { get; set; }
+        public override string Scheme { get; }
+        public override IChannelFactory<TChannel> BuildChannelFactory<TChannel>(BindingContext context);
+        public override BindingElement Clone();
+        public override T GetProperty<T>(BindingContext context);
+    }
+    public class HttpTransportBindingElement : TransportBindingElement {
+        public HttpTransportBindingElement();
+        protected HttpTransportBindingElement(HttpTransportBindingElement elementToBeCloned);
+        public bool AllowCookies { get; set; }
+        public AuthenticationSchemes AuthenticationScheme { get; set; }
+        public bool DecompressionEnabled { get; set; }
+        public ExtendedProtectionPolicy ExtendedProtectionPolicy { get; set; }
+        public HostNameComparisonMode HostNameComparisonMode { get; set; }
+        public bool KeepAliveEnabled { get; set; }
+        public int MaxBufferSize { get; set; }
+        public int MaxPendingAccepts { get; set; }
+        public HttpMessageHandlerFactory MessageHandlerFactory { get; set; }
+        public string Realm { get; set; }
+        public TimeSpan RequestInitializationTimeout { get; set; }
+        public override string Scheme { get; }
+        public TransferMode TransferMode { get; set; }
+        public bool UnsafeConnectionNtlmAuthentication { get; set; }
+        public bool UseDefaultWebProxy { get; }
+        public WebSocketTransportSettings WebSocketSettings { get; set; }
+        public override IChannelFactory<TChannel> BuildChannelFactory<TChannel>(BindingContext context);
+        public override bool CanBuildChannelFactory<TChannel>(BindingContext context);
+        public override BindingElement Clone();
+        public override T GetProperty<T>(BindingContext context);
+    }
+    public static class HttpTransportDefaults {
+        public const bool AllowCookies = false;
+        public const bool DecompressionEnabled = true;
+        public const bool KeepAliveEnabled = true;
+        public const bool UnsafeConnectionNtlmAuthentication = false;
+        public const bool UseDefaultWebProxy = true;
+        public const int DefaultMaxPendingAccepts = 0;
+        public const int MaxPendingAcceptsUpperLimit = 100000;
+        public const AuthenticationSchemes AuthenticationScheme = 32768;
+        public const HttpMessageHandlerFactory MessageHandlerFactory = null;
+        public const HostNameComparisonMode HostNameComparisonMode = 0;
+        public const TransferMode TransferMode = 0;
+        public const string ConnectionHeader = "Connection";
+        public const string Realm = "";
+        public const string RequestInitializationTimeoutString = "00:00:00";
+        public const string UpgradeHeader = "Upgrade";
+        public static TimeSpan RequestInitializationTimeout { get; }
+        public static MessageEncoderFactory GetDefaultMessageEncoderFactory();
+        public static WebSocketTransportSettings GetDefaultWebSocketTransportSettings();
+        public static int GetEffectiveMaxPendingAccepts(int maxPendingAccepts);
+    }
+    public interface IAsyncChannelFactory : IAsyncCommunicationObject, IChannelFactory, ICommunicationObject
+    public interface IAsyncRequest : IRequestBase {
+        Task<Message> ReceiveReplyAsync(TimeoutHelper timeoutHelper);
+        Task SendRequestAsync(Message message, TimeoutHelper timeoutHelper);
+    }
+    public interface IBindingDeliveryCapabilities {
+        bool AssuresOrderedDelivery { get; }
+        bool QueuedDelivery { get; }
+    }
+    public interface IBindingMulticastCapabilities {
+        bool IsMulticast { get; }
+    }
+    public interface IBindingRuntimePreferences {
+        bool ReceiveSynchronously { get; }
+    }
+    public interface IChannel : ICommunicationObject {
+        T GetProperty<T>() where T : class;
+    }
+    public interface IChannelFactory : ICommunicationObject {
+        T GetProperty<T>() where T : class;
+    }
+    public interface IChannelFactory<TChannel> : IChannelFactory, ICommunicationObject {
+        TChannel CreateChannel(EndpointAddress to);
+        TChannel CreateChannel(EndpointAddress to, Uri via);
+    }
+    public interface IChannelListener : ICommunicationObject {
+        Uri Uri { get; }
+        IAsyncResult BeginWaitForChannel(TimeSpan timeout, AsyncCallback callback, object state);
+        bool EndWaitForChannel(IAsyncResult result);
+        T GetProperty<T>() where T : class;
+        bool WaitForChannel(TimeSpan timeout);
+    }
+    public interface IChannelListener<TChannel> : IChannelListener, ICommunicationObject where TChannel : class, IChannel {
+        TChannel AcceptChannel();
+        TChannel AcceptChannel(TimeSpan timeout);
+        IAsyncResult BeginAcceptChannel(AsyncCallback callback, object state);
+        IAsyncResult BeginAcceptChannel(TimeSpan timeout, AsyncCallback callback, object state);
+        TChannel EndAcceptChannel(IAsyncResult result);
+    }
+    public interface IConnection {
+        byte[] AsyncReadBuffer { get; }
+        int AsyncReadBufferSize { get; }
+        void Abort();
+        AsyncCompletionResult BeginRead(int offset, int size, TimeSpan timeout, Action<object> callback, object state);
+        AsyncCompletionResult BeginWrite(byte[] buffer, int offset, int size, bool immediate, TimeSpan timeout, Action<object> callback, object state);
+        void Close(TimeSpan timeout, bool asyncAndLinger);
+        int EndRead();
+        void EndWrite();
+        object GetCoreTransport();
+        int Read(byte[] buffer, int offset, int size, TimeSpan timeout);
+        void Write(byte[] buffer, int offset, int size, bool immediate, TimeSpan timeout);
+        void Write(byte[] buffer, int offset, int size, bool immediate, TimeSpan timeout, BufferManager bufferManager);
+    }
+    public interface IConnectionInitiator {
+        IConnection Connect(Uri uri, TimeSpan timeout);
+        Task<IConnection> ConnectAsync(Uri uri, TimeSpan timeout);
+    }
+    public interface IConnectionOrientedConnectionSettings {
+        int ConnectionBufferSize { get; }
+        TimeSpan IdleTimeout { get; }
+        TimeSpan MaxOutputDelay { get; }
+    }
+    public interface IConnectionOrientedTransportChannelFactorySettings : IConnectionOrientedConnectionSettings, IConnectionOrientedTransportFactorySettings, IDefaultCommunicationTimeouts, ITransportFactorySettings {
+        string ConnectionPoolGroupName { get; }
+        int MaxOutboundConnectionsPerEndpoint { get; }
+    }
+    public interface IConnectionOrientedTransportFactorySettings : IConnectionOrientedConnectionSettings, IDefaultCommunicationTimeouts, ITransportFactorySettings {
+        int MaxBufferSize { get; }
+        TransferMode TransferMode { get; }
+        StreamUpgradeProvider Upgrade { get; }
+    }
+    public abstract class IdlingCommunicationPool<TKey, TItem> : CommunicationPool<TKey, TItem> where TKey : class where TItem : class {
+        protected IdlingCommunicationPool(int maxCount, TimeSpan idleTimeout, TimeSpan leaseTimeout);
+        public TimeSpan IdleTimeout { get; }
+        protected TimeSpan LeaseTimeout { get; }
+        protected override void CloseItemAsync(TItem item, TimeSpan timeout);
+        protected override CommunicationPool<TKey, TItem>.EndpointConnectionPool CreateEndpointConnectionPool(TKey key);
+        protected class IdleTimeoutEndpointConnectionPool : CommunicationPool<TKey, TItem>.EndpointConnectionPool {
+            public IdleTimeoutEndpointConnectionPool(IdlingCommunicationPool<TKey, TItem> parent, TKey key);
+            protected override void AbortItem(TItem item);
+            protected override void CloseItem(TItem item, TimeSpan timeout);
+            protected override void CloseItemAsync(TItem item, TimeSpan timeout);
+            protected override CommunicationPool<TKey, TItem>.IdleConnectionPool GetIdleConnectionPool();
+            public override void Prune(List<TItem> itemsToClose);
+            protected class IdleTimeoutIdleConnectionPool : CommunicationPool<TKey, TItem>.EndpointConnectionPool.PoolIdleConnectionPool {
+                public IdleTimeoutIdleConnectionPool(IdlingCommunicationPool<TKey, TItem>.IdleTimeoutEndpointConnectionPool parent, object thisLock);
+                public override bool Add(TItem connection);
+                public void OnItemClosing(TItem connection);
+                public void Prune(List<TItem> itemsToClose, bool calledFromTimer);
+                public override bool Return(TItem connection);
+                public override TItem Take(out bool closeItem);
+            }
+        }
+    }
+    public interface IDuplexChannel : IChannel, ICommunicationObject, IInputChannel, IOutputChannel
+    public interface IDuplexSession : IInputSession, IOutputSession, ISession {
+        IAsyncResult BeginCloseOutputSession(AsyncCallback callback, object state);
+        IAsyncResult BeginCloseOutputSession(TimeSpan timeout, AsyncCallback callback, object state);
+        void CloseOutputSession();
+        void CloseOutputSession(TimeSpan timeout);
+        void EndCloseOutputSession(IAsyncResult result);
+    }
+    public interface IDuplexSessionChannel : IChannel, ICommunicationObject, IDuplexChannel, IInputChannel, IOutputChannel, ISessionChannel<IDuplexSession>
+    public interface IHttpCookieContainerManager {
+        CookieContainer CookieContainer { get; set; }
+    }
+    public interface IInputChannel : IChannel, ICommunicationObject {
+        EndpointAddress LocalAddress { get; }
+        IAsyncResult BeginReceive(AsyncCallback callback, object state);
+        IAsyncResult BeginReceive(TimeSpan timeout, AsyncCallback callback, object state);
+        IAsyncResult BeginTryReceive(TimeSpan timeout, AsyncCallback callback, object state);
+        IAsyncResult BeginWaitForMessage(TimeSpan timeout, AsyncCallback callback, object state);
+        Message EndReceive(IAsyncResult result);
+        bool EndTryReceive(IAsyncResult result, out Message message);
+        bool EndWaitForMessage(IAsyncResult result);
+        Message Receive();
+        Message Receive(TimeSpan timeout);
+        bool TryReceive(TimeSpan timeout, out Message message);
+        bool WaitForMessage(TimeSpan timeout);
+    }
+    public interface IInputSession : ISession
+    public interface IInputSessionChannel : IChannel, ICommunicationObject, IInputChannel, ISessionChannel<IInputSession>
+    public interface IMessageProperty {
+        IMessageProperty CreateCopy();
+    }
+    public interface IMessageSource {
+        Message Receive(TimeSpan timeout);
+        Task<Message> ReceiveAsync(TimeSpan timeout);
+        bool WaitForMessage(TimeSpan timeout);
+        Task<bool> WaitForMessageAsync(TimeSpan timeout);
+    }
+    public interface IOutputChannel : IChannel, ICommunicationObject {
+        EndpointAddress RemoteAddress { get; }
+        Uri Via { get; }
+        IAsyncResult BeginSend(Message message, AsyncCallback callback, object state);
+        IAsyncResult BeginSend(Message message, TimeSpan timeout, AsyncCallback callback, object state);
+        void EndSend(IAsyncResult result);
+        void Send(Message message);
+        void Send(Message message, TimeSpan timeout);
+    }
+    public interface IOutputSession : ISession
+    public interface IOutputSessionChannel : IChannel, ICommunicationObject, IOutputChannel, ISessionChannel<IOutputSession>
+    public interface IReceiveContextSettings {
+        bool Enabled { get; set; }
+        TimeSpan ValidityDuration { get; }
+    }
+    public interface IReplyChannel : IChannel, ICommunicationObject {
+        EndpointAddress LocalAddress { get; }
+        IAsyncResult BeginReceiveRequest(AsyncCallback callback, object state);
+        IAsyncResult BeginReceiveRequest(TimeSpan timeout, AsyncCallback callback, object state);
+        IAsyncResult BeginTryReceiveRequest(TimeSpan timeout, AsyncCallback callback, object state);
+        IAsyncResult BeginWaitForRequest(TimeSpan timeout, AsyncCallback callback, object state);
+        RequestContext EndReceiveRequest(IAsyncResult result);
+        bool EndTryReceiveRequest(IAsyncResult result, out RequestContext context);
+        bool EndWaitForRequest(IAsyncResult result);
+        RequestContext ReceiveRequest();
+        RequestContext ReceiveRequest(TimeSpan timeout);
+        bool TryReceiveRequest(TimeSpan timeout, out RequestContext context);
+        bool WaitForRequest(TimeSpan timeout);
+    }
+    public interface IReplySessionChannel : IChannel, ICommunicationObject, IReplyChannel, ISessionChannel<IInputSession>
+    public interface IRequestBase {
+        void Abort(RequestChannel requestChannel);
+        void Fault(RequestChannel requestChannel);
+        void OnReleaseRequest();
+    }
+    public interface IRequestChannel : IChannel, ICommunicationObject {
+        EndpointAddress RemoteAddress { get; }
+        Uri Via { get; }
+        IAsyncResult BeginRequest(Message message, AsyncCallback callback, object state);
+        IAsyncResult BeginRequest(Message message, TimeSpan timeout, AsyncCallback callback, object state);
+        Message EndRequest(IAsyncResult result);
+        Message Request(Message message);
+        Message Request(Message message, TimeSpan timeout);
+    }
+    public interface IRequestSessionChannel : IChannel, ICommunicationObject, IRequestChannel, ISessionChannel<IOutputSession>
+    public interface ISecurityCapabilities {
+        ProtectionLevel SupportedRequestProtectionLevel { get; }
+        ProtectionLevel SupportedResponseProtectionLevel { get; }
+        bool SupportsClientAuthentication { get; }
+        bool SupportsClientWindowsIdentity { get; }
+        bool SupportsServerAuthentication { get; }
+    }
+    public interface ISession {
+        string Id { get; }
+    }
+    public interface ISessionChannel<TSession> where TSession : ISession {
+        TSession Session { get; }
+    }
+    public interface ITcpChannelFactorySettings : IConnectionOrientedConnectionSettings, IConnectionOrientedTransportChannelFactorySettings, IConnectionOrientedTransportFactorySettings, IDefaultCommunicationTimeouts, ITransportFactorySettings {
+        TimeSpan LeaseTimeout { get; }
+    }
+    public interface ITransportCompressionSupport {
+        bool IsCompressionFormatSupported(CompressionFormat compressionFormat);
+    }
+    public interface ITransportFactorySettings : IDefaultCommunicationTimeouts {
+        BufferManager BufferManager { get; }
+        bool ManualAddressing { get; }
+        long MaxReceivedMessageSize { get; }
+        MessageEncoderFactory MessageEncoderFactory { get; }
+        MessageVersion MessageVersion { get; }
+    }
+    public sealed class LocalClientSecuritySettings {
+        public LocalClientSecuritySettings();
+        public bool CacheCookies { get; set; }
+        public int CookieRenewalThresholdPercentage { get; set; }
+        public bool DetectReplays { get; set; }
+        public IdentityVerifier IdentityVerifier { get; set; }
+        public TimeSpan MaxClockSkew { get; set; }
+        public TimeSpan MaxCookieCachingTime { get; set; }
+        public NonceCache NonceCache { get; set; }
+        public bool ReconnectTransportOnFailure { get; set; }
+        public int ReplayCacheSize { get; set; }
+        public TimeSpan ReplayWindow { get; set; }
+        public TimeSpan SessionKeyRenewalInterval { get; set; }
+        public TimeSpan SessionKeyRolloverInterval { get; set; }
+        public TimeSpan TimestampValidityDuration { get; set; }
+        public LocalClientSecuritySettings Clone();
+    }
+    public class MaxMessageSizeStream : DelegatingStream {
+        public MaxMessageSizeStream(Stream stream, long maxMessageSize);
+        public static Exception CreateMaxReceivedMessageSizeExceededException(long maxMessageSize);
+        public override int Read(byte[] buffer, int offset, int count);
+        public override Task<int> ReadAsync(byte[] buffer, int offset, int count, CancellationToken cancellationToken);
+        public override int ReadByte();
+        public override void Write(byte[] buffer, int offset, int count);
+        public override Task WriteAsync(byte[] buffer, int offset, int count, CancellationToken cancellationToken);
+        public override void WriteByte(byte value);
+    }
+    public abstract class Message : IDisposable {
+        protected Message();
+        public abstract MessageHeaders Headers { get; }
+        protected bool IsDisposed { get; }
+        public virtual bool IsEmpty { get; }
+        public virtual bool IsFault { get; }
+        public abstract MessageProperties Properties { get; }
+        public MessageState State { get; }
+        public abstract MessageVersion Version { get; }
+        public IAsyncResult BeginWriteBodyContents(XmlDictionaryWriter writer, AsyncCallback callback, object state);
+        public IAsyncResult BeginWriteMessage(XmlDictionaryWriter writer, AsyncCallback callback, object state);
+        public void Close();
+        public MessageBuffer CreateBufferedCopy(int maxBufferSize);
+        public static Message CreateMessage(MessageVersion version, MessageFault fault, string action);
+        public static Message CreateMessage(MessageVersion version, FaultCode faultCode, string reason, object detail, string action);
+        public static Message CreateMessage(MessageVersion version, FaultCode faultCode, string reason, string action);
+        public static Message CreateMessage(MessageVersion version, string action);
+        public static Message CreateMessage(MessageVersion version, string action, object body);
+        public static Message CreateMessage(MessageVersion version, string action, object body, XmlObjectSerializer serializer);
+        public static Message CreateMessage(MessageVersion version, string action, BodyWriter body);
+        public static Message CreateMessage(MessageVersion version, string action, XmlDictionaryReader body);
+        public static Message CreateMessage(MessageVersion version, string action, XmlReader body);
+        public static Message CreateMessage(XmlDictionaryReader envelopeReader, int maxSizeOfHeaders, MessageVersion version);
+        public static Message CreateMessage(XmlReader envelopeReader, int maxSizeOfHeaders, MessageVersion version);
+        public void EndWriteBodyContents(IAsyncResult result);
+        public void EndWriteMessage(IAsyncResult result);
+        public T GetBody<T>();
+        public T GetBody<T>(XmlObjectSerializer serializer);
+        public string GetBodyAttribute(string localName, string ns);
+        public XmlDictionaryReader GetReaderAtBodyContents();
+        protected virtual IAsyncResult OnBeginWriteBodyContents(XmlDictionaryWriter writer, AsyncCallback callback, object state);
+        protected virtual IAsyncResult OnBeginWriteMessage(XmlDictionaryWriter writer, AsyncCallback callback, object state);
+        protected virtual void OnBodyToString(XmlDictionaryWriter writer);
+        protected virtual void OnClose();
+        protected virtual MessageBuffer OnCreateBufferedCopy(int maxBufferSize);
+        protected virtual void OnEndWriteBodyContents(IAsyncResult result);
+        protected virtual void OnEndWriteMessage(IAsyncResult result);
+        protected virtual T OnGetBody<T>(XmlDictionaryReader reader);
+        protected virtual string OnGetBodyAttribute(string localName, string ns);
+        protected virtual XmlDictionaryReader OnGetReaderAtBodyContents();
+        protected abstract void OnWriteBodyContents(XmlDictionaryWriter writer);
+        protected virtual Task OnWriteBodyContentsAsync(XmlDictionaryWriter writer);
+        protected virtual void OnWriteMessage(XmlDictionaryWriter writer);
+        public virtual Task OnWriteMessageAsync(XmlDictionaryWriter writer);
+        protected virtual void OnWriteStartBody(XmlDictionaryWriter writer);
+        protected virtual void OnWriteStartEnvelope(XmlDictionaryWriter writer);
+        protected virtual void OnWriteStartHeaders(XmlDictionaryWriter writer);
+        void System.IDisposable.Dispose();
+        public override string ToString();
+        public void WriteBody(XmlDictionaryWriter writer);
+        public void WriteBody(XmlWriter writer);
+        public void WriteBodyContents(XmlDictionaryWriter writer);
+        public Task WriteBodyContentsAsync(XmlDictionaryWriter writer);
+        public void WriteMessage(XmlDictionaryWriter writer);
+        public void WriteMessage(XmlWriter writer);
+        public virtual Task WriteMessageAsync(XmlDictionaryWriter writer);
+        public virtual Task WriteMessageAsync(XmlWriter writer);
+        public void WriteStartBody(XmlDictionaryWriter writer);
+        public void WriteStartBody(XmlWriter writer);
+        public void WriteStartEnvelope(XmlDictionaryWriter writer);
+    }
+    public abstract class MessageBuffer : IDisposable {
+        protected MessageBuffer();
+        public abstract int BufferSize { get; }
+        public virtual string MessageContentType { get; }
+        public abstract void Close();
+        public abstract Message CreateMessage();
+        void System.IDisposable.Dispose();
+        public virtual void WriteMessage(Stream stream);
+    }
+    public abstract class MessageEncoder {
+        protected MessageEncoder();
+        public abstract string ContentType { get; }
+        public abstract string MediaType { get; }
+        public abstract MessageVersion MessageVersion { get; }
+        public virtual IAsyncResult BeginWriteMessage(Message message, Stream stream, AsyncCallback callback, object state);
+        public virtual void EndWriteMessage(IAsyncResult result);
+        public virtual T GetProperty<T>() where T : class;
+        public virtual bool IsContentTypeSupported(string contentType);
+        public Message ReadMessage(ArraySegment<byte> buffer, BufferManager bufferManager);
+        public abstract Message ReadMessage(ArraySegment<byte> buffer, BufferManager bufferManager, string contentType);
+        public Message ReadMessage(Stream stream, int maxSizeOfHeaders);
+        public abstract Message ReadMessage(Stream stream, int maxSizeOfHeaders, string contentType);
+        public virtual Task<Message> ReadMessageAsync(ArraySegment<byte> buffer, BufferManager bufferManager, string contentType);
+        public virtual Task<Message> ReadMessageAsync(Stream stream, int maxSizeOfHeaders, string contentType);
+        public override string ToString();
+        public ArraySegment<byte> WriteMessage(Message message, int maxMessageSize, BufferManager bufferManager);
+        public abstract ArraySegment<byte> WriteMessage(Message message, int maxMessageSize, BufferManager bufferManager, int messageOffset);
+        public abstract void WriteMessage(Message message, Stream stream);
+        public virtual Task<ArraySegment<byte>> WriteMessageAsync(Message message, int maxMessageSize, BufferManager bufferManager, int messageOffset);
+        public virtual Task WriteMessageAsync(Message message, Stream stream);
+    }
+    public abstract class MessageEncoderFactory {
+        protected MessageEncoderFactory();
+        public abstract MessageEncoder Encoder { get; }
+        public abstract MessageVersion MessageVersion { get; }
+        public virtual MessageEncoder CreateSessionEncoder();
+    }
+    public abstract class MessageEncodingBindingElement : BindingElement {
+        protected MessageEncodingBindingElement();
+        protected MessageEncodingBindingElement(MessageEncodingBindingElement elementToBeCloned);
+        public abstract MessageVersion MessageVersion { get; set; }
+        public abstract MessageEncoderFactory CreateMessageEncoderFactory();
+        public override T GetProperty<T>(BindingContext context);
+    }
+    public abstract class MessageFault {
+        protected MessageFault();
+        public virtual string Actor { get; }
+        public abstract FaultCode Code { get; }
+        public abstract bool HasDetail { get; }
+        public bool IsMustUnderstandFault { get; }
+        public virtual string Node { get; }
+        public abstract FaultReason Reason { get; }
+        public static MessageFault CreateFault(Message message, int maxBufferSize);
+        public static MessageFault CreateFault(FaultCode code, FaultReason reason);
+        public static MessageFault CreateFault(FaultCode code, FaultReason reason, object detail);
+        public static MessageFault CreateFault(FaultCode code, FaultReason reason, object detail, XmlObjectSerializer serializer);
+        public static MessageFault CreateFault(FaultCode code, FaultReason reason, object detail, XmlObjectSerializer serializer, string actor);
+        public static MessageFault CreateFault(FaultCode code, FaultReason reason, object detail, XmlObjectSerializer serializer, string actor, string node);
+        public static MessageFault CreateFault(FaultCode code, string reason);
+        public T GetDetail<T>();
+        public T GetDetail<T>(XmlObjectSerializer serializer);
+        public XmlDictionaryReader GetReaderAtDetailContents();
+        protected virtual XmlDictionaryReader OnGetReaderAtDetailContents();
+        protected virtual void OnWriteDetail(XmlDictionaryWriter writer, EnvelopeVersion version);
+        protected abstract void OnWriteDetailContents(XmlDictionaryWriter writer);
+        protected virtual void OnWriteStartDetail(XmlDictionaryWriter writer, EnvelopeVersion version);
+        public static bool WasHeaderNotUnderstood(MessageHeaders headers, string name, string ns);
+        public void WriteTo(XmlDictionaryWriter writer, EnvelopeVersion version);
+        public void WriteTo(XmlWriter writer, EnvelopeVersion version);
+    }
+    public abstract class MessageHeader : MessageHeaderInfo {
+        protected MessageHeader();
+        public override string Actor { get; }
+        public override bool IsReferenceParameter { get; }
+        public override bool MustUnderstand { get; }
+        public override bool Relay { get; }
+        public static MessageHeader CreateHeader(string name, string ns, object value);
+        public static MessageHeader CreateHeader(string name, string ns, object value, bool mustUnderstand);
+        public static MessageHeader CreateHeader(string name, string ns, object value, bool mustUnderstand, string actor);
+        public static MessageHeader CreateHeader(string name, string ns, object value, bool mustUnderstand, string actor, bool relay);
+        public static MessageHeader CreateHeader(string name, string ns, object value, XmlObjectSerializer serializer);
+        public static MessageHeader CreateHeader(string name, string ns, object value, XmlObjectSerializer serializer, bool mustUnderstand);
+        public static MessageHeader CreateHeader(string name, string ns, object value, XmlObjectSerializer serializer, bool mustUnderstand, string actor);
+        public static MessageHeader CreateHeader(string name, string ns, object value, XmlObjectSerializer serializer, bool mustUnderstand, string actor, bool relay);
+        public virtual bool IsMessageVersionSupported(MessageVersion messageVersion);
+        protected abstract void OnWriteHeaderContents(XmlDictionaryWriter writer, MessageVersion messageVersion);
+        protected virtual void OnWriteStartHeader(XmlDictionaryWriter writer, MessageVersion messageVersion);
+        public override string ToString();
+        public void WriteHeader(XmlDictionaryWriter writer, MessageVersion messageVersion);
+        public void WriteHeader(XmlWriter writer, MessageVersion messageVersion);
+        protected void WriteHeaderAttributes(XmlDictionaryWriter writer, MessageVersion messageVersion);
+        public void WriteHeaderContents(XmlDictionaryWriter writer, MessageVersion messageVersion);
+        public void WriteStartHeader(XmlDictionaryWriter writer, MessageVersion messageVersion);
+    }
+    public abstract class MessageHeaderInfo {
+        protected MessageHeaderInfo();
+        public abstract string Actor { get; }
+        public abstract bool IsReferenceParameter { get; }
+        public abstract bool MustUnderstand { get; }
+        public abstract string Name { get; }
+        public abstract string Namespace { get; }
+        public abstract bool Relay { get; }
+    }
+    public sealed class MessageHeaders : IEnumerable, IEnumerable<MessageHeaderInfo> {
+        public MessageHeaders(MessageHeaders collection);
+        public MessageHeaders(MessageVersion version);
+        public MessageHeaders(MessageVersion version, int initialSize);
+        public string Action { get; set; }
+        public int Count { get; }
+        public EndpointAddress FaultTo { get; set; }
+        public EndpointAddress From { get; set; }
+        public UniqueId MessageId { get; set; }
+        public MessageVersion MessageVersion { get; }
+        public UniqueId RelatesTo { get; set; }
+        public EndpointAddress ReplyTo { get; set; }
+        public MessageHeaderInfo this[int index] { get; }
+        public Uri To { get; set; }
+        public UnderstoodHeaders UnderstoodHeaders { get; }
+        public void Add(MessageHeader header);
+        public void Clear();
+        public void CopyHeaderFrom(Message message, int headerIndex);
+        public void CopyHeaderFrom(MessageHeaders collection, int headerIndex);
+        public void CopyHeadersFrom(Message message);
+        public void CopyHeadersFrom(MessageHeaders collection);
+        public void CopyTo(MessageHeaderInfo[] array, int index);
+        public int FindHeader(string name, string ns);
+        public int FindHeader(string name, string ns, params string[] actors);
+        public IEnumerator<MessageHeaderInfo> GetEnumerator();
+        public T GetHeader<T>(int index);
+        public T GetHeader<T>(int index, XmlObjectSerializer serializer);
+        public T GetHeader<T>(string name, string ns);
+        public T GetHeader<T>(string name, string ns, XmlObjectSerializer serializer);
+        public T GetHeader<T>(string name, string ns, params string[] actors);
+        public XmlDictionaryReader GetReaderAtHeader(int headerIndex);
+        public bool HaveMandatoryHeadersBeenUnderstood();
+        public bool HaveMandatoryHeadersBeenUnderstood(params string[] actors);
+        public void Insert(int headerIndex, MessageHeader header);
+        public void RemoveAll(string name, string ns);
+        public void RemoveAt(int headerIndex);
+        public void SetAction(XmlDictionaryString action);
+        IEnumerator System.Collections.IEnumerable.GetEnumerator();
+        public void WriteHeader(int headerIndex, XmlDictionaryWriter writer);
+        public void WriteHeader(int headerIndex, XmlWriter writer);
+        public void WriteHeaderContents(int headerIndex, XmlDictionaryWriter writer);
+        public void WriteHeaderContents(int headerIndex, XmlWriter writer);
+        public void WriteStartHeader(int headerIndex, XmlDictionaryWriter writer);
+        public void WriteStartHeader(int headerIndex, XmlWriter writer);
+    }
+    public sealed class MessageProperties : ICollection<KeyValuePair<string, object>>, IDictionary<string, object>, IDisposable, IEnumerable, IEnumerable<KeyValuePair<string, object>> {
+        public MessageProperties();
+        public MessageProperties(MessageProperties properties);
+        public bool AllowOutputBatching { get; set; }
+        public int Count { get; }
+        public MessageEncoder Encoder { get; set; }
+        public bool IsFixedSize { get; }
+        public bool IsReadOnly { get; }
+        public ICollection<string> Keys { get; }
+        public SecurityMessageProperty Security { get; set; }
+        bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.IsReadOnly { get; }
+        public object this[string name] { get; set; }
+        public ICollection<object> Values { get; }
+        public Uri Via { get; set; }
+        public void Add(string name, object property);
+        public void Clear();
+        public bool ContainsKey(string name);
+        public void CopyProperties(MessageProperties properties);
+        public void Dispose();
+        public bool Remove(string name);
+        void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.Add(KeyValuePair<string, object> pair);
+        bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.Contains(KeyValuePair<string, object> pair);
+        void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.CopyTo(KeyValuePair<string, object>[] array, int index);
+        bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.Remove(KeyValuePair<string, object> pair);
+        IEnumerator<KeyValuePair<string, object>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.GetEnumerator();
+        IEnumerator System.Collections.IEnumerable.GetEnumerator();
+        public bool TryGetValue(string name, out object value);
+    }
+    public enum MessageState {
+        Closed = 4,
+        Copied = 3,
+        Created = 0,
+        Read = 1,
+        Written = 2,
+    }
+    public sealed class MessageVersion {
+        public AddressingVersion Addressing { get; }
+        public static MessageVersion Default { get; }
+        public EnvelopeVersion Envelope { get; }
+        public static MessageVersion None { get; }
+        public static MessageVersion Soap11 { get; }
+        public static MessageVersion Soap11WSAddressing10 { get; }
+        public static MessageVersion Soap12 { get; }
+        public static MessageVersion Soap12WSAddressing10 { get; }
+        public static MessageVersion CreateVersion(EnvelopeVersion envelopeVersion);
+        public static MessageVersion CreateVersion(EnvelopeVersion envelopeVersion, AddressingVersion addressingVersion);
+        public override bool Equals(object obj);
+        public override int GetHashCode();
+        public override string ToString();
+    }
+    public sealed class NamedPipeSettings {
+        public ApplicationContainerSettings ApplicationContainerSettings { get; private set; }
+    }
+    public static class NetHttpBindingDefaults {
+        public const WebSocketTransportUsage TransportUsage = 0;
+        public const NetHttpMessageEncoding MessageEncoding = 0;
+    }
+    public static class NetTcpDefaults {
+        public const MessageCredentialType MessageSecurityClientCredentialType = 1;
+    }
+    public static class OneWayDefaults {
+        public const bool PacketRoutable = false;
+        public const int MaxAcceptedChannels = 10;
+        public const int MaxOutboundChannelsPerEndpoint = 10;
+        public const string IdleTimeoutString = "00:02:00";
+        public const string LeaseTimeoutString = "00:10:00";
+        public static TimeSpan IdleTimeout { get; }
+        public static TimeSpan LeaseTimeout { get; }
+    }
+    public abstract class OutputChannel : ChannelBase, IChannel, ICommunicationObject, IOutputChannel {
+        protected OutputChannel(ChannelManagerBase manager);
+        public abstract EndpointAddress RemoteAddress { get; }
+        public abstract Uri Via { get; }
+        protected virtual void AddHeadersTo(Message message);
+        public IAsyncResult BeginSend(Message message, AsyncCallback callback, object state);
+        public IAsyncResult BeginSend(Message message, TimeSpan timeout, AsyncCallback callback, object state);
+        public void EndSend(IAsyncResult result);
+        public override T GetProperty<T>();
+        protected abstract void OnSend(Message message, TimeSpan timeout);
+        protected abstract Task OnSendAsync(Message message, TimeSpan timeout);
+        public void Send(Message message);
+        public void Send(Message message, TimeSpan timeout);
+    }
+    public abstract class RequestChannel : ChannelBase, IAsyncCommunicationObject, IAsyncRequestChannel, IChannel, ICommunicationObject, IRequestChannel {
+        protected RequestChannel(ChannelManagerBase channelFactory, EndpointAddress to, Uri via, bool manualAddressing);
+        protected bool ManualAddressing { get; }
+        public EndpointAddress RemoteAddress { get; }
+        public Uri Via { get; }
+        protected void AbortPendingRequests();
+        protected virtual void AddHeadersTo(Message message);
+        public IAsyncResult BeginRequest(Message message, AsyncCallback callback, object state);
+        public IAsyncResult BeginRequest(Message message, TimeSpan timeout, AsyncCallback callback, object state);
+        protected IAsyncResult BeginWaitForPendingRequests(TimeSpan timeout, AsyncCallback callback, object state);
+        protected abstract IAsyncRequest CreateAsyncRequest(Message message);
+        public Message EndRequest(IAsyncResult result);
+        protected void EndWaitForPendingRequests(IAsyncResult result);
+        protected void FaultPendingRequests();
+        public override T GetProperty<T>();
+        protected override void OnAbort();
+        public Message Request(Message message);
+        public Message Request(Message message, TimeSpan timeout);
+        public Task<Message> RequestAsync(Message message);
+        public Task<Message> RequestAsync(Message message, TimeSpan timeout);
+        protected void WaitForPendingRequests(TimeSpan timeout);
+        protected internal Task WaitForPendingRequestsAsync(TimeSpan timeout);
+    }
+    public abstract class RequestContext : IDisposable {
+        protected RequestContext();
+        public abstract Message RequestMessage { get; }
+        public abstract void Abort();
+        public abstract IAsyncResult BeginReply(Message message, AsyncCallback callback, object state);
+        public abstract IAsyncResult BeginReply(Message message, TimeSpan timeout, AsyncCallback callback, object state);
+        public abstract void Close();
+        public abstract void Close(TimeSpan timeout);
+        protected virtual void Dispose(bool disposing);
+        public abstract void EndReply(IAsyncResult result);
+        public abstract void Reply(Message message);
+        public abstract void Reply(Message message, TimeSpan timeout);
+        void System.IDisposable.Dispose();
+    }
+    public abstract class SecurityBindingElement : BindingElement {
+        public SupportingTokenParameters EndpointSupportingTokenParameters { get; }
+        public bool IncludeTimestamp { get; set; }
+        public LocalClientSecuritySettings LocalClientSettings { get; }
+        public MessageSecurityVersion MessageSecurityVersion { get; set; }
+        public SecurityHeaderLayout SecurityHeaderLayout { get; set; }
+        public override IChannelFactory<TChannel> BuildChannelFactory<TChannel>(BindingContext context);
+        protected abstract IChannelFactory<TChannel> BuildChannelFactoryCore<TChannel>(BindingContext context);
+        public override bool CanBuildChannelFactory<TChannel>(BindingContext context);
+        public static TransportSecurityBindingElement CreateCertificateOverTransportBindingElement(MessageSecurityVersion version);
+        public static SecurityBindingElement CreateMutualCertificateBindingElement();
+        public static SecurityBindingElement CreateMutualCertificateBindingElement(MessageSecurityVersion version);
+        public static SecurityBindingElement CreateMutualCertificateBindingElement(MessageSecurityVersion version, bool allowSerializedSigningTokenOnReply);
+        public static SecurityBindingElement CreateSecureConversationBindingElement(SecurityBindingElement bootstrapSecurity);
+        public static TransportSecurityBindingElement CreateUserNameOverTransportBindingElement();
+        public override T GetProperty<T>(BindingContext context);
+        protected static void SetIssuerBindingContextIfRequired(SecurityTokenParameters parameters, BindingContext issuerBindingContext);
+        public virtual void SetKeyDerivation(bool requireDerivedKeys);
+        public override string ToString();
+    }
+    public class SecurityCapabilities : ISecurityCapabilities {
+        public SecurityCapabilities(bool supportsClientAuth, bool supportsServerAuth, bool supportsClientWindowsIdentity, ProtectionLevel requestProtectionLevel, ProtectionLevel responseProtectionLevel);
+        public static SecurityCapabilities None { get; }
+        public ProtectionLevel SupportedRequestProtectionLevel { get; }
+        public ProtectionLevel SupportedResponseProtectionLevel { get; }
+        public bool SupportsClientAuthentication { get; }
+        public bool SupportsClientWindowsIdentity { get; }
+        public bool SupportsServerAuthentication { get; }
+        public static bool IsEqual(ISecurityCapabilities capabilities1, ISecurityCapabilities capabilities2);
+    }
+    public enum SecurityHeaderLayout {
+        Lax = 1,
+        LaxTimestampFirst = 2,
+        LaxTimestampLast = 3,
+        Strict = 0,
+    }
+    public class ServiceChannelProxy : DispatchProxy, IChannel, IClientChannel, ICommunicationObject, IContextChannel, IDisposable, IDuplexContextChannel, IExtensibleObject<IContextChannel>, IOutputChannel, IRequestChannel, IServiceChannel {
+        public ServiceChannelProxy();
+        public bool AutomaticInputSessionShutdown { get; set; }
+        public InstanceContext CallbackInstance { get; set; }
+        EndpointAddress System.ServiceModel.Channels.IOutputChannel.RemoteAddress { get; }
+        Uri System.ServiceModel.Channels.IOutputChannel.Via { get; }
+        EndpointAddress System.ServiceModel.Channels.IRequestChannel.RemoteAddress { get; }
+        Uri System.ServiceModel.Channels.IRequestChannel.Via { get; }
+        bool System.ServiceModel.IClientChannel.AllowInitializationUI { get; set; }
+        bool System.ServiceModel.IClientChannel.DidInteractiveInitialization { get; }
+        Uri System.ServiceModel.IClientChannel.Via { get; }
+        CommunicationState System.ServiceModel.ICommunicationObject.State { get; }
+        bool System.ServiceModel.IContextChannel.AllowOutputBatching { get; set; }
+        IInputSession System.ServiceModel.IContextChannel.InputSession { get; }
+        EndpointAddress System.ServiceModel.IContextChannel.LocalAddress { get; }
+        TimeSpan System.ServiceModel.IContextChannel.OperationTimeout { get; set; }
+        IOutputSession System.ServiceModel.IContextChannel.OutputSession { get; }
+        EndpointAddress System.ServiceModel.IContextChannel.RemoteAddress { get; }
+        string System.ServiceModel.IContextChannel.SessionId { get; }
+        IExtensionCollection<IContextChannel> System.ServiceModel.IExtensibleObject<System.ServiceModel.IContextChannel>.Extensions { get; }
+        Uri System.ServiceModel.IServiceChannel.ListenUri { get; }
+        event EventHandler<UnknownMessageReceivedEventArgs> System.ServiceModel.IClientChannel.UnknownMessageReceived;
+        event EventHandler System.ServiceModel.ICommunicationObject.Closed;
+        event EventHandler System.ServiceModel.ICommunicationObject.Closing;
+        event EventHandler System.ServiceModel.ICommunicationObject.Faulted;
+        event EventHandler System.ServiceModel.ICommunicationObject.Opened;
+        event EventHandler System.ServiceModel.ICommunicationObject.Opening;
+        public IAsyncResult BeginCloseOutputSession(TimeSpan timeout, AsyncCallback callback, object state);
+        public void CloseOutputSession(TimeSpan timeout);
+        public void EndCloseOutputSession(IAsyncResult result);
+        protected override object Invoke(MethodInfo targetMethod, object[] args);
+        void System.IDisposable.Dispose();
+        T System.ServiceModel.Channels.IChannel.GetProperty<T>();
+        IAsyncResult System.ServiceModel.Channels.IOutputChannel.BeginSend(Message message, AsyncCallback callback, object state);
+        IAsyncResult System.ServiceModel.Channels.IOutputChannel.BeginSend(Message message, TimeSpan timeout, AsyncCallback callback, object state);
+        void System.ServiceModel.Channels.IOutputChannel.EndSend(IAsyncResult result);
+        void System.ServiceModel.Channels.IOutputChannel.Send(Message message);
+        void System.ServiceModel.Channels.IOutputChannel.Send(Message message, TimeSpan timeout);
+        IAsyncResult System.ServiceModel.Channels.IRequestChannel.BeginRequest(Message message, AsyncCallback callback, object state);
+        IAsyncResult System.ServiceModel.Channels.IRequestChannel.BeginRequest(Message message, TimeSpan timeout, AsyncCallback callback, object state);
+        Message System.ServiceModel.Channels.IRequestChannel.EndRequest(IAsyncResult result);
+        Message System.ServiceModel.Channels.IRequestChannel.Request(Message message);
+        Message System.ServiceModel.Channels.IRequestChannel.Request(Message message, TimeSpan timeout);
+        IAsyncResult System.ServiceModel.IClientChannel.BeginDisplayInitializationUI(AsyncCallback callback, object state);
+        void System.ServiceModel.IClientChannel.DisplayInitializationUI();
+        void System.ServiceModel.IClientChannel.EndDisplayInitializationUI(IAsyncResult result);
+        void System.ServiceModel.ICommunicationObject.Abort();
+        IAsyncResult System.ServiceModel.ICommunicationObject.BeginClose(AsyncCallback callback, object state);
+        IAsyncResult System.ServiceModel.ICommunicationObject.BeginClose(TimeSpan timeout, AsyncCallback callback, object state);
+        IAsyncResult System.ServiceModel.ICommunicationObject.BeginOpen(AsyncCallback callback, object state);
+        IAsyncResult System.ServiceModel.ICommunicationObject.BeginOpen(TimeSpan timeout, AsyncCallback callback, object state);
+        void System.ServiceModel.ICommunicationObject.Close();
+        void System.ServiceModel.ICommunicationObject.Close(TimeSpan timeout);
+        void System.ServiceModel.ICommunicationObject.EndClose(IAsyncResult result);
+        void System.ServiceModel.ICommunicationObject.EndOpen(IAsyncResult result);
+        void System.ServiceModel.ICommunicationObject.Open();
+        void System.ServiceModel.ICommunicationObject.Open(TimeSpan timeout);
+        public override string ToString();
+    }
+    public class ServiceModelHttpMessageHandler : DelegatingHandler {
+        public ServiceModelHttpMessageHandler();
+        public DecompressionMethods AutomaticDecompression { get; set; }
+        public bool CheckCertificateRevocationList { get; set; }
+        public X509CertificateCollection ClientCertificates { get; }
+        public CookieContainer CookieContainer { get; set; }
+        public ICredentials Credentials { get; set; }
+        public bool PreAuthenticate { get; set; }
+        public Func<HttpRequestMessage, X509Certificate2, X509Chain, SslPolicyErrors, bool> ServerCertificateValidationCallback { get; set; }
+        public bool SupportsCertificateValidationCallback { get; }
+        public bool SupportsClientCertificates { get; }
+        public bool SupportsProxy { get; }
+        public bool UseCookies { get; set; }
+        public bool UseDefaultCredentials { get; set; }
+        public bool UseProxy { get; set; }
+        protected override Task<HttpResponseMessage> SendAsync(HttpRequestMessage request, CancellationToken cancellationToken);
+    }
+    public class SslStreamSecurityBindingElement : BindingElement {
+        public SslStreamSecurityBindingElement();
+        protected SslStreamSecurityBindingElement(SslStreamSecurityBindingElement elementToBeCloned);
+        public IdentityVerifier IdentityVerifier { get; set; }
+        public SslProtocols SslProtocols { get; set; }
+        public override IChannelFactory<TChannel> BuildChannelFactory<TChannel>(BindingContext context);
+        public override StreamUpgradeProvider BuildClientStreamUpgradeProvider(BindingContext context);
+        public override bool CanBuildChannelFactory<TChannel>(BindingContext context);
+        public override BindingElement Clone();
+        public override T GetProperty<T>(BindingContext context);
+    }
+    public abstract class StreamSecurityUpgradeInitiator : StreamUpgradeInitiator {
+        protected StreamSecurityUpgradeInitiator();
+        public abstract SecurityMessageProperty GetRemoteSecurity();
+    }
+    public abstract class StreamSecurityUpgradeProvider : StreamUpgradeProvider {
+        protected StreamSecurityUpgradeProvider();
+        protected StreamSecurityUpgradeProvider(IDefaultCommunicationTimeouts timeouts);
+        public abstract EndpointIdentity Identity { get; }
+    }
+    public abstract class StreamUpgradeBindingElement : BindingElement {
+        protected StreamUpgradeBindingElement();
+        protected StreamUpgradeBindingElement(StreamUpgradeBindingElement elementToBeCloned);
+        public abstract StreamUpgradeProvider BuildClientStreamUpgradeProvider(BindingContext context);
+    }
+    public abstract class StreamUpgradeInitiator {
+        protected StreamUpgradeInitiator();
+        public abstract string GetNextUpgrade();
+        public abstract Stream InitiateUpgrade(Stream stream);
+    }
+    public abstract class StreamUpgradeProvider : CommunicationObject, IAsyncCommunicationObject, ICommunicationObject {
+        protected StreamUpgradeProvider();
+        protected StreamUpgradeProvider(IDefaultCommunicationTimeouts timeouts);
+        protected override TimeSpan DefaultCloseTimeout { get; }
+        protected override TimeSpan DefaultOpenTimeout { get; }
+        public abstract StreamUpgradeInitiator CreateUpgradeInitiator(EndpointAddress remoteAddress, Uri via);
+        public virtual T GetProperty<T>() where T : class;
+    }
+    public enum SupportedAddressingMode {
+        Anonymous = 0,
+        Mixed = 2,
+        NonAnonymous = 1,
+    }
+    public sealed class TcpConnectionPoolSettings {
+        public string GroupName { get; set; }
+        public TimeSpan IdleTimeout { get; set; }
+        public TimeSpan LeaseTimeout { get; set; }
+        public int MaxOutboundConnectionsPerEndpoint { get; set; }
+    }
+    public class TcpTransportBindingElement : ConnectionOrientedTransportBindingElement {
+        public TcpTransportBindingElement();
+        protected TcpTransportBindingElement(TcpTransportBindingElement elementToBeCloned);
+        public TcpConnectionPoolSettings ConnectionPoolSettings { get; }
+        public override string Scheme { get; }
+        public override IChannelFactory<TChannel> BuildChannelFactory<TChannel>(BindingContext context);
+        public override BindingElement Clone();
+        public override T GetProperty<T>(BindingContext context);
+    }
+    public static class TcpTransportDefaults {
+        public const bool PortSharingEnabled = false;
+        public const bool TeredoEnabled = false;
+        public const int ListenBacklogConst = 0;
+        public const string ConnectionLeaseTimeoutString = "00:05:00";
+        public static TimeSpan ConnectionLeaseTimeout { get; }
+        public static int GetListenBacklog();
+    }
+    public static class TextEncoderDefaults {
+        public static readonly TextEncoderDefaults.CharSetEncoding[] CharSetEncodings;
+        public const string EncodingString = "utf-8";
+        public const string MessageVersionString = "Soap12WSAddressing10";
+        public static readonly Encoding Encoding;
+        public static readonly Encoding[] SupportedEncodings;
+        public static string EncodingToCharSet(Encoding encoding);
+        public static bool TryGetEncoding(string charSet, out Encoding encoding);
+        public static void ValidateEncoding(Encoding encoding);
+        public class CharSetEncoding {
+            public string CharSet;
+            public Encoding Encoding;
+            public CharSetEncoding(string charSet, Encoding enc);
+        }
+    }
+    public sealed class TextMessageEncodingBindingElement : MessageEncodingBindingElement {
+        public TextMessageEncodingBindingElement();
+        public TextMessageEncodingBindingElement(MessageVersion messageVersion, Encoding writeEncoding);
+        public int MaxReadPoolSize { get; set; }
+        public int MaxWritePoolSize { get; set; }
+        public override MessageVersion MessageVersion { get; set; }
+        public XmlDictionaryReaderQuotas ReaderQuotas { get; set; }
+        public Encoding WriteEncoding { get; set; }
+        public override IChannelFactory<TChannel> BuildChannelFactory<TChannel>(BindingContext context);
+        public override BindingElement Clone();
+        public override MessageEncoderFactory CreateMessageEncoderFactory();
+        public override T GetProperty<T>(BindingContext context);
+    }
+    public abstract class TransportBindingElement : BindingElement {
+        protected TransportBindingElement();
+        protected TransportBindingElement(TransportBindingElement elementToBeCloned);
+        public virtual bool ManualAddressing { get; set; }
+        public virtual long MaxBufferPoolSize { get; set; }
+        public virtual long MaxReceivedMessageSize { get; set; }
+        public abstract string Scheme { get; }
+        public override T GetProperty<T>(BindingContext context);
+    }
+    public abstract class TransportChannelFactory<TChannel> : ChannelFactoryBase<TChannel>, IDefaultCommunicationTimeouts, ITransportFactorySettings {
+        protected TransportChannelFactory(TransportBindingElement bindingElement, BindingContext context);
+        protected TransportChannelFactory(TransportBindingElement bindingElement, BindingContext context, MessageEncoderFactory defaultMessageEncoderFactory);
+        public BufferManager BufferManager { get; }
+        public bool ManualAddressing { get; }
+        public long MaxBufferPoolSize { get; }
+        public long MaxReceivedMessageSize { get; }
+        public MessageEncoderFactory MessageEncoderFactory { get; }
+        public MessageVersion MessageVersion { get; }
+        public abstract string Scheme { get; }
+        BufferManager System.ServiceModel.Channels.ITransportFactorySettings.BufferManager { get; }
+        bool System.ServiceModel.Channels.ITransportFactorySettings.ManualAddressing { get; }
+        long System.ServiceModel.Channels.ITransportFactorySettings.MaxReceivedMessageSize { get; }
+        MessageEncoderFactory System.ServiceModel.Channels.ITransportFactorySettings.MessageEncoderFactory { get; }
+        public virtual int GetMaxBufferSize();
+        public override T GetProperty<T>();
+        protected override void OnAbort();
+        protected override IAsyncResult OnBeginClose(TimeSpan timeout, AsyncCallback callback, object state);
+        protected override void OnClose(TimeSpan timeout);
+        protected internal override Task OnCloseAsync(TimeSpan timeout);
+        protected override void OnOpening();
+        public void ValidateScheme(Uri via);
+    }
+    public static class TransportDefaults {
+        public const bool ExtractGroupsForWindowsAccounts = true;
+        public const bool ManualAddressing = false;
+        public const bool RequireClientCertificate = false;
+        public const int MaxBufferSize = 65536;
+        public const int MaxDrainSize = 65536;
+        public const int MaxFaultSize = 65536;
+        public const int MaxRMFaultSize = 65536;
+        public const int MaxSecurityFaultSize = 16384;
+        public const long MaxBufferPoolSize = (long)524288;
+        public const long MaxReceivedMessageSize = (long)65536;
+        public const SslProtocols SslProtocols = 4032;
+        public const TokenImpersonationLevel ImpersonationLevel = 2;
+        public const HostNameComparisonMode HostNameComparisonMode = 1;
+        public static MessageEncoderFactory GetDefaultMessageEncoderFactory();
+    }
+    public abstract class TransportDuplexSessionChannel : TransportOutputChannel, IChannel, ICommunicationObject, IDuplexChannel, IDuplexSessionChannel, IInputChannel, IOutputChannel, ISessionChannel<IDuplexSession> {
+        protected TransportDuplexSessionChannel(ChannelManagerBase manager, ITransportFactorySettings settings, EndpointAddress localAddress, Uri localVia, EndpointAddress remoteAddresss, Uri via);
+        protected BufferManager BufferManager { get; }
+        protected abstract bool IsStreamedOutput { get; }
+        public EndpointAddress LocalAddress { get; }
+        protected MessageEncoder MessageEncoder { get; set; }
+        public SecurityMessageProperty RemoteSecurity { get; protected set; }
+        public IDuplexSession Session { get; protected set; }
+        protected void ApplyChannelBinding(Message message);
+        protected abstract AsyncCompletionResult BeginCloseOutput(TimeSpan timeout, Action<object> callback, object state);
+        public IAsyncResult BeginReceive(AsyncCallback callback, object state);
+        public IAsyncResult BeginReceive(TimeSpan timeout, AsyncCallback callback, object state);
+        public IAsyncResult BeginTryReceive(TimeSpan timeout, AsyncCallback callback, object state);
+        public IAsyncResult BeginWaitForMessage(TimeSpan timeout, AsyncCallback callback, object state);
+        protected void CloseOutputSession(TimeSpan timeout);
+        protected Task CloseOutputSessionAsync(TimeSpan timeout);
+        protected abstract void CloseOutputSessionCore(TimeSpan timeout);
+        protected abstract Task CloseOutputSessionCoreAsync(TimeSpan timeout);
+        protected abstract void CompleteClose(TimeSpan timeout);
+        protected abstract ArraySegment<byte> EncodeMessage(Message message);
+        public Message EndReceive(IAsyncResult result);
+        public bool EndTryReceive(IAsyncResult result, out Message message);
+        public bool EndWaitForMessage(IAsyncResult result);
+        protected virtual void FinishWritingMessage();
+        protected override void OnAbort();
+        protected override IAsyncResult OnBeginClose(TimeSpan timeout, AsyncCallback callback, object state);
+        protected override void OnClose(TimeSpan timeout);
+        protected internal override Task OnCloseAsync(TimeSpan timeout);
+        protected override void OnClosed();
+        protected override void OnEndClose(IAsyncResult result);
+        protected override void OnFaulted();
+        protected virtual void OnReceiveMessage(Message message);
+        protected override void OnSend(Message message, TimeSpan timeout);
+        protected override Task OnSendAsync(Message message, TimeSpan timeout);
+        protected abstract void OnSendCore(Message message, TimeSpan timeout);
+        protected virtual void PrepareMessage(Message message);
+        public Message Receive();
+        public Message Receive(TimeSpan timeout);
+        public Task<Message> ReceiveAsync(TimeSpan timeout);
+        protected abstract void ReturnConnectionIfNecessary(bool abort, TimeSpan timeout);
+        protected void SetMessageSource(IMessageSource messageSource);
+        protected abstract AsyncCompletionResult StartWritingBufferedMessage(Message message, ArraySegment<byte> messageData, bool allowOutputBatching, TimeSpan timeout, Action<object> callback, object state);
+        protected abstract AsyncCompletionResult StartWritingStreamedMessage(Message message, TimeSpan timeout, Action<object> callback, object state);
+        public bool TryReceive(TimeSpan timeout, out Message message);
+        public bool WaitForMessage(TimeSpan timeout);
+        public Task<bool> WaitForMessageAsync(TimeSpan timeout);
+        public class ConnectionDuplexSession : IDuplexSession, IInputSession, IOutputSession, ISession {
+            public ConnectionDuplexSession(TransportDuplexSessionChannel channel);
+            public TransportDuplexSessionChannel Channel { get; }
+            public string Id { get; }
+            public IAsyncResult BeginCloseOutputSession(AsyncCallback callback, object state);
+            public IAsyncResult BeginCloseOutputSession(TimeSpan timeout, AsyncCallback callback, object state);
+            public void CloseOutputSession();
+            public void CloseOutputSession(TimeSpan timeout);
+            public void EndCloseOutputSession(IAsyncResult result);
+        }
+    }
+    public abstract class TransportOutputChannel : OutputChannel {
+        protected TransportOutputChannel(ChannelManagerBase channelManager, EndpointAddress to, Uri via, bool manualAddressing, MessageVersion messageVersion);
+        public EventTraceActivity EventTraceActivity { get; }
+        protected bool ManualAddressing { get; }
+        public MessageVersion MessageVersion { get; }
+        public override EndpointAddress RemoteAddress { get; }
+        public override Uri Via { get; }
+        protected override void AddHeadersTo(Message message);
+    }
+    public sealed class TransportSecurityBindingElement : SecurityBindingElement {
+        public TransportSecurityBindingElement();
+        protected override IChannelFactory<TChannel> BuildChannelFactoryCore<TChannel>(BindingContext context);
+        public override BindingElement Clone();
+        public override T GetProperty<T>(BindingContext context);
+    }
+    public sealed class UnderstoodHeaders : IEnumerable, IEnumerable<MessageHeaderInfo> {
+        public void Add(MessageHeaderInfo headerInfo);
+        public bool Contains(MessageHeaderInfo headerInfo);
+        public IEnumerator<MessageHeaderInfo> GetEnumerator();
+        public void Remove(MessageHeaderInfo headerInfo);
+        IEnumerator System.Collections.IEnumerable.GetEnumerator();
+    }
+    public static class WebSocketDefaults {
+        public const bool CreateNotificationOnConnection = false;
+        public const int BufferSize = 16384;
+        public const int MinReceiveBufferSize = 256;
+        public const int MinSendBufferSize = 16;
+        public const WebSocketTransportUsage TransportUsage = 2;
+        public const string DefaultKeepAliveIntervalString = "00:00:00";
+        public const string SubProtocol = null;
+        public const string WebSocketConnectionHeaderValue = "Upgrade";
+        public const string WebSocketUpgradeHeaderValue = "websocket";
+        public static readonly TimeSpan DefaultKeepAliveInterval;
+    }
+    public sealed class WebSocketTransportSettings : IEquatable<WebSocketTransportSettings> {
+        public const string BinaryEncoderTransferModeHeader = "microsoft-binary-transfer-mode";
+        public const string BinaryMessageReceivedAction = "http://schemas.microsoft.com/2011/02/websockets/onbinarymessage";
+        public const string ConnectionOpenedAction = "http://schemas.microsoft.com/2011/02/session/onopen";
+        public const string SoapContentTypeHeader = "soap-content-type";
+        public const string TextMessageReceivedAction = "http://schemas.microsoft.com/2011/02/websockets/ontextmessage";
+        public WebSocketTransportSettings();
+        public bool DisablePayloadMasking { get; set; }
+        public TimeSpan KeepAliveInterval { get; set; }
+        public string SubProtocol { get; set; }
+        public WebSocketTransportUsage TransportUsage { get; set; }
+        public override bool Equals(object obj);
+        public bool Equals(WebSocketTransportSettings other);
+        public override int GetHashCode();
+    }
+    public enum WebSocketTransportUsage {
+        Always = 1,
+        Never = 2,
+        WhenDuplex = 0,
+    }
+    public class WindowsStreamSecurityBindingElement : BindingElement {
+        public WindowsStreamSecurityBindingElement();
+        protected WindowsStreamSecurityBindingElement(WindowsStreamSecurityBindingElement elementToBeCloned);
+        public ProtectionLevel ProtectionLevel { get; set; }
+        public override IChannelFactory<TChannel> BuildChannelFactory<TChannel>(BindingContext context);
+        public override StreamUpgradeProvider BuildClientStreamUpgradeProvider(BindingContext context);
+        public override bool CanBuildChannelFactory<TChannel>(BindingContext context);
+        public override BindingElement Clone();
+        public override T GetProperty<T>(BindingContext context);
+    }
+    public class XmlObjectSerializerFault : MessageFault {
+        public XmlObjectSerializerFault(FaultCode code, FaultReason reason, object detail, XmlObjectSerializer serializer, string actor, string node);
+        public override string Actor { get; }
+        public override FaultCode Code { get; }
+        public override bool HasDetail { get; }
+        public override string Node { get; }
+        public override FaultReason Reason { get; }
+        protected override void OnWriteDetailContents(XmlDictionaryWriter writer);
+    }
+}
```

## System.ServiceModel.Description

```c#
+namespace System.ServiceModel.Description {
+    public class ClientCredentials : IEndpointBehavior {
+        public ClientCredentials();
+        protected ClientCredentials(ClientCredentials other);
+        public X509CertificateInitiatorClientCredential ClientCertificate { get; }
+        public HttpDigestClientCredential HttpDigest { get; }
+        public X509CertificateRecipientClientCredential ServiceCertificate { get; }
+        public UserNamePasswordClientCredential UserName { get; }
+        public WindowsClientCredential Windows { get; }
+        public virtual void ApplyClientBehavior(ServiceEndpoint serviceEndpoint, ClientRuntime behavior);
+        public ClientCredentials Clone();
+        protected virtual ClientCredentials CloneCore();
+        public override SecurityTokenManager CreateSecurityTokenManager();
+        void System.ServiceModel.Description.IEndpointBehavior.AddBindingParameters(ServiceEndpoint serviceEndpoint, BindingParameterCollection bindingParameters);
+        void System.ServiceModel.Description.IEndpointBehavior.ApplyDispatchBehavior(ServiceEndpoint serviceEndpoint, EndpointDispatcher endpointDispatcher);
+        void System.ServiceModel.Description.IEndpointBehavior.Validate(ServiceEndpoint serviceEndpoint);
+    }
+    public class ContractDescription {
+        public ContractDescription(string name);
+        public ContractDescription(string name, string ns);
+        public KeyedByTypeCollection<IContractBehavior> Behaviors { get; }
+        public Type CallbackContractType { get; set; }
+        public string ConfigurationName { get; set; }
+        public KeyedCollection<Type, IContractBehavior> ContractBehaviors { get; }
+        public Type ContractType { get; set; }
+        public bool HasProtectionLevel { get; }
+        public string Name { get; set; }
+        public string Namespace { get; set; }
+        public OperationDescriptionCollection Operations { get; }
+        public ProtectionLevel ProtectionLevel { get; set; }
+        public SessionMode SessionMode { get; set; }
+        public static ContractDescription GetContract(Type contractType);
+        public static ContractDescription GetContract(Type contractType, object serviceImplementation);
+        public static ContractDescription GetContract(Type contractType, Type serviceType);
+        public Collection<ContractDescription> GetInheritedContracts();
+        public bool ShouldSerializeProtectionLevel();
+    }
+    public class DataContractSerializerOperationBehavior : IOperationBehavior {
+        public DataContractSerializerOperationBehavior(OperationDescription operation);
+        public DataContractSerializerOperationBehavior(OperationDescription operation, DataContractFormatAttribute dataContractFormatAttribute);
+        public DataContractFormatAttribute DataContractFormatAttribute { get; }
+        public DataContractResolver DataContractResolver { get; set; }
+        public bool IgnoreExtensionDataObject { get; set; }
+        public int MaxItemsInObjectGraph { get; set; }
+        public virtual XmlObjectSerializer CreateSerializer(Type type, string name, string ns, IList<Type> knownTypes);
+        public virtual XmlObjectSerializer CreateSerializer(Type type, XmlDictionaryString name, XmlDictionaryString ns, IList<Type> knownTypes);
+        void System.ServiceModel.Description.IOperationBehavior.AddBindingParameters(OperationDescription description, BindingParameterCollection parameters);
+        void System.ServiceModel.Description.IOperationBehavior.ApplyClientBehavior(OperationDescription description, ClientOperation proxy);
+        void System.ServiceModel.Description.IOperationBehavior.ApplyDispatchBehavior(OperationDescription description, DispatchOperation dispatch);
+        void System.ServiceModel.Description.IOperationBehavior.Validate(OperationDescription description);
+    }
+    public class FaultDescription {
+        public FaultDescription(string action);
+        public string Action { get; }
+        public Type DetailType { get; set; }
+        public bool HasProtectionLevel { get; }
+        public string Name { get; set; }
+        public string Namespace { get; set; }
+        public ProtectionLevel ProtectionLevel { get; set; }
+        public bool ShouldSerializeProtectionLevel();
+    }
+    public class FaultDescriptionCollection : Collection<FaultDescription> {
+        public FaultDescription Find(string action);
+        public Collection<FaultDescription> FindAll(string action);
+    }
+    public interface IContractBehavior {
+        void AddBindingParameters(ContractDescription contractDescription, ServiceEndpoint endpoint, BindingParameterCollection bindingParameters);
+        void ApplyClientBehavior(ContractDescription contractDescription, ServiceEndpoint endpoint, ClientRuntime clientRuntime);
+        void ApplyDispatchBehavior(ContractDescription contractDescription, ServiceEndpoint endpoint, DispatchRuntime dispatchRuntime);
+        void Validate(ContractDescription contractDescription, ServiceEndpoint endpoint);
+    }
+    public interface IEndpointBehavior {
+        void AddBindingParameters(ServiceEndpoint endpoint, BindingParameterCollection bindingParameters);
+        void ApplyClientBehavior(ServiceEndpoint endpoint, ClientRuntime clientRuntime);
+        void ApplyDispatchBehavior(ServiceEndpoint endpoint, EndpointDispatcher endpointDispatcher);
+        void Validate(ServiceEndpoint endpoint);
+    }
+    public interface IOperationBehavior {
+        void AddBindingParameters(OperationDescription operationDescription, BindingParameterCollection bindingParameters);
+        void ApplyClientBehavior(OperationDescription operationDescription, ClientOperation clientOperation);
+        void ApplyDispatchBehavior(OperationDescription operationDescription, DispatchOperation dispatchOperation);
+        void Validate(OperationDescription operationDescription);
+    }
+    public enum ListenUriMode {
+        Explicit = 0,
+        Unique = 1,
+    }
+    public class MessageBodyDescription {
+        public MessageBodyDescription();
+        public MessagePartDescriptionCollection Parts { get; }
+        public MessagePartDescription ReturnValue { get; set; }
+        public string WrapperName { get; set; }
+        public string WrapperNamespace { get; set; }
+    }
+    public class MessageDescription {
+        public MessageDescription(string action, MessageDirection direction);
+        public string Action { get; }
+        public MessageBodyDescription Body { get; }
+        public MessageDirection Direction { get; }
+        public bool HasProtectionLevel { get; }
+        public MessageHeaderDescriptionCollection Headers { get; }
+        public Type MessageType { get; set; }
+        public MessagePropertyDescriptionCollection Properties { get; }
+        public ProtectionLevel ProtectionLevel { get; set; }
+        public bool ShouldSerializeProtectionLevel();
+    }
+    public class MessageDescriptionCollection : Collection<MessageDescription> {
+        public MessageDescription Find(string action);
+        public Collection<MessageDescription> FindAll(string action);
+    }
+    public enum MessageDirection {
+        Input = 0,
+        Output = 1,
+    }
+    public class MessageHeaderDescription : MessagePartDescription {
+        public MessageHeaderDescription(string name, string ns);
+        public string Actor { get; set; }
+        public bool MustUnderstand { get; set; }
+        public bool Relay { get; set; }
+        public bool TypedHeader { get; set; }
+    }
+    public class MessageHeaderDescriptionCollection : KeyedCollection<XmlQualifiedName, MessageHeaderDescription> {
+        protected override XmlQualifiedName GetKeyForItem(MessageHeaderDescription item);
+    }
+    public class MessagePartDescription {
+        public MessagePartDescription(string name, string ns);
+        public bool HasProtectionLevel { get; }
+        public int Index { get; set; }
+        public MemberInfo MemberInfo { get; set; }
+        public bool Multiple { get; set; }
+        public string Name { get; }
+        public string Namespace { get; }
+        public ProtectionLevel ProtectionLevel { get; set; }
+        public Type Type { get; set; }
+    }
+    public class MessagePartDescriptionCollection : KeyedCollection<XmlQualifiedName, MessagePartDescription> {
+        protected override XmlQualifiedName GetKeyForItem(MessagePartDescription item);
+    }
+    public class MessagePropertyDescription : MessagePartDescription {
+        public MessagePropertyDescription(string name);
+    }
+    public class MessagePropertyDescriptionCollection : KeyedCollection<string, MessagePropertyDescription> {
+        protected override string GetKeyForItem(MessagePropertyDescription item);
+    }
+    public class MetadataConversionError {
+        public MetadataConversionError(string message);
+        public MetadataConversionError(string message, bool isWarning);
+        public bool IsWarning { get; }
+        public string Message { get; }
+        public override bool Equals(object obj);
+        public override int GetHashCode();
+    }
+    public class MetadataLocation {
+        public MetadataLocation();
+        public MetadataLocation(string location);
+        public string Location { get; set; }
+    }
+    public class OperationDescription {
+        public OperationDescription(string name, ContractDescription declaringContract);
+        public MethodInfo BeginMethod { get; set; }
+        public KeyedByTypeCollection<IOperationBehavior> Behaviors { get; }
+        public ContractDescription DeclaringContract { get; set; }
+        public MethodInfo EndMethod { get; set; }
+        public FaultDescriptionCollection Faults { get; }
+        public bool IsInitiating { get; set; }
+        public bool IsOneWay { get; }
+        public Collection<Type> KnownTypes { get; }
+        public MessageDescriptionCollection Messages { get; }
+        public string Name { get; }
+        public KeyedCollection<Type, IOperationBehavior> OperationBehaviors { get; }
+        public MethodInfo SyncMethod { get; set; }
+        public MethodInfo TaskMethod { get; set; }
+    }
+    public class OperationDescriptionCollection : Collection<OperationDescription> {
+        public OperationDescription Find(string name);
+        public Collection<OperationDescription> FindAll(string name);
+        protected override void InsertItem(int index, OperationDescription item);
+        protected override void SetItem(int index, OperationDescription item);
+    }
+    public sealed class PolicyVersion {
+        public static PolicyVersion Default { get; }
+        public string Namespace { get; }
+        public static PolicyVersion Policy12 { get; }
+        public static PolicyVersion Policy15 { get; }
+        public override string ToString();
+    }
+    public enum PrincipalPermissionMode {
+        Always = 4,
+        Custom = 3,
+        None = 0,
+        UseAspNetRoles = 2,
+        UseWindowsGroups = 1,
+    }
+    public class ServiceEndpoint {
+        public ServiceEndpoint(ContractDescription contract);
+        public ServiceEndpoint(ContractDescription contract, Binding binding, EndpointAddress address);
+        public EndpointAddress Address { get; set; }
+        public KeyedByTypeCollection<IEndpointBehavior> Behaviors { get; }
+        public Binding Binding { get; set; }
+        public ContractDescription Contract { get; set; }
+        public KeyedCollection<Type, IEndpointBehavior> EndpointBehaviors { get; }
+        public bool IsSystemEndpoint { get; set; }
+        public Uri ListenUri { get; set; }
+        public ListenUriMode ListenUriMode { get; set; }
+        public string Name { get; set; }
+    }
+    public class ServiceEndpointCollection : Collection<ServiceEndpoint> {
+        public ServiceEndpoint Find(Type contractType);
+        public ServiceEndpoint Find(Type contractType, XmlQualifiedName bindingName);
+        public ServiceEndpoint Find(Uri address);
+        public ServiceEndpoint Find(XmlQualifiedName contractName);
+        public ServiceEndpoint Find(XmlQualifiedName contractName, XmlQualifiedName bindingName);
+        public Collection<ServiceEndpoint> FindAll(Type contractType);
+        public Collection<ServiceEndpoint> FindAll(XmlQualifiedName contractName);
+        protected override void InsertItem(int index, ServiceEndpoint item);
+        protected override void SetItem(int index, ServiceEndpoint item);
+    }
+    public class XmlSerializerOperationBehavior : IOperationBehavior {
+        public XmlSerializerOperationBehavior(OperationDescription operation);
+        public XmlSerializerOperationBehavior(OperationDescription operation, XmlSerializerFormatAttribute attribute);
+        public XmlSerializerFormatAttribute XmlSerializerFormatAttribute { get; }
+        void System.ServiceModel.Description.IOperationBehavior.AddBindingParameters(OperationDescription description, BindingParameterCollection parameters);
+        void System.ServiceModel.Description.IOperationBehavior.ApplyClientBehavior(OperationDescription description, ClientOperation proxy);
+        void System.ServiceModel.Description.IOperationBehavior.ApplyDispatchBehavior(OperationDescription description, DispatchOperation dispatch);
+        void System.ServiceModel.Description.IOperationBehavior.Validate(OperationDescription description);
+    }
+}
```

## System.ServiceModel.Diagnostics

```c#
+namespace System.ServiceModel.Diagnostics {
+    public class ExceptionUtility {
+        public ArgumentException ThrowHelperArgument(string message);
+        public ArgumentException ThrowHelperArgument(string paramName, string message);
+        public ArgumentNullException ThrowHelperArgumentNull(string paramName);
+        public ArgumentNullException ThrowHelperArgumentNull(string paramName, string message);
+        public ArgumentException ThrowHelperArgumentNullOrEmptyString(string arg);
+        public Exception ThrowHelperCallback(Exception innerException);
+        public Exception ThrowHelperCallback(string message, Exception innerException);
+        public Exception ThrowHelperCritical(Exception exception);
+        public Exception ThrowHelperError(Exception exception);
+        public Exception ThrowHelperFatal(string message, Exception innerException);
+        public Exception ThrowHelperInternal(bool fatal);
+        public Exception ThrowHelperInvalidOperation(string message);
+        public Exception ThrowHelperWarning(Exception exception);
+    }
+    public static class TraceUtility {
+        public const string E2EActivityId = "E2EActivityId";
+        public const string TraceApplicationReference = "TraceApplicationReference";
+        public static bool PropagateUserActivity { get; }
+        public static long RetrieveMessageNumber();
+    }
+}
```

## System.ServiceModel.Dispatcher

```c#
+namespace System.ServiceModel.Dispatcher {
+    public class ChannelDispatcher : ChannelDispatcherBase {
+        protected override TimeSpan DefaultCloseTimeout { get; }
+        protected override TimeSpan DefaultOpenTimeout { get; }
+        public SynchronizedCollection<EndpointDispatcher> Endpoints { get; }
+        public Collection<IErrorHandler> ErrorHandlers { get; }
+        public bool IncludeExceptionDetailInFaults { get; set; }
+        public override IChannelListener Listener { get; }
+        public bool ManualAddressing { get; set; }
+        public int MaxPendingReceives { get; set; }
+        public int MaxTransactedBatchSize { get; set; }
+        public MessageVersion MessageVersion { get; set; }
+        public bool ReceiveContextEnabled { get; set; }
+        public bool ReceiveSynchronously { get; set; }
+        public bool SendAsynchronously { get; set; }
+        public override void CloseInput();
+        protected override void OnAbort();
+        protected override IAsyncResult OnBeginClose(TimeSpan timeout, AsyncCallback callback, object state);
+        protected override IAsyncResult OnBeginOpen(TimeSpan timeout, AsyncCallback callback, object state);
+        protected override void OnClose(TimeSpan timeout);
+        protected internal override Task OnCloseAsync(TimeSpan timeout);
+        protected override void OnClosed();
+        protected override void OnEndClose(IAsyncResult result);
+        protected override void OnEndOpen(IAsyncResult result);
+        protected override void OnOpen(TimeSpan timeout);
+        protected internal override Task OnOpenAsync(TimeSpan timeout);
+        protected override void OnOpened();
+        protected override void OnOpening();
+    }
+    public abstract class ChannelDispatcherBase : CommunicationObject {
+        protected ChannelDispatcherBase();
+        public abstract IChannelListener Listener { get; }
+        public virtual void CloseInput();
+    }
+    public sealed class ClientOperation {
+        public ClientOperation(ClientRuntime parent, string name, string action);
+        public ClientOperation(ClientRuntime parent, string name, string action, string replyAction);
+        public string Action { get; }
+        public MethodInfo BeginMethod { get; set; }
+        public ICollection<IParameterInspector> ClientParameterInspectors { get; }
+        public bool DeserializeReply { get; set; }
+        public MethodInfo EndMethod { get; set; }
+        public SynchronizedCollection<FaultContractInfo> FaultContractInfos { get; }
+        public IClientMessageFormatter Formatter { get; set; }
+        public bool IsInitiating { get; set; }
+        public bool IsOneWay { get; set; }
+        public string Name { get; }
+        public new SynchronizedCollection<IParameterInspector> ParameterInspectors { get; }
+        public ClientRuntime Parent { get; }
+        public string ReplyAction { get; }
+        public bool SerializeRequest { get; set; }
+        public MethodInfo SyncMethod { get; set; }
+        public MethodInfo TaskMethod { get; set; }
+        public Type TaskTResult { get; set; }
+    }
+    public class ClientOperationCompatBase {
+        public IList<IParameterInspector> ParameterInspectors { get; }
+    }
+    public sealed class ClientRuntime {
+        public Type CallbackClientType { get; set; }
+        public DispatchRuntime CallbackDispatchRuntime { get; }
+        public SynchronizedCollection<IChannelInitializer> ChannelInitializers { get; }
+        public ICollection<IClientMessageInspector> ClientMessageInspectors { get; }
+        public ICollection<ClientOperation> ClientOperations { get; }
+        public Type ContractClientType { get; set; }
+        public string ContractName { get; }
+        public string ContractNamespace { get; }
+        public DispatchRuntime DispatchRuntime { get; }
+        public SynchronizedCollection<IInteractiveChannelInitializer> InteractiveChannelInitializers { get; }
+        public bool ManualAddressing { get; set; }
+        public int MaxFaultSize { get; set; }
+        public new SynchronizedCollection<IClientMessageInspector> MessageInspectors { get; }
+        public bool MessageVersionNoneFaultsEnabled { get; set; }
+        public new SynchronizedKeyedCollection<string, ClientOperation> Operations { get; }
+        public IClientOperationSelector OperationSelector { get; set; }
+        public ClientOperation UnhandledClientOperation { get; }
+        public bool ValidateMustUnderstand { get; set; }
+        public Uri Via { get; set; }
+    }
+    public class ClientRuntimeCompatBase {
+        public IList<IClientMessageInspector> MessageInspectors { get; }
+        public KeyedCollection<string, ClientOperation> Operations { get; }
+    }
+    public sealed class DispatchOperation {
+        public DispatchOperation(DispatchRuntime parent, string name, string action);
+        public DispatchOperation(DispatchRuntime parent, string name, string action, string replyAction);
+        public string Action { get; }
+        public bool AutoDisposeParameters { get; set; }
+        public bool DeserializeRequest { get; set; }
+        public SynchronizedCollection<FaultContractInfo> FaultContractInfos { get; }
+        public IOperationInvoker Invoker { get; set; }
+        public bool IsOneWay { get; }
+        public string Name { get; }
+        public SynchronizedCollection<IParameterInspector> ParameterInspectors { get; }
+        public DispatchRuntime Parent { get; }
+        public string ReplyAction { get; }
+        public bool SerializeReply { get; set; }
+    }
+    public sealed class DispatchRuntime {
+        public bool AutomaticInputSessionShutdown { get; set; }
+        public ClientRuntime CallbackClientRuntime { get; }
+        public ChannelDispatcher ChannelDispatcher { get; }
+        public ConcurrencyMode ConcurrencyMode { get; set; }
+        public EndpointDispatcher EndpointDispatcher { get; }
+        public bool EnsureOrderedDispatch { get; set; }
+        public IInstanceContextProvider InstanceContextProvider { get; set; }
+        public IInstanceProvider InstanceProvider { get; set; }
+        public SynchronizedKeyedCollection<string, DispatchOperation> Operations { get; }
+        public SynchronizationContext SynchronizationContext { get; set; }
+        public Type Type { get; set; }
+        public DispatchOperation UnhandledDispatchOperation { get; set; }
+    }
+    public class EndpointDispatcher {
+        public EndpointDispatcher();
+        public ChannelDispatcher ChannelDispatcher { get; }
+        public string ContractName { get; }
+        public string ContractNamespace { get; }
+        public DispatchRuntime DispatchRuntime { get; }
+        public EndpointAddress EndpointAddress { get; }
+        public int FilterPriority { get; set; }
+    }
+    public class FaultContractInfo {
+        public FaultContractInfo(string action, Type detail);
+        public string Action { get; }
+        public Type Detail { get; }
+    }
+    public class FaultFormatter : IClientFaultFormatter, IDispatchFaultFormatter {
+        protected virtual FaultException CreateFaultException(MessageFault messageFault, string action);
+        protected FaultException CreateFaultException(MessageFault messageFault, string action, object detailObj, Type detailType, XmlDictionaryReader detailReader);
+        public FaultException Deserialize(MessageFault messageFault, string action);
+        protected virtual XmlObjectSerializer GetSerializer(Type detailType, string faultExceptionAction, out string action);
+        public MessageFault Serialize(FaultException faultException, out string action);
+        public class OperationFault<T> : XmlObjectSerializerFault {
+            public OperationFault(XmlObjectSerializer serializer, FaultException<T> faultException);
+        }
+    }
+    public interface IChannelInitializer {
+        void Initialize(IClientChannel channel);
+    }
+    public interface IClientMessageFormatter {
+        object DeserializeReply(Message message, object[] parameters);
+        Message SerializeRequest(MessageVersion messageVersion, object[] parameters);
+    }
+    public interface IClientMessageInspector {
+        void AfterReceiveReply(ref Message reply, object correlationState);
+        object BeforeSendRequest(ref Message request, IClientChannel channel);
+    }
+    public interface IClientOperationSelector {
+        bool AreParametersRequiredForSelection { get; }
+        string SelectOperation(MethodBase method, object[] parameters);
+    }
+    public interface IErrorHandler {
+        bool HandleError(Exception error);
+        void ProvideFault(Exception error, MessageVersion version, ref Message fault);
+    }
+    public interface IInstanceContextProvider {
+        InstanceContext GetExistingInstanceContext(Message message, IContextChannel channel);
+    }
+    public interface IInstanceProvider {
+        object GetInstance(InstanceContext instanceContext);
+        object GetInstance(InstanceContext instanceContext, Message message);
+        void ReleaseInstance(InstanceContext instanceContext, object instance);
+    }
+    public interface IInteractiveChannelInitializer {
+        IAsyncResult BeginDisplayInitializationUI(IClientChannel channel, AsyncCallback callback, object state);
+        void EndDisplayInitializationUI(IAsyncResult result);
+    }
+    public class InstanceBehavior
+    public interface IOperationInvoker {
+        object[] AllocateInputs();
+        IAsyncResult InvokeBegin(object instance, object[] inputs, AsyncCallback callback, object state);
+        object InvokeEnd(object instance, out object[] outputs, IAsyncResult result);
+    }
+    public interface IParameterInspector {
+        void AfterCall(string operationName, object[] outputs, object returnValue, object correlationState);
+        object BeforeCall(string operationName, object[] inputs);
+    }
+    public class OperationInvokerBehavior : IOperationBehavior {
+        public OperationInvokerBehavior();
+        void System.ServiceModel.Description.IOperationBehavior.AddBindingParameters(OperationDescription description, BindingParameterCollection parameters);
+        void System.ServiceModel.Description.IOperationBehavior.ApplyClientBehavior(OperationDescription description, ClientOperation proxy);
+        void System.ServiceModel.Description.IOperationBehavior.ApplyDispatchBehavior(OperationDescription description, DispatchOperation dispatch);
+        void System.ServiceModel.Description.IOperationBehavior.Validate(OperationDescription description);
+    }
+    public class SyncMethodInvoker : IOperationInvoker {
+        public SyncMethodInvoker(MethodInfo method);
+        public MethodInfo Method { get; }
+        public string MethodName { get; }
+        public object[] AllocateInputs();
+        public IAsyncResult InvokeBegin(object instance, object[] inputs, AsyncCallback callback, object state);
+        public object InvokeEnd(object instance, out object[] outputs, IAsyncResult result);
+    }
+    public class TaskMethodInvoker : IOperationInvoker {
+        public TaskMethodInvoker(MethodInfo taskMethod, Type taskType);
+        public MethodInfo Method { get; }
+        public string MethodName { get; }
+        public object[] AllocateInputs();
+        public IAsyncResult InvokeBegin(object instance, object[] inputs, AsyncCallback callback, object state);
+        public object InvokeEnd(object instance, out object[] outputs, IAsyncResult result);
+    }
+}
```

## System.ServiceModel.Security

```c#
+namespace System.ServiceModel.Security {
+    public class Basic128SecurityAlgorithmSuite : SecurityAlgorithmSuite {
+        public Basic128SecurityAlgorithmSuite();
+        public override string DefaultAsymmetricKeyWrapAlgorithm { get; }
+        public override string DefaultAsymmetricSignatureAlgorithm { get; }
+        public override string DefaultCanonicalizationAlgorithm { get; }
+        public override string DefaultDigestAlgorithm { get; }
+        public override string DefaultEncryptionAlgorithm { get; }
+        public override int DefaultEncryptionKeyDerivationLength { get; }
+        public override int DefaultSignatureKeyDerivationLength { get; }
+        public override int DefaultSymmetricKeyLength { get; }
+        public override string DefaultSymmetricKeyWrapAlgorithm { get; }
+        public override string DefaultSymmetricSignatureAlgorithm { get; }
+        public override bool IsAsymmetricKeyLengthSupported(int length);
+        public override bool IsSymmetricKeyLengthSupported(int length);
+        public override string ToString();
+    }
+    public class Basic192SecurityAlgorithmSuite : SecurityAlgorithmSuite {
+        public Basic192SecurityAlgorithmSuite();
+        public override string DefaultAsymmetricKeyWrapAlgorithm { get; }
+        public override string DefaultAsymmetricSignatureAlgorithm { get; }
+        public override string DefaultCanonicalizationAlgorithm { get; }
+        public override string DefaultDigestAlgorithm { get; }
+        public override string DefaultEncryptionAlgorithm { get; }
+        public override int DefaultEncryptionKeyDerivationLength { get; }
+        public override int DefaultSignatureKeyDerivationLength { get; }
+        public override int DefaultSymmetricKeyLength { get; }
+        public override string DefaultSymmetricKeyWrapAlgorithm { get; }
+        public override string DefaultSymmetricSignatureAlgorithm { get; }
+        public override bool IsAsymmetricKeyLengthSupported(int length);
+        public override bool IsSymmetricKeyLengthSupported(int length);
+        public override string ToString();
+    }
+    public class Basic256SecurityAlgorithmSuite : SecurityAlgorithmSuite {
+        public Basic256SecurityAlgorithmSuite();
+        public override string DefaultAsymmetricKeyWrapAlgorithm { get; }
+        public override string DefaultAsymmetricSignatureAlgorithm { get; }
+        public override string DefaultCanonicalizationAlgorithm { get; }
+        public override string DefaultDigestAlgorithm { get; }
+        public override string DefaultEncryptionAlgorithm { get; }
+        public override int DefaultEncryptionKeyDerivationLength { get; }
+        public override int DefaultSignatureKeyDerivationLength { get; }
+        public override int DefaultSymmetricKeyLength { get; }
+        public override string DefaultSymmetricKeyWrapAlgorithm { get; }
+        public override string DefaultSymmetricSignatureAlgorithm { get; }
+        public override bool IsAsymmetricKeyLengthSupported(int length);
+        public override bool IsSymmetricKeyLengthSupported(int length);
+        public override string ToString();
+    }
+    public abstract class BasicSecurityProfileVersion {
+        public static BasicSecurityProfileVersion BasicSecurityProfile10 { get; }
+    }
+    public class ChannelProtectionRequirements {
+        public ChannelProtectionRequirements();
+        public ChannelProtectionRequirements(ChannelProtectionRequirements other);
+        public ScopedMessagePartSpecification IncomingEncryptionParts { get; }
+        public ScopedMessagePartSpecification IncomingSignatureParts { get; }
+        public bool IsReadOnly { get; }
+        public ScopedMessagePartSpecification OutgoingEncryptionParts { get; }
+        public ScopedMessagePartSpecification OutgoingSignatureParts { get; }
+        public void Add(ChannelProtectionRequirements protectionRequirements);
+        public void Add(ChannelProtectionRequirements protectionRequirements, bool channelScopeOnly);
+        public ChannelProtectionRequirements CreateInverse();
+        public void MakeReadOnly();
+    }
+    public sealed class HttpDigestClientCredential {
+        public NetworkCredential ClientCredential { get; set; }
+    }
+    public abstract class IdentityVerifier {
+        protected IdentityVerifier();
+        public abstract bool CheckAccess(EndpointIdentity identity, AuthorizationContext authContext);
+        public static IdentityVerifier CreateDefault();
+        public abstract bool TryGetIdentity(EndpointAddress reference, out EndpointIdentity identity);
+    }
+    public interface ISecuritySession : ISession {
+        EndpointIdentity RemoteIdentity { get; }
+    }
+    public class MessagePartSpecification {
+        public MessagePartSpecification();
+        public MessagePartSpecification(bool isBodyIncluded);
+        public MessagePartSpecification(bool isBodyIncluded, params XmlQualifiedName[] headerTypes);
+        public MessagePartSpecification(params XmlQualifiedName[] headerTypes);
+        public ICollection<XmlQualifiedName> HeaderTypes { get; }
+        public bool IsBodyIncluded { get; set; }
+        public bool IsReadOnly { get; }
+        public static MessagePartSpecification NoParts { get; }
+        public void Clear();
+        public void MakeReadOnly();
+        public void Union(MessagePartSpecification specification);
+    }
+    public enum MessageProtectionOrder {
+        EncryptBeforeSign = 2,
+        SignBeforeEncrypt = 0,
+        SignBeforeEncryptAndEncryptSignature = 1,
+    }
+    public class MessageSecurityException : CommunicationException {
+        public MessageSecurityException();
+        public MessageSecurityException(string message);
+        public MessageSecurityException(string message, Exception innerException);
+    }
+    public sealed class MessageSecurityTokenVersion : SecurityTokenVersion {
+        public bool EmitBspRequiredAttributes { get; }
+        public SecureConversationVersion SecureConversationVersion { get; }
+        public SecurityVersion SecurityVersion { get; }
+        public TrustVersion TrustVersion { get; }
+        public static MessageSecurityTokenVersion WSSecurity10WSTrust13WSSecureConversation13BasicSecurityProfile10 { get; }
+        public static MessageSecurityTokenVersion WSSecurity10WSTrustFebruary2005WSSecureConversationFebruary2005BasicSecurityProfile10 { get; }
+        public static MessageSecurityTokenVersion WSSecurity11WSTrust13WSSecureConversation13 { get; }
+        public static MessageSecurityTokenVersion WSSecurity11WSTrust13WSSecureConversation13BasicSecurityProfile10 { get; }
+        public static MessageSecurityTokenVersion WSSecurity11WSTrustFebruary2005WSSecureConversationFebruary2005 { get; }
+        public static MessageSecurityTokenVersion WSSecurity11WSTrustFebruary2005WSSecureConversationFebruary2005BasicSecurityProfile10 { get; }
+        public override ReadOnlyCollection<string> GetSecuritySpecifications();
+        public static MessageSecurityTokenVersion GetSecurityTokenVersion(SecurityVersion version, bool emitBspAttributes);
+        public override string ToString();
+    }
+    public abstract class NonceCache {
+        protected NonceCache();
+        public int CacheSize { get; set; }
+        public TimeSpan CachingTimeSpan { get; set; }
+        public abstract bool CheckNonce(byte[] nonce);
+        public abstract bool TryAddNonce(byte[] nonce);
+    }
+    public static class ProtectionLevelHelper {
+        public static int GetOrdinal(Nullable<ProtectionLevel> p);
+        public static bool IsDefined(ProtectionLevel value);
+        public static bool IsStronger(ProtectionLevel v1, ProtectionLevel v2);
+        public static bool IsStrongerOrEqual(ProtectionLevel v1, ProtectionLevel v2);
+        public static ProtectionLevel Max(ProtectionLevel v1, ProtectionLevel v2);
+        public static void Validate(ProtectionLevel value);
+    }
+    public class ScopedMessagePartSpecification {
+        public ScopedMessagePartSpecification();
+        public ScopedMessagePartSpecification(ScopedMessagePartSpecification other);
+        public ICollection<string> Actions { get; }
+        public MessagePartSpecification ChannelParts { get; }
+        public bool IsReadOnly { get; }
+        public void AddParts(MessagePartSpecification parts);
+        public void AddParts(MessagePartSpecification parts, string action);
+        public void MakeReadOnly();
+        public bool TryGetParts(string action, bool excludeChannelScope, out MessagePartSpecification parts);
+        public bool TryGetParts(string action, out MessagePartSpecification parts);
+    }
+    public abstract class SecureConversationVersion {
+        public static SecureConversationVersion Default { get; }
+        public XmlDictionaryString Namespace { get; }
+        public XmlDictionaryString Prefix { get; }
+        public static SecureConversationVersion WSSecureConversation13 { get; }
+        public static SecureConversationVersion WSSecureConversationFeb2005 { get; }
+    }
+    public class SecurityAccessDeniedException : CommunicationException {
+        public SecurityAccessDeniedException(string message);
+        public SecurityAccessDeniedException(string message, Exception innerException);
+    }
+    public abstract class SecurityAlgorithmSuite {
+        protected SecurityAlgorithmSuite();
+        public static SecurityAlgorithmSuite Basic128 { get; }
+        public static SecurityAlgorithmSuite Basic128Rsa15 { get; }
+        public static SecurityAlgorithmSuite Basic128Sha256 { get; }
+        public static SecurityAlgorithmSuite Basic128Sha256Rsa15 { get; }
+        public static SecurityAlgorithmSuite Basic192 { get; }
+        public static SecurityAlgorithmSuite Basic192Rsa15 { get; }
+        public static SecurityAlgorithmSuite Basic192Sha256 { get; }
+        public static SecurityAlgorithmSuite Basic192Sha256Rsa15 { get; }
+        public static SecurityAlgorithmSuite Basic256 { get; }
+        public static SecurityAlgorithmSuite Basic256Rsa15 { get; }
+        public static SecurityAlgorithmSuite Basic256Sha256 { get; }
+        public static SecurityAlgorithmSuite Basic256Sha256Rsa15 { get; }
+        public static SecurityAlgorithmSuite Default { get; }
+        public abstract string DefaultAsymmetricKeyWrapAlgorithm { get; }
+        public abstract string DefaultAsymmetricSignatureAlgorithm { get; }
+        public abstract string DefaultCanonicalizationAlgorithm { get; }
+        public abstract string DefaultDigestAlgorithm { get; }
+        public abstract string DefaultEncryptionAlgorithm { get; }
+        public abstract int DefaultEncryptionKeyDerivationLength { get; }
+        public abstract int DefaultSignatureKeyDerivationLength { get; }
+        public abstract int DefaultSymmetricKeyLength { get; }
+        public abstract string DefaultSymmetricKeyWrapAlgorithm { get; }
+        public abstract string DefaultSymmetricSignatureAlgorithm { get; }
+        public static SecurityAlgorithmSuite TripleDes { get; }
+        public static SecurityAlgorithmSuite TripleDesRsa15 { get; }
+        public static SecurityAlgorithmSuite TripleDesSha256 { get; }
+        public static SecurityAlgorithmSuite TripleDesSha256Rsa15 { get; }
+        public abstract bool IsAsymmetricKeyLengthSupported(int length);
+        public virtual bool IsAsymmetricKeyWrapAlgorithmSupported(string algorithm);
+        public virtual bool IsAsymmetricSignatureAlgorithmSupported(string algorithm);
+        public virtual bool IsCanonicalizationAlgorithmSupported(string algorithm);
+        public virtual bool IsDigestAlgorithmSupported(string algorithm);
+        public virtual bool IsEncryptionAlgorithmSupported(string algorithm);
+        public virtual bool IsEncryptionKeyDerivationAlgorithmSupported(string algorithm);
+        public virtual bool IsSignatureKeyDerivationAlgorithmSupported(string algorithm);
+        public abstract bool IsSymmetricKeyLengthSupported(int length);
+        public virtual bool IsSymmetricKeyWrapAlgorithmSupported(string algorithm);
+        public virtual bool IsSymmetricSignatureAlgorithmSupported(string algorithm);
+    }
+    public class SecurityContextKeyIdentifierClause : SecurityKeyIdentifierClause {
+        public SecurityContextKeyIdentifierClause(UniqueId contextId);
+        public SecurityContextKeyIdentifierClause(UniqueId contextId, UniqueId generation);
+        public SecurityContextKeyIdentifierClause(UniqueId contextId, UniqueId generation, byte[] derivationNonce, int derivationLength);
+        public UniqueId ContextId { get; }
+        public UniqueId Generation { get; }
+        public override bool Matches(SecurityKeyIdentifierClause keyIdentifierClause);
+        public bool Matches(UniqueId contextId, UniqueId generation);
+        public override string ToString();
+    }
+    public abstract class SecurityCredentialsManager {
+        protected SecurityCredentialsManager();
+        public abstract SecurityTokenManager CreateSecurityTokenManager();
+    }
+    public enum SecurityKeyEntropyMode {
+        ClientEntropy = 0,
+        CombinedEntropy = 2,
+        ServerEntropy = 1,
+    }
+    public class SecurityMessageProperty : IDisposable, IMessageProperty {
+        public SecurityMessageProperty();
+        public ReadOnlyCollection<IAuthorizationPolicy> ExternalAuthorizationPolicies { get; set; }
+        public bool HasIncomingSupportingTokens { get; }
+        public Collection<SupportingTokenSpecification> IncomingSupportingTokens { get; }
+        public SecurityTokenSpecification InitiatorToken { get; set; }
+        public Collection<SupportingTokenSpecification> OutgoingSupportingTokens { get; }
+        public SecurityTokenSpecification ProtectionToken { get; set; }
+        public SecurityTokenSpecification RecipientToken { get; set; }
+        public string SenderIdPrefix { get; set; }
+        public ServiceSecurityContext ServiceSecurityContext { get; set; }
+        public SecurityTokenSpecification TransportToken { get; set; }
+        public IMessageProperty CreateCopy();
+        public void Dispose();
+        public static SecurityMessageProperty GetOrCreate(Message message);
+    }
+    public class SecurityNegotiationException : CommunicationException {
+        public SecurityNegotiationException();
+        public SecurityNegotiationException(string message);
+        public SecurityNegotiationException(string message, Exception innerException);
+    }
+    public abstract class SecurityPolicyVersion {
+        public string Namespace { get; }
+        public string Prefix { get; }
+        public static SecurityPolicyVersion WSSecurityPolicy11 { get; }
+        public static SecurityPolicyVersion WSSecurityPolicy12 { get; }
+    }
+    public abstract class SecurityStateEncoder {
+        protected SecurityStateEncoder();
+        protected internal abstract byte[] DecodeSecurityState(byte[] data);
+        protected internal abstract byte[] EncodeSecurityState(byte[] data);
+    }
+    public enum SecurityTokenAttachmentMode {
+        Endorsing = 1,
+        Signed = 0,
+        SignedEncrypted = 3,
+        SignedEndorsing = 2,
+    }
+    public class SecurityTokenSpecification {
+        public SecurityTokenSpecification(SecurityToken token, ReadOnlyCollection<IAuthorizationPolicy> tokenPolicies);
+        public SecurityToken SecurityToken { get; }
+        public ReadOnlyCollection<IAuthorizationPolicy> SecurityTokenPolicies { get; }
+    }
+    public abstract class SecurityVersion {
+        public static SecurityVersion WSSecurity10 { get; }
+        public static SecurityVersion WSSecurity11 { get; }
+    }
+    public class SspiSecurityTokenProvider : SecurityTokenProvider {
+        public SspiSecurityTokenProvider(NetworkCredential credential, bool extractGroupsForWindowsAccounts, bool allowUnauthenticatedCallers);
+        public SspiSecurityTokenProvider(NetworkCredential credential, bool allowNtlm, TokenImpersonationLevel impersonationLevel);
+        protected override Task<SecurityToken> GetTokenCoreAsync(CancellationToken cancellationToken);
+    }
+    public class SupportingTokenSpecification : SecurityTokenSpecification {
+        public SupportingTokenSpecification(SecurityToken token, ReadOnlyCollection<IAuthorizationPolicy> tokenPolicies, SecurityTokenAttachmentMode attachmentMode);
+        public SupportingTokenSpecification(SecurityToken token, ReadOnlyCollection<IAuthorizationPolicy> tokenPolicies, SecurityTokenAttachmentMode attachmentMode, SecurityTokenParameters tokenParameters);
+        public SecurityTokenAttachmentMode SecurityTokenAttachmentMode { get; }
+    }
+    public class TripleDesSecurityAlgorithmSuite : SecurityAlgorithmSuite {
+        public TripleDesSecurityAlgorithmSuite();
+        public override string DefaultAsymmetricKeyWrapAlgorithm { get; }
+        public override string DefaultAsymmetricSignatureAlgorithm { get; }
+        public override string DefaultCanonicalizationAlgorithm { get; }
+        public override string DefaultDigestAlgorithm { get; }
+        public override string DefaultEncryptionAlgorithm { get; }
+        public override int DefaultEncryptionKeyDerivationLength { get; }
+        public override int DefaultSignatureKeyDerivationLength { get; }
+        public override int DefaultSymmetricKeyLength { get; }
+        public override string DefaultSymmetricKeyWrapAlgorithm { get; }
+        public override string DefaultSymmetricSignatureAlgorithm { get; }
+        public override bool IsAsymmetricKeyLengthSupported(int length);
+        public override bool IsSymmetricKeyLengthSupported(int length);
+        public override string ToString();
+    }
+    public abstract class TrustVersion {
+        public static TrustVersion Default { get; }
+        public XmlDictionaryString Namespace { get; }
+        public XmlDictionaryString Prefix { get; }
+        public static TrustVersion WSTrust13 { get; }
+        public static TrustVersion WSTrustFeb2005 { get; }
+    }
+    public sealed class UserNamePasswordClientCredential {
+        public string Password { get; set; }
+        public string UserName { get; set; }
+    }
+    public sealed class WindowsClientCredential {
+        public TokenImpersonationLevel AllowedImpersonationLevel { get; set; }
+        public bool AllowNtlm { get; set; }
+        public NetworkCredential ClientCredential { get; set; }
+    }
+    public class WSSecurityTokenSerializer : SecurityTokenSerializer {
+        public WSSecurityTokenSerializer();
+        public WSSecurityTokenSerializer(bool emitBspRequiredAttributes);
+        public WSSecurityTokenSerializer(SecurityVersion securityVersion);
+        public WSSecurityTokenSerializer(SecurityVersion securityVersion, bool emitBspRequiredAttributes);
+        public WSSecurityTokenSerializer(SecurityVersion securityVersion, bool emitBspRequiredAttributes, SamlSerializer samlSerializer);
+        public WSSecurityTokenSerializer(SecurityVersion securityVersion, bool emitBspRequiredAttributes, SamlSerializer samlSerializer, SecurityStateEncoder securityStateEncoder, IEnumerable<Type> knownTypes);
+        public WSSecurityTokenSerializer(SecurityVersion securityVersion, bool emitBspRequiredAttributes, SamlSerializer samlSerializer, SecurityStateEncoder securityStateEncoder, IEnumerable<Type> knownTypes, int maximumKeyDerivationOffset, int maximumKeyDerivationLabelLength, int maximumKeyDerivationNonceLength);
+        public WSSecurityTokenSerializer(SecurityVersion securityVersion, TrustVersion trustVersion, SecureConversationVersion secureConversationVersion, bool emitBspRequiredAttributes, SamlSerializer samlSerializer, SecurityStateEncoder securityStateEncoder, IEnumerable<Type> knownTypes);
+        public WSSecurityTokenSerializer(SecurityVersion securityVersion, TrustVersion trustVersion, SecureConversationVersion secureConversationVersion, bool emitBspRequiredAttributes, SamlSerializer samlSerializer, SecurityStateEncoder securityStateEncoder, IEnumerable<Type> knownTypes, int maximumKeyDerivationOffset, int maximumKeyDerivationLabelLength, int maximumKeyDerivationNonceLength);
+        public static WSSecurityTokenSerializer DefaultInstance { get; }
+        public bool EmitBspRequiredAttributes { get; }
+        public int MaximumKeyDerivationLabelLength { get; }
+        public int MaximumKeyDerivationNonceLength { get; }
+        public int MaximumKeyDerivationOffset { get; }
+        public SecurityVersion SecurityVersion { get; }
+        protected override bool CanReadKeyIdentifierClauseCore(XmlReader reader);
+        protected override bool CanReadKeyIdentifierCore(XmlReader reader);
+        protected override bool CanReadTokenCore(XmlReader reader);
+        protected override bool CanWriteKeyIdentifierClauseCore(SecurityKeyIdentifierClause keyIdentifierClause);
+        protected override bool CanWriteKeyIdentifierCore(SecurityKeyIdentifier keyIdentifier);
+        protected override bool CanWriteTokenCore(SecurityToken token);
+        public virtual SecurityKeyIdentifierClause CreateKeyIdentifierClauseFromTokenXml(XmlElement element, SecurityTokenReferenceStyle tokenReferenceStyle);
+        protected internal virtual string GetTokenTypeUri(Type tokenType);
+        protected override SecurityKeyIdentifierClause ReadKeyIdentifierClauseCore(XmlReader reader);
+        protected override SecurityKeyIdentifier ReadKeyIdentifierCore(XmlReader reader);
+        protected override SecurityToken ReadTokenCore(XmlReader reader, SecurityTokenResolver tokenResolver);
+        public virtual bool TryCreateKeyIdentifierClauseFromTokenXml(XmlElement element, SecurityTokenReferenceStyle tokenReferenceStyle, out SecurityKeyIdentifierClause securityKeyIdentifierClause);
+        protected override void WriteKeyIdentifierClauseCore(XmlWriter writer, SecurityKeyIdentifierClause keyIdentifierClause);
+        protected override void WriteKeyIdentifierCore(XmlWriter writer, SecurityKeyIdentifier keyIdentifier);
+        protected override void WriteTokenCore(XmlWriter writer, SecurityToken token);
+    }
+    public sealed class X509CertificateInitiatorClientCredential {
+        public X509Certificate2 Certificate { get; set; }
+        public void SetCertificate(StoreLocation storeLocation, StoreName storeName, X509FindType findType, object findValue);
+        public void SetCertificate(string subjectName, StoreLocation storeLocation, StoreName storeName);
+    }
+    public sealed class X509CertificateRecipientClientCredential {
+        public X509ServiceCertificateAuthentication Authentication { get; }
+        public X509Certificate2 DefaultCertificate { get; set; }
+        public Dictionary<Uri, X509Certificate2> ScopedCertificates { get; }
+        public X509ServiceCertificateAuthentication SslCertificateAuthentication { get; set; }
+        public void SetDefaultCertificate(StoreLocation storeLocation, StoreName storeName, X509FindType findType, object findValue);
+        public void SetDefaultCertificate(string subjectName, StoreLocation storeLocation, StoreName storeName);
+        public void SetScopedCertificate(StoreLocation storeLocation, StoreName storeName, X509FindType findType, object findValue, Uri targetService);
+        public void SetScopedCertificate(string subjectName, StoreLocation storeLocation, StoreName storeName, Uri targetService);
+    }
+    public enum X509CertificateValidationMode {
+        ChainTrust = 2,
+        Custom = 4,
+        None = 0,
+        PeerOrChainTrust = 3,
+        PeerTrust = 1,
+    }
+    public class X509ClientCertificateAuthentication {
+        public X509ClientCertificateAuthentication();
+    }
+    public sealed class X509ServiceCertificateAuthentication {
+        public X509ServiceCertificateAuthentication();
+        public X509CertificateValidationMode CertificateValidationMode { get; set; }
+        public X509CertificateValidator CustomCertificateValidator { get; set; }
+        public X509RevocationMode RevocationMode { get; set; }
+        public StoreLocation TrustedStoreLocation { get; set; }
+    }
+}
```

## System.ServiceModel.Security.Tokens

```c#
+namespace System.ServiceModel.Security.Tokens {
+    public class ClaimTypeRequirement {
+        public ClaimTypeRequirement(string claimType);
+        public ClaimTypeRequirement(string claimType, bool isOptional);
+        public string ClaimType { get; }
+        public bool IsOptional { get; }
+    }
+    public sealed class InitiatorServiceModelSecurityTokenRequirement : ServiceModelSecurityTokenRequirement {
+        public InitiatorServiceModelSecurityTokenRequirement();
+        public EndpointAddress TargetAddress { get; set; }
+        public Uri Via { get; set; }
+        public override string ToString();
+    }
+    public interface ISecurityContextSecurityTokenCache {
+        void AddContext(SecurityContextSecurityToken token);
+        void ClearContexts();
+        Collection<SecurityContextSecurityToken> GetAllContexts(UniqueId contextId);
+        SecurityContextSecurityToken GetContext(UniqueId contextId, UniqueId generation);
+        void RemoveAllContexts(UniqueId contextId);
+        void RemoveContext(UniqueId contextId, UniqueId generation);
+        bool TryAddContext(SecurityContextSecurityToken token);
+        void UpdateContextCachingTime(SecurityContextSecurityToken context, DateTime expirationTime);
+    }
+    public sealed class RecipientServiceModelSecurityTokenRequirement : ServiceModelSecurityTokenRequirement {
+        public RecipientServiceModelSecurityTokenRequirement();
+        public Uri ListenUri { get; set; }
+        public override string ToString();
+    }
+    public class SecureConversationSecurityTokenParameters : SecurityTokenParameters {
+        public SecureConversationSecurityTokenParameters();
+        public SecureConversationSecurityTokenParameters(SecurityBindingElement bootstrapSecurityBindingElement);
+        protected SecureConversationSecurityTokenParameters(SecureConversationSecurityTokenParameters other);
+        public SecurityBindingElement BootstrapSecurityBindingElement { get; set; }
+        protected internal override bool HasAsymmetricKey { get; }
+        protected internal override bool SupportsClientAuthentication { get; }
+        protected internal override bool SupportsClientWindowsIdentity { get; }
+        protected internal override bool SupportsServerAuthentication { get; }
+        protected override SecurityTokenParameters CloneCore();
+        public override string ToString();
+    }
+    public class SecurityContextSecurityToken : SecurityToken, IDisposable, TimeBoundedCache.IExpirableItem {
+        public SecurityContextSecurityToken(UniqueId contextId, byte[] key, DateTime validFrom, DateTime validTo);
+        public SecurityContextSecurityToken(UniqueId contextId, string id, byte[] key, DateTime validFrom, DateTime validTo);
+        public SecurityContextSecurityToken(UniqueId contextId, string id, byte[] key, DateTime validFrom, DateTime validTo, ReadOnlyCollection<IAuthorizationPolicy> authorizationPolicies);
+        public SecurityContextSecurityToken(UniqueId contextId, string id, byte[] key, DateTime validFrom, DateTime validTo, UniqueId keyGeneration, DateTime keyEffectiveTime, DateTime keyExpirationTime, ReadOnlyCollection<IAuthorizationPolicy> authorizationPolicies);
+        public ReadOnlyCollection<IAuthorizationPolicy> AuthorizationPolicies { get; internal set; }
+        public SecurityMessageProperty BootstrapMessageProperty { get; set; }
+        public UniqueId ContextId { get; }
+        public override string Id { get; }
+        public bool IsCookieMode { get; }
+        public DateTime KeyEffectiveTime { get; }
+        public DateTime KeyExpirationTime { get; }
+        public UniqueId KeyGeneration { get; }
+        public override ReadOnlyCollection<SecurityKey> SecurityKeys { get; }
+        public override DateTime ValidFrom { get; }
+        public override DateTime ValidTo { get; }
+        public static SecurityContextSecurityToken CreateCookieSecurityContextToken(UniqueId contextId, string id, byte[] key, DateTime validFrom, DateTime validTo, ReadOnlyCollection<IAuthorizationPolicy> authorizationPolicies, SecurityStateEncoder securityStateEncoder);
+        public static SecurityContextSecurityToken CreateCookieSecurityContextToken(UniqueId contextId, string id, byte[] key, DateTime validFrom, DateTime validTo, UniqueId keyGeneration, DateTime keyEffectiveTime, DateTime keyExpirationTime, ReadOnlyCollection<IAuthorizationPolicy> authorizationPolicies, SecurityStateEncoder securityStateEncoder);
+        public void Dispose();
+        public override string ToString();
+    }
+    public enum SecurityTokenInclusionMode {
+        AlwaysToInitiator = 3,
+        AlwaysToRecipient = 0,
+        Never = 1,
+        Once = 2,
+    }
+    public abstract class SecurityTokenParameters {
+        protected SecurityTokenParameters();
+        protected SecurityTokenParameters(SecurityTokenParameters other);
+        protected internal abstract bool HasAsymmetricKey { get; }
+        public bool RequireDerivedKeys { get; set; }
+        protected internal abstract bool SupportsClientAuthentication { get; }
+        protected internal abstract bool SupportsClientWindowsIdentity { get; }
+        protected internal abstract bool SupportsServerAuthentication { get; }
+        public SecurityTokenParameters Clone();
+        protected abstract SecurityTokenParameters CloneCore();
+        public override string ToString();
+    }
+    public enum SecurityTokenReferenceStyle {
+        External = 1,
+        Internal = 0,
+    }
+    public abstract class ServiceModelSecurityTokenRequirement : SecurityTokenRequirement {
+        protected const string Namespace = "http://schemas.microsoft.com/ws/2006/05/servicemodel/securitytokenrequirement";
+        protected ServiceModelSecurityTokenRequirement();
+        public static string AuditLogLocationProperty { get; }
+        public static string ChannelParametersCollectionProperty { get; }
+        public static string DuplexClientLocalAddressProperty { get; }
+        public static string EndpointFilterTableProperty { get; }
+        public static string ExtendedProtectionPolicy { get; }
+        public static string HttpAuthenticationSchemeProperty { get; }
+        public bool IsInitiator { get; }
+        public static string IsInitiatorProperty { get; }
+        public static string IsOutOfBandTokenProperty { get; }
+        public static string IssuedSecurityTokenParametersProperty { get; }
+        public EndpointAddress IssuerAddress { get; set; }
+        public static string IssuerAddressProperty { get; }
+        public Binding IssuerBinding { get; set; }
+        public static string IssuerBindingContextProperty { get; }
+        public static string IssuerBindingProperty { get; }
+        public static string ListenUriProperty { get; }
+        public static string MessageAuthenticationAuditLevelProperty { get; }
+        public static string MessageDirectionProperty { get; }
+        public SecurityTokenVersion MessageSecurityVersion { get; set; }
+        public static string MessageSecurityVersionProperty { get; }
+        public static string PreferSslCertificateAuthenticatorProperty { get; }
+        public static string PrivacyNoticeUriProperty { get; }
+        public static string PrivacyNoticeVersionProperty { get; }
+        public SecurityBindingElement SecureConversationSecurityBindingElement { get; set; }
+        public static string SecureConversationSecurityBindingElementProperty { get; }
+        public SecurityAlgorithmSuite SecurityAlgorithmSuite { get; set; }
+        public static string SecurityAlgorithmSuiteProperty { get; }
+        public SecurityBindingElement SecurityBindingElement { get; set; }
+        public static string SecurityBindingElementProperty { get; }
+        public static string SupportingTokenAttachmentModeProperty { get; }
+        public static string SupportSecurityContextCancellationProperty { get; }
+        public static string SuppressAuditFailureProperty { get; }
+        public static string TargetAddressProperty { get; }
+        public string TransportScheme { get; set; }
+        public static string TransportSchemeProperty { get; }
+        public static string ViaProperty { get; }
+    }
+    public static class ServiceModelSecurityTokenTypes {
+        public static string AnonymousSslnego { get; }
+        public static string MutualSslnego { get; }
+        public static string SecureConversation { get; }
+        public static string SecurityContext { get; }
+        public static string Spnego { get; }
+        public static string SspiCredential { get; }
+    }
+    public class SspiSecurityToken : SecurityToken {
+        public SspiSecurityToken(NetworkCredential networkCredential, bool extractGroupsForWindowsAccounts, bool allowUnauthenticatedCallers);
+        public SspiSecurityToken(TokenImpersonationLevel impersonationLevel, bool allowNtlm, NetworkCredential networkCredential);
+        public bool AllowNtlm { get; }
+        public bool AllowUnauthenticatedCallers { get; }
+        public bool ExtractGroupsForWindowsAccounts { get; }
+        public override string Id { get; }
+        public TokenImpersonationLevel ImpersonationLevel { get; }
+        public NetworkCredential NetworkCredential { get; }
+        public override ReadOnlyCollection<SecurityKey> SecurityKeys { get; }
+        public override DateTime ValidFrom { get; }
+        public override DateTime ValidTo { get; }
+    }
+    public class SupportingTokenParameters {
+        public SupportingTokenParameters();
+        public Collection<SecurityTokenParameters> Endorsing { get; }
+        public Collection<SecurityTokenParameters> Signed { get; }
+        public Collection<SecurityTokenParameters> SignedEncrypted { get; }
+        public Collection<SecurityTokenParameters> SignedEndorsing { get; }
+        public SupportingTokenParameters Clone();
+        protected virtual SupportingTokenParameters CloneCore();
+        public void SetKeyDerivation(bool requireDerivedKeys);
+        public override string ToString();
+    }
+    public class UserNameSecurityTokenParameters : SecurityTokenParameters {
+        public UserNameSecurityTokenParameters();
+        protected UserNameSecurityTokenParameters(UserNameSecurityTokenParameters other);
+        protected internal override bool HasAsymmetricKey { get; }
+        protected internal override bool SupportsClientAuthentication { get; }
+        protected internal override bool SupportsClientWindowsIdentity { get; }
+        protected internal override bool SupportsServerAuthentication { get; }
+        protected override SecurityTokenParameters CloneCore();
+    }
+    public enum X509KeyIdentifierClauseType {
+        Any = 0,
+        IssuerSerial = 2,
+        RawDataKeyIdentifier = 4,
+        SubjectKeyIdentifier = 3,
+        Thumbprint = 1,
+    }
+}
```

## System.ServiceProcess

```c#
+namespace System.ServiceProcess {
+    public class ServiceController : IDisposable {
+        public ServiceController(string name);
+        public ServiceController(string name, string machineName);
+        public bool CanPauseAndContinue { get; }
+        public bool CanShutdown { get; }
+        public bool CanStop { get; }
+        public ServiceController[] DependentServices { get; }
+        public string DisplayName { get; }
+        public string MachineName { get; }
+        public SafeHandle ServiceHandle { get; }
+        public string ServiceName { get; }
+        public ServiceController[] ServicesDependedOn { get; }
+        public ServiceType ServiceType { get; }
+        public ServiceStartMode StartType { get; }
+        public ServiceControllerStatus Status { get; }
+        public void Continue();
+        public void Dispose();
+        protected virtual void Dispose(bool disposing);
+        public static ServiceController[] GetDevices();
+        public static ServiceController[] GetDevices(string machineName);
+        public static ServiceController[] GetServices();
+        public static ServiceController[] GetServices(string machineName);
+        public void Pause();
+        public void Refresh();
+        public void Start();
+        public void Start(string[] args);
+        public void Stop();
+        public void WaitForStatus(ServiceControllerStatus desiredStatus);
+        public void WaitForStatus(ServiceControllerStatus desiredStatus, TimeSpan timeout);
+    }
+    public enum ServiceControllerStatus {
+        ContinuePending = 5,
+        Paused = 7,
+        PausePending = 6,
+        Running = 4,
+        StartPending = 2,
+        Stopped = 1,
+        StopPending = 3,
+    }
+    public enum ServiceStartMode {
+        Automatic = 2,
+        Boot = 0,
+        Disabled = 4,
+        Manual = 3,
+        System = 1,
+    }
+    public enum ServiceType {
+        Adapter = 4,
+        FileSystemDriver = 2,
+        InteractiveProcess = 256,
+        KernelDriver = 1,
+        RecognizerDriver = 8,
+        Win32OwnProcess = 16,
+        Win32ShareProcess = 32,
+    }
+    public class TimeoutException : Exception {
+        public TimeoutException();
+        public TimeoutException(string message);
+        public TimeoutException(string message, Exception innerException);
+    }
+}
```

## System.Text

```c#
+namespace System.Text {
+    public class ASCIIEncoding : Encoding {
+        public ASCIIEncoding();
+        public override bool IsSingleByte { get; }
+        public unsafe override int GetByteCount(char* chars, int count);
+        public override int GetByteCount(char[] chars, int index, int count);
+        public override int GetByteCount(string chars);
+        public unsafe override int GetBytes(char* chars, int charCount, byte* bytes, int byteCount);
+        public override int GetBytes(char[] chars, int charIndex, int charCount, byte[] bytes, int byteIndex);
+        public override int GetBytes(string chars, int charIndex, int charCount, byte[] bytes, int byteIndex);
+        public unsafe override int GetCharCount(byte* bytes, int count);
+        public override int GetCharCount(byte[] bytes, int index, int count);
+        public unsafe override int GetChars(byte* bytes, int byteCount, char* chars, int charCount);
+        public override int GetChars(byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex);
+        public override Decoder GetDecoder();
+        public override Encoder GetEncoder();
+        public override int GetMaxByteCount(int charCount);
+        public override int GetMaxCharCount(int byteCount);
+        public override string GetString(byte[] bytes, int byteIndex, int byteCount);
+    }
+    public sealed class CodePagesEncodingProvider {
+        public static EncodingProvider Instance { get; }
+    }
+    public abstract class Decoder {
+        protected Decoder();
+        public DecoderFallback Fallback { get; set; }
+        public DecoderFallbackBuffer FallbackBuffer { get; }
+        public unsafe virtual void Convert(byte* bytes, int byteCount, char* chars, int charCount, bool flush, out int bytesUsed, out int charsUsed, out bool completed);
+        public virtual void Convert(byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex, int charCount, bool flush, out int bytesUsed, out int charsUsed, out bool completed);
+        public unsafe virtual int GetCharCount(byte* bytes, int count, bool flush);
+        public abstract int GetCharCount(byte[] bytes, int index, int count);
+        public virtual int GetCharCount(byte[] bytes, int index, int count, bool flush);
+        public unsafe virtual int GetChars(byte* bytes, int byteCount, char* chars, int charCount, bool flush);
+        public abstract int GetChars(byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex);
+        public virtual int GetChars(byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex, bool flush);
+        public virtual void Reset();
+    }
+    public sealed class DecoderExceptionFallback : DecoderFallback {
+        public DecoderExceptionFallback();
+        public override int MaxCharCount { get; }
+        public override DecoderFallbackBuffer CreateFallbackBuffer();
+        public override bool Equals(object value);
+        public override int GetHashCode();
+    }
+    public abstract class DecoderFallback {
+        protected DecoderFallback();
+        public static DecoderFallback ExceptionFallback { get; }
+        public abstract int MaxCharCount { get; }
+        public static DecoderFallback ReplacementFallback { get; }
+        public abstract DecoderFallbackBuffer CreateFallbackBuffer();
+    }
+    public abstract class DecoderFallbackBuffer {
+        protected DecoderFallbackBuffer();
+        public abstract int Remaining { get; }
+        public abstract bool Fallback(byte[] bytesUnknown, int index);
+        public abstract char GetNextChar();
+        public abstract bool MovePrevious();
+        public virtual void Reset();
+    }
+    public sealed class DecoderFallbackException : ArgumentException {
+        public DecoderFallbackException();
+        public DecoderFallbackException(string message);
+        public DecoderFallbackException(string message, byte[] bytesUnknown, int index);
+        public DecoderFallbackException(string message, Exception innerException);
+        public byte[] BytesUnknown { get; }
+        public int Index { get; }
+    }
+    public sealed class DecoderReplacementFallback : DecoderFallback {
+        public DecoderReplacementFallback();
+        public DecoderReplacementFallback(string replacement);
+        public string DefaultString { get; }
+        public override int MaxCharCount { get; }
+        public override DecoderFallbackBuffer CreateFallbackBuffer();
+        public override bool Equals(object value);
+        public override int GetHashCode();
+    }
+    public abstract class Encoder {
+        protected Encoder();
+        public EncoderFallback Fallback { get; set; }
+        public EncoderFallbackBuffer FallbackBuffer { get; }
+        public unsafe virtual void Convert(char* chars, int charCount, byte* bytes, int byteCount, bool flush, out int charsUsed, out int bytesUsed, out bool completed);
+        public virtual void Convert(char[] chars, int charIndex, int charCount, byte[] bytes, int byteIndex, int byteCount, bool flush, out int charsUsed, out int bytesUsed, out bool completed);
+        public unsafe virtual int GetByteCount(char* chars, int count, bool flush);
+        public abstract int GetByteCount(char[] chars, int index, int count, bool flush);
+        public unsafe virtual int GetBytes(char* chars, int charCount, byte* bytes, int byteCount, bool flush);
+        public abstract int GetBytes(char[] chars, int charIndex, int charCount, byte[] bytes, int byteIndex, bool flush);
+        public virtual void Reset();
+    }
+    public sealed class EncoderExceptionFallback : EncoderFallback {
+        public EncoderExceptionFallback();
+        public override int MaxCharCount { get; }
+        public override EncoderFallbackBuffer CreateFallbackBuffer();
+        public override bool Equals(object value);
+        public override int GetHashCode();
+    }
+    public abstract class EncoderFallback {
+        protected EncoderFallback();
+        public static EncoderFallback ExceptionFallback { get; }
+        public abstract int MaxCharCount { get; }
+        public static EncoderFallback ReplacementFallback { get; }
+        public abstract EncoderFallbackBuffer CreateFallbackBuffer();
+    }
+    public abstract class EncoderFallbackBuffer {
+        protected EncoderFallbackBuffer();
+        public abstract int Remaining { get; }
+        public abstract bool Fallback(char charUnknownHigh, char charUnknownLow, int index);
+        public abstract bool Fallback(char charUnknown, int index);
+        public abstract char GetNextChar();
+        public abstract bool MovePrevious();
+        public virtual void Reset();
+    }
+    public sealed class EncoderFallbackException : ArgumentException {
+        public EncoderFallbackException();
+        public EncoderFallbackException(string message);
+        public EncoderFallbackException(string message, Exception innerException);
+        public char CharUnknown { get; }
+        public char CharUnknownHigh { get; }
+        public char CharUnknownLow { get; }
+        public int Index { get; }
+        public bool IsUnknownSurrogate();
+    }
+    public sealed class EncoderReplacementFallback : EncoderFallback {
+        public EncoderReplacementFallback();
+        public EncoderReplacementFallback(string replacement);
+        public string DefaultString { get; }
+        public override int MaxCharCount { get; }
+        public override EncoderFallbackBuffer CreateFallbackBuffer();
+        public override bool Equals(object value);
+        public override int GetHashCode();
+    }
+    public abstract class Encoding {
+        protected Encoding();
+        protected Encoding(int codePage);
+        protected Encoding(int codePage, EncoderFallback encoderFallback, DecoderFallback decoderFallback);
+        public static Encoding ASCII { get; }
+        public static Encoding BigEndianUnicode { get; }
+        public virtual int CodePage { get; }
+        public DecoderFallback DecoderFallback { get; }
+        public EncoderFallback EncoderFallback { get; }
+        public virtual string EncodingName { get; }
+        public virtual bool IsSingleByte { get; }
+        public static Encoding Unicode { get; }
+        public static Encoding UTF32 { get; }
+        public static Encoding UTF7 { get; }
+        public static Encoding UTF8 { get; }
+        public virtual string WebName { get; }
+        public virtual object Clone();
+        public static byte[] Convert(Encoding srcEncoding, Encoding dstEncoding, byte[] bytes);
+        public static byte[] Convert(Encoding srcEncoding, Encoding dstEncoding, byte[] bytes, int index, int count);
+        public override bool Equals(object value);
+        public unsafe virtual int GetByteCount(char* chars, int count);
+        public virtual int GetByteCount(char[] chars);
+        public abstract int GetByteCount(char[] chars, int index, int count);
+        public virtual int GetByteCount(string s);
+        public unsafe virtual int GetBytes(char* chars, int charCount, byte* bytes, int byteCount);
+        public virtual byte[] GetBytes(char[] chars);
+        public virtual byte[] GetBytes(char[] chars, int index, int count);
+        public abstract int GetBytes(char[] chars, int charIndex, int charCount, byte[] bytes, int byteIndex);
+        public virtual byte[] GetBytes(string s);
+        public virtual int GetBytes(string s, int charIndex, int charCount, byte[] bytes, int byteIndex);
+        public unsafe virtual int GetCharCount(byte* bytes, int count);
+        public virtual int GetCharCount(byte[] bytes);
+        public abstract int GetCharCount(byte[] bytes, int index, int count);
+        public unsafe virtual int GetChars(byte* bytes, int byteCount, char* chars, int charCount);
+        public virtual char[] GetChars(byte[] bytes);
+        public virtual char[] GetChars(byte[] bytes, int index, int count);
+        public abstract int GetChars(byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex);
+        public virtual Decoder GetDecoder();
+        public virtual Encoder GetEncoder();
+        public static Encoding GetEncoding(int codepage);
+        public static Encoding GetEncoding(int codepage, EncoderFallback encoderFallback, DecoderFallback decoderFallback);
+        public static Encoding GetEncoding(string name);
+        public static Encoding GetEncoding(string name, EncoderFallback encoderFallback, DecoderFallback decoderFallback);
+        public override int GetHashCode();
+        public abstract int GetMaxByteCount(int charCount);
+        public abstract int GetMaxCharCount(int byteCount);
+        public virtual byte[] GetPreamble();
+        public unsafe string GetString(byte* bytes, int byteCount);
+        public virtual string GetString(byte[] bytes);
+        public virtual string GetString(byte[] bytes, int index, int count);
+        public static void RegisterProvider(EncodingProvider provider);
+    }
+    public abstract class EncodingProvider {
+        public EncodingProvider();
+        public abstract Encoding GetEncoding(int codepage);
+        public virtual Encoding GetEncoding(int codepage, EncoderFallback encoderFallback, DecoderFallback decoderFallback);
+        public abstract Encoding GetEncoding(string name);
+        public virtual Encoding GetEncoding(string name, EncoderFallback encoderFallback, DecoderFallback decoderFallback);
+    }
+    public enum NormalizationForm {
+        FormC = 1,
+        FormD = 2,
+        FormKC = 5,
+        FormKD = 6,
+    }
+    public sealed class StringBuilder {
+        public StringBuilder();
+        public StringBuilder(int capacity);
+        public StringBuilder(int capacity, int maxCapacity);
+        public StringBuilder(string value);
+        public StringBuilder(string value, int capacity);
+        public StringBuilder(string value, int startIndex, int length, int capacity);
+        public int Capacity { get; set; }
+        public int Length { get; set; }
+        public int MaxCapacity { get; }
+        [System.Runtime.CompilerServices.IndexerName("Chars")]
+        public char this[int index] { get; set; }
+        public StringBuilder Append(bool value);
+        public StringBuilder Append(byte value);
+        public StringBuilder Append(char value);
+        public unsafe StringBuilder Append(char* value, int valueCount);
+        public StringBuilder Append(char value, int repeatCount);
+        public StringBuilder Append(char[] value);
+        public StringBuilder Append(char[] value, int startIndex, int charCount);
+        public StringBuilder Append(Decimal value);
+        public StringBuilder Append(double value);
+        public StringBuilder Append(short value);
+        public StringBuilder Append(int value);
+        public StringBuilder Append(long value);
+        public StringBuilder Append(object value);
+        public StringBuilder Append(sbyte value);
+        public StringBuilder Append(float value);
+        public StringBuilder Append(string value);
+        public StringBuilder Append(string value, int startIndex, int count);
+        public StringBuilder Append(ushort value);
+        public StringBuilder Append(uint value);
+        public StringBuilder Append(ulong value);
+        public StringBuilder AppendFormat(IFormatProvider provider, string format, object arg0);
+        public StringBuilder AppendFormat(IFormatProvider provider, string format, object arg0, object arg1);
+        public StringBuilder AppendFormat(IFormatProvider provider, string format, object arg0, object arg1, object arg2);
+        public StringBuilder AppendFormat(IFormatProvider provider, string format, params object[] args);
+        public StringBuilder AppendFormat(string format, object arg0);
+        public StringBuilder AppendFormat(string format, object arg0, object arg1);
+        public StringBuilder AppendFormat(string format, object arg0, object arg1, object arg2);
+        public StringBuilder AppendFormat(string format, params object[] args);
+        public StringBuilder AppendLine();
+        public StringBuilder AppendLine(string value);
+        public StringBuilder Clear();
+        public void CopyTo(int sourceIndex, char[] destination, int destinationIndex, int count);
+        public int EnsureCapacity(int capacity);
+        public bool Equals(StringBuilder sb);
+        public StringBuilder Insert(int index, bool value);
+        public StringBuilder Insert(int index, byte value);
+        public StringBuilder Insert(int index, char value);
+        public StringBuilder Insert(int index, char[] value);
+        public StringBuilder Insert(int index, char[] value, int startIndex, int charCount);
+        public StringBuilder Insert(int index, Decimal value);
+        public StringBuilder Insert(int index, double value);
+        public StringBuilder Insert(int index, short value);
+        public StringBuilder Insert(int index, int value);
+        public StringBuilder Insert(int index, long value);
+        public StringBuilder Insert(int index, object value);
+        public StringBuilder Insert(int index, sbyte value);
+        public StringBuilder Insert(int index, float value);
+        public StringBuilder Insert(int index, string value);
+        public StringBuilder Insert(int index, string value, int count);
+        public StringBuilder Insert(int index, ushort value);
+        public StringBuilder Insert(int index, uint value);
+        public StringBuilder Insert(int index, ulong value);
+        public StringBuilder Remove(int startIndex, int length);
+        public StringBuilder Replace(char oldChar, char newChar);
+        public StringBuilder Replace(char oldChar, char newChar, int startIndex, int count);
+        public StringBuilder Replace(string oldValue, string newValue);
+        public StringBuilder Replace(string oldValue, string newValue, int startIndex, int count);
+        public override string ToString();
+        public string ToString(int startIndex, int length);
+    }
+    public class UnicodeEncoding : Encoding {
+        public UnicodeEncoding();
+        public UnicodeEncoding(bool bigEndian, bool byteOrderMark);
+        public UnicodeEncoding(bool bigEndian, bool byteOrderMark, bool throwOnInvalidBytes);
+        public override bool Equals(object value);
+        public unsafe override int GetByteCount(char* chars, int count);
+        public override int GetByteCount(char[] chars, int index, int count);
+        public override int GetByteCount(string s);
+        public unsafe override int GetBytes(char* chars, int charCount, byte* bytes, int byteCount);
+        public override int GetBytes(char[] chars, int charIndex, int charCount, byte[] bytes, int byteIndex);
+        public override int GetBytes(string s, int charIndex, int charCount, byte[] bytes, int byteIndex);
+        public unsafe override int GetCharCount(byte* bytes, int count);
+        public override int GetCharCount(byte[] bytes, int index, int count);
+        public unsafe override int GetChars(byte* bytes, int byteCount, char* chars, int charCount);
+        public override int GetChars(byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex);
+        public override Decoder GetDecoder();
+        public override Encoder GetEncoder();
+        public override int GetHashCode();
+        public override int GetMaxByteCount(int charCount);
+        public override int GetMaxCharCount(int byteCount);
+        public override byte[] GetPreamble();
+        public override string GetString(byte[] bytes, int index, int count);
+    }
+    public sealed class UTF32Encoding : Encoding {
+        public UTF32Encoding();
+        public UTF32Encoding(bool bigEndian, bool byteOrderMark);
+        public UTF32Encoding(bool bigEndian, bool byteOrderMark, bool throwOnInvalidCharacters);
+        public override bool Equals(object value);
+        public unsafe override int GetByteCount(char* chars, int count);
+        public override int GetByteCount(char[] chars, int index, int count);
+        public override int GetByteCount(string s);
+        public unsafe override int GetBytes(char* chars, int charCount, byte* bytes, int byteCount);
+        public override int GetBytes(char[] chars, int charIndex, int charCount, byte[] bytes, int byteIndex);
+        public override int GetBytes(string s, int charIndex, int charCount, byte[] bytes, int byteIndex);
+        public unsafe override int GetCharCount(byte* bytes, int count);
+        public override int GetCharCount(byte[] bytes, int index, int count);
+        public unsafe override int GetChars(byte* bytes, int byteCount, char* chars, int charCount);
+        public override int GetChars(byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex);
+        public override Decoder GetDecoder();
+        public override Encoder GetEncoder();
+        public override int GetHashCode();
+        public override int GetMaxByteCount(int charCount);
+        public override int GetMaxCharCount(int byteCount);
+        public override byte[] GetPreamble();
+        public override string GetString(byte[] bytes, int index, int count);
+    }
+    public class UTF7Encoding : Encoding {
+        public UTF7Encoding();
+        public UTF7Encoding(bool allowOptionals);
+        public override bool Equals(object value);
+        public unsafe override int GetByteCount(char* chars, int count);
+        public override int GetByteCount(char[] chars, int index, int count);
+        public override int GetByteCount(string s);
+        public unsafe override int GetBytes(char* chars, int charCount, byte* bytes, int byteCount);
+        public override int GetBytes(char[] chars, int charIndex, int charCount, byte[] bytes, int byteIndex);
+        public override int GetBytes(string s, int charIndex, int charCount, byte[] bytes, int byteIndex);
+        public unsafe override int GetCharCount(byte* bytes, int count);
+        public override int GetCharCount(byte[] bytes, int index, int count);
+        public unsafe override int GetChars(byte* bytes, int byteCount, char* chars, int charCount);
+        public override int GetChars(byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex);
+        public override Decoder GetDecoder();
+        public override Encoder GetEncoder();
+        public override int GetHashCode();
+        public override int GetMaxByteCount(int charCount);
+        public override int GetMaxCharCount(int byteCount);
+        public override string GetString(byte[] bytes, int index, int count);
+    }
+    public class UTF8Encoding : Encoding {
+        public UTF8Encoding();
+        public UTF8Encoding(bool encoderShouldEmitUTF8Identifier);
+        public UTF8Encoding(bool encoderShouldEmitUTF8Identifier, bool throwOnInvalidBytes);
+        public override bool Equals(object value);
+        public unsafe override int GetByteCount(char* chars, int count);
+        public override int GetByteCount(char[] chars, int index, int count);
+        public override int GetByteCount(string chars);
+        public unsafe override int GetBytes(char* chars, int charCount, byte* bytes, int byteCount);
+        public override int GetBytes(char[] chars, int charIndex, int charCount, byte[] bytes, int byteIndex);
+        public override int GetBytes(string s, int charIndex, int charCount, byte[] bytes, int byteIndex);
+        public unsafe override int GetCharCount(byte* bytes, int count);
+        public override int GetCharCount(byte[] bytes, int index, int count);
+        public unsafe override int GetChars(byte* bytes, int byteCount, char* chars, int charCount);
+        public override int GetChars(byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex);
+        public override Decoder GetDecoder();
+        public override Encoder GetEncoder();
+        public override int GetHashCode();
+        public override int GetMaxByteCount(int charCount);
+        public override int GetMaxCharCount(int byteCount);
+        public override byte[] GetPreamble();
+        public override string GetString(byte[] bytes, int index, int count);
+    }
+}
```

## System.Text.Encodings.Web

```c#
+namespace System.Text.Encodings.Web {
+    public abstract class HtmlEncoder : TextEncoder {
+        protected HtmlEncoder();
+        public static HtmlEncoder Default { get; }
+        public static HtmlEncoder Create(TextEncoderSettings settings);
+        public static HtmlEncoder Create(params UnicodeRange[] allowedRanges);
+    }
+    public abstract class JavaScriptEncoder : TextEncoder {
+        protected JavaScriptEncoder();
+        public static JavaScriptEncoder Default { get; }
+        public static JavaScriptEncoder Create(TextEncoderSettings settings);
+        public static JavaScriptEncoder Create(params UnicodeRange[] allowedRanges);
+    }
+    public abstract class TextEncoder {
+        protected TextEncoder();
+        public abstract int MaxOutputCharactersPerInputCharacter { get; }
+        public virtual void Encode(TextWriter output, char[] value, int startIndex, int characterCount);
+        public void Encode(TextWriter output, string value);
+        public virtual void Encode(TextWriter output, string value, int startIndex, int characterCount);
+        public virtual string Encode(string value);
+        public unsafe abstract int FindFirstCharacterToEncode(char* text, int textLength);
+        public unsafe abstract bool TryEncodeUnicodeScalar(int unicodeScalar, char* buffer, int bufferLength, out int numberOfCharactersWritten);
+        public abstract bool WillEncode(int unicodeScalar);
+    }
+    public class TextEncoderSettings {
+        public TextEncoderSettings();
+        public TextEncoderSettings(TextEncoderSettings other);
+        public TextEncoderSettings(params UnicodeRange[] allowedRanges);
+        public virtual void AllowCharacter(char character);
+        public virtual void AllowCharacters(params char[] characters);
+        public virtual void AllowCodePoints(IEnumerable<int> codePoints);
+        public virtual void AllowRange(UnicodeRange range);
+        public virtual void AllowRanges(params UnicodeRange[] ranges);
+        public virtual void Clear();
+        public virtual void ForbidCharacter(char character);
+        public virtual void ForbidCharacters(params char[] characters);
+        public virtual void ForbidRange(UnicodeRange range);
+        public virtual void ForbidRanges(params UnicodeRange[] ranges);
+        public virtual IEnumerable<int> GetAllowedCodePoints();
+    }
+    public abstract class UrlEncoder : TextEncoder {
+        protected UrlEncoder();
+        public static UrlEncoder Default { get; }
+        public static UrlEncoder Create(TextEncoderSettings settings);
+        public static UrlEncoder Create(params UnicodeRange[] allowedRanges);
+    }
+}
```

## System.Text.RegularExpressions

```c#
+namespace System.Text.RegularExpressions {
+    public class Capture {
+        public int Index { get; }
+        public int Length { get; }
+        public string Value { get; }
+        public override string ToString();
+    }
+    public class CaptureCollection : ICollection, IEnumerable {
+        public int Count { get; }
+        bool System.Collections.ICollection.IsSynchronized { get; }
+        object System.Collections.ICollection.SyncRoot { get; }
+        public Capture this[int i] { get; }
+        public IEnumerator GetEnumerator();
+        void System.Collections.ICollection.CopyTo(Array array, int arrayIndex);
+    }
+    public class Group : Capture {
+        public CaptureCollection Captures { get; }
+        public bool Success { get; }
+    }
+    public class GroupCollection : ICollection, IEnumerable {
+        public int Count { get; }
+        bool System.Collections.ICollection.IsSynchronized { get; }
+        object System.Collections.ICollection.SyncRoot { get; }
+        public Group this[int groupnum] { get; }
+        public Group this[string groupname] { get; }
+        public IEnumerator GetEnumerator();
+        void System.Collections.ICollection.CopyTo(Array array, int arrayIndex);
+    }
+    public class Match : Group {
+        public static Match Empty { get; }
+        public virtual GroupCollection Groups { get; }
+        public Match NextMatch();
+        public virtual string Result(string replacement);
+    }
+    public class MatchCollection : ICollection, IEnumerable {
+        public int Count { get; }
+        bool System.Collections.ICollection.IsSynchronized { get; }
+        object System.Collections.ICollection.SyncRoot { get; }
+        public virtual Match this[int i] { get; }
+        public IEnumerator GetEnumerator();
+        void System.Collections.ICollection.CopyTo(Array array, int arrayIndex);
+    }
+    public delegate string MatchEvaluator(Match match);
+    public class Regex {
+        protected internal int capsize;
+        protected internal string pattern;
+        protected internal string[] capslist;
+        protected internal RegexOptions roptions;
+        protected internal RegexRunnerFactory factory;
+        public static readonly TimeSpan InfiniteMatchTimeout;
+        protected internal TimeSpan internalMatchTimeout;
+        protected Regex();
+        public Regex(string pattern);
+        public Regex(string pattern, RegexOptions options);
+        public Regex(string pattern, RegexOptions options, TimeSpan matchTimeout);
+        public static int CacheSize { get; set; }
+        protected IDictionary CapNames { get; set; }
+        protected IDictionary Caps { get; set; }
+        public TimeSpan MatchTimeout { get; }
+        public RegexOptions Options { get; }
+        public bool RightToLeft { get; }
+        public static string Escape(string str);
+        public string[] GetGroupNames();
+        public int[] GetGroupNumbers();
+        public string GroupNameFromNumber(int i);
+        public int GroupNumberFromName(string name);
+        protected void InitializeReferences();
+        public bool IsMatch(string input);
+        public bool IsMatch(string input, int startat);
+        public static bool IsMatch(string input, string pattern);
+        public static bool IsMatch(string input, string pattern, RegexOptions options);
+        public static bool IsMatch(string input, string pattern, RegexOptions options, TimeSpan matchTimeout);
+        public Match Match(string input);
+        public Match Match(string input, int startat);
+        public Match Match(string input, int beginning, int length);
+        public static Match Match(string input, string pattern);
+        public static Match Match(string input, string pattern, RegexOptions options);
+        public static Match Match(string input, string pattern, RegexOptions options, TimeSpan matchTimeout);
+        public MatchCollection Matches(string input);
+        public MatchCollection Matches(string input, int startat);
+        public static MatchCollection Matches(string input, string pattern);
+        public static MatchCollection Matches(string input, string pattern, RegexOptions options);
+        public static MatchCollection Matches(string input, string pattern, RegexOptions options, TimeSpan matchTimeout);
+        public string Replace(string input, string replacement);
+        public string Replace(string input, string replacement, int count);
+        public string Replace(string input, string replacement, int count, int startat);
+        public static string Replace(string input, string pattern, string replacement);
+        public static string Replace(string input, string pattern, string replacement, RegexOptions options);
+        public static string Replace(string input, string pattern, string replacement, RegexOptions options, TimeSpan matchTimeout);
+        public static string Replace(string input, string pattern, MatchEvaluator evaluator);
+        public static string Replace(string input, string pattern, MatchEvaluator evaluator, RegexOptions options);
+        public static string Replace(string input, string pattern, MatchEvaluator evaluator, RegexOptions options, TimeSpan matchTimeout);
+        public string Replace(string input, MatchEvaluator evaluator);
+        public string Replace(string input, MatchEvaluator evaluator, int count);
+        public string Replace(string input, MatchEvaluator evaluator, int count, int startat);
+        public string[] Split(string input);
+        public string[] Split(string input, int count);
+        public string[] Split(string input, int count, int startat);
+        public static string[] Split(string input, string pattern);
+        public static string[] Split(string input, string pattern, RegexOptions options);
+        public static string[] Split(string input, string pattern, RegexOptions options, TimeSpan matchTimeout);
+        public override string ToString();
+        public static string Unescape(string str);
+        protected internal static void ValidateMatchTimeout(TimeSpan matchTimeout);
+    }
+    public class RegexMatchTimeoutException : TimeoutException {
+        public RegexMatchTimeoutException();
+        public RegexMatchTimeoutException(string message);
+        public RegexMatchTimeoutException(string message, Exception inner);
+        public RegexMatchTimeoutException(string regexInput, string regexPattern, TimeSpan matchTimeout);
+        public string Input { get; }
+        public TimeSpan MatchTimeout { get; }
+        public string Pattern { get; }
+    }
+    public enum RegexOptions {
+        Compiled = 8,
+        CultureInvariant = 512,
+        ECMAScript = 256,
+        ExplicitCapture = 4,
+        IgnoreCase = 1,
+        IgnorePatternWhitespace = 32,
+        Multiline = 2,
+        None = 0,
+        RightToLeft = 64,
+        Singleline = 16,
+    }
+    public abstract class RegexRunner {
+        protected internal int runcrawlpos;
+        protected internal int runstackpos;
+        protected internal int runtextbeg;
+        protected internal int runtextend;
+        protected internal int runtextpos;
+        protected internal int runtextstart;
+        protected internal int runtrackcount;
+        protected internal int runtrackpos;
+        protected internal int[] runcrawl;
+        protected internal int[] runstack;
+        protected internal int[] runtrack;
+        protected internal string runtext;
+        protected internal Match runmatch;
+        protected internal Regex runregex;
+        protected internal RegexRunner();
+        protected void Capture(int capnum, int start, int end);
+        protected static bool CharInClass(char ch, string charClass);
+        protected static bool CharInSet(char ch, string @set, string category);
+        protected void CheckTimeout();
+        protected void Crawl(int i);
+        protected int Crawlpos();
+        protected void DoubleCrawl();
+        protected void DoubleStack();
+        protected void DoubleTrack();
+        protected void EnsureStorage();
+        protected abstract bool FindFirstChar();
+        protected abstract void Go();
+        protected abstract void InitTrackCount();
+        protected bool IsBoundary(int index, int startpos, int endpos);
+        protected bool IsECMABoundary(int index, int startpos, int endpos);
+        protected bool IsMatched(int cap);
+        protected int MatchIndex(int cap);
+        protected int MatchLength(int cap);
+        protected int Popcrawl();
+        protected internal Match Scan(Regex regex, string text, int textbeg, int textend, int textstart, int prevlen, bool quick);
+        protected internal Match Scan(Regex regex, string text, int textbeg, int textend, int textstart, int prevlen, bool quick, TimeSpan timeout);
+        protected void TransferCapture(int capnum, int uncapnum, int start, int end);
+        protected void Uncapture();
+    }
+    public abstract class RegexRunnerFactory {
+        protected RegexRunnerFactory();
+        protected internal abstract RegexRunner CreateInstance();
+    }
+}
```

## System.Text.Unicode

```c#
+namespace System.Text.Unicode {
+    public sealed class UnicodeRange {
+        public UnicodeRange(int firstCodePoint, int length);
+        public int FirstCodePoint { get; private set; }
+        public int Length { get; private set; }
+        public static UnicodeRange Create(char firstCharacter, char lastCharacter);
+    }
+    public static class UnicodeRanges {
+        public static UnicodeRange All { get; }
+        public static UnicodeRange AlphabeticPresentationForms { get; }
+        public static UnicodeRange Arabic { get; }
+        public static UnicodeRange ArabicExtendedA { get; }
+        public static UnicodeRange ArabicPresentationFormsA { get; }
+        public static UnicodeRange ArabicPresentationFormsB { get; }
+        public static UnicodeRange ArabicSupplement { get; }
+        public static UnicodeRange Armenian { get; }
+        public static UnicodeRange Arrows { get; }
+        public static UnicodeRange Balinese { get; }
+        public static UnicodeRange Bamum { get; }
+        public static UnicodeRange BasicLatin { get; }
+        public static UnicodeRange Batak { get; }
+        public static UnicodeRange Bengali { get; }
+        public static UnicodeRange BlockElements { get; }
+        public static UnicodeRange Bopomofo { get; }
+        public static UnicodeRange BopomofoExtended { get; }
+        public static UnicodeRange BoxDrawing { get; }
+        public static UnicodeRange BraillePatterns { get; }
+        public static UnicodeRange Buginese { get; }
+        public static UnicodeRange Buhid { get; }
+        public static UnicodeRange Cham { get; }
+        public static UnicodeRange Cherokee { get; }
+        public static UnicodeRange CherokeeSupplement { get; }
+        public static UnicodeRange CjkCompatibility { get; }
+        public static UnicodeRange CjkCompatibilityForms { get; }
+        public static UnicodeRange CjkCompatibilityIdeographs { get; }
+        public static UnicodeRange CjkRadicalsSupplement { get; }
+        public static UnicodeRange CjkStrokes { get; }
+        public static UnicodeRange CjkSymbolsandPunctuation { get; }
+        public static UnicodeRange CjkUnifiedIdeographs { get; }
+        public static UnicodeRange CjkUnifiedIdeographsExtensionA { get; }
+        public static UnicodeRange CombiningDiacriticalMarks { get; }
+        public static UnicodeRange CombiningDiacriticalMarksExtended { get; }
+        public static UnicodeRange CombiningDiacriticalMarksforSymbols { get; }
+        public static UnicodeRange CombiningDiacriticalMarksSupplement { get; }
+        public static UnicodeRange CombiningHalfMarks { get; }
+        public static UnicodeRange CommonIndicNumberForms { get; }
+        public static UnicodeRange ControlPictures { get; }
+        public static UnicodeRange Coptic { get; }
+        public static UnicodeRange CurrencySymbols { get; }
+        public static UnicodeRange Cyrillic { get; }
+        public static UnicodeRange CyrillicExtendedA { get; }
+        public static UnicodeRange CyrillicExtendedB { get; }
+        public static UnicodeRange CyrillicSupplement { get; }
+        public static UnicodeRange Devanagari { get; }
+        public static UnicodeRange DevanagariExtended { get; }
+        public static UnicodeRange Dingbats { get; }
+        public static UnicodeRange EnclosedAlphanumerics { get; }
+        public static UnicodeRange EnclosedCjkLettersandMonths { get; }
+        public static UnicodeRange Ethiopic { get; }
+        public static UnicodeRange EthiopicExtended { get; }
+        public static UnicodeRange EthiopicExtendedA { get; }
+        public static UnicodeRange EthiopicSupplement { get; }
+        public static UnicodeRange GeneralPunctuation { get; }
+        public static UnicodeRange GeometricShapes { get; }
+        public static UnicodeRange Georgian { get; }
+        public static UnicodeRange GeorgianSupplement { get; }
+        public static UnicodeRange Glagolitic { get; }
+        public static UnicodeRange GreekandCoptic { get; }
+        public static UnicodeRange GreekExtended { get; }
+        public static UnicodeRange Gujarati { get; }
+        public static UnicodeRange Gurmukhi { get; }
+        public static UnicodeRange HalfwidthandFullwidthForms { get; }
+        public static UnicodeRange HangulCompatibilityJamo { get; }
+        public static UnicodeRange HangulJamo { get; }
+        public static UnicodeRange HangulJamoExtendedA { get; }
+        public static UnicodeRange HangulJamoExtendedB { get; }
+        public static UnicodeRange HangulSyllables { get; }
+        public static UnicodeRange Hanunoo { get; }
+        public static UnicodeRange Hebrew { get; }
+        public static UnicodeRange Hiragana { get; }
+        public static UnicodeRange IdeographicDescriptionCharacters { get; }
+        public static UnicodeRange IpaExtensions { get; }
+        public static UnicodeRange Javanese { get; }
+        public static UnicodeRange Kanbun { get; }
+        public static UnicodeRange KangxiRadicals { get; }
+        public static UnicodeRange Kannada { get; }
+        public static UnicodeRange Katakana { get; }
+        public static UnicodeRange KatakanaPhoneticExtensions { get; }
+        public static UnicodeRange KayahLi { get; }
+        public static UnicodeRange Khmer { get; }
+        public static UnicodeRange KhmerSymbols { get; }
+        public static UnicodeRange Lao { get; }
+        public static UnicodeRange Latin1Supplement { get; }
+        public static UnicodeRange LatinExtendedA { get; }
+        public static UnicodeRange LatinExtendedAdditional { get; }
+        public static UnicodeRange LatinExtendedB { get; }
+        public static UnicodeRange LatinExtendedC { get; }
+        public static UnicodeRange LatinExtendedD { get; }
+        public static UnicodeRange LatinExtendedE { get; }
+        public static UnicodeRange Lepcha { get; }
+        public static UnicodeRange LetterlikeSymbols { get; }
+        public static UnicodeRange Limbu { get; }
+        public static UnicodeRange Lisu { get; }
+        public static UnicodeRange Malayalam { get; }
+        public static UnicodeRange Mandaic { get; }
+        public static UnicodeRange MathematicalOperators { get; }
+        public static UnicodeRange MeeteiMayek { get; }
+        public static UnicodeRange MeeteiMayekExtensions { get; }
+        public static UnicodeRange MiscellaneousMathematicalSymbolsA { get; }
+        public static UnicodeRange MiscellaneousMathematicalSymbolsB { get; }
+        public static UnicodeRange MiscellaneousSymbols { get; }
+        public static UnicodeRange MiscellaneousSymbolsandArrows { get; }
+        public static UnicodeRange MiscellaneousTechnical { get; }
+        public static UnicodeRange ModifierToneLetters { get; }
+        public static UnicodeRange Mongolian { get; }
+        public static UnicodeRange Myanmar { get; }
+        public static UnicodeRange MyanmarExtendedA { get; }
+        public static UnicodeRange MyanmarExtendedB { get; }
+        public static UnicodeRange NewTaiLue { get; }
+        public static UnicodeRange NKo { get; }
+        public static UnicodeRange None { get; }
+        public static UnicodeRange NumberForms { get; }
+        public static UnicodeRange Ogham { get; }
+        public static UnicodeRange OlChiki { get; }
+        public static UnicodeRange OpticalCharacterRecognition { get; }
+        public static UnicodeRange Oriya { get; }
+        public static UnicodeRange Phagspa { get; }
+        public static UnicodeRange PhoneticExtensions { get; }
+        public static UnicodeRange PhoneticExtensionsSupplement { get; }
+        public static UnicodeRange Rejang { get; }
+        public static UnicodeRange Runic { get; }
+        public static UnicodeRange Samaritan { get; }
+        public static UnicodeRange Saurashtra { get; }
+        public static UnicodeRange Sinhala { get; }
+        public static UnicodeRange SmallFormVariants { get; }
+        public static UnicodeRange SpacingModifierLetters { get; }
+        public static UnicodeRange Specials { get; }
+        public static UnicodeRange Sundanese { get; }
+        public static UnicodeRange SundaneseSupplement { get; }
+        public static UnicodeRange SuperscriptsandSubscripts { get; }
+        public static UnicodeRange SupplementalArrowsA { get; }
+        public static UnicodeRange SupplementalArrowsB { get; }
+        public static UnicodeRange SupplementalMathematicalOperators { get; }
+        public static UnicodeRange SupplementalPunctuation { get; }
+        public static UnicodeRange SylotiNagri { get; }
+        public static UnicodeRange Syriac { get; }
+        public static UnicodeRange Tagalog { get; }
+        public static UnicodeRange Tagbanwa { get; }
+        public static UnicodeRange TaiLe { get; }
+        public static UnicodeRange TaiTham { get; }
+        public static UnicodeRange TaiViet { get; }
+        public static UnicodeRange Tamil { get; }
+        public static UnicodeRange Telugu { get; }
+        public static UnicodeRange Thaana { get; }
+        public static UnicodeRange Thai { get; }
+        public static UnicodeRange Tibetan { get; }
+        public static UnicodeRange Tifinagh { get; }
+        public static UnicodeRange UnifiedCanadianAboriginalSyllabics { get; }
+        public static UnicodeRange UnifiedCanadianAboriginalSyllabicsExtended { get; }
+        public static UnicodeRange Vai { get; }
+        public static UnicodeRange VariationSelectors { get; }
+        public static UnicodeRange VedicExtensions { get; }
+        public static UnicodeRange VerticalForms { get; }
+        public static UnicodeRange YijingHexagramSymbols { get; }
+        public static UnicodeRange YiRadicals { get; }
+        public static UnicodeRange YiSyllables { get; }
+    }
+}
```

## System.Threading

```c#
+namespace System.Threading {
+    public class AbandonedMutexException : Exception {
+        public AbandonedMutexException();
+        public AbandonedMutexException(int location, WaitHandle handle);
+        public AbandonedMutexException(string message);
+        public AbandonedMutexException(string message, Exception inner);
+        public AbandonedMutexException(string message, Exception inner, int location, WaitHandle handle);
+        public AbandonedMutexException(string message, int location, WaitHandle handle);
+        public Mutex Mutex { get; }
+        public int MutexIndex { get; }
+    }
+    public sealed class AsyncLocal<T> {
+        public AsyncLocal();
+        public AsyncLocal(Action<AsyncLocalValueChangedArgs<T>> valueChangedHandler);
+        public T Value { get; set; }
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct AsyncLocalValueChangedArgs<T> {
+        public T CurrentValue { get; }
+        public T PreviousValue { get; }
+        public bool ThreadContextChanged { get; }
+    }
+    public sealed class AutoResetEvent : EventWaitHandle {
+        public AutoResetEvent(bool initialState);
+    }
+    public class Barrier : IDisposable {
+        public Barrier(int participantCount);
+        public Barrier(int participantCount, Action<Barrier> postPhaseAction);
+        public long CurrentPhaseNumber { get; }
+        public int ParticipantCount { get; }
+        public int ParticipantsRemaining { get; }
+        public long AddParticipant();
+        public long AddParticipants(int participantCount);
+        public void Dispose();
+        protected virtual void Dispose(bool disposing);
+        public void RemoveParticipant();
+        public void RemoveParticipants(int participantCount);
+        public void SignalAndWait();
+        public bool SignalAndWait(int millisecondsTimeout);
+        public bool SignalAndWait(int millisecondsTimeout, CancellationToken cancellationToken);
+        public void SignalAndWait(CancellationToken cancellationToken);
+        public bool SignalAndWait(TimeSpan timeout);
+        public bool SignalAndWait(TimeSpan timeout, CancellationToken cancellationToken);
+    }
+    public class BarrierPostPhaseException : Exception {
+        public BarrierPostPhaseException();
+        public BarrierPostPhaseException(Exception innerException);
+        public BarrierPostPhaseException(string message);
+        public BarrierPostPhaseException(string message, Exception innerException);
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct CancellationToken {
+        public CancellationToken(bool canceled);
+        public bool CanBeCanceled { get; }
+        public bool IsCancellationRequested { get; }
+        public static CancellationToken None { get; }
+        public WaitHandle WaitHandle { get; }
+        public override bool Equals(object other);
+        public bool Equals(CancellationToken other);
+        public override int GetHashCode();
+        public static bool operator ==(CancellationToken left, CancellationToken right);
+        public static bool operator !=(CancellationToken left, CancellationToken right);
+        public CancellationTokenRegistration Register(Action callback);
+        public CancellationTokenRegistration Register(Action callback, bool useSynchronizationContext);
+        public CancellationTokenRegistration Register(Action<object> callback, object state);
+        public CancellationTokenRegistration Register(Action<object> callback, object state, bool useSynchronizationContext);
+        public void ThrowIfCancellationRequested();
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct CancellationTokenRegistration : IDisposable, IEquatable<CancellationTokenRegistration> {
+        public void Dispose();
+        public override bool Equals(object obj);
+        public bool Equals(CancellationTokenRegistration other);
+        public override int GetHashCode();
+        public static bool operator ==(CancellationTokenRegistration left, CancellationTokenRegistration right);
+        public static bool operator !=(CancellationTokenRegistration left, CancellationTokenRegistration right);
+    }
+    public class CancellationTokenSource : IDisposable {
+        public CancellationTokenSource();
+        public CancellationTokenSource(int millisecondsDelay);
+        public CancellationTokenSource(TimeSpan delay);
+        public bool IsCancellationRequested { get; }
+        public CancellationToken Token { get; }
+        public void Cancel();
+        public void Cancel(bool throwOnFirstException);
+        public void CancelAfter(int millisecondsDelay);
+        public void CancelAfter(TimeSpan delay);
+        public static CancellationTokenSource CreateLinkedTokenSource(CancellationToken token1, CancellationToken token2);
+        public static CancellationTokenSource CreateLinkedTokenSource(params CancellationToken[] tokens);
+        public void Dispose();
+        protected virtual void Dispose(bool disposing);
+    }
+    public delegate void ContextCallback(object state);
+    public class CountdownEvent : IDisposable {
+        public CountdownEvent(int initialCount);
+        public int CurrentCount { get; }
+        public int InitialCount { get; }
+        public bool IsSet { get; }
+        public WaitHandle WaitHandle { get; }
+        public void AddCount();
+        public void AddCount(int signalCount);
+        public void Dispose();
+        protected virtual void Dispose(bool disposing);
+        public void Reset();
+        public void Reset(int count);
+        public bool Signal();
+        public bool Signal(int signalCount);
+        public bool TryAddCount();
+        public bool TryAddCount(int signalCount);
+        public void Wait();
+        public bool Wait(int millisecondsTimeout);
+        public bool Wait(int millisecondsTimeout, CancellationToken cancellationToken);
+        public void Wait(CancellationToken cancellationToken);
+        public bool Wait(TimeSpan timeout);
+        public bool Wait(TimeSpan timeout, CancellationToken cancellationToken);
+    }
+    public enum EventResetMode {
+        AutoReset = 0,
+        ManualReset = 1,
+    }
+    public class EventWaitHandle : WaitHandle {
+        public EventWaitHandle(bool initialState, EventResetMode mode);
+        public EventWaitHandle(bool initialState, EventResetMode mode, string name);
+        public EventWaitHandle(bool initialState, EventResetMode mode, string name, out bool createdNew);
+        public static EventWaitHandle OpenExisting(string name);
+        public bool Reset();
+        public bool Set();
+        public static bool TryOpenExisting(string name, out EventWaitHandle result);
+    }
+    public sealed class ExecutionContext {
+        public static ExecutionContext Capture();
+        public void Dispose();
+        public static void Run(ExecutionContext executionContext, ContextCallback callback, object state);
+    }
+    public static class Interlocked {
+        public static int Add(ref int location1, int value);
+        public static long Add(ref long location1, long value);
+        public static double CompareExchange(ref double location1, double value, double comparand);
+        public static int CompareExchange(ref int location1, int value, int comparand);
+        public static long CompareExchange(ref long location1, long value, long comparand);
+        public static IntPtr CompareExchange(ref IntPtr location1, IntPtr value, IntPtr comparand);
+        public static object CompareExchange(ref object location1, object value, object comparand);
+        public static float CompareExchange(ref float location1, float value, float comparand);
+        public static T CompareExchange<T>(ref T location1, T value, T comparand) where T : class;
+        public static int Decrement(ref int location);
+        public static long Decrement(ref long location);
+        public static double Exchange(ref double location1, double value);
+        public static int Exchange(ref int location1, int value);
+        public static long Exchange(ref long location1, long value);
+        public static IntPtr Exchange(ref IntPtr location1, IntPtr value);
+        public static object Exchange(ref object location1, object value);
+        public static float Exchange(ref float location1, float value);
+        public static T Exchange<T>(ref T location1, T value) where T : class;
+        public static int Increment(ref int location);
+        public static long Increment(ref long location);
+        public static void MemoryBarrier();
+        public static long Read(ref long location);
+    }
+    public unsafe delegate void IOCompletionCallback(uint errorCode, uint numBytes, NativeOverlapped* pOVERLAP);
+    public static class LazyInitializer {
+        public static T EnsureInitialized<T>(ref T target) where T : class;
+        public static T EnsureInitialized<T>(ref T target, ref bool initialized, ref object syncLock);
+        public static T EnsureInitialized<T>(ref T target, ref bool initialized, ref object syncLock, Func<T> valueFactory);
+        public static T EnsureInitialized<T>(ref T target, Func<T> valueFactory) where T : class;
+    }
+    public enum LazyThreadSafetyMode {
+        ExecutionAndPublication = 2,
+        None = 0,
+        PublicationOnly = 1,
+    }
+    public class LockRecursionException : Exception {
+        public LockRecursionException();
+        public LockRecursionException(string message);
+        public LockRecursionException(string message, Exception innerException);
+    }
+    public enum LockRecursionPolicy {
+        NoRecursion = 0,
+        SupportsRecursion = 1,
+    }
+    public sealed class ManualResetEvent : EventWaitHandle {
+        public ManualResetEvent(bool initialState);
+    }
+    public class ManualResetEventSlim : IDisposable {
+        public ManualResetEventSlim();
+        public ManualResetEventSlim(bool initialState);
+        public ManualResetEventSlim(bool initialState, int spinCount);
+        public bool IsSet { get; }
+        public int SpinCount { get; }
+        public WaitHandle WaitHandle { get; }
+        public void Dispose();
+        protected virtual void Dispose(bool disposing);
+        public void Reset();
+        public void Set();
+        public void Wait();
+        public bool Wait(int millisecondsTimeout);
+        public bool Wait(int millisecondsTimeout, CancellationToken cancellationToken);
+        public void Wait(CancellationToken cancellationToken);
+        public bool Wait(TimeSpan timeout);
+        public bool Wait(TimeSpan timeout, CancellationToken cancellationToken);
+    }
+    public static class Monitor {
+        public static void Enter(object obj);
+        public static void Enter(object obj, ref bool lockTaken);
+        public static void Exit(object obj);
+        public static bool IsEntered(object obj);
+        public static void Pulse(object obj);
+        public static void PulseAll(object obj);
+        public static bool TryEnter(object obj);
+        public static void TryEnter(object obj, ref bool lockTaken);
+        public static bool TryEnter(object obj, int millisecondsTimeout);
+        public static void TryEnter(object obj, int millisecondsTimeout, ref bool lockTaken);
+        public static bool TryEnter(object obj, TimeSpan timeout);
+        public static void TryEnter(object obj, TimeSpan timeout, ref bool lockTaken);
+        public static bool Wait(object obj);
+        public static bool Wait(object obj, int millisecondsTimeout);
+        public static bool Wait(object obj, TimeSpan timeout);
+    }
+    public sealed class Mutex : WaitHandle {
+        public Mutex();
+        public Mutex(bool initiallyOwned);
+        public Mutex(bool initiallyOwned, string name);
+        public Mutex(bool initiallyOwned, string name, out bool createdNew);
+        public static Mutex OpenExisting(string name);
+        public void ReleaseMutex();
+        public static bool TryOpenExisting(string name, out Mutex result);
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct NativeOverlapped {
+        public int OffsetHigh;
+        public int OffsetLow;
+        public IntPtr EventHandle;
+        public IntPtr InternalHigh;
+        public IntPtr InternalLow;
+    }
+    public class Overlapped {
+        public Overlapped();
+        public IAsyncResult AsyncResult { get; set; }
+        public int OffsetHigh { get; set; }
+        public int OffsetLow { get; set; }
+        public unsafe static void Free(NativeOverlapped* nativeOverlappedPtr);
+        public unsafe NativeOverlapped* Pack(IOCompletionCallback iocb, object userData);
+        public unsafe static Overlapped Unpack(NativeOverlapped* nativeOverlappedPtr);
+        public unsafe NativeOverlapped* UnsafePack(IOCompletionCallback iocb, object userData);
+    }
+    public delegate void ParameterizedThreadStart(object obj);
+    public sealed class PreAllocatedOverlapped : IDisposable {
+        public PreAllocatedOverlapped(IOCompletionCallback callback, object state, object pinData);
+        public void Dispose();
+    }
+    public class ReaderWriterLockSlim : IDisposable {
+        public ReaderWriterLockSlim();
+        public ReaderWriterLockSlim(LockRecursionPolicy recursionPolicy);
+        public int CurrentReadCount { get; }
+        public bool IsReadLockHeld { get; }
+        public bool IsUpgradeableReadLockHeld { get; }
+        public bool IsWriteLockHeld { get; }
+        public LockRecursionPolicy RecursionPolicy { get; }
+        public int RecursiveReadCount { get; }
+        public int RecursiveUpgradeCount { get; }
+        public int RecursiveWriteCount { get; }
+        public int WaitingReadCount { get; }
+        public int WaitingUpgradeCount { get; }
+        public int WaitingWriteCount { get; }
+        public void Dispose();
+        public void EnterReadLock();
+        public void EnterUpgradeableReadLock();
+        public void EnterWriteLock();
+        public void ExitReadLock();
+        public void ExitUpgradeableReadLock();
+        public void ExitWriteLock();
+        public bool TryEnterReadLock(int millisecondsTimeout);
+        public bool TryEnterReadLock(TimeSpan timeout);
+        public bool TryEnterUpgradeableReadLock(int millisecondsTimeout);
+        public bool TryEnterUpgradeableReadLock(TimeSpan timeout);
+        public bool TryEnterWriteLock(int millisecondsTimeout);
+        public bool TryEnterWriteLock(TimeSpan timeout);
+    }
+    public sealed class RegisteredWaitHandle {
+        public bool Unregister(WaitHandle waitObject);
+    }
+    public sealed class Semaphore : WaitHandle {
+        public Semaphore(int initialCount, int maximumCount);
+        public Semaphore(int initialCount, int maximumCount, string name);
+        public Semaphore(int initialCount, int maximumCount, string name, out bool createdNew);
+        public static Semaphore OpenExisting(string name);
+        public int Release();
+        public int Release(int releaseCount);
+        public static bool TryOpenExisting(string name, out Semaphore result);
+    }
+    public class SemaphoreFullException : Exception {
+        public SemaphoreFullException();
+        public SemaphoreFullException(string message);
+        public SemaphoreFullException(string message, Exception innerException);
+    }
+    public class SemaphoreSlim : IDisposable {
+        public SemaphoreSlim(int initialCount);
+        public SemaphoreSlim(int initialCount, int maxCount);
+        public WaitHandle AvailableWaitHandle { get; }
+        public int CurrentCount { get; }
+        public void Dispose();
+        protected virtual void Dispose(bool disposing);
+        public int Release();
+        public int Release(int releaseCount);
+        public void Wait();
+        public bool Wait(int millisecondsTimeout);
+        public bool Wait(int millisecondsTimeout, CancellationToken cancellationToken);
+        public void Wait(CancellationToken cancellationToken);
+        public bool Wait(TimeSpan timeout);
+        public bool Wait(TimeSpan timeout, CancellationToken cancellationToken);
+        public Task WaitAsync();
+        public Task<bool> WaitAsync(int millisecondsTimeout);
+        public Task<bool> WaitAsync(int millisecondsTimeout, CancellationToken cancellationToken);
+        public Task WaitAsync(CancellationToken cancellationToken);
+        public Task<bool> WaitAsync(TimeSpan timeout);
+        public Task<bool> WaitAsync(TimeSpan timeout, CancellationToken cancellationToken);
+    }
+    public delegate void SendOrPostCallback(object state);
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct SpinLock {
+        public SpinLock(bool enableThreadOwnerTracking);
+        public bool IsHeld { get; }
+        public bool IsHeldByCurrentThread { get; }
+        public bool IsThreadOwnerTrackingEnabled { get; }
+        public void Enter(ref bool lockTaken);
+        public void Exit();
+        public void Exit(bool useMemoryBarrier);
+        public void TryEnter(ref bool lockTaken);
+        public void TryEnter(int millisecondsTimeout, ref bool lockTaken);
+        public void TryEnter(TimeSpan timeout, ref bool lockTaken);
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct SpinWait {
+        public int Count { get; }
+        public bool NextSpinWillYield { get; }
+        public void Reset();
+        public void SpinOnce();
+        public static void SpinUntil(Func<bool> condition);
+        public static bool SpinUntil(Func<bool> condition, int millisecondsTimeout);
+        public static bool SpinUntil(Func<bool> condition, TimeSpan timeout);
+    }
+    public class SynchronizationContext {
+        public SynchronizationContext();
+        public static SynchronizationContext Current { get; }
+        public virtual SynchronizationContext CreateCopy();
+        public virtual void OperationCompleted();
+        public virtual void OperationStarted();
+        public virtual void Post(SendOrPostCallback d, object state);
+        public virtual void Send(SendOrPostCallback d, object state);
+        public static void SetSynchronizationContext(SynchronizationContext syncContext);
+    }
+    public class SynchronizationLockException : Exception {
+        public SynchronizationLockException();
+        public SynchronizationLockException(string message);
+        public SynchronizationLockException(string message, Exception innerException);
+    }
+    public sealed class Thread {
+        public Thread(ParameterizedThreadStart start);
+        public Thread(ThreadStart start);
+        public CultureInfo CurrentCulture { get; set; }
+        public static Thread CurrentThread { get; }
+        public CultureInfo CurrentUICulture { get; set; }
+        public bool IsAlive { get; }
+        public bool IsBackground { get; set; }
+        public int ManagedThreadId { get; }
+        public string Name { get; set; }
+        public ThreadState ThreadState { get; }
+        ~Thread();
+        public static AppDomain GetDomain();
+        public override int GetHashCode();
+        public void Join();
+        public bool Join(int millisecondsTimeout);
+        [MethodImpl(InternalCall)]public static void MemoryBarrier();
+        public static void Sleep(int millisecondsTimeout);
+        public static void Sleep(TimeSpan timeout);
+        public static void SpinWait(int iterations);
+        public void Start();
+        public void Start(object parameter);
+    }
+    public sealed class ThreadAbortException : SystemException
+    public static class ThreadingAclExtensions {
+        public static EventWaitHandleSecurity GetAccessControl(this EventWaitHandle handle);
+        public static MutexSecurity GetAccessControl(this Mutex mutex);
+        public static SemaphoreSecurity GetAccessControl(this Semaphore semaphore);
+        public static void SetAccessControl(this EventWaitHandle handle, EventWaitHandleSecurity eventSecurity);
+        public static void SetAccessControl(this Mutex mutex, MutexSecurity mutexSecurity);
+        public static void SetAccessControl(this Semaphore semaphore, SemaphoreSecurity semaphoreSecurity);
+    }
+    public class ThreadLocal<T> : IDisposable {
+        public ThreadLocal();
+        public ThreadLocal(bool trackAllValues);
+        public ThreadLocal(Func<T> valueFactory);
+        public ThreadLocal(Func<T> valueFactory, bool trackAllValues);
+        public bool IsValueCreated { get; }
+        public T Value { get; set; }
+        public IList<T> Values { get; }
+        public void Dispose();
+        protected virtual void Dispose(bool disposing);
+        ~ThreadLocal();
+        public override string ToString();
+    }
+    public static class ThreadPool {
+        public static bool BindHandle(SafeHandle osHandle);
+        public static void GetMaxThreads(out int workerThreads, out int completionPortThreads);
+        public static void GetMinThreads(out int workerThreads, out int completionPortThreads);
+        public static bool QueueUserWorkItem(WaitCallback callBack);
+        public static bool QueueUserWorkItem(WaitCallback callBack, object state);
+        public static RegisteredWaitHandle RegisterWaitForSingleObject(WaitHandle waitObject, WaitOrTimerCallback callBack, object state, int millisecondsTimeOutInterval, bool executeOnlyOnce);
+        public static RegisteredWaitHandle RegisterWaitForSingleObject(WaitHandle waitObject, WaitOrTimerCallback callBack, object state, long millisecondsTimeOutInterval, bool executeOnlyOnce);
+        public static RegisteredWaitHandle RegisterWaitForSingleObject(WaitHandle waitObject, WaitOrTimerCallback callBack, object state, TimeSpan timeout, bool executeOnlyOnce);
+        public static RegisteredWaitHandle RegisterWaitForSingleObject(WaitHandle waitObject, WaitOrTimerCallback callBack, object state, uint millisecondsTimeOutInterval, bool executeOnlyOnce);
+        public static bool SetMaxThreads(int workerThreads, int completionPortThreads);
+        public static bool SetMinThreads(int workerThreads, int completionPortThreads);
+    }
+    public sealed class ThreadPoolBoundHandle : IDisposable {
+        public SafeHandle Handle { get; }
+        public unsafe NativeOverlapped* AllocateNativeOverlapped(IOCompletionCallback callback, object state, object pinData);
+        public unsafe NativeOverlapped* AllocateNativeOverlapped(PreAllocatedOverlapped preAllocated);
+        public static ThreadPoolBoundHandle BindHandle(SafeHandle handle);
+        public void Dispose();
+        public unsafe void FreeNativeOverlapped(NativeOverlapped* overlapped);
+        public unsafe static object GetNativeOverlappedState(NativeOverlapped* overlapped);
+    }
+    public delegate void ThreadStart();
+    public sealed class ThreadStartException : Exception
+    public enum ThreadState {
+        Aborted = 256,
+        AbortRequested = 128,
+        Background = 4,
+        Running = 0,
+        Stopped = 16,
+        StopRequested = 1,
+        Suspended = 64,
+        SuspendRequested = 2,
+        Unstarted = 8,
+        WaitSleepJoin = 32,
+    }
+    public class ThreadStateException : Exception {
+        public ThreadStateException();
+        public ThreadStateException(string message);
+        public ThreadStateException(string message, Exception innerException);
+    }
+    public static class Timeout {
+        public const int Infinite = -1;
+        public static readonly TimeSpan InfiniteTimeSpan;
+    }
+    public sealed class Timer : IDisposable {
+        [MethodImpl(NoInlining)]public Timer(TimerCallback callback);
+        public Timer(TimerCallback callback, object state, int dueTime, int period);
+        [MethodImpl(NoInlining)]public Timer(TimerCallback callback, object state, long dueTime, long period);
+        public Timer(TimerCallback callback, object state, TimeSpan dueTime, TimeSpan period);
+        [MethodImpl(NoInlining)]public Timer(TimerCallback callback, object state, uint dueTime, uint period);
+        public bool Change(int dueTime, int period);
+        public bool Change(long dueTime, long period);
+        public bool Change(TimeSpan dueTime, TimeSpan period);
+        public bool Change(uint dueTime, uint period);
+        public void Dispose();
+        public bool Dispose(WaitHandle notifyObject);
+    }
+    public delegate void TimerCallback(object state);
+    public static class Volatile {
+        public static bool Read(ref bool location);
+        public static byte Read(ref byte location);
+        public static double Read(ref double location);
+        public static short Read(ref short location);
+        public static int Read(ref int location);
+        public static long Read(ref long location);
+        public static IntPtr Read(ref IntPtr location);
+        public static sbyte Read(ref sbyte location);
+        public static float Read(ref float location);
+        public static ushort Read(ref ushort location);
+        public static uint Read(ref uint location);
+        public static ulong Read(ref ulong location);
+        public static UIntPtr Read(ref UIntPtr location);
+        public static T Read<T>(ref T location) where T : class;
+        public static void Write(ref bool location, bool value);
+        public static void Write(ref byte location, byte value);
+        public static void Write(ref double location, double value);
+        public static void Write(ref short location, short value);
+        public static void Write(ref int location, int value);
+        public static void Write(ref long location, long value);
+        public static void Write(ref IntPtr location, IntPtr value);
+        public static void Write(ref sbyte location, sbyte value);
+        public static void Write(ref float location, float value);
+        public static void Write(ref ushort location, ushort value);
+        public static void Write(ref uint location, uint value);
+        public static void Write(ref ulong location, ulong value);
+        public static void Write(ref UIntPtr location, UIntPtr value);
+        public static void Write<T>(ref T location, T value) where T : class;
+    }
+    public delegate void WaitCallback(object state);
+    public abstract class WaitHandle : IDisposable {
+        public const int WaitTimeout = 258;
+        protected static readonly IntPtr InvalidHandle;
+        protected WaitHandle();
+        public SafeWaitHandle SafeWaitHandle { get; set; }
+        public virtual void Close();
+        public void Dispose();
+        protected virtual void Dispose(bool explicitDisposing);
+        public static bool WaitAll(WaitHandle[] waitHandles);
+        public static bool WaitAll(WaitHandle[] waitHandles, int millisecondsTimeout);
+        public static bool WaitAll(WaitHandle[] waitHandles, TimeSpan timeout);
+        public static int WaitAny(WaitHandle[] waitHandles);
+        public static int WaitAny(WaitHandle[] waitHandles, int millisecondsTimeout);
+        public static int WaitAny(WaitHandle[] waitHandles, TimeSpan timeout);
+        public virtual bool WaitOne();
+        public virtual bool WaitOne(int millisecondsTimeout);
+        public virtual bool WaitOne(TimeSpan timeout);
+    }
+    public class WaitHandleCannotBeOpenedException : Exception {
+        public WaitHandleCannotBeOpenedException();
+        public WaitHandleCannotBeOpenedException(string message);
+        public WaitHandleCannotBeOpenedException(string message, Exception innerException);
+    }
+    public static class WaitHandleExtensions {
+        public static SafeWaitHandle GetSafeWaitHandle(this WaitHandle waitHandle);
+        public static void SetSafeWaitHandle(this WaitHandle waitHandle, SafeWaitHandle value);
+    }
+    public delegate void WaitOrTimerCallback(object state, bool timedOut);
+}
```

## System.Threading.Tasks

```c#
+namespace System.Threading.Tasks {
+    public class ConcurrentExclusiveSchedulerPair {
+        public ConcurrentExclusiveSchedulerPair();
+        public ConcurrentExclusiveSchedulerPair(TaskScheduler taskScheduler);
+        public ConcurrentExclusiveSchedulerPair(TaskScheduler taskScheduler, int maxConcurrencyLevel);
+        public ConcurrentExclusiveSchedulerPair(TaskScheduler taskScheduler, int maxConcurrencyLevel, int maxItemsPerTask);
+        public Task Completion { get; }
+        public TaskScheduler ConcurrentScheduler { get; }
+        public TaskScheduler ExclusiveScheduler { get; }
+        public void Complete();
+    }
+    public static class Parallel {
+        public static ParallelLoopResult For(int fromInclusive, int toExclusive, Action<int, ParallelLoopState> body);
+        public static ParallelLoopResult For(int fromInclusive, int toExclusive, Action<int> body);
+        public static ParallelLoopResult For(int fromInclusive, int toExclusive, ParallelOptions parallelOptions, Action<int, ParallelLoopState> body);
+        public static ParallelLoopResult For(int fromInclusive, int toExclusive, ParallelOptions parallelOptions, Action<int> body);
+        public static ParallelLoopResult For(long fromInclusive, long toExclusive, Action<long, ParallelLoopState> body);
+        public static ParallelLoopResult For(long fromInclusive, long toExclusive, Action<long> body);
+        public static ParallelLoopResult For(long fromInclusive, long toExclusive, ParallelOptions parallelOptions, Action<long, ParallelLoopState> body);
+        public static ParallelLoopResult For(long fromInclusive, long toExclusive, ParallelOptions parallelOptions, Action<long> body);
+        public static ParallelLoopResult For<TLocal>(int fromInclusive, int toExclusive, Func<TLocal> localInit, Func<int, ParallelLoopState, TLocal, TLocal> body, Action<TLocal> localFinally);
+        public static ParallelLoopResult For<TLocal>(int fromInclusive, int toExclusive, ParallelOptions parallelOptions, Func<TLocal> localInit, Func<int, ParallelLoopState, TLocal, TLocal> body, Action<TLocal> localFinally);
+        public static ParallelLoopResult For<TLocal>(long fromInclusive, long toExclusive, Func<TLocal> localInit, Func<long, ParallelLoopState, TLocal, TLocal> body, Action<TLocal> localFinally);
+        public static ParallelLoopResult For<TLocal>(long fromInclusive, long toExclusive, ParallelOptions parallelOptions, Func<TLocal> localInit, Func<long, ParallelLoopState, TLocal, TLocal> body, Action<TLocal> localFinally);
+        public static ParallelLoopResult ForEach<TSource, TLocal>(OrderablePartitioner<TSource> source, Func<TLocal> localInit, Func<TSource, ParallelLoopState, long, TLocal, TLocal> body, Action<TLocal> localFinally);
+        public static ParallelLoopResult ForEach<TSource, TLocal>(OrderablePartitioner<TSource> source, ParallelOptions parallelOptions, Func<TLocal> localInit, Func<TSource, ParallelLoopState, long, TLocal, TLocal> body, Action<TLocal> localFinally);
+        public static ParallelLoopResult ForEach<TSource, TLocal>(Partitioner<TSource> source, Func<TLocal> localInit, Func<TSource, ParallelLoopState, TLocal, TLocal> body, Action<TLocal> localFinally);
+        public static ParallelLoopResult ForEach<TSource, TLocal>(Partitioner<TSource> source, ParallelOptions parallelOptions, Func<TLocal> localInit, Func<TSource, ParallelLoopState, TLocal, TLocal> body, Action<TLocal> localFinally);
+        public static ParallelLoopResult ForEach<TSource, TLocal>(IEnumerable<TSource> source, Func<TLocal> localInit, Func<TSource, ParallelLoopState, long, TLocal, TLocal> body, Action<TLocal> localFinally);
+        public static ParallelLoopResult ForEach<TSource, TLocal>(IEnumerable<TSource> source, Func<TLocal> localInit, Func<TSource, ParallelLoopState, TLocal, TLocal> body, Action<TLocal> localFinally);
+        public static ParallelLoopResult ForEach<TSource, TLocal>(IEnumerable<TSource> source, ParallelOptions parallelOptions, Func<TLocal> localInit, Func<TSource, ParallelLoopState, long, TLocal, TLocal> body, Action<TLocal> localFinally);
+        public static ParallelLoopResult ForEach<TSource, TLocal>(IEnumerable<TSource> source, ParallelOptions parallelOptions, Func<TLocal> localInit, Func<TSource, ParallelLoopState, TLocal, TLocal> body, Action<TLocal> localFinally);
+        public static ParallelLoopResult ForEach<TSource>(OrderablePartitioner<TSource> source, Action<TSource, ParallelLoopState, long> body);
+        public static ParallelLoopResult ForEach<TSource>(OrderablePartitioner<TSource> source, ParallelOptions parallelOptions, Action<TSource, ParallelLoopState, long> body);
+        public static ParallelLoopResult ForEach<TSource>(Partitioner<TSource> source, Action<TSource, ParallelLoopState> body);
+        public static ParallelLoopResult ForEach<TSource>(Partitioner<TSource> source, Action<TSource> body);
+        public static ParallelLoopResult ForEach<TSource>(Partitioner<TSource> source, ParallelOptions parallelOptions, Action<TSource, ParallelLoopState> body);
+        public static ParallelLoopResult ForEach<TSource>(Partitioner<TSource> source, ParallelOptions parallelOptions, Action<TSource> body);
+        public static ParallelLoopResult ForEach<TSource>(IEnumerable<TSource> source, Action<TSource, ParallelLoopState, long> body);
+        public static ParallelLoopResult ForEach<TSource>(IEnumerable<TSource> source, Action<TSource, ParallelLoopState> body);
+        public static ParallelLoopResult ForEach<TSource>(IEnumerable<TSource> source, Action<TSource> body);
+        public static ParallelLoopResult ForEach<TSource>(IEnumerable<TSource> source, ParallelOptions parallelOptions, Action<TSource, ParallelLoopState, long> body);
+        public static ParallelLoopResult ForEach<TSource>(IEnumerable<TSource> source, ParallelOptions parallelOptions, Action<TSource, ParallelLoopState> body);
+        public static ParallelLoopResult ForEach<TSource>(IEnumerable<TSource> source, ParallelOptions parallelOptions, Action<TSource> body);
+        public static void Invoke(params Action[] actions);
+        public static void Invoke(ParallelOptions parallelOptions, params Action[] actions);
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct ParallelLoopResult {
+        public bool IsCompleted { get; }
+        public Nullable<long> LowestBreakIteration { get; }
+    }
+    public class ParallelLoopState {
+        public bool IsExceptional { get; }
+        public bool IsStopped { get; }
+        public Nullable<long> LowestBreakIteration { get; }
+        public bool ShouldExitCurrentIteration { get; }
+        public void Break();
+        public void Stop();
+    }
+    public class ParallelOptions {
+        public ParallelOptions();
+        public CancellationToken CancellationToken { get; set; }
+        public int MaxDegreeOfParallelism { get; set; }
+        public TaskScheduler TaskScheduler { get; set; }
+    }
+    public class Task : IAsyncResult {
+        public Task(Action action);
+        public Task(Action action, CancellationToken cancellationToken);
+        public Task(Action action, CancellationToken cancellationToken, TaskCreationOptions creationOptions);
+        public Task(Action action, TaskCreationOptions creationOptions);
+        public Task(Action<object> action, object state);
+        public Task(Action<object> action, object state, CancellationToken cancellationToken);
+        public Task(Action<object> action, object state, CancellationToken cancellationToken, TaskCreationOptions creationOptions);
+        public Task(Action<object> action, object state, TaskCreationOptions creationOptions);
+        public object AsyncState { get; }
+        public static Task CompletedTask { get; }
+        public TaskCreationOptions CreationOptions { get; }
+        public static Nullable<int> CurrentId { get; }
+        public AggregateException Exception { get; }
+        public static TaskFactory Factory { get; }
+        public int Id { get; }
+        public bool IsCanceled { get; }
+        public bool IsCompleted { get; }
+        public bool IsFaulted { get; }
+        public TaskStatus Status { get; }
+        WaitHandle System.IAsyncResult.AsyncWaitHandle { get; }
+        bool System.IAsyncResult.CompletedSynchronously { get; }
+        public ConfiguredTaskAwaitable ConfigureAwait(bool continueOnCapturedContext);
+        public Task ContinueWith(Action<Task, object> continuationAction, object state);
+        public Task ContinueWith(Action<Task, object> continuationAction, object state, CancellationToken cancellationToken);
+        public Task ContinueWith(Action<Task, object> continuationAction, object state, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
+        public Task ContinueWith(Action<Task, object> continuationAction, object state, TaskContinuationOptions continuationOptions);
+        public Task ContinueWith(Action<Task, object> continuationAction, object state, TaskScheduler scheduler);
+        public Task ContinueWith(Action<Task> continuationAction);
+        public Task ContinueWith(Action<Task> continuationAction, CancellationToken cancellationToken);
+        public Task ContinueWith(Action<Task> continuationAction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
+        public Task ContinueWith(Action<Task> continuationAction, TaskContinuationOptions continuationOptions);
+        public Task ContinueWith(Action<Task> continuationAction, TaskScheduler scheduler);
+        public Task<TResult> ContinueWith<TResult>(Func<Task, object, TResult> continuationFunction, object state);
+        public Task<TResult> ContinueWith<TResult>(Func<Task, object, TResult> continuationFunction, object state, CancellationToken cancellationToken);
+        public Task<TResult> ContinueWith<TResult>(Func<Task, object, TResult> continuationFunction, object state, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
+        public Task<TResult> ContinueWith<TResult>(Func<Task, object, TResult> continuationFunction, object state, TaskContinuationOptions continuationOptions);
+        public Task<TResult> ContinueWith<TResult>(Func<Task, object, TResult> continuationFunction, object state, TaskScheduler scheduler);
+        public Task<TResult> ContinueWith<TResult>(Func<Task, TResult> continuationFunction);
+        public Task<TResult> ContinueWith<TResult>(Func<Task, TResult> continuationFunction, CancellationToken cancellationToken);
+        public Task<TResult> ContinueWith<TResult>(Func<Task, TResult> continuationFunction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
+        public Task<TResult> ContinueWith<TResult>(Func<Task, TResult> continuationFunction, TaskContinuationOptions continuationOptions);
+        public Task<TResult> ContinueWith<TResult>(Func<Task, TResult> continuationFunction, TaskScheduler scheduler);
+        public static Task Delay(int millisecondsDelay);
+        public static Task Delay(int millisecondsDelay, CancellationToken cancellationToken);
+        public static Task Delay(TimeSpan delay);
+        public static Task Delay(TimeSpan delay, CancellationToken cancellationToken);
+        public void Dispose();
+        protected virtual void Dispose(bool disposing);
+        public static Task FromCanceled(CancellationToken cancellationToken);
+        public static Task<TResult> FromCanceled<TResult>(CancellationToken cancellationToken);
+        public static Task FromException(Exception exception);
+        public static Task<TResult> FromException<TResult>(Exception exception);
+        public static Task<TResult> FromResult<TResult>(TResult result);
+        public TaskAwaiter GetAwaiter();
+        public static Task Run(Action action);
+        public static Task Run(Action action, CancellationToken cancellationToken);
+        public static Task Run(Func<Task> function);
+        public static Task Run(Func<Task> function, CancellationToken cancellationToken);
+        public static Task<TResult> Run<TResult>(Func<Task<TResult>> function);
+        public static Task<TResult> Run<TResult>(Func<Task<TResult>> function, CancellationToken cancellationToken);
+        public static Task<TResult> Run<TResult>(Func<TResult> function);
+        public static Task<TResult> Run<TResult>(Func<TResult> function, CancellationToken cancellationToken);
+        public void RunSynchronously();
+        public void RunSynchronously(TaskScheduler scheduler);
+        public void Start();
+        public void Start(TaskScheduler scheduler);
+        public void Wait();
+        public bool Wait(int millisecondsTimeout);
+        public bool Wait(int millisecondsTimeout, CancellationToken cancellationToken);
+        public void Wait(CancellationToken cancellationToken);
+        public bool Wait(TimeSpan timeout);
+        public static void WaitAll(params Task[] tasks);
+        public static bool WaitAll(Task[] tasks, int millisecondsTimeout);
+        public static bool WaitAll(Task[] tasks, int millisecondsTimeout, CancellationToken cancellationToken);
+        public static void WaitAll(Task[] tasks, CancellationToken cancellationToken);
+        public static bool WaitAll(Task[] tasks, TimeSpan timeout);
+        public static int WaitAny(params Task[] tasks);
+        public static int WaitAny(Task[] tasks, int millisecondsTimeout);
+        public static int WaitAny(Task[] tasks, int millisecondsTimeout, CancellationToken cancellationToken);
+        public static int WaitAny(Task[] tasks, CancellationToken cancellationToken);
+        public static int WaitAny(Task[] tasks, TimeSpan timeout);
+        public static Task WhenAll(IEnumerable<Task> tasks);
+        public static Task WhenAll(params Task[] tasks);
+        public static Task<TResult[]> WhenAll<TResult>(IEnumerable<Task<TResult>> tasks);
+        public static Task<TResult[]> WhenAll<TResult>(params Task<TResult>[] tasks);
+        public static Task<Task> WhenAny(IEnumerable<Task> tasks);
+        public static Task<Task> WhenAny(params Task[] tasks);
+        public static Task<Task<TResult>> WhenAny<TResult>(IEnumerable<Task<TResult>> tasks);
+        public static Task<Task<TResult>> WhenAny<TResult>(params Task<TResult>[] tasks);
+        public static YieldAwaitable Yield();
+    }
+    public class Task<TResult> : Task {
+        public Task(Func<object, TResult> function, object state);
+        public Task(Func<object, TResult> function, object state, CancellationToken cancellationToken);
+        public Task(Func<object, TResult> function, object state, CancellationToken cancellationToken, TaskCreationOptions creationOptions);
+        public Task(Func<object, TResult> function, object state, TaskCreationOptions creationOptions);
+        public Task(Func<TResult> function);
+        public Task(Func<TResult> function, CancellationToken cancellationToken);
+        public Task(Func<TResult> function, CancellationToken cancellationToken, TaskCreationOptions creationOptions);
+        public Task(Func<TResult> function, TaskCreationOptions creationOptions);
+        public static new TaskFactory<TResult> Factory { get; }
+        public TResult Result { get; }
+        public new ConfiguredTaskAwaitable<TResult> ConfigureAwait(bool continueOnCapturedContext);
+        public Task ContinueWith(Action<Task<TResult>, object> continuationAction, object state);
+        public Task ContinueWith(Action<Task<TResult>, object> continuationAction, object state, CancellationToken cancellationToken);
+        public Task ContinueWith(Action<Task<TResult>, object> continuationAction, object state, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
+        public Task ContinueWith(Action<Task<TResult>, object> continuationAction, object state, TaskContinuationOptions continuationOptions);
+        public Task ContinueWith(Action<Task<TResult>, object> continuationAction, object state, TaskScheduler scheduler);
+        public Task ContinueWith(Action<Task<TResult>> continuationAction);
+        public Task ContinueWith(Action<Task<TResult>> continuationAction, CancellationToken cancellationToken);
+        public Task ContinueWith(Action<Task<TResult>> continuationAction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
+        public Task ContinueWith(Action<Task<TResult>> continuationAction, TaskContinuationOptions continuationOptions);
+        public Task ContinueWith(Action<Task<TResult>> continuationAction, TaskScheduler scheduler);
+        public Task<TNewResult> ContinueWith<TNewResult>(Func<Task<TResult>, object, TNewResult> continuationFunction, object state);
+        public Task<TNewResult> ContinueWith<TNewResult>(Func<Task<TResult>, object, TNewResult> continuationFunction, object state, CancellationToken cancellationToken);
+        public Task<TNewResult> ContinueWith<TNewResult>(Func<Task<TResult>, object, TNewResult> continuationFunction, object state, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
+        public Task<TNewResult> ContinueWith<TNewResult>(Func<Task<TResult>, object, TNewResult> continuationFunction, object state, TaskContinuationOptions continuationOptions);
+        public Task<TNewResult> ContinueWith<TNewResult>(Func<Task<TResult>, object, TNewResult> continuationFunction, object state, TaskScheduler scheduler);
+        public Task<TNewResult> ContinueWith<TNewResult>(Func<Task<TResult>, TNewResult> continuationFunction);
+        public Task<TNewResult> ContinueWith<TNewResult>(Func<Task<TResult>, TNewResult> continuationFunction, CancellationToken cancellationToken);
+        public Task<TNewResult> ContinueWith<TNewResult>(Func<Task<TResult>, TNewResult> continuationFunction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
+        public Task<TNewResult> ContinueWith<TNewResult>(Func<Task<TResult>, TNewResult> continuationFunction, TaskContinuationOptions continuationOptions);
+        public Task<TNewResult> ContinueWith<TNewResult>(Func<Task<TResult>, TNewResult> continuationFunction, TaskScheduler scheduler);
+        public new TaskAwaiter<TResult> GetAwaiter();
+    }
+    public class TaskCanceledException : OperationCanceledException {
+        public TaskCanceledException();
+        public TaskCanceledException(string message);
+        public TaskCanceledException(string message, Exception innerException);
+        public TaskCanceledException(Task task);
+        public Task Task { get; }
+    }
+    public class TaskCompletionSource<TResult> {
+        public TaskCompletionSource();
+        public TaskCompletionSource(object state);
+        public TaskCompletionSource(object state, TaskCreationOptions creationOptions);
+        public TaskCompletionSource(TaskCreationOptions creationOptions);
+        public Task<TResult> Task { get; }
+        public void SetCanceled();
+        public void SetException(IEnumerable<Exception> exceptions);
+        public void SetException(Exception exception);
+        public void SetResult(TResult result);
+        public bool TrySetCanceled();
+        public bool TrySetCanceled(CancellationToken cancellationToken);
+        public bool TrySetException(IEnumerable<Exception> exceptions);
+        public bool TrySetException(Exception exception);
+        public bool TrySetResult(TResult result);
+    }
+    public enum TaskContinuationOptions {
+        AttachedToParent = 4,
+        DenyChildAttach = 8,
+        ExecuteSynchronously = 524288,
+        HideScheduler = 16,
+        LazyCancellation = 32,
+        LongRunning = 2,
+        None = 0,
+        NotOnCanceled = 262144,
+        NotOnFaulted = 131072,
+        NotOnRanToCompletion = 65536,
+        OnlyOnCanceled = 196608,
+        OnlyOnFaulted = 327680,
+        OnlyOnRanToCompletion = 393216,
+        PreferFairness = 1,
+        RunContinuationsAsynchronously = 64,
+    }
+    public enum TaskCreationOptions {
+        AttachedToParent = 4,
+        DenyChildAttach = 8,
+        HideScheduler = 16,
+        LongRunning = 2,
+        None = 0,
+        PreferFairness = 1,
+        RunContinuationsAsynchronously = 64,
+    }
+    public static class TaskExtensions {
+        public static Task Unwrap(this Task<Task> task);
+        public static Task<TResult> Unwrap<TResult>(this Task<Task<TResult>> task);
+    }
+    public class TaskFactory {
+        public TaskFactory();
+        public TaskFactory(CancellationToken cancellationToken);
+        public TaskFactory(CancellationToken cancellationToken, TaskCreationOptions creationOptions, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
+        public TaskFactory(TaskCreationOptions creationOptions, TaskContinuationOptions continuationOptions);
+        public TaskFactory(TaskScheduler scheduler);
+        public CancellationToken CancellationToken { get; }
+        public TaskContinuationOptions ContinuationOptions { get; }
+        public TaskCreationOptions CreationOptions { get; }
+        public TaskScheduler Scheduler { get; }
+        public Task ContinueWhenAll(Task[] tasks, Action<Task[]> continuationAction);
+        public Task ContinueWhenAll(Task[] tasks, Action<Task[]> continuationAction, CancellationToken cancellationToken);
+        public Task ContinueWhenAll(Task[] tasks, Action<Task[]> continuationAction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
+        public Task ContinueWhenAll(Task[] tasks, Action<Task[]> continuationAction, TaskContinuationOptions continuationOptions);
+        public Task<TResult> ContinueWhenAll<TAntecedentResult, TResult>(Task<TAntecedentResult>[] tasks, Func<Task<TAntecedentResult>[], TResult> continuationFunction);
+        public Task<TResult> ContinueWhenAll<TAntecedentResult, TResult>(Task<TAntecedentResult>[] tasks, Func<Task<TAntecedentResult>[], TResult> continuationFunction, CancellationToken cancellationToken);
+        public Task<TResult> ContinueWhenAll<TAntecedentResult, TResult>(Task<TAntecedentResult>[] tasks, Func<Task<TAntecedentResult>[], TResult> continuationFunction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
+        public Task<TResult> ContinueWhenAll<TAntecedentResult, TResult>(Task<TAntecedentResult>[] tasks, Func<Task<TAntecedentResult>[], TResult> continuationFunction, TaskContinuationOptions continuationOptions);
+        public Task ContinueWhenAll<TAntecedentResult>(Task<TAntecedentResult>[] tasks, Action<Task<TAntecedentResult>[]> continuationAction);
+        public Task ContinueWhenAll<TAntecedentResult>(Task<TAntecedentResult>[] tasks, Action<Task<TAntecedentResult>[]> continuationAction, CancellationToken cancellationToken);
+        public Task ContinueWhenAll<TAntecedentResult>(Task<TAntecedentResult>[] tasks, Action<Task<TAntecedentResult>[]> continuationAction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
+        public Task ContinueWhenAll<TAntecedentResult>(Task<TAntecedentResult>[] tasks, Action<Task<TAntecedentResult>[]> continuationAction, TaskContinuationOptions continuationOptions);
+        public Task<TResult> ContinueWhenAll<TResult>(Task[] tasks, Func<Task[], TResult> continuationFunction);
+        public Task<TResult> ContinueWhenAll<TResult>(Task[] tasks, Func<Task[], TResult> continuationFunction, CancellationToken cancellationToken);
+        public Task<TResult> ContinueWhenAll<TResult>(Task[] tasks, Func<Task[], TResult> continuationFunction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
+        public Task<TResult> ContinueWhenAll<TResult>(Task[] tasks, Func<Task[], TResult> continuationFunction, TaskContinuationOptions continuationOptions);
+        public Task ContinueWhenAny(Task[] tasks, Action<Task> continuationAction);
+        public Task ContinueWhenAny(Task[] tasks, Action<Task> continuationAction, CancellationToken cancellationToken);
+        public Task ContinueWhenAny(Task[] tasks, Action<Task> continuationAction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
+        public Task ContinueWhenAny(Task[] tasks, Action<Task> continuationAction, TaskContinuationOptions continuationOptions);
+        public Task<TResult> ContinueWhenAny<TAntecedentResult, TResult>(Task<TAntecedentResult>[] tasks, Func<Task<TAntecedentResult>, TResult> continuationFunction);
+        public Task<TResult> ContinueWhenAny<TAntecedentResult, TResult>(Task<TAntecedentResult>[] tasks, Func<Task<TAntecedentResult>, TResult> continuationFunction, CancellationToken cancellationToken);
+        public Task<TResult> ContinueWhenAny<TAntecedentResult, TResult>(Task<TAntecedentResult>[] tasks, Func<Task<TAntecedentResult>, TResult> continuationFunction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
+        public Task<TResult> ContinueWhenAny<TAntecedentResult, TResult>(Task<TAntecedentResult>[] tasks, Func<Task<TAntecedentResult>, TResult> continuationFunction, TaskContinuationOptions continuationOptions);
+        public Task ContinueWhenAny<TAntecedentResult>(Task<TAntecedentResult>[] tasks, Action<Task<TAntecedentResult>> continuationAction);
+        public Task ContinueWhenAny<TAntecedentResult>(Task<TAntecedentResult>[] tasks, Action<Task<TAntecedentResult>> continuationAction, CancellationToken cancellationToken);
+        public Task ContinueWhenAny<TAntecedentResult>(Task<TAntecedentResult>[] tasks, Action<Task<TAntecedentResult>> continuationAction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
+        public Task ContinueWhenAny<TAntecedentResult>(Task<TAntecedentResult>[] tasks, Action<Task<TAntecedentResult>> continuationAction, TaskContinuationOptions continuationOptions);
+        public Task<TResult> ContinueWhenAny<TResult>(Task[] tasks, Func<Task, TResult> continuationFunction);
+        public Task<TResult> ContinueWhenAny<TResult>(Task[] tasks, Func<Task, TResult> continuationFunction, CancellationToken cancellationToken);
+        public Task<TResult> ContinueWhenAny<TResult>(Task[] tasks, Func<Task, TResult> continuationFunction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
+        public Task<TResult> ContinueWhenAny<TResult>(Task[] tasks, Func<Task, TResult> continuationFunction, TaskContinuationOptions continuationOptions);
+        public Task FromAsync(Func<AsyncCallback, object, IAsyncResult> beginMethod, Action<IAsyncResult> endMethod, object state);
+        public Task FromAsync(Func<AsyncCallback, object, IAsyncResult> beginMethod, Action<IAsyncResult> endMethod, object state, TaskCreationOptions creationOptions);
+        public Task FromAsync(IAsyncResult asyncResult, Action<IAsyncResult> endMethod);
+        public Task FromAsync(IAsyncResult asyncResult, Action<IAsyncResult> endMethod, TaskCreationOptions creationOptions);
+        public Task FromAsync(IAsyncResult asyncResult, Action<IAsyncResult> endMethod, TaskCreationOptions creationOptions, TaskScheduler scheduler);
+        public Task<TResult> FromAsync<TArg1, TArg2, TArg3, TResult>(Func<TArg1, TArg2, TArg3, AsyncCallback, object, IAsyncResult> beginMethod, Func<IAsyncResult, TResult> endMethod, TArg1 arg1, TArg2 arg2, TArg3 arg3, object state);
+        public Task<TResult> FromAsync<TArg1, TArg2, TArg3, TResult>(Func<TArg1, TArg2, TArg3, AsyncCallback, object, IAsyncResult> beginMethod, Func<IAsyncResult, TResult> endMethod, TArg1 arg1, TArg2 arg2, TArg3 arg3, object state, TaskCreationOptions creationOptions);
+        public Task FromAsync<TArg1, TArg2, TArg3>(Func<TArg1, TArg2, TArg3, AsyncCallback, object, IAsyncResult> beginMethod, Action<IAsyncResult> endMethod, TArg1 arg1, TArg2 arg2, TArg3 arg3, object state);
+        public Task FromAsync<TArg1, TArg2, TArg3>(Func<TArg1, TArg2, TArg3, AsyncCallback, object, IAsyncResult> beginMethod, Action<IAsyncResult> endMethod, TArg1 arg1, TArg2 arg2, TArg3 arg3, object state, TaskCreationOptions creationOptions);
+        public Task<TResult> FromAsync<TArg1, TArg2, TResult>(Func<TArg1, TArg2, AsyncCallback, object, IAsyncResult> beginMethod, Func<IAsyncResult, TResult> endMethod, TArg1 arg1, TArg2 arg2, object state);
+        public Task<TResult> FromAsync<TArg1, TArg2, TResult>(Func<TArg1, TArg2, AsyncCallback, object, IAsyncResult> beginMethod, Func<IAsyncResult, TResult> endMethod, TArg1 arg1, TArg2 arg2, object state, TaskCreationOptions creationOptions);
+        public Task FromAsync<TArg1, TArg2>(Func<TArg1, TArg2, AsyncCallback, object, IAsyncResult> beginMethod, Action<IAsyncResult> endMethod, TArg1 arg1, TArg2 arg2, object state);
+        public Task FromAsync<TArg1, TArg2>(Func<TArg1, TArg2, AsyncCallback, object, IAsyncResult> beginMethod, Action<IAsyncResult> endMethod, TArg1 arg1, TArg2 arg2, object state, TaskCreationOptions creationOptions);
+        public Task<TResult> FromAsync<TArg1, TResult>(Func<TArg1, AsyncCallback, object, IAsyncResult> beginMethod, Func<IAsyncResult, TResult> endMethod, TArg1 arg1, object state);
+        public Task<TResult> FromAsync<TArg1, TResult>(Func<TArg1, AsyncCallback, object, IAsyncResult> beginMethod, Func<IAsyncResult, TResult> endMethod, TArg1 arg1, object state, TaskCreationOptions creationOptions);
+        public Task FromAsync<TArg1>(Func<TArg1, AsyncCallback, object, IAsyncResult> beginMethod, Action<IAsyncResult> endMethod, TArg1 arg1, object state);
+        public Task FromAsync<TArg1>(Func<TArg1, AsyncCallback, object, IAsyncResult> beginMethod, Action<IAsyncResult> endMethod, TArg1 arg1, object state, TaskCreationOptions creationOptions);
+        public Task<TResult> FromAsync<TResult>(Func<AsyncCallback, object, IAsyncResult> beginMethod, Func<IAsyncResult, TResult> endMethod, object state);
+        public Task<TResult> FromAsync<TResult>(Func<AsyncCallback, object, IAsyncResult> beginMethod, Func<IAsyncResult, TResult> endMethod, object state, TaskCreationOptions creationOptions);
+        public Task<TResult> FromAsync<TResult>(IAsyncResult asyncResult, Func<IAsyncResult, TResult> endMethod);
+        public Task<TResult> FromAsync<TResult>(IAsyncResult asyncResult, Func<IAsyncResult, TResult> endMethod, TaskCreationOptions creationOptions);
+        public Task<TResult> FromAsync<TResult>(IAsyncResult asyncResult, Func<IAsyncResult, TResult> endMethod, TaskCreationOptions creationOptions, TaskScheduler scheduler);
+        public Task StartNew(Action action);
+        public Task StartNew(Action action, CancellationToken cancellationToken);
+        public Task StartNew(Action action, CancellationToken cancellationToken, TaskCreationOptions creationOptions, TaskScheduler scheduler);
+        public Task StartNew(Action action, TaskCreationOptions creationOptions);
+        public Task StartNew(Action<object> action, object state);
+        public Task StartNew(Action<object> action, object state, CancellationToken cancellationToken);
+        public Task StartNew(Action<object> action, object state, CancellationToken cancellationToken, TaskCreationOptions creationOptions, TaskScheduler scheduler);
+        public Task StartNew(Action<object> action, object state, TaskCreationOptions creationOptions);
+        public Task<TResult> StartNew<TResult>(Func<object, TResult> function, object state);
+        public Task<TResult> StartNew<TResult>(Func<object, TResult> function, object state, CancellationToken cancellationToken);
+        public Task<TResult> StartNew<TResult>(Func<object, TResult> function, object state, CancellationToken cancellationToken, TaskCreationOptions creationOptions, TaskScheduler scheduler);
+        public Task<TResult> StartNew<TResult>(Func<object, TResult> function, object state, TaskCreationOptions creationOptions);
+        public Task<TResult> StartNew<TResult>(Func<TResult> function);
+        public Task<TResult> StartNew<TResult>(Func<TResult> function, CancellationToken cancellationToken);
+        public Task<TResult> StartNew<TResult>(Func<TResult> function, CancellationToken cancellationToken, TaskCreationOptions creationOptions, TaskScheduler scheduler);
+        public Task<TResult> StartNew<TResult>(Func<TResult> function, TaskCreationOptions creationOptions);
+    }
+    public class TaskFactory<TResult> {
+        public TaskFactory();
+        public TaskFactory(CancellationToken cancellationToken);
+        public TaskFactory(CancellationToken cancellationToken, TaskCreationOptions creationOptions, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
+        public TaskFactory(TaskCreationOptions creationOptions, TaskContinuationOptions continuationOptions);
+        public TaskFactory(TaskScheduler scheduler);
+        public CancellationToken CancellationToken { get; }
+        public TaskContinuationOptions ContinuationOptions { get; }
+        public TaskCreationOptions CreationOptions { get; }
+        public TaskScheduler Scheduler { get; }
+        public Task<TResult> ContinueWhenAll(Task[] tasks, Func<Task[], TResult> continuationFunction);
+        public Task<TResult> ContinueWhenAll(Task[] tasks, Func<Task[], TResult> continuationFunction, CancellationToken cancellationToken);
+        public Task<TResult> ContinueWhenAll(Task[] tasks, Func<Task[], TResult> continuationFunction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
+        public Task<TResult> ContinueWhenAll(Task[] tasks, Func<Task[], TResult> continuationFunction, TaskContinuationOptions continuationOptions);
+        public Task<TResult> ContinueWhenAll<TAntecedentResult>(Task<TAntecedentResult>[] tasks, Func<Task<TAntecedentResult>[], TResult> continuationFunction);
+        public Task<TResult> ContinueWhenAll<TAntecedentResult>(Task<TAntecedentResult>[] tasks, Func<Task<TAntecedentResult>[], TResult> continuationFunction, CancellationToken cancellationToken);
+        public Task<TResult> ContinueWhenAll<TAntecedentResult>(Task<TAntecedentResult>[] tasks, Func<Task<TAntecedentResult>[], TResult> continuationFunction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
+        public Task<TResult> ContinueWhenAll<TAntecedentResult>(Task<TAntecedentResult>[] tasks, Func<Task<TAntecedentResult>[], TResult> continuationFunction, TaskContinuationOptions continuationOptions);
+        public Task<TResult> ContinueWhenAny(Task[] tasks, Func<Task, TResult> continuationFunction);
+        public Task<TResult> ContinueWhenAny(Task[] tasks, Func<Task, TResult> continuationFunction, CancellationToken cancellationToken);
+        public Task<TResult> ContinueWhenAny(Task[] tasks, Func<Task, TResult> continuationFunction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
+        public Task<TResult> ContinueWhenAny(Task[] tasks, Func<Task, TResult> continuationFunction, TaskContinuationOptions continuationOptions);
+        public Task<TResult> ContinueWhenAny<TAntecedentResult>(Task<TAntecedentResult>[] tasks, Func<Task<TAntecedentResult>, TResult> continuationFunction);
+        public Task<TResult> ContinueWhenAny<TAntecedentResult>(Task<TAntecedentResult>[] tasks, Func<Task<TAntecedentResult>, TResult> continuationFunction, CancellationToken cancellationToken);
+        public Task<TResult> ContinueWhenAny<TAntecedentResult>(Task<TAntecedentResult>[] tasks, Func<Task<TAntecedentResult>, TResult> continuationFunction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
+        public Task<TResult> ContinueWhenAny<TAntecedentResult>(Task<TAntecedentResult>[] tasks, Func<Task<TAntecedentResult>, TResult> continuationFunction, TaskContinuationOptions continuationOptions);
+        public Task<TResult> FromAsync(Func<AsyncCallback, object, IAsyncResult> beginMethod, Func<IAsyncResult, TResult> endMethod, object state);
+        public Task<TResult> FromAsync(Func<AsyncCallback, object, IAsyncResult> beginMethod, Func<IAsyncResult, TResult> endMethod, object state, TaskCreationOptions creationOptions);
+        public Task<TResult> FromAsync(IAsyncResult asyncResult, Func<IAsyncResult, TResult> endMethod);
+        public Task<TResult> FromAsync(IAsyncResult asyncResult, Func<IAsyncResult, TResult> endMethod, TaskCreationOptions creationOptions);
+        public Task<TResult> FromAsync(IAsyncResult asyncResult, Func<IAsyncResult, TResult> endMethod, TaskCreationOptions creationOptions, TaskScheduler scheduler);
+        public Task<TResult> FromAsync<TArg1, TArg2, TArg3>(Func<TArg1, TArg2, TArg3, AsyncCallback, object, IAsyncResult> beginMethod, Func<IAsyncResult, TResult> endMethod, TArg1 arg1, TArg2 arg2, TArg3 arg3, object state);
+        public Task<TResult> FromAsync<TArg1, TArg2, TArg3>(Func<TArg1, TArg2, TArg3, AsyncCallback, object, IAsyncResult> beginMethod, Func<IAsyncResult, TResult> endMethod, TArg1 arg1, TArg2 arg2, TArg3 arg3, object state, TaskCreationOptions creationOptions);
+        public Task<TResult> FromAsync<TArg1, TArg2>(Func<TArg1, TArg2, AsyncCallback, object, IAsyncResult> beginMethod, Func<IAsyncResult, TResult> endMethod, TArg1 arg1, TArg2 arg2, object state);
+        public Task<TResult> FromAsync<TArg1, TArg2>(Func<TArg1, TArg2, AsyncCallback, object, IAsyncResult> beginMethod, Func<IAsyncResult, TResult> endMethod, TArg1 arg1, TArg2 arg2, object state, TaskCreationOptions creationOptions);
+        public Task<TResult> FromAsync<TArg1>(Func<TArg1, AsyncCallback, object, IAsyncResult> beginMethod, Func<IAsyncResult, TResult> endMethod, TArg1 arg1, object state);
+        public Task<TResult> FromAsync<TArg1>(Func<TArg1, AsyncCallback, object, IAsyncResult> beginMethod, Func<IAsyncResult, TResult> endMethod, TArg1 arg1, object state, TaskCreationOptions creationOptions);
+        public Task<TResult> StartNew(Func<object, TResult> function, object state);
+        public Task<TResult> StartNew(Func<object, TResult> function, object state, CancellationToken cancellationToken);
+        public Task<TResult> StartNew(Func<object, TResult> function, object state, CancellationToken cancellationToken, TaskCreationOptions creationOptions, TaskScheduler scheduler);
+        public Task<TResult> StartNew(Func<object, TResult> function, object state, TaskCreationOptions creationOptions);
+        public Task<TResult> StartNew(Func<TResult> function);
+        public Task<TResult> StartNew(Func<TResult> function, CancellationToken cancellationToken);
+        public Task<TResult> StartNew(Func<TResult> function, CancellationToken cancellationToken, TaskCreationOptions creationOptions, TaskScheduler scheduler);
+        public Task<TResult> StartNew(Func<TResult> function, TaskCreationOptions creationOptions);
+    }
+    public abstract class TaskScheduler {
+        protected TaskScheduler();
+        public static TaskScheduler Current { get; }
+        public static TaskScheduler Default { get; }
+        public int Id { get; }
+        public virtual int MaximumConcurrencyLevel { get; }
+        public static event EventHandler<UnobservedTaskExceptionEventArgs> UnobservedTaskException;
+        public static TaskScheduler FromCurrentSynchronizationContext();
+        protected abstract IEnumerable<Task> GetScheduledTasks();
+        protected internal abstract void QueueTask(Task task);
+        protected internal virtual bool TryDequeue(Task task);
+        protected bool TryExecuteTask(Task task);
+        protected abstract bool TryExecuteTaskInline(Task task, bool taskWasPreviouslyQueued);
+    }
+    public class TaskSchedulerException : Exception {
+        public TaskSchedulerException();
+        public TaskSchedulerException(Exception innerException);
+        public TaskSchedulerException(string message);
+        public TaskSchedulerException(string message, Exception innerException);
+    }
+    public enum TaskStatus {
+        Canceled = 6,
+        Created = 0,
+        Faulted = 7,
+        RanToCompletion = 5,
+        Running = 3,
+        WaitingForActivation = 1,
+        WaitingForChildrenToComplete = 4,
+        WaitingToRun = 2,
+    }
+    public class UnobservedTaskExceptionEventArgs : EventArgs {
+        public UnobservedTaskExceptionEventArgs(AggregateException exception);
+        public AggregateException Exception { get; }
+        public bool Observed { get; }
+        public void SetObserved();
+    }
+    public struct ValueTask<TResult> : IEquatable<ValueTask<TResult>> {
+        public ValueTask(Task<TResult> task);
+        public ValueTask(TResult result);
+        public bool IsCanceled { get; }
+        public bool IsCompleted { get; }
+        public bool IsCompletedSuccessfully { get; }
+        public bool IsFaulted { get; }
+        public TResult Result { get; }
+        public Task<TResult> AsTask();
+        public ConfiguredValueTaskAwaitable<TResult> ConfigureAwait(bool continueOnCapturedContext);
+        public override bool Equals(object obj);
+        public bool Equals(ValueTask<TResult> other);
+        public ValueTaskAwaiter<TResult> GetAwaiter();
+        public override int GetHashCode();
+        public static bool operator ==(ValueTask<TResult> left, ValueTask<TResult> right);
+        public static bool operator !=(ValueTask<TResult> left, ValueTask<TResult> right);
+        public override string ToString();
+    }
+}
```

## System.Threading.Tasks.Dataflow

```c#
+namespace System.Threading.Tasks.Dataflow {
+    public sealed class ActionBlock<TInput> : IDataflowBlock, IDebuggerDisplay, ITargetBlock<TInput> {
+        public ActionBlock(Action<TInput> action);
+        public ActionBlock(Action<TInput> action, ExecutionDataflowBlockOptions dataflowBlockOptions);
+        public ActionBlock(Func<TInput, Task> action);
+        public ActionBlock(Func<TInput, Task> action, ExecutionDataflowBlockOptions dataflowBlockOptions);
+        public Task Completion { get; }
+        public int InputCount { get; }
+        public void Complete();
+        [MethodImpl(AggressiveInlining)]public bool Post(TInput item);
+        void System.Threading.Tasks.Dataflow.IDataflowBlock.Fault(Exception exception);
+        DataflowMessageStatus System.Threading.Tasks.Dataflow.ITargetBlock<TInput>.OfferMessage(DataflowMessageHeader messageHeader, TInput messageValue, ISourceBlock<TInput> source, bool consumeToAccept);
+        public override string ToString();
+    }
+    public sealed class BatchBlock<T> : IDataflowBlock, IDebuggerDisplay, IPropagatorBlock<T, T[]>, IReceivableSourceBlock<T[]>, ISourceBlock<T[]>, ITargetBlock<T> {
+        public BatchBlock(int batchSize);
+        public BatchBlock(int batchSize, GroupingDataflowBlockOptions dataflowBlockOptions);
+        public int BatchSize { get; }
+        public Task Completion { get; }
+        public int OutputCount { get; }
+        public void Complete();
+        public IDisposable LinkTo(ITargetBlock<T[]> target, DataflowLinkOptions linkOptions);
+        void System.Threading.Tasks.Dataflow.IDataflowBlock.Fault(Exception exception);
+        T[] System.Threading.Tasks.Dataflow.ISourceBlock<T[]>.ConsumeMessage(DataflowMessageHeader messageHeader, ITargetBlock<T[]> target, out bool messageConsumed);
+        void System.Threading.Tasks.Dataflow.ISourceBlock<T[]>.ReleaseReservation(DataflowMessageHeader messageHeader, ITargetBlock<T[]> target);
+        bool System.Threading.Tasks.Dataflow.ISourceBlock<T[]>.ReserveMessage(DataflowMessageHeader messageHeader, ITargetBlock<T[]> target);
+        DataflowMessageStatus System.Threading.Tasks.Dataflow.ITargetBlock<T>.OfferMessage(DataflowMessageHeader messageHeader, T messageValue, ISourceBlock<T> source, bool consumeToAccept);
+        public override string ToString();
+        public void TriggerBatch();
+        public bool TryReceive(Predicate<T[]> filter, out T[] item);
+        public bool TryReceiveAll(out IList<T[]> items);
+    }
+    public sealed class BatchedJoinBlock<T1, T2> : IDataflowBlock, IDebuggerDisplay, IReceivableSourceBlock<Tuple<IList<T1>, IList<T2>>>, ISourceBlock<Tuple<IList<T1>, IList<T2>>> {
+        public BatchedJoinBlock(int batchSize);
+        public BatchedJoinBlock(int batchSize, GroupingDataflowBlockOptions dataflowBlockOptions);
+        public int BatchSize { get; }
+        public Task Completion { get; }
+        public int OutputCount { get; }
+        public ITargetBlock<T1> Target1 { get; }
+        public ITargetBlock<T2> Target2 { get; }
+        public void Complete();
+        public IDisposable LinkTo(ITargetBlock<Tuple<IList<T1>, IList<T2>>> target, DataflowLinkOptions linkOptions);
+        void System.Threading.Tasks.Dataflow.IDataflowBlock.Fault(Exception exception);
+        Tuple<IList<T1>, IList<T2>> System.Threading.Tasks.Dataflow.ISourceBlock<System.Tuple<System.Collections.Generic.IList<T1>,System.Collections.Generic.IList<T2>>>.ConsumeMessage(DataflowMessageHeader messageHeader, ITargetBlock<Tuple<IList<T1>, IList<T2>>> target, out bool messageConsumed);
+        void System.Threading.Tasks.Dataflow.ISourceBlock<System.Tuple<System.Collections.Generic.IList<T1>,System.Collections.Generic.IList<T2>>>.ReleaseReservation(DataflowMessageHeader messageHeader, ITargetBlock<Tuple<IList<T1>, IList<T2>>> target);
+        bool System.Threading.Tasks.Dataflow.ISourceBlock<System.Tuple<System.Collections.Generic.IList<T1>,System.Collections.Generic.IList<T2>>>.ReserveMessage(DataflowMessageHeader messageHeader, ITargetBlock<Tuple<IList<T1>, IList<T2>>> target);
+        public override string ToString();
+        public bool TryReceive(Predicate<Tuple<IList<T1>, IList<T2>>> filter, out Tuple<IList<T1>, IList<T2>> item);
+        public bool TryReceiveAll(out IList<Tuple<IList<T1>, IList<T2>>> items);
+    }
+    public sealed class BatchedJoinBlock<T1, T2, T3> : IDataflowBlock, IDebuggerDisplay, IReceivableSourceBlock<Tuple<IList<T1>, IList<T2>, IList<T3>>>, ISourceBlock<Tuple<IList<T1>, IList<T2>, IList<T3>>> {
+        public BatchedJoinBlock(int batchSize);
+        public BatchedJoinBlock(int batchSize, GroupingDataflowBlockOptions dataflowBlockOptions);
+        public int BatchSize { get; }
+        public Task Completion { get; }
+        public int OutputCount { get; }
+        public ITargetBlock<T1> Target1 { get; }
+        public ITargetBlock<T2> Target2 { get; }
+        public ITargetBlock<T3> Target3 { get; }
+        public void Complete();
+        public IDisposable LinkTo(ITargetBlock<Tuple<IList<T1>, IList<T2>, IList<T3>>> target, DataflowLinkOptions linkOptions);
+        void System.Threading.Tasks.Dataflow.IDataflowBlock.Fault(Exception exception);
+        Tuple<IList<T1>, IList<T2>, IList<T3>> System.Threading.Tasks.Dataflow.ISourceBlock<System.Tuple<System.Collections.Generic.IList<T1>,System.Collections.Generic.IList<T2>,System.Collections.Generic.IList<T3>>>.ConsumeMessage(DataflowMessageHeader messageHeader, ITargetBlock<Tuple<IList<T1>, IList<T2>, IList<T3>>> target, out bool messageConsumed);
+        void System.Threading.Tasks.Dataflow.ISourceBlock<System.Tuple<System.Collections.Generic.IList<T1>,System.Collections.Generic.IList<T2>,System.Collections.Generic.IList<T3>>>.ReleaseReservation(DataflowMessageHeader messageHeader, ITargetBlock<Tuple<IList<T1>, IList<T2>, IList<T3>>> target);
+        bool System.Threading.Tasks.Dataflow.ISourceBlock<System.Tuple<System.Collections.Generic.IList<T1>,System.Collections.Generic.IList<T2>,System.Collections.Generic.IList<T3>>>.ReserveMessage(DataflowMessageHeader messageHeader, ITargetBlock<Tuple<IList<T1>, IList<T2>, IList<T3>>> target);
+        public override string ToString();
+        public bool TryReceive(Predicate<Tuple<IList<T1>, IList<T2>, IList<T3>>> filter, out Tuple<IList<T1>, IList<T2>, IList<T3>> item);
+        public bool TryReceiveAll(out IList<Tuple<IList<T1>, IList<T2>, IList<T3>>> items);
+    }
+    public sealed class BroadcastBlock<T> : IDataflowBlock, IDebuggerDisplay, IPropagatorBlock<T, T>, IReceivableSourceBlock<T>, ISourceBlock<T>, ITargetBlock<T> {
+        public BroadcastBlock(Func<T, T> cloningFunction);
+        public BroadcastBlock(Func<T, T> cloningFunction, DataflowBlockOptions dataflowBlockOptions);
+        public Task Completion { get; }
+        public void Complete();
+        public IDisposable LinkTo(ITargetBlock<T> target, DataflowLinkOptions linkOptions);
+        void System.Threading.Tasks.Dataflow.IDataflowBlock.Fault(Exception exception);
+        bool System.Threading.Tasks.Dataflow.IReceivableSourceBlock<T>.TryReceiveAll(out IList<T> items);
+        T System.Threading.Tasks.Dataflow.ISourceBlock<T>.ConsumeMessage(DataflowMessageHeader messageHeader, ITargetBlock<T> target, out bool messageConsumed);
+        void System.Threading.Tasks.Dataflow.ISourceBlock<T>.ReleaseReservation(DataflowMessageHeader messageHeader, ITargetBlock<T> target);
+        bool System.Threading.Tasks.Dataflow.ISourceBlock<T>.ReserveMessage(DataflowMessageHeader messageHeader, ITargetBlock<T> target);
+        DataflowMessageStatus System.Threading.Tasks.Dataflow.ITargetBlock<T>.OfferMessage(DataflowMessageHeader messageHeader, T messageValue, ISourceBlock<T> source, bool consumeToAccept);
+        public override string ToString();
+        public bool TryReceive(Predicate<T> filter, out T item);
+    }
+    public sealed class BufferBlock<T> : IDataflowBlock, IDebuggerDisplay, IPropagatorBlock<T, T>, IReceivableSourceBlock<T>, ISourceBlock<T>, ITargetBlock<T> {
+        public BufferBlock();
+        public BufferBlock(DataflowBlockOptions dataflowBlockOptions);
+        public Task Completion { get; }
+        public int Count { get; }
+        public void Complete();
+        public IDisposable LinkTo(ITargetBlock<T> target, DataflowLinkOptions linkOptions);
+        void System.Threading.Tasks.Dataflow.IDataflowBlock.Fault(Exception exception);
+        T System.Threading.Tasks.Dataflow.ISourceBlock<T>.ConsumeMessage(DataflowMessageHeader messageHeader, ITargetBlock<T> target, out bool messageConsumed);
+        void System.Threading.Tasks.Dataflow.ISourceBlock<T>.ReleaseReservation(DataflowMessageHeader messageHeader, ITargetBlock<T> target);
+        bool System.Threading.Tasks.Dataflow.ISourceBlock<T>.ReserveMessage(DataflowMessageHeader messageHeader, ITargetBlock<T> target);
+        DataflowMessageStatus System.Threading.Tasks.Dataflow.ITargetBlock<T>.OfferMessage(DataflowMessageHeader messageHeader, T messageValue, ISourceBlock<T> source, bool consumeToAccept);
+        public override string ToString();
+        public bool TryReceive(Predicate<T> filter, out T item);
+        public bool TryReceiveAll(out IList<T> items);
+    }
+    public static class DataflowBlock {
+        public static IObservable<TOutput> AsObservable<TOutput>(this ISourceBlock<TOutput> source);
+        public static IObserver<TInput> AsObserver<TInput>(this ITargetBlock<TInput> target);
+        public static Task<int> Choose<T1, T2, T3>(ISourceBlock<T1> source1, Action<T1> action1, ISourceBlock<T2> source2, Action<T2> action2, ISourceBlock<T3> source3, Action<T3> action3);
+        public static Task<int> Choose<T1, T2, T3>(ISourceBlock<T1> source1, Action<T1> action1, ISourceBlock<T2> source2, Action<T2> action2, ISourceBlock<T3> source3, Action<T3> action3, DataflowBlockOptions dataflowBlockOptions);
+        public static Task<int> Choose<T1, T2>(ISourceBlock<T1> source1, Action<T1> action1, ISourceBlock<T2> source2, Action<T2> action2);
+        public static Task<int> Choose<T1, T2>(ISourceBlock<T1> source1, Action<T1> action1, ISourceBlock<T2> source2, Action<T2> action2, DataflowBlockOptions dataflowBlockOptions);
+        public static IPropagatorBlock<TInput, TOutput> Encapsulate<TInput, TOutput>(ITargetBlock<TInput> target, ISourceBlock<TOutput> source);
+        public static IDisposable LinkTo<TOutput>(this ISourceBlock<TOutput> source, ITargetBlock<TOutput> target);
+        public static IDisposable LinkTo<TOutput>(this ISourceBlock<TOutput> source, ITargetBlock<TOutput> target, Predicate<TOutput> predicate);
+        public static IDisposable LinkTo<TOutput>(this ISourceBlock<TOutput> source, ITargetBlock<TOutput> target, DataflowLinkOptions linkOptions, Predicate<TOutput> predicate);
+        public static ITargetBlock<TInput> NullTarget<TInput>();
+        public static Task<bool> OutputAvailableAsync<TOutput>(this ISourceBlock<TOutput> source);
+        public static Task<bool> OutputAvailableAsync<TOutput>(this ISourceBlock<TOutput> source, CancellationToken cancellationToken);
+        public static bool Post<TInput>(this ITargetBlock<TInput> target, TInput item);
+        public static TOutput Receive<TOutput>(this ISourceBlock<TOutput> source);
+        public static TOutput Receive<TOutput>(this ISourceBlock<TOutput> source, CancellationToken cancellationToken);
+        public static TOutput Receive<TOutput>(this ISourceBlock<TOutput> source, TimeSpan timeout);
+        public static TOutput Receive<TOutput>(this ISourceBlock<TOutput> source, TimeSpan timeout, CancellationToken cancellationToken);
+        public static Task<TOutput> ReceiveAsync<TOutput>(this ISourceBlock<TOutput> source);
+        public static Task<TOutput> ReceiveAsync<TOutput>(this ISourceBlock<TOutput> source, CancellationToken cancellationToken);
+        public static Task<TOutput> ReceiveAsync<TOutput>(this ISourceBlock<TOutput> source, TimeSpan timeout);
+        public static Task<TOutput> ReceiveAsync<TOutput>(this ISourceBlock<TOutput> source, TimeSpan timeout, CancellationToken cancellationToken);
+        public static Task<bool> SendAsync<TInput>(this ITargetBlock<TInput> target, TInput item);
+        public static Task<bool> SendAsync<TInput>(this ITargetBlock<TInput> target, TInput item, CancellationToken cancellationToken);
+        public static bool TryReceive<TOutput>(this IReceivableSourceBlock<TOutput> source, out TOutput item);
+    }
+    public class DataflowBlockOptions {
+        public const int Unbounded = -1;
+        public DataflowBlockOptions();
+        public int BoundedCapacity { get; set; }
+        public CancellationToken CancellationToken { get; set; }
+        public bool EnsureOrdered { get; set; }
+        public int MaxMessagesPerTask { get; set; }
+        public string NameFormat { get; set; }
+        public TaskScheduler TaskScheduler { get; set; }
+    }
+    public class DataflowLinkOptions {
+        public DataflowLinkOptions();
+        public bool Append { get; set; }
+        public int MaxMessages { get; set; }
+        public bool PropagateCompletion { get; set; }
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct DataflowMessageHeader : IEquatable<DataflowMessageHeader> {
+        public DataflowMessageHeader(long id);
+        public long Id { get; }
+        public bool IsValid { get; }
+        public override bool Equals(object obj);
+        public bool Equals(DataflowMessageHeader other);
+        public override int GetHashCode();
+        public static bool operator ==(DataflowMessageHeader left, DataflowMessageHeader right);
+        public static bool operator !=(DataflowMessageHeader left, DataflowMessageHeader right);
+    }
+    public enum DataflowMessageStatus {
+        Accepted = 0,
+        Declined = 1,
+        DecliningPermanently = 4,
+        NotAvailable = 3,
+        Postponed = 2,
+    }
+    public class ExecutionDataflowBlockOptions : DataflowBlockOptions {
+        public ExecutionDataflowBlockOptions();
+        public int MaxDegreeOfParallelism { get; set; }
+        public bool SingleProducerConstrained { get; set; }
+    }
+    public class GroupingDataflowBlockOptions : DataflowBlockOptions {
+        public GroupingDataflowBlockOptions();
+        public bool Greedy { get; set; }
+        public long MaxNumberOfGroups { get; set; }
+    }
+    public interface IDataflowBlock {
+        Task Completion { get; }
+        void Complete();
+        void Fault(Exception exception);
+    }
+    public interface IPropagatorBlock<in TInput, out TOutput> : IDataflowBlock, ISourceBlock<TOutput>, ITargetBlock<TInput>
+    public interface IReceivableSourceBlock<TOutput> : IDataflowBlock, ISourceBlock<TOutput> {
+        bool TryReceive(Predicate<TOutput> filter, out TOutput item);
+        bool TryReceiveAll(out IList<TOutput> items);
+    }
+    public interface ISourceBlock<out TOutput> : IDataflowBlock {
+        TOutput ConsumeMessage(DataflowMessageHeader messageHeader, ITargetBlock<TOutput> target, out bool messageConsumed);
+        IDisposable LinkTo(ITargetBlock<TOutput> target, DataflowLinkOptions linkOptions);
+        void ReleaseReservation(DataflowMessageHeader messageHeader, ITargetBlock<TOutput> target);
+        bool ReserveMessage(DataflowMessageHeader messageHeader, ITargetBlock<TOutput> target);
+    }
+    public interface ITargetBlock<in TInput> : IDataflowBlock {
+        DataflowMessageStatus OfferMessage(DataflowMessageHeader messageHeader, TInput messageValue, ISourceBlock<TInput> source, bool consumeToAccept);
+    }
+    public sealed class JoinBlock<T1, T2> : IDataflowBlock, IDebuggerDisplay, IReceivableSourceBlock<Tuple<T1, T2>>, ISourceBlock<Tuple<T1, T2>> {
+        public JoinBlock();
+        public JoinBlock(GroupingDataflowBlockOptions dataflowBlockOptions);
+        public Task Completion { get; }
+        public int OutputCount { get; }
+        public ITargetBlock<T1> Target1 { get; }
+        public ITargetBlock<T2> Target2 { get; }
+        public void Complete();
+        public IDisposable LinkTo(ITargetBlock<Tuple<T1, T2>> target, DataflowLinkOptions linkOptions);
+        void System.Threading.Tasks.Dataflow.IDataflowBlock.Fault(Exception exception);
+        Tuple<T1, T2> System.Threading.Tasks.Dataflow.ISourceBlock<System.Tuple<T1,T2>>.ConsumeMessage(DataflowMessageHeader messageHeader, ITargetBlock<Tuple<T1, T2>> target, out bool messageConsumed);
+        void System.Threading.Tasks.Dataflow.ISourceBlock<System.Tuple<T1,T2>>.ReleaseReservation(DataflowMessageHeader messageHeader, ITargetBlock<Tuple<T1, T2>> target);
+        bool System.Threading.Tasks.Dataflow.ISourceBlock<System.Tuple<T1,T2>>.ReserveMessage(DataflowMessageHeader messageHeader, ITargetBlock<Tuple<T1, T2>> target);
+        public override string ToString();
+        public bool TryReceive(Predicate<Tuple<T1, T2>> filter, out Tuple<T1, T2> item);
+        public bool TryReceiveAll(out IList<Tuple<T1, T2>> items);
+    }
+    public sealed class JoinBlock<T1, T2, T3> : IDataflowBlock, IDebuggerDisplay, IReceivableSourceBlock<Tuple<T1, T2, T3>>, ISourceBlock<Tuple<T1, T2, T3>> {
+        public JoinBlock();
+        public JoinBlock(GroupingDataflowBlockOptions dataflowBlockOptions);
+        public Task Completion { get; }
+        public int OutputCount { get; }
+        public ITargetBlock<T1> Target1 { get; }
+        public ITargetBlock<T2> Target2 { get; }
+        public ITargetBlock<T3> Target3 { get; }
+        public void Complete();
+        public IDisposable LinkTo(ITargetBlock<Tuple<T1, T2, T3>> target, DataflowLinkOptions linkOptions);
+        void System.Threading.Tasks.Dataflow.IDataflowBlock.Fault(Exception exception);
+        Tuple<T1, T2, T3> System.Threading.Tasks.Dataflow.ISourceBlock<System.Tuple<T1,T2,T3>>.ConsumeMessage(DataflowMessageHeader messageHeader, ITargetBlock<Tuple<T1, T2, T3>> target, out bool messageConsumed);
+        void System.Threading.Tasks.Dataflow.ISourceBlock<System.Tuple<T1,T2,T3>>.ReleaseReservation(DataflowMessageHeader messageHeader, ITargetBlock<Tuple<T1, T2, T3>> target);
+        bool System.Threading.Tasks.Dataflow.ISourceBlock<System.Tuple<T1,T2,T3>>.ReserveMessage(DataflowMessageHeader messageHeader, ITargetBlock<Tuple<T1, T2, T3>> target);
+        public override string ToString();
+        public bool TryReceive(Predicate<Tuple<T1, T2, T3>> filter, out Tuple<T1, T2, T3> item);
+        public bool TryReceiveAll(out IList<Tuple<T1, T2, T3>> items);
+    }
+    public sealed class TransformBlock<TInput, TOutput> : IDataflowBlock, IDebuggerDisplay, IPropagatorBlock<TInput, TOutput>, IReceivableSourceBlock<TOutput>, ISourceBlock<TOutput>, ITargetBlock<TInput> {
+        public TransformBlock(Func<TInput, Task<TOutput>> transform);
+        public TransformBlock(Func<TInput, Task<TOutput>> transform, ExecutionDataflowBlockOptions dataflowBlockOptions);
+        public TransformBlock(Func<TInput, TOutput> transform);
+        public TransformBlock(Func<TInput, TOutput> transform, ExecutionDataflowBlockOptions dataflowBlockOptions);
+        public Task Completion { get; }
+        public int InputCount { get; }
+        public int OutputCount { get; }
+        public void Complete();
+        public IDisposable LinkTo(ITargetBlock<TOutput> target, DataflowLinkOptions linkOptions);
+        void System.Threading.Tasks.Dataflow.IDataflowBlock.Fault(Exception exception);
+        TOutput System.Threading.Tasks.Dataflow.ISourceBlock<TOutput>.ConsumeMessage(DataflowMessageHeader messageHeader, ITargetBlock<TOutput> target, out bool messageConsumed);
+        void System.Threading.Tasks.Dataflow.ISourceBlock<TOutput>.ReleaseReservation(DataflowMessageHeader messageHeader, ITargetBlock<TOutput> target);
+        bool System.Threading.Tasks.Dataflow.ISourceBlock<TOutput>.ReserveMessage(DataflowMessageHeader messageHeader, ITargetBlock<TOutput> target);
+        DataflowMessageStatus System.Threading.Tasks.Dataflow.ITargetBlock<TInput>.OfferMessage(DataflowMessageHeader messageHeader, TInput messageValue, ISourceBlock<TInput> source, bool consumeToAccept);
+        public override string ToString();
+        public bool TryReceive(Predicate<TOutput> filter, out TOutput item);
+        public bool TryReceiveAll(out IList<TOutput> items);
+    }
+    public sealed class TransformManyBlock<TInput, TOutput> : IDataflowBlock, IDebuggerDisplay, IPropagatorBlock<TInput, TOutput>, IReceivableSourceBlock<TOutput>, ISourceBlock<TOutput>, ITargetBlock<TInput> {
+        public TransformManyBlock(Func<TInput, IEnumerable<TOutput>> transform);
+        public TransformManyBlock(Func<TInput, IEnumerable<TOutput>> transform, ExecutionDataflowBlockOptions dataflowBlockOptions);
+        public TransformManyBlock(Func<TInput, Task<IEnumerable<TOutput>>> transform);
+        public TransformManyBlock(Func<TInput, Task<IEnumerable<TOutput>>> transform, ExecutionDataflowBlockOptions dataflowBlockOptions);
+        public Task Completion { get; }
+        public int InputCount { get; }
+        public int OutputCount { get; }
+        public void Complete();
+        public IDisposable LinkTo(ITargetBlock<TOutput> target, DataflowLinkOptions linkOptions);
+        void System.Threading.Tasks.Dataflow.IDataflowBlock.Fault(Exception exception);
+        TOutput System.Threading.Tasks.Dataflow.ISourceBlock<TOutput>.ConsumeMessage(DataflowMessageHeader messageHeader, ITargetBlock<TOutput> target, out bool messageConsumed);
+        void System.Threading.Tasks.Dataflow.ISourceBlock<TOutput>.ReleaseReservation(DataflowMessageHeader messageHeader, ITargetBlock<TOutput> target);
+        bool System.Threading.Tasks.Dataflow.ISourceBlock<TOutput>.ReserveMessage(DataflowMessageHeader messageHeader, ITargetBlock<TOutput> target);
+        DataflowMessageStatus System.Threading.Tasks.Dataflow.ITargetBlock<TInput>.OfferMessage(DataflowMessageHeader messageHeader, TInput messageValue, ISourceBlock<TInput> source, bool consumeToAccept);
+        public override string ToString();
+        public bool TryReceive(Predicate<TOutput> filter, out TOutput item);
+        public bool TryReceiveAll(out IList<TOutput> items);
+    }
+    public sealed class WriteOnceBlock<T> : IDataflowBlock, IDebuggerDisplay, IPropagatorBlock<T, T>, IReceivableSourceBlock<T>, ISourceBlock<T>, ITargetBlock<T> {
+        public WriteOnceBlock(Func<T, T> cloningFunction);
+        public WriteOnceBlock(Func<T, T> cloningFunction, DataflowBlockOptions dataflowBlockOptions);
+        public Task Completion { get; }
+        public void Complete();
+        public IDisposable LinkTo(ITargetBlock<T> target, DataflowLinkOptions linkOptions);
+        void System.Threading.Tasks.Dataflow.IDataflowBlock.Fault(Exception exception);
+        bool System.Threading.Tasks.Dataflow.IReceivableSourceBlock<T>.TryReceiveAll(out IList<T> items);
+        T System.Threading.Tasks.Dataflow.ISourceBlock<T>.ConsumeMessage(DataflowMessageHeader messageHeader, ITargetBlock<T> target, out bool messageConsumed);
+        void System.Threading.Tasks.Dataflow.ISourceBlock<T>.ReleaseReservation(DataflowMessageHeader messageHeader, ITargetBlock<T> target);
+        bool System.Threading.Tasks.Dataflow.ISourceBlock<T>.ReserveMessage(DataflowMessageHeader messageHeader, ITargetBlock<T> target);
+        DataflowMessageStatus System.Threading.Tasks.Dataflow.ITargetBlock<T>.OfferMessage(DataflowMessageHeader messageHeader, T messageValue, ISourceBlock<T> source, bool consumeToAccept);
+        public override string ToString();
+        public bool TryReceive(Predicate<T> filter, out T item);
+    }
+}
```

## System.Windows.Input

```c#
+namespace System.Windows.Input {
+    public interface ICommand {
+        event EventHandler CanExecuteChanged;
+        bool CanExecute(object parameter);
+        void Execute(object parameter);
+    }
+}
```

## System.Xml

```c#
+namespace System.Xml {
+    public enum ConformanceLevel {
+        Auto = 0,
+        Document = 2,
+        Fragment = 1,
+    }
+    public enum DtdProcessing {
+        Ignore = 1,
+        Prohibit = 0,
+    }
+    public interface IStreamProvider {
+        Stream GetStream();
+        void ReleaseStream(Stream stream);
+    }
+    public interface IXmlDictionary {
+        bool TryLookup(int key, out XmlDictionaryString result);
+        bool TryLookup(string value, out XmlDictionaryString result);
+        bool TryLookup(XmlDictionaryString value, out XmlDictionaryString result);
+    }
+    public interface IXmlLineInfo {
+        int LineNumber { get; }
+        int LinePosition { get; }
+        bool HasLineInfo();
+    }
+    public interface IXmlNamespaceResolver {
+        IDictionary<string, string> GetNamespacesInScope(XmlNamespaceScope scope);
+        string LookupNamespace(string prefix);
+        string LookupPrefix(string namespaceName);
+    }
+    public interface IXmlTextReaderInitializer {
+        void SetInput(byte[] buffer, int offset, int count, Encoding encoding, XmlDictionaryReaderQuotas quotas, OnXmlDictionaryReaderClose onClose);
+        void SetInput(Stream stream, Encoding encoding, XmlDictionaryReaderQuotas quotas, OnXmlDictionaryReaderClose onClose);
+    }
+    public enum NamespaceHandling {
+        Default = 0,
+        OmitDuplicates = 1,
+    }
+    public class NameTable : XmlNameTable {
+        public NameTable();
+        public override string Add(char[] key, int start, int len);
+        public override string Add(string key);
+        public override string Get(char[] key, int start, int len);
+        public override string Get(string value);
+    }
+    public enum NewLineHandling {
+        Entitize = 1,
+        None = 2,
+        Replace = 0,
+    }
+    public delegate void OnXmlDictionaryReaderClose(XmlDictionaryReader reader);
+    public enum ReadState {
+        Closed = 4,
+        EndOfFile = 3,
+        Error = 2,
+        Initial = 0,
+        Interactive = 1,
+    }
+    public class UniqueId {
+        public UniqueId();
+        public UniqueId(byte[] guid);
+        public UniqueId(byte[] guid, int offset);
+        public UniqueId(char[] chars, int offset, int count);
+        public UniqueId(Guid guid);
+        public UniqueId(string value);
+        public int CharArrayLength { get; }
+        public bool IsGuid { get; }
+        public override bool Equals(object obj);
+        public override int GetHashCode();
+        public static bool operator ==(UniqueId id1, UniqueId id2);
+        public static bool operator !=(UniqueId id1, UniqueId id2);
+        public int ToCharArray(char[] chars, int offset);
+        public override string ToString();
+        public bool TryGetGuid(byte[] buffer, int offset);
+        public bool TryGetGuid(out Guid guid);
+    }
+    public enum WriteState {
+        Attribute = 3,
+        Closed = 5,
+        Content = 4,
+        Element = 2,
+        Error = 6,
+        Prolog = 1,
+        Start = 0,
+    }
+    public class XmlAttribute : XmlNode {
+        protected internal XmlAttribute(string prefix, string localName, string namespaceURI, XmlDocument doc);
+        public override string BaseURI { get; }
+        public override string InnerText { set; }
+        public override string InnerXml { set; }
+        public override string LocalName { get; }
+        public override string Name { get; }
+        public override string NamespaceURI { get; }
+        public override XmlNodeType NodeType { get; }
+        public override XmlDocument OwnerDocument { get; }
+        public virtual XmlElement OwnerElement { get; }
+        public override XmlNode ParentNode { get; }
+        public override string Prefix { get; set; }
+        public virtual bool Specified { get; }
+        public override string Value { get; set; }
+        public override XmlNode AppendChild(XmlNode newChild);
+        public override XmlNode CloneNode(bool deep);
+        public override XmlNode InsertAfter(XmlNode newChild, XmlNode refChild);
+        public override XmlNode InsertBefore(XmlNode newChild, XmlNode refChild);
+        public override XmlNode PrependChild(XmlNode newChild);
+        public override XmlNode RemoveChild(XmlNode oldChild);
+        public override XmlNode ReplaceChild(XmlNode newChild, XmlNode oldChild);
+        public override void WriteContentTo(XmlWriter w);
+        public override void WriteTo(XmlWriter w);
+    }
+    public sealed class XmlAttributeCollection : XmlNamedNodeMap, ICollection, IEnumerable {
+        int System.Collections.ICollection.Count { get; }
+        bool System.Collections.ICollection.IsSynchronized { get; }
+        object System.Collections.ICollection.SyncRoot { get; }
+        [System.Runtime.CompilerServices.IndexerName("ItemOf")]
+        public XmlAttribute this[int i] { get; }
+        [System.Runtime.CompilerServices.IndexerName("ItemOf")]
+        public XmlAttribute this[string localName, string namespaceURI] { get; }
+        [System.Runtime.CompilerServices.IndexerName("ItemOf")]
+        public XmlAttribute this[string name] { get; }
+        public XmlAttribute Append(XmlAttribute node);
+        public void CopyTo(XmlAttribute[] array, int index);
+        public XmlAttribute InsertAfter(XmlAttribute newNode, XmlAttribute refNode);
+        public XmlAttribute InsertBefore(XmlAttribute newNode, XmlAttribute refNode);
+        public XmlAttribute Prepend(XmlAttribute node);
+        public XmlAttribute Remove(XmlAttribute node);
+        public void RemoveAll();
+        public XmlAttribute RemoveAt(int i);
+        public override XmlNode SetNamedItem(XmlNode node);
+        void System.Collections.ICollection.CopyTo(Array array, int index);
+    }
+    public class XmlBinaryReaderSession : IXmlDictionary {
+        public XmlBinaryReaderSession();
+        public XmlDictionaryString Add(int id, string value);
+        public void Clear();
+        public bool TryLookup(int key, out XmlDictionaryString result);
+        public bool TryLookup(string value, out XmlDictionaryString result);
+        public bool TryLookup(XmlDictionaryString value, out XmlDictionaryString result);
+    }
+    public class XmlBinaryWriterSession {
+        public XmlBinaryWriterSession();
+        public void Reset();
+        public virtual bool TryAdd(XmlDictionaryString value, out int key);
+    }
+    public class XmlCDataSection : XmlCharacterData {
+        protected internal XmlCDataSection(string data, XmlDocument doc);
+        public override string LocalName { get; }
+        public override string Name { get; }
+        public override XmlNodeType NodeType { get; }
+        public override XmlNode ParentNode { get; }
+        public override XmlNode PreviousText { get; }
+        public override XmlNode CloneNode(bool deep);
+        public override void WriteContentTo(XmlWriter w);
+        public override void WriteTo(XmlWriter w);
+    }
+    public abstract class XmlCharacterData : XmlLinkedNode {
+        protected internal XmlCharacterData(string data, XmlDocument doc);
+        public virtual string Data { get; set; }
+        public virtual int Length { get; }
+        public override string Value { get; set; }
+        public virtual void AppendData(string strData);
+        public virtual void DeleteData(int offset, int count);
+        public virtual void InsertData(int offset, string strData);
+        public virtual void ReplaceData(int offset, int count, string strData);
+        public virtual string Substring(int offset, int count);
+    }
+    public class XmlComment : XmlCharacterData {
+        protected internal XmlComment(string comment, XmlDocument doc);
+        public override string LocalName { get; }
+        public override string Name { get; }
+        public override XmlNodeType NodeType { get; }
+        public override XmlNode CloneNode(bool deep);
+        public override void WriteContentTo(XmlWriter w);
+        public override void WriteTo(XmlWriter w);
+    }
+    public static class XmlConvert {
+        public static string DecodeName(string name);
+        public static string EncodeLocalName(string name);
+        public static string EncodeName(string name);
+        public static string EncodeNmToken(string name);
+        public static bool ToBoolean(string s);
+        public static byte ToByte(string s);
+        public static char ToChar(string s);
+        public static DateTime ToDateTime(string s, XmlDateTimeSerializationMode dateTimeOption);
+        public static DateTimeOffset ToDateTimeOffset(string s);
+        public static DateTimeOffset ToDateTimeOffset(string s, string format);
+        public static DateTimeOffset ToDateTimeOffset(string s, string[] formats);
+        public static Decimal ToDecimal(string s);
+        public static double ToDouble(string s);
+        public static Guid ToGuid(string s);
+        public static short ToInt16(string s);
+        public static int ToInt32(string s);
+        public static long ToInt64(string s);
+        public static sbyte ToSByte(string s);
+        public static float ToSingle(string s);
+        public static string ToString(bool value);
+        public static string ToString(byte value);
+        public static string ToString(char value);
+        public static string ToString(DateTime value, XmlDateTimeSerializationMode dateTimeOption);
+        public static string ToString(DateTimeOffset value);
+        public static string ToString(DateTimeOffset value, string format);
+        public static string ToString(Decimal value);
+        public static string ToString(double value);
+        public static string ToString(Guid value);
+        public static string ToString(short value);
+        public static string ToString(int value);
+        public static string ToString(long value);
+        public static string ToString(sbyte value);
+        public static string ToString(float value);
+        public static string ToString(TimeSpan value);
+        public static string ToString(ushort value);
+        public static string ToString(uint value);
+        public static string ToString(ulong value);
+        public static TimeSpan ToTimeSpan(string s);
+        public static ushort ToUInt16(string s);
+        public static uint ToUInt32(string s);
+        public static ulong ToUInt64(string s);
+        public static string VerifyName(string name);
+        public static string VerifyNCName(string name);
+        public static string VerifyNMTOKEN(string name);
+        public static string VerifyPublicId(string publicId);
+        public static string VerifyWhitespace(string content);
+        public static string VerifyXmlChars(string content);
+    }
+    public enum XmlDateTimeSerializationMode {
+        Local = 0,
+        RoundtripKind = 3,
+        Unspecified = 2,
+        Utc = 1,
+    }
+    public class XmlDeclaration : XmlLinkedNode {
+        protected internal XmlDeclaration(string version, string encoding, string standalone, XmlDocument doc);
+        public string Encoding { get; set; }
+        public override string InnerText { get; set; }
+        public override string LocalName { get; }
+        public override string Name { get; }
+        public override XmlNodeType NodeType { get; }
+        public string Standalone { get; set; }
+        public override string Value { get; set; }
+        public string Version { get; }
+        public override XmlNode CloneNode(bool deep);
+        public override void WriteContentTo(XmlWriter w);
+        public override void WriteTo(XmlWriter w);
+    }
+    public class XmlDictionary : IXmlDictionary {
+        public XmlDictionary();
+        public XmlDictionary(int capacity);
+        public static IXmlDictionary Empty { get; }
+        public virtual XmlDictionaryString Add(string value);
+        public virtual bool TryLookup(int key, out XmlDictionaryString result);
+        public virtual bool TryLookup(string value, out XmlDictionaryString result);
+        public virtual bool TryLookup(XmlDictionaryString value, out XmlDictionaryString result);
+    }
+    public abstract class XmlDictionaryReader : XmlReader {
+        protected XmlDictionaryReader();
+        public virtual bool CanCanonicalize { get; }
+        public virtual XmlDictionaryReaderQuotas Quotas { get; }
+        public virtual void Close();
+        public static XmlDictionaryReader CreateBinaryReader(byte[] buffer, int offset, int count, IXmlDictionary dictionary, XmlDictionaryReaderQuotas quotas);
+        public static XmlDictionaryReader CreateBinaryReader(byte[] buffer, int offset, int count, IXmlDictionary dictionary, XmlDictionaryReaderQuotas quotas, XmlBinaryReaderSession session);
+        public static XmlDictionaryReader CreateBinaryReader(byte[] buffer, int offset, int count, XmlDictionaryReaderQuotas quotas);
+        public static XmlDictionaryReader CreateBinaryReader(byte[] buffer, XmlDictionaryReaderQuotas quotas);
+        public static XmlDictionaryReader CreateBinaryReader(Stream stream, IXmlDictionary dictionary, XmlDictionaryReaderQuotas quotas);
+        public static XmlDictionaryReader CreateBinaryReader(Stream stream, IXmlDictionary dictionary, XmlDictionaryReaderQuotas quotas, XmlBinaryReaderSession session);
+        public static XmlDictionaryReader CreateBinaryReader(Stream stream, XmlDictionaryReaderQuotas quotas);
+        public static XmlDictionaryReader CreateDictionaryReader(XmlReader reader);
+        public static XmlDictionaryReader CreateTextReader(byte[] buffer, int offset, int count, XmlDictionaryReaderQuotas quotas);
+        public static XmlDictionaryReader CreateTextReader(byte[] buffer, XmlDictionaryReaderQuotas quotas);
+        public static XmlDictionaryReader CreateTextReader(Stream stream, Encoding encoding, XmlDictionaryReaderQuotas quotas, OnXmlDictionaryReaderClose onClose);
+        public static XmlDictionaryReader CreateTextReader(Stream stream, XmlDictionaryReaderQuotas quotas);
+        public virtual void EndCanonicalization();
+        public virtual string GetAttribute(XmlDictionaryString localName, XmlDictionaryString namespaceUri);
+        public virtual int IndexOfLocalName(string[] localNames, string namespaceUri);
+        public virtual int IndexOfLocalName(XmlDictionaryString[] localNames, XmlDictionaryString namespaceUri);
+        public virtual bool IsLocalName(string localName);
+        public virtual bool IsLocalName(XmlDictionaryString localName);
+        public virtual bool IsNamespaceUri(string namespaceUri);
+        public virtual bool IsNamespaceUri(XmlDictionaryString namespaceUri);
+        public virtual bool IsStartArray(out Type type);
+        public virtual bool IsStartElement(XmlDictionaryString localName, XmlDictionaryString namespaceUri);
+        protected bool IsTextNode(XmlNodeType nodeType);
+        public virtual void MoveToStartElement();
+        public virtual void MoveToStartElement(string name);
+        public virtual void MoveToStartElement(string localName, string namespaceUri);
+        public virtual void MoveToStartElement(XmlDictionaryString localName, XmlDictionaryString namespaceUri);
+        public virtual int ReadArray(string localName, string namespaceUri, bool[] array, int offset, int count);
+        public virtual int ReadArray(string localName, string namespaceUri, DateTime[] array, int offset, int count);
+        public virtual int ReadArray(string localName, string namespaceUri, Decimal[] array, int offset, int count);
+        public virtual int ReadArray(string localName, string namespaceUri, double[] array, int offset, int count);
+        public virtual int ReadArray(string localName, string namespaceUri, Guid[] array, int offset, int count);
+        public virtual int ReadArray(string localName, string namespaceUri, short[] array, int offset, int count);
+        public virtual int ReadArray(string localName, string namespaceUri, int[] array, int offset, int count);
+        public virtual int ReadArray(string localName, string namespaceUri, long[] array, int offset, int count);
+        public virtual int ReadArray(string localName, string namespaceUri, float[] array, int offset, int count);
+        public virtual int ReadArray(string localName, string namespaceUri, TimeSpan[] array, int offset, int count);
+        public virtual int ReadArray(XmlDictionaryString localName, XmlDictionaryString namespaceUri, bool[] array, int offset, int count);
+        public virtual int ReadArray(XmlDictionaryString localName, XmlDictionaryString namespaceUri, DateTime[] array, int offset, int count);
+        public virtual int ReadArray(XmlDictionaryString localName, XmlDictionaryString namespaceUri, Decimal[] array, int offset, int count);
+        public virtual int ReadArray(XmlDictionaryString localName, XmlDictionaryString namespaceUri, double[] array, int offset, int count);
+        public virtual int ReadArray(XmlDictionaryString localName, XmlDictionaryString namespaceUri, Guid[] array, int offset, int count);
+        public virtual int ReadArray(XmlDictionaryString localName, XmlDictionaryString namespaceUri, short[] array, int offset, int count);
+        public virtual int ReadArray(XmlDictionaryString localName, XmlDictionaryString namespaceUri, int[] array, int offset, int count);
+        public virtual int ReadArray(XmlDictionaryString localName, XmlDictionaryString namespaceUri, long[] array, int offset, int count);
+        public virtual int ReadArray(XmlDictionaryString localName, XmlDictionaryString namespaceUri, float[] array, int offset, int count);
+        public virtual int ReadArray(XmlDictionaryString localName, XmlDictionaryString namespaceUri, TimeSpan[] array, int offset, int count);
+        public virtual bool[] ReadBooleanArray(string localName, string namespaceUri);
+        public virtual bool[] ReadBooleanArray(XmlDictionaryString localName, XmlDictionaryString namespaceUri);
+        public override object ReadContentAs(Type type, IXmlNamespaceResolver namespaceResolver);
+        public virtual byte[] ReadContentAsBase64();
+        public virtual byte[] ReadContentAsBinHex();
+        protected byte[] ReadContentAsBinHex(int maxByteArrayContentLength);
+        public virtual int ReadContentAsChars(char[] chars, int offset, int count);
+        public override Decimal ReadContentAsDecimal();
+        public override float ReadContentAsFloat();
+        public virtual Guid ReadContentAsGuid();
+        public virtual void ReadContentAsQualifiedName(out string localName, out string namespaceUri);
+        public override string ReadContentAsString();
+        protected string ReadContentAsString(int maxStringContentLength);
+        public virtual string ReadContentAsString(string[] strings, out int index);
+        public virtual string ReadContentAsString(XmlDictionaryString[] strings, out int index);
+        public virtual TimeSpan ReadContentAsTimeSpan();
+        public virtual UniqueId ReadContentAsUniqueId();
+        public virtual DateTime[] ReadDateTimeArray(string localName, string namespaceUri);
+        public virtual DateTime[] ReadDateTimeArray(XmlDictionaryString localName, XmlDictionaryString namespaceUri);
+        public virtual Decimal[] ReadDecimalArray(string localName, string namespaceUri);
+        public virtual Decimal[] ReadDecimalArray(XmlDictionaryString localName, XmlDictionaryString namespaceUri);
+        public virtual double[] ReadDoubleArray(string localName, string namespaceUri);
+        public virtual double[] ReadDoubleArray(XmlDictionaryString localName, XmlDictionaryString namespaceUri);
+        public virtual byte[] ReadElementContentAsBase64();
+        public virtual byte[] ReadElementContentAsBinHex();
+        public override bool ReadElementContentAsBoolean();
+        public virtual DateTime ReadElementContentAsDateTime();
+        public override Decimal ReadElementContentAsDecimal();
+        public override double ReadElementContentAsDouble();
+        public override float ReadElementContentAsFloat();
+        public virtual Guid ReadElementContentAsGuid();
+        public override int ReadElementContentAsInt();
+        public override long ReadElementContentAsLong();
+        public override string ReadElementContentAsString();
+        public virtual TimeSpan ReadElementContentAsTimeSpan();
+        public virtual UniqueId ReadElementContentAsUniqueId();
+        public virtual void ReadFullStartElement();
+        public virtual void ReadFullStartElement(string name);
+        public virtual void ReadFullStartElement(string localName, string namespaceUri);
+        public virtual void ReadFullStartElement(XmlDictionaryString localName, XmlDictionaryString namespaceUri);
+        public virtual Guid[] ReadGuidArray(string localName, string namespaceUri);
+        public virtual Guid[] ReadGuidArray(XmlDictionaryString localName, XmlDictionaryString namespaceUri);
+        public virtual short[] ReadInt16Array(string localName, string namespaceUri);
+        public virtual short[] ReadInt16Array(XmlDictionaryString localName, XmlDictionaryString namespaceUri);
+        public virtual int[] ReadInt32Array(string localName, string namespaceUri);
+        public virtual int[] ReadInt32Array(XmlDictionaryString localName, XmlDictionaryString namespaceUri);
+        public virtual long[] ReadInt64Array(string localName, string namespaceUri);
+        public virtual long[] ReadInt64Array(XmlDictionaryString localName, XmlDictionaryString namespaceUri);
+        public virtual float[] ReadSingleArray(string localName, string namespaceUri);
+        public virtual float[] ReadSingleArray(XmlDictionaryString localName, XmlDictionaryString namespaceUri);
+        public virtual void ReadStartElement(XmlDictionaryString localName, XmlDictionaryString namespaceUri);
+        public virtual TimeSpan[] ReadTimeSpanArray(string localName, string namespaceUri);
+        public virtual TimeSpan[] ReadTimeSpanArray(XmlDictionaryString localName, XmlDictionaryString namespaceUri);
+        public virtual int ReadValueAsBase64(byte[] buffer, int offset, int count);
+        public virtual void StartCanonicalization(Stream stream, bool includeComments, string[] inclusivePrefixes);
+        public virtual bool TryGetArrayLength(out int count);
+        public virtual bool TryGetBase64ContentLength(out int length);
+        public virtual bool TryGetLocalNameAsDictionaryString(out XmlDictionaryString localName);
+        public virtual bool TryGetNamespaceUriAsDictionaryString(out XmlDictionaryString namespaceUri);
+        public virtual bool TryGetValueAsDictionaryString(out XmlDictionaryString value);
+    }
+    public sealed class XmlDictionaryReaderQuotas {
+        public XmlDictionaryReaderQuotas();
+        public static XmlDictionaryReaderQuotas Max { get; }
+        public int MaxArrayLength { get; set; }
+        public int MaxBytesPerRead { get; set; }
+        public int MaxDepth { get; set; }
+        public int MaxNameTableCharCount { get; set; }
+        public int MaxStringContentLength { get; set; }
+        public XmlDictionaryReaderQuotaTypes ModifiedQuotas { get; }
+        public void CopyTo(XmlDictionaryReaderQuotas quotas);
+    }
+    public enum XmlDictionaryReaderQuotaTypes {
+        MaxArrayLength = 4,
+        MaxBytesPerRead = 8,
+        MaxDepth = 1,
+        MaxNameTableCharCount = 16,
+        MaxStringContentLength = 2,
+    }
+    public class XmlDictionaryString {
+        public XmlDictionaryString(IXmlDictionary dictionary, string value, int key);
+        public IXmlDictionary Dictionary { get; }
+        public static XmlDictionaryString Empty { get; }
+        public int Key { get; }
+        public string Value { get; }
+        public override string ToString();
+    }
+    public abstract class XmlDictionaryWriter : XmlWriter {
+        protected XmlDictionaryWriter();
+        public virtual bool CanCanonicalize { get; }
+        public virtual void Close();
+        public static XmlDictionaryWriter CreateBinaryWriter(Stream stream);
+        public static XmlDictionaryWriter CreateBinaryWriter(Stream stream, IXmlDictionary dictionary);
+        public static XmlDictionaryWriter CreateBinaryWriter(Stream stream, IXmlDictionary dictionary, XmlBinaryWriterSession session);
+        public static XmlDictionaryWriter CreateBinaryWriter(Stream stream, IXmlDictionary dictionary, XmlBinaryWriterSession session, bool ownsStream);
+        public static XmlDictionaryWriter CreateDictionaryWriter(XmlWriter writer);
+        public static XmlDictionaryWriter CreateTextWriter(Stream stream);
+        public static XmlDictionaryWriter CreateTextWriter(Stream stream, Encoding encoding);
+        public static XmlDictionaryWriter CreateTextWriter(Stream stream, Encoding encoding, bool ownsStream);
+        protected override void Dispose(bool disposing);
+        public virtual void EndCanonicalization();
+        public virtual void StartCanonicalization(Stream stream, bool includeComments, string[] inclusivePrefixes);
+        public virtual void WriteArray(string prefix, string localName, string namespaceUri, bool[] array, int offset, int count);
+        public virtual void WriteArray(string prefix, string localName, string namespaceUri, DateTime[] array, int offset, int count);
+        public virtual void WriteArray(string prefix, string localName, string namespaceUri, Decimal[] array, int offset, int count);
+        public virtual void WriteArray(string prefix, string localName, string namespaceUri, double[] array, int offset, int count);
+        public virtual void WriteArray(string prefix, string localName, string namespaceUri, Guid[] array, int offset, int count);
+        public virtual void WriteArray(string prefix, string localName, string namespaceUri, short[] array, int offset, int count);
+        public virtual void WriteArray(string prefix, string localName, string namespaceUri, int[] array, int offset, int count);
+        public virtual void WriteArray(string prefix, string localName, string namespaceUri, long[] array, int offset, int count);
+        public virtual void WriteArray(string prefix, string localName, string namespaceUri, float[] array, int offset, int count);
+        public virtual void WriteArray(string prefix, string localName, string namespaceUri, TimeSpan[] array, int offset, int count);
+        public virtual void WriteArray(string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, bool[] array, int offset, int count);
+        public virtual void WriteArray(string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, DateTime[] array, int offset, int count);
+        public virtual void WriteArray(string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, Decimal[] array, int offset, int count);
+        public virtual void WriteArray(string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, double[] array, int offset, int count);
+        public virtual void WriteArray(string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, Guid[] array, int offset, int count);
+        public virtual void WriteArray(string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, short[] array, int offset, int count);
+        public virtual void WriteArray(string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, int[] array, int offset, int count);
+        public virtual void WriteArray(string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, long[] array, int offset, int count);
+        public virtual void WriteArray(string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, float[] array, int offset, int count);
+        public virtual void WriteArray(string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, TimeSpan[] array, int offset, int count);
+        public void WriteAttributeString(string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, string value);
+        public void WriteAttributeString(XmlDictionaryString localName, XmlDictionaryString namespaceUri, string value);
+        public void WriteElementString(string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, string value);
+        public void WriteElementString(XmlDictionaryString localName, XmlDictionaryString namespaceUri, string value);
+        public virtual void WriteNode(XmlDictionaryReader reader, bool defattr);
+        public override void WriteNode(XmlReader reader, bool defattr);
+        public virtual void WriteQualifiedName(XmlDictionaryString localName, XmlDictionaryString namespaceUri);
+        public virtual void WriteStartAttribute(string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri);
+        public void WriteStartAttribute(XmlDictionaryString localName, XmlDictionaryString namespaceUri);
+        public virtual void WriteStartElement(string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri);
+        public void WriteStartElement(XmlDictionaryString localName, XmlDictionaryString namespaceUri);
+        public virtual void WriteString(XmlDictionaryString value);
+        protected virtual void WriteTextNode(XmlDictionaryReader reader, bool isAttribute);
+        public virtual void WriteValue(Guid value);
+        public virtual void WriteValue(TimeSpan value);
+        public virtual void WriteValue(UniqueId value);
+        public virtual void WriteValue(XmlDictionaryString value);
+        public virtual void WriteXmlAttribute(string localName, string value);
+        public virtual void WriteXmlAttribute(XmlDictionaryString localName, XmlDictionaryString value);
+        public virtual void WriteXmlnsAttribute(string prefix, string namespaceUri);
+        public virtual void WriteXmlnsAttribute(string prefix, XmlDictionaryString namespaceUri);
+    }
+    public class XmlDocument : XmlNode {
+        public XmlDocument();
+        protected internal XmlDocument(XmlImplementation imp);
+        public XmlDocument(XmlNameTable nt);
+        public override string BaseURI { get; }
+        public XmlElement DocumentElement { get; }
+        public XmlImplementation Implementation { get; }
+        public override string InnerText { set; }
+        public override string InnerXml { get; set; }
+        public override bool IsReadOnly { get; }
+        public override string LocalName { get; }
+        public override string Name { get; }
+        public XmlNameTable NameTable { get; }
+        public override XmlNodeType NodeType { get; }
+        public override XmlDocument OwnerDocument { get; }
+        public override XmlNode ParentNode { get; }
+        public bool PreserveWhitespace { get; set; }
+        public event XmlNodeChangedEventHandler NodeChanged;
+        public event XmlNodeChangedEventHandler NodeChanging;
+        public event XmlNodeChangedEventHandler NodeInserted;
+        public event XmlNodeChangedEventHandler NodeInserting;
+        public event XmlNodeChangedEventHandler NodeRemoved;
+        public event XmlNodeChangedEventHandler NodeRemoving;
+        public override XmlNode CloneNode(bool deep);
+        public XmlAttribute CreateAttribute(string name);
+        public XmlAttribute CreateAttribute(string qualifiedName, string namespaceURI);
+        public virtual XmlAttribute CreateAttribute(string prefix, string localName, string namespaceURI);
+        public virtual XmlCDataSection CreateCDataSection(string data);
+        public virtual XmlComment CreateComment(string data);
+        public virtual XmlDocumentFragment CreateDocumentFragment();
+        public XmlElement CreateElement(string name);
+        public XmlElement CreateElement(string qualifiedName, string namespaceURI);
+        public virtual XmlElement CreateElement(string prefix, string localName, string namespaceURI);
+        public virtual XmlNode CreateNode(string nodeTypeString, string name, string namespaceURI);
+        public virtual XmlNode CreateNode(XmlNodeType type, string name, string namespaceURI);
+        public virtual XmlNode CreateNode(XmlNodeType type, string prefix, string name, string namespaceURI);
+        public virtual XmlProcessingInstruction CreateProcessingInstruction(string target, string data);
+        public virtual XmlSignificantWhitespace CreateSignificantWhitespace(string text);
+        public virtual XmlText CreateTextNode(string text);
+        public virtual XmlWhitespace CreateWhitespace(string text);
+        public virtual XmlDeclaration CreateXmlDeclaration(string version, string encoding, string standalone);
+        public virtual XmlNodeList GetElementsByTagName(string name);
+        public virtual XmlNodeList GetElementsByTagName(string localName, string namespaceURI);
+        public virtual XmlNode ImportNode(XmlNode node, bool deep);
+        public virtual void Load(Stream inStream);
+        public virtual void Load(TextReader txtReader);
+        public virtual void Load(XmlReader reader);
+        public virtual void LoadXml(string xml);
+        public virtual XmlNode ReadNode(XmlReader reader);
+        public virtual void Save(Stream outStream);
+        public virtual void Save(TextWriter writer);
+        public virtual void Save(XmlWriter w);
+        public override void WriteContentTo(XmlWriter xw);
+        public override void WriteTo(XmlWriter w);
+    }
+    public class XmlDocumentFragment : XmlNode {
+        protected internal XmlDocumentFragment(XmlDocument ownerDocument);
+        public override string InnerXml { get; set; }
+        public override string LocalName { get; }
+        public override string Name { get; }
+        public override XmlNodeType NodeType { get; }
+        public override XmlDocument OwnerDocument { get; }
+        public override XmlNode ParentNode { get; }
+        public override XmlNode CloneNode(bool deep);
+        public override void WriteContentTo(XmlWriter w);
+        public override void WriteTo(XmlWriter w);
+    }
+    public static class XmlDocumentXPathExtensions {
+        public static XPathNavigator CreateNavigator(this XmlDocument document);
+        public static XPathNavigator CreateNavigator(this XmlDocument document, XmlNode node);
+        public static XPathNavigator CreateNavigator(this XmlNode node);
+        public static XmlNodeList SelectNodes(this XmlNode node, string xpath);
+        public static XmlNodeList SelectNodes(this XmlNode node, string xpath, XmlNamespaceManager nsmgr);
+        public static XmlNode SelectSingleNode(this XmlNode node, string xpath);
+        public static XmlNode SelectSingleNode(this XmlNode node, string xpath, XmlNamespaceManager nsmgr);
+        public static IXPathNavigable ToXPathNavigable(this XmlNode node);
+    }
+    public class XmlElement : XmlLinkedNode {
+        protected internal XmlElement(string prefix, string localName, string namespaceURI, XmlDocument doc);
+        public override XmlAttributeCollection Attributes { get; }
+        public virtual bool HasAttributes { get; }
+        public override string InnerText { get; set; }
+        public override string InnerXml { get; set; }
+        public bool IsEmpty { get; set; }
+        public override string LocalName { get; }
+        public override string Name { get; }
+        public override string NamespaceURI { get; }
+        public override XmlNode NextSibling { get; }
+        public override XmlNodeType NodeType { get; }
+        public override XmlDocument OwnerDocument { get; }
+        public override XmlNode ParentNode { get; }
+        public override string Prefix { get; set; }
+        public override XmlNode CloneNode(bool deep);
+        public virtual string GetAttribute(string name);
+        public virtual string GetAttribute(string localName, string namespaceURI);
+        public virtual XmlAttribute GetAttributeNode(string name);
+        public virtual XmlAttribute GetAttributeNode(string localName, string namespaceURI);
+        public virtual XmlNodeList GetElementsByTagName(string name);
+        public virtual XmlNodeList GetElementsByTagName(string localName, string namespaceURI);
+        public virtual bool HasAttribute(string name);
+        public virtual bool HasAttribute(string localName, string namespaceURI);
+        public override void RemoveAll();
+        public virtual void RemoveAllAttributes();
+        public virtual void RemoveAttribute(string name);
+        public virtual void RemoveAttribute(string localName, string namespaceURI);
+        public virtual XmlNode RemoveAttributeAt(int i);
+        public virtual XmlAttribute RemoveAttributeNode(string localName, string namespaceURI);
+        public virtual XmlAttribute RemoveAttributeNode(XmlAttribute oldAttr);
+        public virtual void SetAttribute(string name, string value);
+        public virtual string SetAttribute(string localName, string namespaceURI, string value);
+        public virtual XmlAttribute SetAttributeNode(string localName, string namespaceURI);
+        public virtual XmlAttribute SetAttributeNode(XmlAttribute newAttr);
+        public override void WriteContentTo(XmlWriter w);
+        public override void WriteTo(XmlWriter w);
+    }
+    public class XmlException : Exception {
+        public XmlException();
+        public XmlException(string message);
+        public XmlException(string message, Exception innerException);
+        public XmlException(string message, Exception innerException, int lineNumber, int linePosition);
+        public int LineNumber { get; }
+        public int LinePosition { get; }
+        public override string Message { get; }
+    }
+    public class XmlImplementation {
+        public XmlImplementation();
+        public XmlImplementation(XmlNameTable nt);
+        public virtual XmlDocument CreateDocument();
+        public bool HasFeature(string strFeature, string strVersion);
+    }
+    public abstract class XmlLinkedNode : XmlNode {
+        public override XmlNode NextSibling { get; }
+        public override XmlNode PreviousSibling { get; }
+    }
+    public class XmlNamedNodeMap : IEnumerable {
+        public virtual int Count { get; }
+        public virtual IEnumerator GetEnumerator();
+        public virtual XmlNode GetNamedItem(string name);
+        public virtual XmlNode GetNamedItem(string localName, string namespaceURI);
+        public virtual XmlNode Item(int index);
+        public virtual XmlNode RemoveNamedItem(string name);
+        public virtual XmlNode RemoveNamedItem(string localName, string namespaceURI);
+        public virtual XmlNode SetNamedItem(XmlNode node);
+    }
+    public class XmlNamespaceManager : IEnumerable, IXmlNamespaceResolver {
+        public XmlNamespaceManager(XmlNameTable nameTable);
+        public virtual string DefaultNamespace { get; }
+        public virtual XmlNameTable NameTable { get; }
+        public virtual void AddNamespace(string prefix, string uri);
+        public virtual IEnumerator GetEnumerator();
+        public virtual IDictionary<string, string> GetNamespacesInScope(XmlNamespaceScope scope);
+        public virtual bool HasNamespace(string prefix);
+        public virtual string LookupNamespace(string prefix);
+        public virtual string LookupPrefix(string uri);
+        public virtual bool PopScope();
+        public virtual void PushScope();
+        public virtual void RemoveNamespace(string prefix, string uri);
+    }
+    public enum XmlNamespaceScope {
+        All = 0,
+        ExcludeXml = 1,
+        Local = 2,
+    }
+    public abstract class XmlNameTable {
+        protected XmlNameTable();
+        public abstract string Add(char[] array, int offset, int length);
+        public abstract string Add(string array);
+        public abstract string Get(char[] array, int offset, int length);
+        public abstract string Get(string array);
+    }
+    public abstract class XmlNode : IEnumerable {
+        public virtual XmlAttributeCollection Attributes { get; }
+        public virtual string BaseURI { get; }
+        public virtual XmlNodeList ChildNodes { get; }
+        public virtual XmlNode FirstChild { get; }
+        public virtual bool HasChildNodes { get; }
+        public virtual string InnerText { get; set; }
+        public virtual string InnerXml { get; set; }
+        public virtual bool IsReadOnly { get; }
+        public virtual XmlNode LastChild { get; }
+        public abstract string LocalName { get; }
+        public abstract string Name { get; }
+        public virtual string NamespaceURI { get; }
+        public virtual XmlNode NextSibling { get; }
+        public abstract XmlNodeType NodeType { get; }
+        public virtual string OuterXml { get; }
+        public virtual XmlDocument OwnerDocument { get; }
+        public virtual XmlNode ParentNode { get; }
+        public virtual string Prefix { get; set; }
+        public virtual XmlNode PreviousSibling { get; }
+        public virtual XmlNode PreviousText { get; }
+        public virtual XmlElement this[string localname, string ns] { get; }
+        public virtual XmlElement this[string name] { get; }
+        public virtual string Value { get; set; }
+        public virtual XmlNode AppendChild(XmlNode newChild);
+        public abstract XmlNode CloneNode(bool deep);
+        public IEnumerator GetEnumerator();
+        public virtual string GetNamespaceOfPrefix(string prefix);
+        public virtual string GetPrefixOfNamespace(string namespaceURI);
+        public virtual XmlNode InsertAfter(XmlNode newChild, XmlNode refChild);
+        public virtual XmlNode InsertBefore(XmlNode newChild, XmlNode refChild);
+        public virtual void Normalize();
+        public virtual XmlNode PrependChild(XmlNode newChild);
+        public virtual void RemoveAll();
+        public virtual XmlNode RemoveChild(XmlNode oldChild);
+        public virtual XmlNode ReplaceChild(XmlNode newChild, XmlNode oldChild);
+        public virtual bool Supports(string feature, string version);
+        IEnumerator System.Collections.IEnumerable.GetEnumerator();
+        public abstract void WriteContentTo(XmlWriter w);
+        public abstract void WriteTo(XmlWriter w);
+    }
+    public enum XmlNodeChangedAction {
+        Change = 2,
+        Insert = 0,
+        Remove = 1,
+    }
+    public class XmlNodeChangedEventArgs : EventArgs {
+        public XmlNodeChangedEventArgs(XmlNode node, XmlNode oldParent, XmlNode newParent, string oldValue, string newValue, XmlNodeChangedAction action);
+        public XmlNodeChangedAction Action { get; }
+        public XmlNode NewParent { get; }
+        public string NewValue { get; }
+        public XmlNode Node { get; }
+        public XmlNode OldParent { get; }
+        public string OldValue { get; }
+    }
+    public delegate void XmlNodeChangedEventHandler(object sender, XmlNodeChangedEventArgs e);
+    public abstract class XmlNodeList : IDisposable, IEnumerable {
+        protected XmlNodeList();
+        public abstract int Count { get; }
+        [System.Runtime.CompilerServices.IndexerName("ItemOf")]
+        public virtual XmlNode this[int i] { get; }
+        public abstract IEnumerator GetEnumerator();
+        public abstract XmlNode Item(int index);
+        protected virtual void PrivateDisposeNodeList();
+        void System.IDisposable.Dispose();
+    }
+    public enum XmlNodeOrder {
+        After = 1,
+        Before = 0,
+        Same = 2,
+        Unknown = 3,
+    }
+    public enum XmlNodeType {
+        Attribute = 2,
+        CDATA = 4,
+        Comment = 8,
+        Document = 9,
+        DocumentFragment = 11,
+        DocumentType = 10,
+        Element = 1,
+        EndElement = 15,
+        EndEntity = 16,
+        Entity = 6,
+        EntityReference = 5,
+        None = 0,
+        Notation = 12,
+        ProcessingInstruction = 7,
+        SignificantWhitespace = 14,
+        Text = 3,
+        Whitespace = 13,
+        XmlDeclaration = 17,
+    }
+    public class XmlParserContext {
+        public XmlParserContext(XmlNameTable nt, XmlNamespaceManager nsMgr, string docTypeName, string pubId, string sysId, string internalSubset, string baseURI, string xmlLang, XmlSpace xmlSpace);
+        public XmlParserContext(XmlNameTable nt, XmlNamespaceManager nsMgr, string docTypeName, string pubId, string sysId, string internalSubset, string baseURI, string xmlLang, XmlSpace xmlSpace, Encoding enc);
+        public XmlParserContext(XmlNameTable nt, XmlNamespaceManager nsMgr, string xmlLang, XmlSpace xmlSpace);
+        public XmlParserContext(XmlNameTable nt, XmlNamespaceManager nsMgr, string xmlLang, XmlSpace xmlSpace, Encoding enc);
+        public string BaseURI { get; set; }
+        public string DocTypeName { get; set; }
+        public Encoding Encoding { get; set; }
+        public string InternalSubset { get; set; }
+        public XmlNamespaceManager NamespaceManager { get; set; }
+        public XmlNameTable NameTable { get; set; }
+        public string PublicId { get; set; }
+        public string SystemId { get; set; }
+        public string XmlLang { get; set; }
+        public XmlSpace XmlSpace { get; set; }
+    }
+    public class XmlProcessingInstruction : XmlLinkedNode {
+        protected internal XmlProcessingInstruction(string target, string data, XmlDocument doc);
+        public string Data { get; set; }
+        public override string InnerText { get; set; }
+        public override string LocalName { get; }
+        public override string Name { get; }
+        public override XmlNodeType NodeType { get; }
+        public string Target { get; }
+        public override string Value { get; set; }
+        public override XmlNode CloneNode(bool deep);
+        public override void WriteContentTo(XmlWriter w);
+        public override void WriteTo(XmlWriter w);
+    }
+    public class XmlQualifiedName {
+        public static readonly XmlQualifiedName Empty;
+        public XmlQualifiedName();
+        public XmlQualifiedName(string name);
+        public XmlQualifiedName(string name, string ns);
+        public bool IsEmpty { get; }
+        public string Name { get; }
+        public string Namespace { get; }
+        public override bool Equals(object other);
+        public override int GetHashCode();
+        public static bool operator ==(XmlQualifiedName a, XmlQualifiedName b);
+        public static bool operator !=(XmlQualifiedName a, XmlQualifiedName b);
+        public override string ToString();
+        public static string ToString(string name, string ns);
+    }
+    public abstract class XmlReader : IDisposable {
+        protected XmlReader();
+        public abstract int AttributeCount { get; }
+        public abstract string BaseURI { get; }
+        public virtual bool CanReadBinaryContent { get; }
+        public virtual bool CanReadValueChunk { get; }
+        public virtual bool CanResolveEntity { get; }
+        public abstract int Depth { get; }
+        public abstract bool EOF { get; }
+        public virtual bool HasAttributes { get; }
+        public virtual bool HasValue { get; }
+        public virtual bool IsDefault { get; }
+        public abstract bool IsEmptyElement { get; }
+        public abstract string LocalName { get; }
+        public virtual string Name { get; }
+        public abstract string NamespaceURI { get; }
+        public abstract XmlNameTable NameTable { get; }
+        public abstract XmlNodeType NodeType { get; }
+        public abstract string Prefix { get; }
+        public abstract ReadState ReadState { get; }
+        public virtual XmlReaderSettings Settings { get; }
+        public virtual string this[int i] { get; }
+        public virtual string this[string name, string namespaceURI] { get; }
+        public virtual string this[string name] { get; }
+        public abstract string Value { get; }
+        public virtual Type ValueType { get; }
+        public virtual string XmlLang { get; }
+        public virtual XmlSpace XmlSpace { get; }
+        public static XmlReader Create(Stream input);
+        public static XmlReader Create(Stream input, XmlReaderSettings settings);
+        public static XmlReader Create(Stream input, XmlReaderSettings settings, XmlParserContext inputContext);
+        public static XmlReader Create(TextReader input);
+        public static XmlReader Create(TextReader input, XmlReaderSettings settings);
+        public static XmlReader Create(TextReader input, XmlReaderSettings settings, XmlParserContext inputContext);
+        public static XmlReader Create(string inputUri);
+        public static XmlReader Create(string inputUri, XmlReaderSettings settings);
+        public static XmlReader Create(XmlReader reader, XmlReaderSettings settings);
+        public void Dispose();
+        protected virtual void Dispose(bool disposing);
+        public abstract string GetAttribute(int i);
+        public abstract string GetAttribute(string name);
+        public abstract string GetAttribute(string name, string namespaceURI);
+        public virtual Task<string> GetValueAsync();
+        public static bool IsName(string str);
+        public static bool IsNameToken(string str);
+        public virtual bool IsStartElement();
+        public virtual bool IsStartElement(string name);
+        public virtual bool IsStartElement(string localname, string ns);
+        public abstract string LookupNamespace(string prefix);
+        public virtual void MoveToAttribute(int i);
+        public abstract bool MoveToAttribute(string name);
+        public abstract bool MoveToAttribute(string name, string ns);
+        public virtual XmlNodeType MoveToContent();
+        public virtual Task<XmlNodeType> MoveToContentAsync();
+        public abstract bool MoveToElement();
+        public abstract bool MoveToFirstAttribute();
+        public abstract bool MoveToNextAttribute();
+        public abstract bool Read();
+        public virtual Task<bool> ReadAsync();
+        public abstract bool ReadAttributeValue();
+        public virtual object ReadContentAs(Type returnType, IXmlNamespaceResolver namespaceResolver);
+        public virtual Task<object> ReadContentAsAsync(Type returnType, IXmlNamespaceResolver namespaceResolver);
+        public virtual int ReadContentAsBase64(byte[] buffer, int index, int count);
+        public virtual Task<int> ReadContentAsBase64Async(byte[] buffer, int index, int count);
+        public virtual int ReadContentAsBinHex(byte[] buffer, int index, int count);
+        public virtual Task<int> ReadContentAsBinHexAsync(byte[] buffer, int index, int count);
+        public virtual bool ReadContentAsBoolean();
+        public virtual DateTimeOffset ReadContentAsDateTimeOffset();
+        public virtual Decimal ReadContentAsDecimal();
+        public virtual double ReadContentAsDouble();
+        public virtual float ReadContentAsFloat();
+        public virtual int ReadContentAsInt();
+        public virtual long ReadContentAsLong();
+        public virtual object ReadContentAsObject();
+        public virtual Task<object> ReadContentAsObjectAsync();
+        public virtual string ReadContentAsString();
+        public virtual Task<string> ReadContentAsStringAsync();
+        public virtual object ReadElementContentAs(Type returnType, IXmlNamespaceResolver namespaceResolver);
+        public virtual object ReadElementContentAs(Type returnType, IXmlNamespaceResolver namespaceResolver, string localName, string namespaceURI);
+        public virtual Task<object> ReadElementContentAsAsync(Type returnType, IXmlNamespaceResolver namespaceResolver);
+        public virtual int ReadElementContentAsBase64(byte[] buffer, int index, int count);
+        public virtual Task<int> ReadElementContentAsBase64Async(byte[] buffer, int index, int count);
+        public virtual int ReadElementContentAsBinHex(byte[] buffer, int index, int count);
+        public virtual Task<int> ReadElementContentAsBinHexAsync(byte[] buffer, int index, int count);
+        public virtual bool ReadElementContentAsBoolean();
+        public virtual bool ReadElementContentAsBoolean(string localName, string namespaceURI);
+        public virtual Decimal ReadElementContentAsDecimal();
+        public virtual Decimal ReadElementContentAsDecimal(string localName, string namespaceURI);
+        public virtual double ReadElementContentAsDouble();
+        public virtual double ReadElementContentAsDouble(string localName, string namespaceURI);
+        public virtual float ReadElementContentAsFloat();
+        public virtual float ReadElementContentAsFloat(string localName, string namespaceURI);
+        public virtual int ReadElementContentAsInt();
+        public virtual int ReadElementContentAsInt(string localName, string namespaceURI);
+        public virtual long ReadElementContentAsLong();
+        public virtual long ReadElementContentAsLong(string localName, string namespaceURI);
+        public virtual object ReadElementContentAsObject();
+        public virtual object ReadElementContentAsObject(string localName, string namespaceURI);
+        public virtual Task<object> ReadElementContentAsObjectAsync();
+        public virtual string ReadElementContentAsString();
+        public virtual string ReadElementContentAsString(string localName, string namespaceURI);
+        public virtual Task<string> ReadElementContentAsStringAsync();
+        public virtual void ReadEndElement();
+        public virtual string ReadInnerXml();
+        public virtual Task<string> ReadInnerXmlAsync();
+        public virtual string ReadOuterXml();
+        public virtual Task<string> ReadOuterXmlAsync();
+        public virtual void ReadStartElement();
+        public virtual void ReadStartElement(string name);
+        public virtual void ReadStartElement(string localname, string ns);
+        public virtual XmlReader ReadSubtree();
+        public virtual bool ReadToDescendant(string name);
+        public virtual bool ReadToDescendant(string localName, string namespaceURI);
+        public virtual bool ReadToFollowing(string name);
+        public virtual bool ReadToFollowing(string localName, string namespaceURI);
+        public virtual bool ReadToNextSibling(string name);
+        public virtual bool ReadToNextSibling(string localName, string namespaceURI);
+        public virtual int ReadValueChunk(char[] buffer, int index, int count);
+        public virtual Task<int> ReadValueChunkAsync(char[] buffer, int index, int count);
+        public abstract void ResolveEntity();
+        public virtual void Skip();
+        public virtual Task SkipAsync();
+    }
+    public sealed class XmlReaderSettings {
+        public XmlReaderSettings();
+        public bool Async { get; set; }
+        public bool CheckCharacters { get; set; }
+        public bool CloseInput { get; set; }
+        public ConformanceLevel ConformanceLevel { get; set; }
+        public DtdProcessing DtdProcessing { get; set; }
+        public bool IgnoreComments { get; set; }
+        public bool IgnoreProcessingInstructions { get; set; }
+        public bool IgnoreWhitespace { get; set; }
+        public int LineNumberOffset { get; set; }
+        public int LinePositionOffset { get; set; }
+        public long MaxCharactersFromEntities { get; set; }
+        public long MaxCharactersInDocument { get; set; }
+        public XmlNameTable NameTable { get; set; }
+        public XmlReaderSettings Clone();
+        public void Reset();
+    }
+    public class XmlSignificantWhitespace : XmlCharacterData {
+        protected internal XmlSignificantWhitespace(string strData, XmlDocument doc);
+        public override string LocalName { get; }
+        public override string Name { get; }
+        public override XmlNodeType NodeType { get; }
+        public override XmlNode ParentNode { get; }
+        public override XmlNode PreviousText { get; }
+        public override string Value { get; set; }
+        public override XmlNode CloneNode(bool deep);
+        public override void WriteContentTo(XmlWriter w);
+        public override void WriteTo(XmlWriter w);
+    }
+    public enum XmlSpace {
+        Default = 1,
+        None = 0,
+        Preserve = 2,
+    }
+    public class XmlText : XmlCharacterData {
+        protected internal XmlText(string strData, XmlDocument doc);
+        public override string LocalName { get; }
+        public override string Name { get; }
+        public override XmlNodeType NodeType { get; }
+        public override XmlNode ParentNode { get; }
+        public override XmlNode PreviousText { get; }
+        public override string Value { get; set; }
+        public override XmlNode CloneNode(bool deep);
+        public virtual XmlText SplitText(int offset);
+        public override void WriteContentTo(XmlWriter w);
+        public override void WriteTo(XmlWriter w);
+    }
+    public class XmlWhitespace : XmlCharacterData {
+        protected internal XmlWhitespace(string strData, XmlDocument doc);
+        public override string LocalName { get; }
+        public override string Name { get; }
+        public override XmlNodeType NodeType { get; }
+        public override XmlNode ParentNode { get; }
+        public override XmlNode PreviousText { get; }
+        public override string Value { get; set; }
+        public override XmlNode CloneNode(bool deep);
+        public override void WriteContentTo(XmlWriter w);
+        public override void WriteTo(XmlWriter w);
+    }
+    public abstract class XmlWriter : IDisposable {
+        protected XmlWriter();
+        public virtual XmlWriterSettings Settings { get; }
+        public abstract WriteState WriteState { get; }
+        public virtual string XmlLang { get; }
+        public virtual XmlSpace XmlSpace { get; }
+        public static XmlWriter Create(Stream output);
+        public static XmlWriter Create(Stream output, XmlWriterSettings settings);
+        public static XmlWriter Create(TextWriter output);
+        public static XmlWriter Create(TextWriter output, XmlWriterSettings settings);
+        public static XmlWriter Create(StringBuilder output);
+        public static XmlWriter Create(StringBuilder output, XmlWriterSettings settings);
+        public static XmlWriter Create(XmlWriter output);
+        public static XmlWriter Create(XmlWriter output, XmlWriterSettings settings);
+        public void Dispose();
+        protected virtual void Dispose(bool disposing);
+        public abstract void Flush();
+        public virtual Task FlushAsync();
+        public abstract string LookupPrefix(string ns);
+        public virtual void WriteAttributes(XmlReader reader, bool defattr);
+        public virtual Task WriteAttributesAsync(XmlReader reader, bool defattr);
+        public void WriteAttributeString(string localName, string value);
+        public void WriteAttributeString(string localName, string ns, string value);
+        public void WriteAttributeString(string prefix, string localName, string ns, string value);
+        public Task WriteAttributeStringAsync(string prefix, string localName, string ns, string value);
+        public abstract void WriteBase64(byte[] buffer, int index, int count);
+        public virtual Task WriteBase64Async(byte[] buffer, int index, int count);
+        public virtual void WriteBinHex(byte[] buffer, int index, int count);
+        public virtual Task WriteBinHexAsync(byte[] buffer, int index, int count);
+        public abstract void WriteCData(string text);
+        public virtual Task WriteCDataAsync(string text);
+        public abstract void WriteCharEntity(char ch);
+        public virtual Task WriteCharEntityAsync(char ch);
+        public abstract void WriteChars(char[] buffer, int index, int count);
+        public virtual Task WriteCharsAsync(char[] buffer, int index, int count);
+        public abstract void WriteComment(string text);
+        public virtual Task WriteCommentAsync(string text);
+        public abstract void WriteDocType(string name, string pubid, string sysid, string subset);
+        public virtual Task WriteDocTypeAsync(string name, string pubid, string sysid, string subset);
+        public void WriteElementString(string localName, string value);
+        public void WriteElementString(string localName, string ns, string value);
+        public void WriteElementString(string prefix, string localName, string ns, string value);
+        public Task WriteElementStringAsync(string prefix, string localName, string ns, string value);
+        public abstract void WriteEndAttribute();
+        protected internal virtual Task WriteEndAttributeAsync();
+        public abstract void WriteEndDocument();
+        public virtual Task WriteEndDocumentAsync();
+        public abstract void WriteEndElement();
+        public virtual Task WriteEndElementAsync();
+        public abstract void WriteEntityRef(string name);
+        public virtual Task WriteEntityRefAsync(string name);
+        public abstract void WriteFullEndElement();
+        public virtual Task WriteFullEndElementAsync();
+        public virtual void WriteName(string name);
+        public virtual Task WriteNameAsync(string name);
+        public virtual void WriteNmToken(string name);
+        public virtual Task WriteNmTokenAsync(string name);
+        public virtual void WriteNode(XmlReader reader, bool defattr);
+        public virtual Task WriteNodeAsync(XmlReader reader, bool defattr);
+        public abstract void WriteProcessingInstruction(string name, string text);
+        public virtual Task WriteProcessingInstructionAsync(string name, string text);
+        public virtual void WriteQualifiedName(string localName, string ns);
+        public virtual Task WriteQualifiedNameAsync(string localName, string ns);
+        public abstract void WriteRaw(char[] buffer, int index, int count);
+        public abstract void WriteRaw(string data);
+        public virtual Task WriteRawAsync(char[] buffer, int index, int count);
+        public virtual Task WriteRawAsync(string data);
+        public void WriteStartAttribute(string localName);
+        public void WriteStartAttribute(string localName, string ns);
+        public abstract void WriteStartAttribute(string prefix, string localName, string ns);
+        protected internal virtual Task WriteStartAttributeAsync(string prefix, string localName, string ns);
+        public abstract void WriteStartDocument();
+        public abstract void WriteStartDocument(bool standalone);
+        public virtual Task WriteStartDocumentAsync();
+        public virtual Task WriteStartDocumentAsync(bool standalone);
+        public void WriteStartElement(string localName);
+        public void WriteStartElement(string localName, string ns);
+        public abstract void WriteStartElement(string prefix, string localName, string ns);
+        public virtual Task WriteStartElementAsync(string prefix, string localName, string ns);
+        public abstract void WriteString(string text);
+        public virtual Task WriteStringAsync(string text);
+        public abstract void WriteSurrogateCharEntity(char lowChar, char highChar);
+        public virtual Task WriteSurrogateCharEntityAsync(char lowChar, char highChar);
+        public virtual void WriteValue(bool value);
+        public virtual void WriteValue(DateTimeOffset value);
+        public virtual void WriteValue(Decimal value);
+        public virtual void WriteValue(double value);
+        public virtual void WriteValue(int value);
+        public virtual void WriteValue(long value);
+        public virtual void WriteValue(object value);
+        public virtual void WriteValue(float value);
+        public virtual void WriteValue(string value);
+        public abstract void WriteWhitespace(string ws);
+        public virtual Task WriteWhitespaceAsync(string ws);
+    }
+    public sealed class XmlWriterSettings {
+        public XmlWriterSettings();
+        public bool Async { get; set; }
+        public bool CheckCharacters { get; set; }
+        public bool CloseOutput { get; set; }
+        public ConformanceLevel ConformanceLevel { get; set; }
+        public Encoding Encoding { get; set; }
+        public bool Indent { get; set; }
+        public string IndentChars { get; set; }
+        public NamespaceHandling NamespaceHandling { get; set; }
+        public string NewLineChars { get; set; }
+        public NewLineHandling NewLineHandling { get; set; }
+        public bool NewLineOnAttributes { get; set; }
+        public bool OmitXmlDeclaration { get; set; }
+        public bool WriteEndDocumentOnClose { get; set; }
+        public XmlWriterSettings Clone();
+        public void Reset();
+    }
+}
```

## System.Xml.Linq

```c#
+namespace System.Xml.Linq {
+    public static class Extensions {
+        public static IEnumerable<XElement> Ancestors<T>(this IEnumerable<T> source) where T : XNode;
+        public static IEnumerable<XElement> Ancestors<T>(this IEnumerable<T> source, XName name) where T : XNode;
+        public static IEnumerable<XElement> AncestorsAndSelf(this IEnumerable<XElement> source);
+        public static IEnumerable<XElement> AncestorsAndSelf(this IEnumerable<XElement> source, XName name);
+        public static IEnumerable<XAttribute> Attributes(this IEnumerable<XElement> source);
+        public static IEnumerable<XAttribute> Attributes(this IEnumerable<XElement> source, XName name);
+        public static IEnumerable<XNode> DescendantNodes<T>(this IEnumerable<T> source) where T : XContainer;
+        public static IEnumerable<XNode> DescendantNodesAndSelf(this IEnumerable<XElement> source);
+        public static IEnumerable<XElement> Descendants<T>(this IEnumerable<T> source) where T : XContainer;
+        public static IEnumerable<XElement> Descendants<T>(this IEnumerable<T> source, XName name) where T : XContainer;
+        public static IEnumerable<XElement> DescendantsAndSelf(this IEnumerable<XElement> source);
+        public static IEnumerable<XElement> DescendantsAndSelf(this IEnumerable<XElement> source, XName name);
+        public static IEnumerable<XElement> Elements<T>(this IEnumerable<T> source) where T : XContainer;
+        public static IEnumerable<XElement> Elements<T>(this IEnumerable<T> source, XName name) where T : XContainer;
+        public static IEnumerable<T> InDocumentOrder<T>(this IEnumerable<T> source) where T : XNode;
+        public static IEnumerable<XNode> Nodes<T>(this IEnumerable<T> source) where T : XContainer;
+        public static void Remove(this IEnumerable<XAttribute> source);
+        public static void Remove<T>(this IEnumerable<T> source) where T : XNode;
+    }
+    public enum LoadOptions {
+        None = 0,
+        PreserveWhitespace = 1,
+        SetBaseUri = 2,
+        SetLineInfo = 4,
+    }
+    public enum ReaderOptions {
+        None = 0,
+        OmitDuplicateNamespaces = 1,
+    }
+    public enum SaveOptions {
+        DisableFormatting = 1,
+        None = 0,
+        OmitDuplicateNamespaces = 2,
+    }
+    public class XAttribute : XObject {
+        public XAttribute(XAttribute other);
+        public XAttribute(XName name, object value);
+        public static IEnumerable<XAttribute> EmptySequence { get; }
+        public bool IsNamespaceDeclaration { get; }
+        public XName Name { get; }
+        public XAttribute NextAttribute { get; }
+        public override XmlNodeType NodeType { get; }
+        public XAttribute PreviousAttribute { get; }
+        public string Value { get; set; }
+        public static explicit operator bool (XAttribute attribute);
+        public static explicit operator DateTime (XAttribute attribute);
+        public static explicit operator DateTimeOffset (XAttribute attribute);
+        public static explicit operator Decimal (XAttribute attribute);
+        public static explicit operator double (XAttribute attribute);
+        public static explicit operator Guid (XAttribute attribute);
+        public static explicit operator int (XAttribute attribute);
+        public static explicit operator long (XAttribute attribute);
+        public static explicit operator Nullable<bool> (XAttribute attribute);
+        public static explicit operator Nullable<DateTime> (XAttribute attribute);
+        public static explicit operator Nullable<DateTimeOffset> (XAttribute attribute);
+        public static explicit operator Nullable<Decimal> (XAttribute attribute);
+        public static explicit operator Nullable<double> (XAttribute attribute);
+        public static explicit operator Nullable<Guid> (XAttribute attribute);
+        public static explicit operator Nullable<int> (XAttribute attribute);
+        public static explicit operator Nullable<long> (XAttribute attribute);
+        public static explicit operator Nullable<float> (XAttribute attribute);
+        public static explicit operator Nullable<TimeSpan> (XAttribute attribute);
+        public static explicit operator Nullable<uint> (XAttribute attribute);
+        public static explicit operator Nullable<ulong> (XAttribute attribute);
+        public static explicit operator float (XAttribute attribute);
+        public static explicit operator string (XAttribute attribute);
+        public static explicit operator TimeSpan (XAttribute attribute);
+        public static explicit operator uint (XAttribute attribute);
+        public static explicit operator ulong (XAttribute attribute);
+        public void Remove();
+        public void SetValue(object value);
+        public override string ToString();
+    }
+    public class XCData : XText {
+        public XCData(string value);
+        public XCData(XCData other);
+        public override XmlNodeType NodeType { get; }
+        public override void WriteTo(XmlWriter writer);
+    }
+    public class XComment : XNode {
+        public XComment(string value);
+        public XComment(XComment other);
+        public override XmlNodeType NodeType { get; }
+        public string Value { get; set; }
+        public override void WriteTo(XmlWriter writer);
+    }
+    public abstract class XContainer : XNode {
+        public XNode FirstNode { get; }
+        public XNode LastNode { get; }
+        public void Add(object content);
+        public void Add(params object[] content);
+        public void AddFirst(object content);
+        public void AddFirst(params object[] content);
+        public XmlWriter CreateWriter();
+        public IEnumerable<XNode> DescendantNodes();
+        public IEnumerable<XElement> Descendants();
+        public IEnumerable<XElement> Descendants(XName name);
+        public XElement Element(XName name);
+        public IEnumerable<XElement> Elements();
+        public IEnumerable<XElement> Elements(XName name);
+        public IEnumerable<XNode> Nodes();
+        public void RemoveNodes();
+        public void ReplaceNodes(object content);
+        public void ReplaceNodes(params object[] content);
+    }
+    public class XDeclaration {
+        public XDeclaration(string version, string encoding, string standalone);
+        public XDeclaration(XDeclaration other);
+        public string Encoding { get; set; }
+        public string Standalone { get; set; }
+        public string Version { get; set; }
+        public override string ToString();
+    }
+    public class XDocument : XContainer {
+        public XDocument();
+        public XDocument(params object[] content);
+        public XDocument(XDeclaration declaration, params object[] content);
+        public XDocument(XDocument other);
+        public XDeclaration Declaration { get; set; }
+        public XDocumentType DocumentType { get; }
+        public override XmlNodeType NodeType { get; }
+        public XElement Root { get; }
+        public static XDocument Load(Stream stream);
+        public static XDocument Load(Stream stream, LoadOptions options);
+        public static XDocument Load(TextReader textReader);
+        public static XDocument Load(TextReader textReader, LoadOptions options);
+        public static XDocument Load(string uri);
+        public static XDocument Load(string uri, LoadOptions options);
+        public static XDocument Load(XmlReader reader);
+        public static XDocument Load(XmlReader reader, LoadOptions options);
+        public static XDocument Parse(string text);
+        public static XDocument Parse(string text, LoadOptions options);
+        public void Save(Stream stream);
+        public void Save(Stream stream, SaveOptions options);
+        public void Save(TextWriter textWriter);
+        public void Save(TextWriter textWriter, SaveOptions options);
+        public void Save(XmlWriter writer);
+        public override void WriteTo(XmlWriter writer);
+    }
+    public class XDocumentType : XNode {
+        public XDocumentType(string name, string publicId, string systemId, string internalSubset);
+        public XDocumentType(XDocumentType other);
+        public string InternalSubset { get; set; }
+        public string Name { get; set; }
+        public override XmlNodeType NodeType { get; }
+        public string PublicId { get; set; }
+        public string SystemId { get; set; }
+        public override void WriteTo(XmlWriter writer);
+    }
+    public class XElement : XContainer, IXmlSerializable {
+        public XElement(XElement other);
+        public XElement(XName name);
+        public XElement(XName name, object content);
+        public XElement(XName name, params object[] content);
+        public XElement(XStreamingElement other);
+        public static IEnumerable<XElement> EmptySequence { get; }
+        public XAttribute FirstAttribute { get; }
+        public bool HasAttributes { get; }
+        public bool HasElements { get; }
+        public bool IsEmpty { get; }
+        public XAttribute LastAttribute { get; }
+        public XName Name { get; set; }
+        public override XmlNodeType NodeType { get; }
+        public string Value { get; set; }
+        public IEnumerable<XElement> AncestorsAndSelf();
+        public IEnumerable<XElement> AncestorsAndSelf(XName name);
+        public XAttribute Attribute(XName name);
+        public IEnumerable<XAttribute> Attributes();
+        public IEnumerable<XAttribute> Attributes(XName name);
+        public IEnumerable<XNode> DescendantNodesAndSelf();
+        public IEnumerable<XElement> DescendantsAndSelf();
+        public IEnumerable<XElement> DescendantsAndSelf(XName name);
+        public XNamespace GetDefaultNamespace();
+        public XNamespace GetNamespaceOfPrefix(string prefix);
+        public string GetPrefixOfNamespace(XNamespace ns);
+        public static XElement Load(Stream stream);
+        public static XElement Load(Stream stream, LoadOptions options);
+        public static XElement Load(TextReader textReader);
+        public static XElement Load(TextReader textReader, LoadOptions options);
+        public static XElement Load(string uri);
+        public static XElement Load(string uri, LoadOptions options);
+        public static XElement Load(XmlReader reader);
+        public static XElement Load(XmlReader reader, LoadOptions options);
+        public static explicit operator bool (XElement element);
+        public static explicit operator DateTime (XElement element);
+        public static explicit operator DateTimeOffset (XElement element);
+        public static explicit operator Decimal (XElement element);
+        public static explicit operator double (XElement element);
+        public static explicit operator Guid (XElement element);
+        public static explicit operator int (XElement element);
+        public static explicit operator long (XElement element);
+        public static explicit operator Nullable<bool> (XElement element);
+        public static explicit operator Nullable<DateTime> (XElement element);
+        public static explicit operator Nullable<DateTimeOffset> (XElement element);
+        public static explicit operator Nullable<Decimal> (XElement element);
+        public static explicit operator Nullable<double> (XElement element);
+        public static explicit operator Nullable<Guid> (XElement element);
+        public static explicit operator Nullable<int> (XElement element);
+        public static explicit operator Nullable<long> (XElement element);
+        public static explicit operator Nullable<float> (XElement element);
+        public static explicit operator Nullable<TimeSpan> (XElement element);
+        public static explicit operator Nullable<uint> (XElement element);
+        public static explicit operator Nullable<ulong> (XElement element);
+        public static explicit operator float (XElement element);
+        public static explicit operator string (XElement element);
+        public static explicit operator TimeSpan (XElement element);
+        public static explicit operator uint (XElement element);
+        public static explicit operator ulong (XElement element);
+        public static XElement Parse(string text);
+        public static XElement Parse(string text, LoadOptions options);
+        public void RemoveAll();
+        public void RemoveAttributes();
+        public void ReplaceAll(object content);
+        public void ReplaceAll(params object[] content);
+        public void ReplaceAttributes(object content);
+        public void ReplaceAttributes(params object[] content);
+        public void Save(Stream stream);
+        public void Save(Stream stream, SaveOptions options);
+        public void Save(TextWriter textWriter);
+        public void Save(TextWriter textWriter, SaveOptions options);
+        public void Save(XmlWriter writer);
+        public void SetAttributeValue(XName name, object value);
+        public void SetElementValue(XName name, object value);
+        public void SetValue(object value);
+        XmlSchema System.Xml.Serialization.IXmlSerializable.GetSchema();
+        void System.Xml.Serialization.IXmlSerializable.ReadXml(XmlReader reader);
+        void System.Xml.Serialization.IXmlSerializable.WriteXml(XmlWriter writer);
+        public override void WriteTo(XmlWriter writer);
+    }
+    public sealed class XName : IEquatable<XName> {
+        public string LocalName { get; }
+        public XNamespace Namespace { get; }
+        public string NamespaceName { get; }
+        public override bool Equals(object obj);
+        public static XName Get(string expandedName);
+        public static XName Get(string localName, string namespaceName);
+        public override int GetHashCode();
+        public static bool operator ==(XName left, XName right);
+        public static implicit operator XName (string expandedName);
+        public static bool operator !=(XName left, XName right);
+        bool System.IEquatable<System.Xml.Linq.XName>.Equals(XName other);
+        public override string ToString();
+    }
+    public sealed class XNamespace {
+        public string NamespaceName { get; }
+        public static XNamespace None { get; }
+        public static XNamespace Xml { get; }
+        public static XNamespace Xmlns { get; }
+        public override bool Equals(object obj);
+        public static XNamespace Get(string namespaceName);
+        public override int GetHashCode();
+        public XName GetName(string localName);
+        public static XName operator +(XNamespace ns, string localName);
+        public static bool operator ==(XNamespace left, XNamespace right);
+        public static implicit operator XNamespace (string namespaceName);
+        public static bool operator !=(XNamespace left, XNamespace right);
+        public override string ToString();
+    }
+    public abstract class XNode : XObject {
+        public static XNodeDocumentOrderComparer DocumentOrderComparer { get; }
+        public static XNodeEqualityComparer EqualityComparer { get; }
+        public XNode NextNode { get; }
+        public XNode PreviousNode { get; }
+        public void AddAfterSelf(object content);
+        public void AddAfterSelf(params object[] content);
+        public void AddBeforeSelf(object content);
+        public void AddBeforeSelf(params object[] content);
+        public IEnumerable<XElement> Ancestors();
+        public IEnumerable<XElement> Ancestors(XName name);
+        public static int CompareDocumentOrder(XNode n1, XNode n2);
+        public XmlReader CreateReader();
+        public XmlReader CreateReader(ReaderOptions readerOptions);
+        public static bool DeepEquals(XNode n1, XNode n2);
+        public IEnumerable<XElement> ElementsAfterSelf();
+        public IEnumerable<XElement> ElementsAfterSelf(XName name);
+        public IEnumerable<XElement> ElementsBeforeSelf();
+        public IEnumerable<XElement> ElementsBeforeSelf(XName name);
+        public bool IsAfter(XNode node);
+        public bool IsBefore(XNode node);
+        public IEnumerable<XNode> NodesAfterSelf();
+        public IEnumerable<XNode> NodesBeforeSelf();
+        public static XNode ReadFrom(XmlReader reader);
+        public void Remove();
+        public void ReplaceWith(object content);
+        public void ReplaceWith(params object[] content);
+        public override string ToString();
+        public string ToString(SaveOptions options);
+        public abstract void WriteTo(XmlWriter writer);
+    }
+    public sealed class XNodeDocumentOrderComparer : IComparer, IComparer<XNode> {
+        public XNodeDocumentOrderComparer();
+        public int Compare(XNode x, XNode y);
+        int System.Collections.IComparer.Compare(object x, object y);
+    }
+    public sealed class XNodeEqualityComparer : IEqualityComparer, IEqualityComparer<XNode> {
+        public XNodeEqualityComparer();
+        public bool Equals(XNode x, XNode y);
+        public int GetHashCode(XNode obj);
+        bool System.Collections.IEqualityComparer.Equals(object x, object y);
+        int System.Collections.IEqualityComparer.GetHashCode(object obj);
+    }
+    public abstract class XObject : IXmlLineInfo {
+        public string BaseUri { get; }
+        public XDocument Document { get; }
+        public abstract XmlNodeType NodeType { get; }
+        public XElement Parent { get; }
+        int System.Xml.IXmlLineInfo.LineNumber { get; }
+        int System.Xml.IXmlLineInfo.LinePosition { get; }
+        public event EventHandler<XObjectChangeEventArgs> Changed;
+        public event EventHandler<XObjectChangeEventArgs> Changing;
+        public void AddAnnotation(object annotation);
+        public object Annotation(Type type);
+        public T Annotation<T>() where T : class;
+        public IEnumerable<object> Annotations(Type type);
+        public IEnumerable<T> Annotations<T>() where T : class;
+        public void RemoveAnnotations(Type type);
+        public void RemoveAnnotations<T>() where T : class;
+        bool System.Xml.IXmlLineInfo.HasLineInfo();
+    }
+    public enum XObjectChange {
+        Add = 0,
+        Name = 2,
+        Remove = 1,
+        Value = 3,
+    }
+    public class XObjectChangeEventArgs : EventArgs {
+        public static readonly XObjectChangeEventArgs Add;
+        public static readonly XObjectChangeEventArgs Name;
+        public static readonly XObjectChangeEventArgs Remove;
+        public static readonly XObjectChangeEventArgs Value;
+        public XObjectChangeEventArgs(XObjectChange objectChange);
+        public XObjectChange ObjectChange { get; }
+    }
+    public class XProcessingInstruction : XNode {
+        public XProcessingInstruction(string target, string data);
+        public XProcessingInstruction(XProcessingInstruction other);
+        public string Data { get; set; }
+        public override XmlNodeType NodeType { get; }
+        public string Target { get; set; }
+        public override void WriteTo(XmlWriter writer);
+    }
+    public class XStreamingElement {
+        public XStreamingElement(XName name);
+        public XStreamingElement(XName name, object content);
+        public XStreamingElement(XName name, params object[] content);
+        public XName Name { get; set; }
+        public void Add(object content);
+        public void Add(params object[] content);
+        public void Save(Stream stream);
+        public void Save(Stream stream, SaveOptions options);
+        public void Save(TextWriter textWriter);
+        public void Save(TextWriter textWriter, SaveOptions options);
+        public void Save(XmlWriter writer);
+        public override string ToString();
+        public string ToString(SaveOptions options);
+        public void WriteTo(XmlWriter writer);
+    }
+    public class XText : XNode {
+        public XText(string value);
+        public XText(XText other);
+        public override XmlNodeType NodeType { get; }
+        public string Value { get; set; }
+        public override void WriteTo(XmlWriter writer);
+    }
+}
```

## System.Xml.Schema

```c#
+namespace System.Xml.Schema {
+    public class XmlSchema
+    public enum XmlSchemaForm {
+        None = 0,
+        Qualified = 1,
+        Unqualified = 2,
+    }
+}
```

## System.Xml.Serialization

```c#
+namespace System.Xml.Serialization {
+    public interface IXmlSerializable {
+        XmlSchema GetSchema();
+        void ReadXml(XmlReader reader);
+        void WriteXml(XmlWriter writer);
+    }
+    public class XmlAnyAttributeAttribute : Attribute {
+        public XmlAnyAttributeAttribute();
+    }
+    public class XmlAnyElementAttribute : Attribute {
+        public XmlAnyElementAttribute();
+        public XmlAnyElementAttribute(string name);
+        public XmlAnyElementAttribute(string name, string ns);
+        public string Name { get; set; }
+        public string Namespace { get; set; }
+        public int Order { get; set; }
+    }
+    public class XmlAnyElementAttributes : ICollection, IEnumerable, IList {
+        public XmlAnyElementAttributes();
+        public int Count { get; }
+        bool System.Collections.ICollection.IsSynchronized { get; }
+        object System.Collections.ICollection.SyncRoot { get; }
+        bool System.Collections.IList.IsFixedSize { get; }
+        bool System.Collections.IList.IsReadOnly { get; }
+        object System.Collections.IList.this[int index] { get; set; }
+        public XmlAnyElementAttribute this[int index] { get; set; }
+        public int Add(XmlAnyElementAttribute attribute);
+        public void Clear();
+        public bool Contains(XmlAnyElementAttribute attribute);
+        public void CopyTo(XmlAnyElementAttribute[] array, int index);
+        public IEnumerator GetEnumerator();
+        public int IndexOf(XmlAnyElementAttribute attribute);
+        public void Insert(int index, XmlAnyElementAttribute attribute);
+        public void Remove(XmlAnyElementAttribute attribute);
+        public void RemoveAt(int index);
+        void System.Collections.ICollection.CopyTo(Array array, int index);
+        int System.Collections.IList.Add(object value);
+        bool System.Collections.IList.Contains(object value);
+        int System.Collections.IList.IndexOf(object value);
+        void System.Collections.IList.Insert(int index, object value);
+        void System.Collections.IList.Remove(object value);
+    }
+    public class XmlArrayAttribute : Attribute {
+        public XmlArrayAttribute();
+        public XmlArrayAttribute(string elementName);
+        public string ElementName { get; set; }
+        public XmlSchemaForm Form { get; set; }
+        public bool IsNullable { get; set; }
+        public string Namespace { get; set; }
+        public int Order { get; set; }
+    }
+    public class XmlArrayItemAttribute : Attribute {
+        public XmlArrayItemAttribute();
+        public XmlArrayItemAttribute(string elementName);
+        public XmlArrayItemAttribute(string elementName, Type type);
+        public XmlArrayItemAttribute(Type type);
+        public string DataType { get; set; }
+        public string ElementName { get; set; }
+        public XmlSchemaForm Form { get; set; }
+        public bool IsNullable { get; set; }
+        public string Namespace { get; set; }
+        public int NestingLevel { get; set; }
+        public Type Type { get; set; }
+    }
+    public class XmlArrayItemAttributes : ICollection, IEnumerable, IList {
+        public XmlArrayItemAttributes();
+        public int Count { get; }
+        bool System.Collections.ICollection.IsSynchronized { get; }
+        object System.Collections.ICollection.SyncRoot { get; }
+        bool System.Collections.IList.IsFixedSize { get; }
+        bool System.Collections.IList.IsReadOnly { get; }
+        object System.Collections.IList.this[int index] { get; set; }
+        public XmlArrayItemAttribute this[int index] { get; set; }
+        public int Add(XmlArrayItemAttribute attribute);
+        public void Clear();
+        public bool Contains(XmlArrayItemAttribute attribute);
+        public void CopyTo(XmlArrayItemAttribute[] array, int index);
+        public IEnumerator GetEnumerator();
+        public int IndexOf(XmlArrayItemAttribute attribute);
+        public void Insert(int index, XmlArrayItemAttribute attribute);
+        public void Remove(XmlArrayItemAttribute attribute);
+        public void RemoveAt(int index);
+        void System.Collections.ICollection.CopyTo(Array array, int index);
+        int System.Collections.IList.Add(object value);
+        bool System.Collections.IList.Contains(object value);
+        int System.Collections.IList.IndexOf(object value);
+        void System.Collections.IList.Insert(int index, object value);
+        void System.Collections.IList.Remove(object value);
+    }
+    public class XmlAttributeAttribute : Attribute {
+        public XmlAttributeAttribute();
+        public XmlAttributeAttribute(string attributeName);
+        public XmlAttributeAttribute(string attributeName, Type type);
+        public XmlAttributeAttribute(Type type);
+        public string AttributeName { get; set; }
+        public string DataType { get; set; }
+        public XmlSchemaForm Form { get; set; }
+        public string Namespace { get; set; }
+        public Type Type { get; set; }
+    }
+    public class XmlAttributeOverrides {
+        public XmlAttributeOverrides();
+        public XmlAttributes this[Type type, string member] { get; }
+        public XmlAttributes this[Type type] { get; }
+        public void Add(Type type, string member, XmlAttributes attributes);
+        public void Add(Type type, XmlAttributes attributes);
+    }
+    public class XmlAttributes {
+        public XmlAttributes();
+        public XmlAnyAttributeAttribute XmlAnyAttribute { get; set; }
+        public XmlAnyElementAttributes XmlAnyElements { get; }
+        public XmlArrayAttribute XmlArray { get; set; }
+        public XmlArrayItemAttributes XmlArrayItems { get; }
+        public XmlAttributeAttribute XmlAttribute { get; set; }
+        public XmlChoiceIdentifierAttribute XmlChoiceIdentifier { get; }
+        public object XmlDefaultValue { get; set; }
+        public XmlElementAttributes XmlElements { get; }
+        public XmlEnumAttribute XmlEnum { get; set; }
+        public bool XmlIgnore { get; set; }
+        public bool Xmlns { get; set; }
+        public XmlRootAttribute XmlRoot { get; set; }
+        public XmlTextAttribute XmlText { get; set; }
+        public XmlTypeAttribute XmlType { get; set; }
+    }
+    public class XmlChoiceIdentifierAttribute : Attribute {
+        public XmlChoiceIdentifierAttribute();
+        public XmlChoiceIdentifierAttribute(string name);
+        public string MemberName { get; set; }
+    }
+    public class XmlElementAttribute : Attribute {
+        public XmlElementAttribute();
+        public XmlElementAttribute(string elementName);
+        public XmlElementAttribute(string elementName, Type type);
+        public XmlElementAttribute(Type type);
+        public string DataType { get; set; }
+        public string ElementName { get; set; }
+        public XmlSchemaForm Form { get; set; }
+        public bool IsNullable { get; set; }
+        public string Namespace { get; set; }
+        public int Order { get; set; }
+        public Type Type { get; set; }
+    }
+    public class XmlElementAttributes : ICollection, IEnumerable, IList {
+        public XmlElementAttributes();
+        public int Count { get; }
+        bool System.Collections.ICollection.IsSynchronized { get; }
+        object System.Collections.ICollection.SyncRoot { get; }
+        bool System.Collections.IList.IsFixedSize { get; }
+        bool System.Collections.IList.IsReadOnly { get; }
+        object System.Collections.IList.this[int index] { get; set; }
+        public XmlElementAttribute this[int index] { get; set; }
+        public int Add(XmlElementAttribute attribute);
+        public void Clear();
+        public bool Contains(XmlElementAttribute attribute);
+        public void CopyTo(XmlElementAttribute[] array, int index);
+        public IEnumerator GetEnumerator();
+        public int IndexOf(XmlElementAttribute attribute);
+        public void Insert(int index, XmlElementAttribute attribute);
+        public void Remove(XmlElementAttribute attribute);
+        public void RemoveAt(int index);
+        void System.Collections.ICollection.CopyTo(Array array, int index);
+        int System.Collections.IList.Add(object value);
+        bool System.Collections.IList.Contains(object value);
+        int System.Collections.IList.IndexOf(object value);
+        void System.Collections.IList.Insert(int index, object value);
+        void System.Collections.IList.Remove(object value);
+    }
+    public class XmlEnumAttribute : Attribute {
+        public XmlEnumAttribute();
+        public XmlEnumAttribute(string name);
+        public string Name { get; set; }
+    }
+    public class XmlIgnoreAttribute : Attribute {
+        public XmlIgnoreAttribute();
+    }
+    public class XmlIncludeAttribute : Attribute {
+        public XmlIncludeAttribute(Type type);
+        public Type Type { get; set; }
+    }
+    public class XmlNamespaceDeclarationsAttribute : Attribute {
+        public XmlNamespaceDeclarationsAttribute();
+    }
+    public class XmlRootAttribute : Attribute {
+        public XmlRootAttribute();
+        public XmlRootAttribute(string elementName);
+        public string DataType { get; set; }
+        public string ElementName { get; set; }
+        public bool IsNullable { get; set; }
+        public string Namespace { get; set; }
+    }
+    public sealed class XmlSchemaProviderAttribute : Attribute {
+        public XmlSchemaProviderAttribute(string methodName);
+        public bool IsAny { get; set; }
+        public string MethodName { get; }
+    }
+    public class XmlSerializer {
+        protected XmlSerializer();
+        public XmlSerializer(Type type);
+        public XmlSerializer(Type type, string defaultNamespace);
+        public XmlSerializer(Type type, Type[] extraTypes);
+        public XmlSerializer(Type type, XmlAttributeOverrides overrides);
+        public XmlSerializer(Type type, XmlAttributeOverrides overrides, Type[] extraTypes, XmlRootAttribute root, string defaultNamespace);
+        public XmlSerializer(Type type, XmlRootAttribute root);
+        public virtual bool CanDeserialize(XmlReader xmlReader);
+        public object Deserialize(Stream stream);
+        public object Deserialize(TextReader textReader);
+        public object Deserialize(XmlReader xmlReader);
+        public static XmlSerializer[] FromTypes(Type[] types);
+        public void Serialize(Stream stream, object o);
+        public void Serialize(Stream stream, object o, XmlSerializerNamespaces namespaces);
+        public void Serialize(TextWriter textWriter, object o);
+        public void Serialize(TextWriter textWriter, object o, XmlSerializerNamespaces namespaces);
+        public void Serialize(XmlWriter xmlWriter, object o);
+        public void Serialize(XmlWriter xmlWriter, object o, XmlSerializerNamespaces namespaces);
+    }
+    public class XmlSerializerNamespaces {
+        public XmlSerializerNamespaces();
+        public XmlSerializerNamespaces(XmlSerializerNamespaces namespaces);
+        public XmlSerializerNamespaces(XmlQualifiedName[] namespaces);
+        public int Count { get; }
+        public void Add(string prefix, string ns);
+        public XmlQualifiedName[] ToArray();
+    }
+    public class XmlTextAttribute : Attribute {
+        public XmlTextAttribute();
+        public XmlTextAttribute(Type type);
+        public string DataType { get; set; }
+        public Type Type { get; set; }
+    }
+    public class XmlTypeAttribute : Attribute {
+        public XmlTypeAttribute();
+        public XmlTypeAttribute(string typeName);
+        public bool AnonymousType { get; set; }
+        public bool IncludeInSchema { get; set; }
+        public string Namespace { get; set; }
+        public string TypeName { get; set; }
+    }
+}
```

## System.Xml.XPath

```c#
+namespace System.Xml.XPath {
+    public static class Extensions {
+        public static XPathNavigator CreateNavigator(this XNode node);
+        public static XPathNavigator CreateNavigator(this XNode node, XmlNameTable nameTable);
+        public static object XPathEvaluate(this XNode node, string expression);
+        public static object XPathEvaluate(this XNode node, string expression, IXmlNamespaceResolver resolver);
+        public static XElement XPathSelectElement(this XNode node, string expression);
+        public static XElement XPathSelectElement(this XNode node, string expression, IXmlNamespaceResolver resolver);
+        public static IEnumerable<XElement> XPathSelectElements(this XNode node, string expression);
+        public static IEnumerable<XElement> XPathSelectElements(this XNode node, string expression, IXmlNamespaceResolver resolver);
+    }
+    public interface IXPathNavigable {
+        XPathNavigator CreateNavigator();
+    }
+    public static class XDocumentExtensions {
+        public static IXPathNavigable ToXPathNavigable(this XNode node);
+    }
+    public enum XmlCaseOrder {
+        LowerFirst = 2,
+        None = 0,
+        UpperFirst = 1,
+    }
+    public enum XmlDataType {
+        Number = 2,
+        Text = 1,
+    }
+    public enum XmlSortOrder {
+        Ascending = 1,
+        Descending = 2,
+    }
+    public class XPathDocument : IXPathNavigable {
+        public XPathDocument(Stream stream);
+        public XPathDocument(TextReader textReader);
+        public XPathDocument(string uri);
+        public XPathDocument(string uri, XmlSpace space);
+        public XPathDocument(XmlReader reader);
+        public XPathDocument(XmlReader reader, XmlSpace space);
+        public XPathNavigator CreateNavigator();
+    }
+    public class XPathException : Exception {
+        public XPathException();
+        public XPathException(string message);
+        public XPathException(string message, Exception innerException);
+    }
+    public abstract class XPathExpression {
+        public abstract string Expression { get; }
+        public abstract XPathResultType ReturnType { get; }
+        public abstract void AddSort(object expr, IComparer comparer);
+        public abstract void AddSort(object expr, XmlSortOrder order, XmlCaseOrder caseOrder, string lang, XmlDataType dataType);
+        public abstract XPathExpression Clone();
+        public static XPathExpression Compile(string xpath);
+        public static XPathExpression Compile(string xpath, IXmlNamespaceResolver nsResolver);
+        public abstract void SetContext(IXmlNamespaceResolver nsResolver);
+        public abstract void SetContext(XmlNamespaceManager nsManager);
+    }
+    public abstract class XPathItem {
+        public abstract bool IsNode { get; }
+        public abstract object TypedValue { get; }
+        public abstract string Value { get; }
+        public abstract bool ValueAsBoolean { get; }
+        public abstract DateTime ValueAsDateTime { get; }
+        public abstract double ValueAsDouble { get; }
+        public abstract int ValueAsInt { get; }
+        public abstract long ValueAsLong { get; }
+        public abstract Type ValueType { get; }
+        public virtual object ValueAs(Type returnType);
+        public abstract object ValueAs(Type returnType, IXmlNamespaceResolver nsResolver);
+    }
+    public enum XPathNamespaceScope {
+        All = 0,
+        ExcludeXml = 1,
+        Local = 2,
+    }
+    public abstract class XPathNavigator : XPathItem, IXmlNamespaceResolver, IXPathNavigable {
+        protected XPathNavigator();
+        public abstract string BaseURI { get; }
+        public virtual bool CanEdit { get; }
+        public virtual bool HasAttributes { get; }
+        public virtual bool HasChildren { get; }
+        public virtual string InnerXml { get; set; }
+        public abstract bool IsEmptyElement { get; }
+        public sealed override bool IsNode { get; }
+        public abstract string LocalName { get; }
+        public abstract string Name { get; }
+        public abstract string NamespaceURI { get; }
+        public abstract XmlNameTable NameTable { get; }
+        public static IEqualityComparer NavigatorComparer { get; }
+        public abstract XPathNodeType NodeType { get; }
+        public virtual string OuterXml { get; set; }
+        public abstract string Prefix { get; }
+        public override object TypedValue { get; }
+        public virtual object UnderlyingObject { get; }
+        public override bool ValueAsBoolean { get; }
+        public override DateTime ValueAsDateTime { get; }
+        public override double ValueAsDouble { get; }
+        public override int ValueAsInt { get; }
+        public override long ValueAsLong { get; }
+        public override Type ValueType { get; }
+        public virtual string XmlLang { get; }
+        public virtual XmlWriter AppendChild();
+        public virtual void AppendChild(string newChild);
+        public virtual void AppendChild(XmlReader newChild);
+        public virtual void AppendChild(XPathNavigator newChild);
+        public virtual void AppendChildElement(string prefix, string localName, string namespaceURI, string value);
+        public abstract XPathNavigator Clone();
+        public virtual XmlNodeOrder ComparePosition(XPathNavigator nav);
+        public virtual XPathExpression Compile(string xpath);
+        public virtual void CreateAttribute(string prefix, string localName, string namespaceURI, string value);
+        public virtual XmlWriter CreateAttributes();
+        public virtual XPathNavigator CreateNavigator();
+        public virtual void DeleteRange(XPathNavigator lastSiblingToDelete);
+        public virtual void DeleteSelf();
+        public virtual object Evaluate(string xpath);
+        public virtual object Evaluate(string xpath, IXmlNamespaceResolver resolver);
+        public virtual object Evaluate(XPathExpression expr);
+        public virtual object Evaluate(XPathExpression expr, XPathNodeIterator context);
+        public virtual string GetAttribute(string localName, string namespaceURI);
+        public virtual string GetNamespace(string name);
+        public virtual IDictionary<string, string> GetNamespacesInScope(XmlNamespaceScope scope);
+        public virtual XmlWriter InsertAfter();
+        public virtual void InsertAfter(string newSibling);
+        public virtual void InsertAfter(XmlReader newSibling);
+        public virtual void InsertAfter(XPathNavigator newSibling);
+        public virtual XmlWriter InsertBefore();
+        public virtual void InsertBefore(string newSibling);
+        public virtual void InsertBefore(XmlReader newSibling);
+        public virtual void InsertBefore(XPathNavigator newSibling);
+        public virtual void InsertElementAfter(string prefix, string localName, string namespaceURI, string value);
+        public virtual void InsertElementBefore(string prefix, string localName, string namespaceURI, string value);
+        public virtual bool IsDescendant(XPathNavigator nav);
+        public abstract bool IsSamePosition(XPathNavigator other);
+        public virtual string LookupNamespace(string prefix);
+        public virtual string LookupPrefix(string namespaceURI);
+        public virtual bool Matches(string xpath);
+        public virtual bool Matches(XPathExpression expr);
+        public abstract bool MoveTo(XPathNavigator other);
+        public virtual bool MoveToAttribute(string localName, string namespaceURI);
+        public virtual bool MoveToChild(string localName, string namespaceURI);
+        public virtual bool MoveToChild(XPathNodeType type);
+        public virtual bool MoveToFirst();
+        public abstract bool MoveToFirstAttribute();
+        public abstract bool MoveToFirstChild();
+        public bool MoveToFirstNamespace();
+        public abstract bool MoveToFirstNamespace(XPathNamespaceScope namespaceScope);
+        public virtual bool MoveToFollowing(string localName, string namespaceURI);
+        public virtual bool MoveToFollowing(string localName, string namespaceURI, XPathNavigator end);
+        public virtual bool MoveToFollowing(XPathNodeType type);
+        public virtual bool MoveToFollowing(XPathNodeType type, XPathNavigator end);
+        public abstract bool MoveToId(string id);
+        public virtual bool MoveToNamespace(string name);
+        public abstract bool MoveToNext();
+        public virtual bool MoveToNext(string localName, string namespaceURI);
+        public virtual bool MoveToNext(XPathNodeType type);
+        public abstract bool MoveToNextAttribute();
+        public bool MoveToNextNamespace();
+        public abstract bool MoveToNextNamespace(XPathNamespaceScope namespaceScope);
+        public abstract bool MoveToParent();
+        public abstract bool MoveToPrevious();
+        public virtual void MoveToRoot();
+        public virtual XmlWriter PrependChild();
+        public virtual void PrependChild(string newChild);
+        public virtual void PrependChild(XmlReader newChild);
+        public virtual void PrependChild(XPathNavigator newChild);
+        public virtual void PrependChildElement(string prefix, string localName, string namespaceURI, string value);
+        public virtual XmlReader ReadSubtree();
+        public virtual XmlWriter ReplaceRange(XPathNavigator lastSiblingToReplace);
+        public virtual void ReplaceSelf(string newNode);
+        public virtual void ReplaceSelf(XmlReader newNode);
+        public virtual void ReplaceSelf(XPathNavigator newNode);
+        public virtual XPathNodeIterator Select(string xpath);
+        public virtual XPathNodeIterator Select(string xpath, IXmlNamespaceResolver resolver);
+        public virtual XPathNodeIterator Select(XPathExpression expr);
+        public virtual XPathNodeIterator SelectAncestors(string name, string namespaceURI, bool matchSelf);
+        public virtual XPathNodeIterator SelectAncestors(XPathNodeType type, bool matchSelf);
+        public virtual XPathNodeIterator SelectChildren(string name, string namespaceURI);
+        public virtual XPathNodeIterator SelectChildren(XPathNodeType type);
+        public virtual XPathNodeIterator SelectDescendants(string name, string namespaceURI, bool matchSelf);
+        public virtual XPathNodeIterator SelectDescendants(XPathNodeType type, bool matchSelf);
+        public virtual XPathNavigator SelectSingleNode(string xpath);
+        public virtual XPathNavigator SelectSingleNode(string xpath, IXmlNamespaceResolver resolver);
+        public virtual XPathNavigator SelectSingleNode(XPathExpression expression);
+        public virtual void SetTypedValue(object typedValue);
+        public virtual void SetValue(string value);
+        public override string ToString();
+        public override object ValueAs(Type returnType, IXmlNamespaceResolver nsResolver);
+        public virtual void WriteSubtree(XmlWriter writer);
+    }
+    public abstract class XPathNodeIterator : IEnumerable {
+        protected XPathNodeIterator();
+        public virtual int Count { get; }
+        public abstract XPathNavigator Current { get; }
+        public abstract int CurrentPosition { get; }
+        public abstract XPathNodeIterator Clone();
+        public virtual IEnumerator GetEnumerator();
+        public abstract bool MoveNext();
+    }
+    public enum XPathNodeType {
+        All = 9,
+        Attribute = 2,
+        Comment = 8,
+        Element = 1,
+        Namespace = 3,
+        ProcessingInstruction = 7,
+        Root = 0,
+        SignificantWhitespace = 5,
+        Text = 4,
+        Whitespace = 6,
+    }
+    public enum XPathResultType {
+        Any = 5,
+        Boolean = 2,
+        Error = 6,
+        Navigator = 1,
+        NodeSet = 3,
+        Number = 0,
+        String = 1,
+    }
+}
```

